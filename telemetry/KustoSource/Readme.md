# How to write maintainable and readable kusto queries

Codespace service is a distrubuted application. Logs gets streamed from different pods. State transitions are possible via user actions, workers, heartbeat, etc. All the above, makes KQL queries complex. This is an attempt to write readable, maintainable kusto queries. 

This also helps tracks the queries in source control.

## How do I write a query? 
Use Kusto Explorer Client or the Azure Data Explorer to write your query. Often your queries will be based on a well known event which other queries are using.
Those re-usable queries are added to *Events* folder. 
* Create a <something>.ksf file
* #include the events that you need
* Run the kc.exe tool, to produce the .ksl file.
* The contents of the resulting .ksl file can be run used in dashboard or for investigation. 

Caveats:
* If your query is simple enough, then your ksf file and kql file would essentially be the same. 

## Why not use stored functions? 
* Source of truth in stored function, is in the database. There is only one copy of it, and it is easy for any one to stomp on each other if they are trying to modify the same function. 
* Our service is still young and things do change. Going forward most of the re-used blocks can be converted to functions and uploaded to the Kusto DB.

## Building Blocks
Kusto queries are normally written as a single blob. When it becomes large, it become unreadable and undebuggable. 

KC.exe tool, can pre-process `#include` token and generate full KQL blob.

Input:

CreateEnvironmentPOSTRequestEvents.ksf
```
#include("Raw\ScopedRawEvents_7Days.ksf")
let CreateEnvironmentPOSTRequestEvents = ScopedRawEvents
    | where HttpRequestMethod == "POST" and HttpRequestUri == "/api/v1/environments";
```

Output:

```
// WARNING: AUTO GENERATED BY KUSTO COMPILER.
// See vsclk-core repository for details.
// Source File: Events\CreateEnvironmentPOSTRequestEvents.ksf
let ScopedRawEvents = DefaultEvent
    | where ['time'] between (ago(7d) .. now())
    | where ServiceEnvironment == "vsclk-online-prod";
let CreateEnvironmentPOSTRequestEvents = ScopedRawEvents
    | where HttpRequestMethod == "POST" and HttpRequestUri == "/api/v1/environments";
```

Kusto allows stored functions in the database proper. However, building on top of stored functions will require those functions to be stable.
This tool, could be easily extended to create/upload stored functions in the future.

## Conventions

Please follow the conventions to make the Kusto Source File readable and maintainable.

1. Extension of the kusto source file **should be** .ksf
2. One file **should do** only one thing. 
    a. It can do export a certain events using **let** which ends with semi-colon. (or)
    b. It can evaluate the query and output result in tabular form.
3. Name of the file **should be** name of the export or meaningful name in case of tabular output.
4. Always add documentation at the top of the file.
5. Only `#include` at the top of the file.

## Fully Qualify Events and Limit your projections

When writing a base building block,
1. Fully qualify a property and extend it. When joining events, properties can be stomped on, confused with or lost. Fully qualifying it will make it readable.
2. Project only the required properties. More the number of properties, the longer it will take to execute the query. 


```
#include("GetStateTransitionEvents.ksf")
let StartingToAvailableEvents = GetStateTransitionEvents(fromState="Starting", toState="Available")
    | extend EventAtStartingToAvailable = 1
    | extend EventAtStartingToAvailable_Time = ['time']
    | extend EventAtStartingToAvailable_ViaHeartbeat = iff(HttpRequestUri == "/api/v1/heartbeat" and HttpRequestMethod == "POST", 1, 0)
    | extend EventAtStartingToAvailable_WorkspaceId = WorkspaceId
    | extend EventAtStartingToAvailable_CloudEnvironmentId = CloudEnvironmentId
    | extend EventAtStartingToAvailable_CorrelationId = CorrelationId
    | project EventAtStartingToAvailable, EventAtStartingToAvailable_Time, EventAtStartingToAvailable_ViaHeartbeat, EventAtStartingToAvailable_WorkspaceId, EventAtStartingToAvailable_CloudEnvironmentId, EventAtStartingToAvailable_CorrelationId
    | summarize arg_min(EventAtStartingToAvailable_Time, *) by EventAtStartingToAvailable_WorkspaceId, EventAtStartingToAvailable_CloudEnvironmentId;
```

## Preprocessing tables or Cooking

Some queries are so expensive, that they cannot be directly used on a dashboard. Such queries are pre-processed on a scheduled task to produce an intermediate table. The intermediate tables are usually small and have targetted information, which is easy and fast to query.

## Using the Tool

The Kusto Compiler tool, pre-processes .ksf files into .kql files. It can take an individual file or a directory. Today it only handles `#inlcude`.

```
 kc compile -i c:\mywork\vsclk-core\telemetry\KustoSource\ -o c:\mywork\vsclk-core\telemetry\KustoQuery\
```

The .kql can be run in Kusto Explorer Client or Kusto Data Explorer webpage readily without any changes. 
Note: The default date range is last 7 days and scoped only to prod.

## Using Generated KQL files in Lens/PowerBI/AzureDataExplorer Dashboards

Generated queries are scoped to a hardcoded date range and ring. When using the same query on Dashboard, you can copy paste the query, but have to make manual adjustment on defining the filter.