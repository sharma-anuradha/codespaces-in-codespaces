//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v9.10.19.0 (Newtonsoft.Json v9.0.0.0) (http://NJsonSchema.org)
// </auto-generated>
//----------------------


/* tslint:disable:member-access jsdoc-format */

/** Alias for when a string is actually a base64 representation of a byte array. */
type stringBase64 = string;

/** Describes the kind of data to be formatted. */
export enum DataFormat {
    Default = <any>'default', 
    Email = <any>'email', 
    Token = <any>'token', 
    Path = <any>'path', 
    Text = <any>'text', 
    Uri = <any>'uri', 
    Omit = <any>'omit', 
    OmitDefault = <any>'omitDefault', 
    Hide = <any>'hide', 
    SingleMember = <any>'singleMember', 
}

/** Creates a decorator that saves the property format in a map attached to the class constructor. */
export function dataFormat(...format: any[]) {
    return function (target: any, propertyKey: string) {
        if (!target.constructor.dataFormat) {
            target.constructor.dataFormat = {};
        }
        target.constructor.dataFormat[propertyKey] = format;
    };
}


export class RemoteStreamMoniker {
    name!: string;
    condition?: string;
}

export enum SeekOrigin {
    Begin = <any>'begin', 
    Current = <any>'current', 
    End = <any>'end', 
}

export class FeatureFlagStore {
    fileOperations?: boolean;
    localUndo?: boolean;
    workspaceTask?: boolean;
    sharedTerminals?: boolean;
    guestApproval?: boolean;
    shareDebugTerminal?: boolean;
    api?: boolean;
    localRedo?: boolean;
    newFileProvider?: boolean;
    findFiles?: boolean;
    multiRootWorkspaceVSIDE?: boolean;
    multiRootWorkspaceVSCode?: boolean;
    searchInSolutionExplorer?: boolean;
    strongFollowBehavior?: boolean;
    textSearch?: boolean;
    shareExternalFiles?: boolean;
    showExternalFilesInSolutionView?: boolean;
    showExplorer?: boolean;
    accessControl?: boolean;
    navigateTo?: boolean;
    solutionView?: boolean;
    newShareTerminalCommand?: boolean;
    enableDebugAdapterTracker?: boolean;
    agentExtension?: boolean;
    userContactsViewlet?: boolean;
    helpViewlet?: boolean;
    headlessSupport?: boolean;
    sourceControl?: boolean;
    userReadOnlyElevationToggle?: boolean;
    comments?: boolean;
    solutionFileOperations?: boolean;
    searchProviderContacts?: boolean;
}

export abstract class MaybeImmutableOfAccessControl {
}

export class AccessControl extends MaybeImmutableOfAccessControl {
    isReadOnly?: boolean;
}

export class EventArgs {
}

export class AccessControlEventArgs extends EventArgs {
    @dataFormat(AccessControl)
    accessControl!: AccessControl;
}

export class AgentTraceEventArgs extends EventArgs {
    line!: string;
}

export class AgentSessionRequest {
    reconnectId?: string;
    keepAliveOnDisconnect?: number;
}

export class AgentSessionResponse {
    reconnectSuccess!: boolean;
    hostSessionNumber!: number;
    agentProcessId!: number;
}

export class AuthenticationToken {
    @dataFormat(DataFormat.Text)
    token?: string;
    @dataFormat(DataFormat.Text)
    code?: string;
}

export class UserAccountInfo {
    providerName?: string;
    @dataFormat(DataFormat.Text)
    accountId?: string;
}

export class UserInfo extends UserAccountInfo {
    @dataFormat(DataFormat.Hide)
    id!: string;
    @dataFormat(DataFormat.Text)
    displayName?: string;
    @dataFormat(DataFormat.Email)
    emailAddress?: string;
    @dataFormat(DataFormat.Text)
    userName?: string;
    accountStatus?: UserAccountStatus;
    isGlobalLogin?: boolean;
    @dataFormat(DataFormat.Uri)
    avatarUri?: string;
    isAnonymous?: boolean;
    recentCollaborators?: RecentCollaborator[];
}

export enum UserAccountStatus {
    Unknown = <any>'unknown', 
    Transient = <any>'transient', 
    Pending = <any>'pending', 
    Accepted = <any>'accepted', 
    Deleted = <any>'deleted', 
}

export class RecentCollaborator {
    id!: string;
    email?: string;
    name?: string;
    avatarUri?: string;
}

export class AuthenticationOptions {
    cache?: boolean;
    cacheDefault?: boolean;
    global?: boolean;
}

export class AuthenticationChangedEventArgs extends EventArgs {
    @dataFormat(UserInfo)
    account!: UserInfo;
    accessToken!: string;
}

export class AuthenticatedUserInfo {
    @dataFormat(UserInfo)
    userInfo?: UserInfo;
    @dataFormat(DataFormat.Text)
    accessToken?: string;
}

export class BrokerManifest {
    hostServices?: string[];
    guestServices?: string[];
}

export class BrokerEventArgs extends EventArgs {
    clientId!: number;
    token!: string;
}

export class Position {
    line!: number;
    offset!: number;
    startOffset?: number = -1;
}

export enum CommentThreadStatus {
    Active = <any>'active', 
    Closed = <any>'closed', 
}

export class CommentThreadContext {
    @dataFormat(DataFormat.Path)
    filePath!: string;
    @dataFormat(Position)
    leftFileStart?: Position;
    @dataFormat(Position)
    leftFileEnd?: Position;
    @dataFormat(Position)
    rightFileStart?: Position;
    @dataFormat(Position)
    rightFileEnd?: Position;
    documentVersion!: number;
}

export class Comment {
    commentId?: number;
    parentId!: number;
    @dataFormat(DataFormat.Text)
    participantId!: string;
    @dataFormat(DataFormat.Text)
    participantLabel?: string;
    lastUpdatedSessionId!: number;
    threadId!: number;
    @dataFormat(DataFormat.Text)
    text!: string;
    likers?: string[];
    isDeleted?: boolean;
    publishedDate?: Date;
    lastUpdatedDate?: Date;
}

export class CommentThread {
    threadId?: number;
    lastUpdatedSessionId!: number;
    leftSnapshotIndex?: number;
    rightSnapshotIndex?: number;
    @dataFormat(Comment)
    comments!: Comment[];
    @dataFormat(CommentThreadContext)
    threadContext!: CommentThreadContext;
    isDeleted?: boolean;
    status?: CommentThreadStatus;
    publishedDate?: Date;
    lastUpdatedDate?: Date;
}

export class CommentThreadChangedEventArgs extends EventArgs {
    @dataFormat(CommentThread)
    newThread?: CommentThread;
    @dataFormat(Comment)
    changedComment?: Comment;
}

export class CommentThreadLocation {
    threadId!: number;
    @dataFormat(CommentThreadContext)
    @dataFormat(CommentThreadContext)
    threadContext!: CommentThreadContext;
}

export class AddressAndMask {
    address?: string;
    mask?: string;
}

export class AgentVersionInfo {
    version?: string;
    protocolVersion?: string;
    platformName?: string;
    platformVersion?: string;
}

export class ClientVersionInfo {
    extensionName?: string;
    extensionVersion?: string;
    applicationName?: string;
    applicationVersion?: string;
    protocolVersion?: string;
    platformName?: string;
    platformVersion?: string;
}

export class FileListOptions {
    enableMultipleRoots?: boolean;
    includeDetails?: boolean;
    includeHidden?: boolean;
    includeExcluded?: boolean;
    recurseMode?: FileRecurseMode;
    excludePatterns?: string[];
    includePatterns?: string[];
}

export enum FileRecurseMode {
    None = <any>'none', 
    Children = <any>'children', 
    SingleChildDescendants = <any>'singleChildDescendants', 
    AllDescendants = <any>'allDescendants', 
}

export enum FileAttributes {
    None = <any>'none', 
    Hidden = <any>'hidden', 
    ReadOnly = <any>'readOnly', 
    Excluded = <any>'excluded', 
    External = <any>'external', 
}

export class FileInfo {
    @dataFormat(DataFormat.Path)
    path!: string;
    exists?: boolean = true;
    isDirectory?: boolean;
    hasChildren?: boolean;
    @dataFormat(FileInfo)
    children?: FileInfo[];
    mtime?: Date;
    size?: number;
    attributes?: FileAttributes;
}

export class FileRootInfo extends FileInfo {
    friendlyName?: string;
    @dataFormat(DataFormat.Path)
    localPath?: string;
    isCaseSensitive?: boolean;
}

export class FileTextInfo extends FileInfo {
    @dataFormat(DataFormat.Text)
    text!: string;
}

export class FileStreamInfo extends FileInfo {
}

export class FileReadOptions {
    diffBase?: string;
}

export class FileWriteOptions {
    createIfNotExist?: boolean;
    overwrite?: boolean;
    append?: boolean;
}

export class FileMoveOptions {
    overwrite?: boolean;
}

export class FileDeleteOptions {
    useTrash?: boolean;
}

export class FileWatchOptions {
    recurseMode?: FileRecurseMode;
}

export class FileChange {
    @dataFormat(DataFormat.Path)
    path!: string;
    @dataFormat(DataFormat.Path)
    fullPath?: string;
    changeType?: FileChangeType;
}

export enum FileChangeType {
    None = <any>'none', 
    Updated = <any>'updated', 
    Added = <any>'added', 
    Deleted = <any>'deleted', 
}

export class FilesChangedEventArgs extends EventArgs {
    @dataFormat(FileChange)
    changes!: FileChange[];
}

export class DiffBaseInfo {
    id!: string;
    @dataFormat(DataFormat.Text)
    description?: string;
}

export class ExternalFileMapResult {
    vslsPath!: string;
    createdNewEntry!: boolean;
}

export class TextSearchResultRange {
    line!: number;
    column!: number;
    endLine!: number;
    endColumn!: number;
}

export class TextSearchResult {
    @dataFormat(DataFormat.Path)
    path!: string;
    @dataFormat(DataFormat.Text)
    text!: string;
    line!: number;
    column!: number;
    length!: number;
    hitResultsLimit?: boolean;
    @dataFormat(TextSearchResultRange)
    ranges?: TextSearchResultRange[];
    @dataFormat(TextSearchResultRange)
    previewRanges?: TextSearchResultRange[];
}

export class TextSearchOptions {
    isRegex?: boolean;
    isCaseSensitive?: boolean;
    isWordMatch?: boolean;
    includeHiddenFiles?: boolean;
    encoding?: string;
    @dataFormat(DataFormat.Text)
    fileIncludes?: string[];
    @dataFormat(DataFormat.Text)
    fileExcludes?: string[];
    @dataFormat(DataFormat.Text)
    pattern!: string;
}

export enum FirewallStatus {
    None = <any>'none', 
    Allow = <any>'allow', 
    Block = <any>'block', 
}

export enum InviteContactStatus {
    None = <any>'none', 
    Invited = <any>'invited', 
    Dismissed = <any>'dismissed', 
    Joining = <any>'joining', 
}

export class InviteStatusNotify {
    fromContactId!: string;
    status!: InviteContactStatus;
}

export class SharedServer {
    sourcePort!: number;
    destinationPort?: number;
    sessionName!: string;
    streamName!: string;
    streamCondition!: string;
    @dataFormat(DataFormat.Uri)
    browseUrl!: string;
}

export class ServerSharingStartedEventArgs extends EventArgs {
    @dataFormat(SharedServer)
    server!: SharedServer;
}

export class ServerSharingStoppedEventArgs extends EventArgs {
    @dataFormat(SharedServer)
    server!: SharedServer;
}

export class ServerSharingChangedEventArgs extends EventArgs {
    @dataFormat(SharedServer)
    server!: SharedServer;
}

export class SessionUpdateEventArgs extends EventArgs {
    value!: string;
}

export abstract class NodeType {
}

export class SolutionWorkspaceNode {
    nodeType?: string;
    name?: string;
    path?: string;
    id?: string;
    parentId?: string;
    isExpandable?: boolean;
    isExpanded?: boolean;
    iconGuid?: string;
    iconId?: number;
}

export class SolutionChangedEventArgs extends EventArgs {
    id?: string;
    property?: string;
    isRootUpdate!: boolean;
}

export abstract class SolutionChangeType {
}

export class SourceControlIdentifier {
    sourceControlId!: string;
    @dataFormat(DataFormat.Path)
    instanceId!: string;
}

export class SourceControlVersion {
    @dataFormat(DataFormat.Path)
    version!: string;
    label!: string;
    description?: string;
}

export enum SourceControlResourceType {
    Workspace = <any>'workspace', 
    External = <any>'external', 
    SpecificVerision = <any>'specificVerision', 
    WorkspaceWithSpecificVersion = <any>'workspaceWithSpecificVersion', 
}

export enum SourceControlChangeType {
    None = <any>'none', 
    Add = <any>'add', 
    Edit = <any>'edit', 
    Delete = <any>'delete', 
    Rename = <any>'rename', 
    Conflict = <any>'conflict', 
    IndexEdit = <any>'indexEdit', 
    IndexDelete = <any>'indexDelete', 
    IndexCopy = <any>'indexCopy', 
    Untracked = <any>'untracked', 
    Ignored = <any>'ignored', 
    AddByUs = <any>'addByUs', 
    AddByThem = <any>'addByThem', 
    DeleteByUs = <any>'deleteByUs', 
    DeleteByThem = <any>'deleteByThem', 
    AddBoth = <any>'addBoth', 
    DeleteBoth = <any>'deleteBoth', 
}

export class SourceControlResource {
    type!: SourceControlResourceType;
    @dataFormat(DataFormat.Path)
    path!: string;
    @dataFormat(DataFormat.Path)
    version?: string;
}

export class SourceControlResourceState {
    @dataFormat(SourceControlResource)
    current!: SourceControlResource;
    changeType!: SourceControlChangeType;
    @dataFormat(SourceControlResource)
    original?: SourceControlResource;
}

export class SourceControlResourceIdentifier extends SourceControlResource {
    groupId?: string;
    sourceControlId?: string;
    @dataFormat(DataFormat.Uri)
    instanceId?: string;
}

export class SourceControlResourceGroup {
    groupId!: string;
    label?: string;
    hideWhenEmpty?: boolean;
    supportsClean?: boolean;
    supportsOpenFile?: boolean;
    supportsOpenChanges?: boolean;
    @dataFormat(SourceControlResourceState)
    resourceStates?: SourceControlResourceState[];
}

export class SourceControlInstance extends SourceControlIdentifier {
    label?: string;
    @dataFormat(DataFormat.Path)
    name?: string;
    @dataFormat(SourceControlResourceGroup)
    resourceGroups?: SourceControlResourceGroup[];
}

export class SourceControlResourceDiff {
    @dataFormat(SourceControlResource)
    right?: SourceControlResource;
    changeType!: SourceControlChangeType;
    @dataFormat(SourceControlResource)
    left?: SourceControlResource;
    @dataFormat(DataFormat.Path)
    title?: string;
}

export enum SourceControlChange {
    Updated = <any>'updated', 
    Added = <any>'added', 
    Removed = <any>'removed', 
}

export class SourceControlChangedEventArgs extends EventArgs {
    @dataFormat(SourceControlIdentifier)
    sourceControl?: SourceControlIdentifier;
    change!: SourceControlChange;
}

export class SourceControlResourceChangedEventArgs extends EventArgs {
    @dataFormat(SourceControlIdentifier)
    sourceControl!: SourceControlIdentifier;
    @dataFormat(SourceControlResource)
    resources?: SourceControlResource[];
}

export class SourceEventArgs extends EventArgs {
    sourceId!: string;
    eventId!: number;
    @dataFormat(DataFormat.Hide)
    jsonContent!: string;
}

export enum StreamTraits {
    None = <any>'none', 
    CanRead = <any>'canRead', 
    CanWrite = <any>'canWrite', 
    CanSeek = <any>'canSeek', 
}

export enum TaskOutputContentType {
    PlainText = <any>'plainText', 
    TextWithAnsiEscapeCodes = <any>'textWithAnsiEscapeCodes', 
}

export class TaskOutputFeedInfo {
    id!: number;
    @dataFormat(RemoteStreamMoniker)
    streamMoniker!: RemoteStreamMoniker;
}

export class TaskOutputOptions {
    contentType!: TaskOutputContentType;
    taskKinds?: string[];
    encoding?: string;
}

export class TaskOutputInfo {
    id!: number;
    name!: string;
    @dataFormat(TaskOutputFeedInfo)
    feed!: TaskOutputFeedInfo;
    @dataFormat(TaskOutputOptions)
    options!: TaskOutputOptions;
}

export class TaskOutputEventArgs extends EventArgs {
    @dataFormat(TaskOutputInfo)
    taskOutput!: TaskOutputInfo;
}

export class TelemetrySettings {
    canCollectPII?: boolean;
    privacyKey?: string;
}

export class GenericOperationEventArgs extends EventArgs {
    eventName!: string;
    result!: TelemetryResult;
    @dataFormat(DataFormat.Omit)
    payload!: { [key: string]: any; };
}

/** An enum to define the result from user task or operation. */
export enum TelemetryResult {
    None = <any>'none', 
    Success = <any>'success', 
    Failure = <any>'failure', 
    UserFault = <any>'userFault', 
    UserCancel = <any>'userCancel', 
}

export class TerminalOptions {
    name!: string;
    rows!: number;
    cols!: number;
    @dataFormat(DataFormat.Path)
    cwd?: string;
    @dataFormat(DataFormat.Path)
    app?: string;
    @dataFormat(DataFormat.Hide)
    commandLine?: string[];
    @dataFormat(DataFormat.Omit)
    verbatimCommandLine?: boolean;
    @dataFormat(DataFormat.Omit)
    environment?: { [key: string]: string; };
    readOnlyForGuests!: boolean;
    isSharedDebugTerminal?: boolean;
    dataPipeName?: string;
}

export class TerminalInfo {
    id!: number;
    @dataFormat(TerminalOptions)
    options!: TerminalOptions;
    streamName!: string;
    streamCondition!: string;
    localPipeName?: string;
}

export class TerminalEventArgs extends EventArgs {
    @dataFormat(TerminalInfo)
    terminal!: TerminalInfo;
}

export class RestrictedOperation {
    name!: string;
    sessionId?: number;
}

export class SharedTerminalRestrictedOperation extends RestrictedOperation {
    terminalId!: number;
    isEscapeSequence?: boolean;
}

export abstract class MaybeImmutableOfWorkspaceAccessControl {
}

export class WorkspaceAccessControl extends MaybeImmutableOfWorkspaceAccessControl {
    @dataFormat(AccessControl)
    defaultAccessControl?: AccessControl;
    userAccessControl?: { [key: string]: AccessControl; };
}

export class WorkspaceAccessControlEventArgs extends EventArgs {
    @dataFormat(WorkspaceAccessControl)
    accessControl!: WorkspaceAccessControl;
}

export class RestrictedOperationAccessRequestedEventArgs extends EventArgs {
    @dataFormat(RestrictedOperation)
    operation!: RestrictedOperation;
    sessionId!: number;
}

export class RestrictedOperationAccessEventArgs extends EventArgs {
    @dataFormat(RestrictedOperation)
    operation!: RestrictedOperation;
    access!: RestrictedOperationAccess;
}

export enum RestrictedOperationAccess {
    Allowed = <any>'allowed', 
    RejectedInReadOnlySession = <any>'rejectedInReadOnlySession', 
    RejectedForNotOwner = <any>'rejectedForNotOwner', 
    DisabledByHostConfiguration = <any>'disabledByHostConfiguration', 
    ExplicitlyRejectedByHost = <any>'explicitlyRejectedByHost', 
}

export enum ErrorSeverity {
    Error = <any>'error', 
    Warning = <any>'warning', 
    Message = <any>'message', 
}

export class DiagnosticEntry {
    severity?: ErrorSeverity;
    @dataFormat(DataFormat.Path)
    fileId?: WorkspaceFileId;
    lineNumber?: number;
    column?: number;
    errorCode?: string;
    @dataFormat(DataFormat.Hide)
    message?: string;
    @dataFormat(DataFormat.Omit)
    properties?: { [key: string]: string; };
}

type WorkspaceFileId = string;

export class DiagnosticDataChangedEventArgs extends EventArgs {
    @dataFormat(DiagnosticEntry)
    entries!: DiagnosticEntry[];
}

export class WorkspaceInfo {
    id?: string;
    @dataFormat(DataFormat.Text)
    name!: string;
    @dataFormat(DataFormat.Omit)
    joinUri?: string;
    @dataFormat(DataFormat.Omit)
    ownerId?: string;
    connectionStatus?: WorkspaceConnectionStatus;
}

export enum WorkspaceConnectionStatus {
    Unknown = <any>'unknown', 
    Available = <any>'available', 
    Unavailable = <any>'unavailable', 
    Connected = <any>'connected', 
    Disconnected = <any>'disconnected', 
}

export enum WorkspaceDisconnectedReason {
    None = <any>'none', 
    Requested = <any>'requested', 
    UserRemoved = <any>'userRemoved', 
    SessionEnded = <any>'sessionEnded', 
    ConnectionLost = <any>'connectionLost', 
    InternalError = <any>'internalError', 
    SessionExpired = <any>'sessionExpired', 
    NetworkDisconnected = <any>'networkDisconnected', 
    ListenerWentOffline = <any>'listenerWentOffline', 
}

export class WorkspaceConnectionStatusChangedEventArgs extends EventArgs {
    connectionStatus!: WorkspaceConnectionStatus;
    disconnectedReason?: WorkspaceDisconnectedReason;
}

export enum WorkspaceProgress {
    None = <any>'none', 
    CreatedWorkspace = <any>'createdWorkspace', 
    InitializedAgentServices = <any>'initializedAgentServices', 
    InitializedRelayAndTCP = <any>'initializedRelayAndTCP', 
    AddedUserToWorkspace = <any>'addedUserToWorkspace', 
    JoinedLocalWorkspace = <any>'joinedLocalWorkspace', 
    ReadWorkspaceInfo = <any>'readWorkspaceInfo', 
    OpeningRemoteSession = <any>'openingRemoteSession', 
    OpenedRemoteSession = <any>'openedRemoteSession', 
    JoiningRemoteSession = <any>'joiningRemoteSession', 
    JoinedRemoteSession = <any>'joinedRemoteSession', 
    WaitingForHost = <any>'waitingForHost', 
    DoneWaitingForHost = <any>'doneWaitingForHost', 
}

export class WorkspaceProgressEventArgs extends EventArgs {
    progress!: WorkspaceProgress;
    duration!: number;
}

export class WorkspaceShareInfo extends WorkspaceInfo {
    @dataFormat(DataFormat.Path)
    rootDirectories!: string[];
    connectionMode?: ConnectionMode;
    areAnonymousGuestsAllowed?: boolean;
    keepAlive?: boolean;
}

export enum ConnectionMode {
    Auto = <any>'auto', 
    Direct = <any>'direct', 
    Relay = <any>'relay', 
    Local = <any>'local', 
}

export class ClientCapabilities {
    extensionReadOnlySupport?: boolean;
    clientReadOnlySupport?: boolean;
    isNonInteractive?: boolean;
}

export class WorkspaceJoinInfo {
    id?: string;
    correlationId?: string;
    @dataFormat(DataFormat.Text)
    directAddress?: string;
    @dataFormat(DataFormat.Text)
    relayAddress?: string;
    @dataFormat(DataFormat.Token)
    relaySharedAccessSignature?: string;
    @dataFormat(DataFormat.Token)
    joiningUserSessionToken?: string;
    connectionMode?: ConnectionMode;
    @dataFormat(ClientCapabilities)
    clientCapabilities?: ClientCapabilities;
    anonymousUserName?: string;
    keepAlive?: boolean;
}

export class WorkspaceListOptions {
    includeRemoteWorkspaces?: boolean = true;
    owner?: string;
}

export class WorkspaceSessionInfo extends WorkspaceInfo {
    sessionNumber!: number;
    conversationId!: string;
    connectionMode?: ConnectionMode;
    relayConnected?: boolean;
    createdAt?: Date;
    updatedAt?: Date;
    sessions?: { [key: string]: WorkspaceUserProfile; };
    accessControl?: WorkspaceAccessControl;
}

export class WorkspaceUserProfile {
    id!: string;
    @dataFormat(DataFormat.Text)
    name?: string;
    @dataFormat(DataFormat.Email)
    email!: string;
    @dataFormat(DataFormat.Text)
    userName?: string;
    @dataFormat(DataFormat.Text)
    provider?: string;
    @dataFormat(DataFormat.Uri)
    avatarUri?: string;
    isOwner!: boolean;
    isHost?: boolean;
    @dataFormat(ClientCapabilities)
    clientCapabilities?: ClientCapabilities;
    isAnonymous?: boolean;
}

export enum CollectionChangeType {
    None = <any>'none', 
    Add = <any>'add', 
    Remove = <any>'remove', 
}

export class WorkspaceServicesChangedEventArgs extends EventArgs {
    changeType!: CollectionChangeType;
    serviceNames!: string[];
}

export enum TaskScope {
    Global = <any>'global', 
    Workspace = <any>'workspace', 
    WorkspaceFolder = <any>'workspaceFolder', 
}

export class WorkspaceTask {
    uniqueId!: string;
    name!: string;
    kind?: string;
    source?: string;
    scope?: TaskScope;
    owningWorkspace?: string;
}

export class TaskExecutionMoniker {
    id!: string;
    taskUid!: string;
}

export enum TaskExecutionStatusChange {
    Started = <any>'started', 
    Terminated = <any>'terminated', 
}

export class TaskExecutionStatusEventArgs extends EventArgs {
    @dataFormat(TaskExecutionMoniker)
    taskExecution!: TaskExecutionMoniker;
    change!: TaskExecutionStatusChange;
    @dataFormat(WorkspaceTask)
    task!: WorkspaceTask;
}

export enum RunTaskStatus {
    Started = <any>'started', 
    AlreadyRunning = <any>'alreadyRunning', 
    RetryLater = <any>'retryLater', 
    TaskNotFound = <any>'taskNotFound', 
    RejectedByHost = <any>'rejectedByHost', 
}

export class RunTaskResult {
    status!: RunTaskStatus;
    @dataFormat(TaskExecutionMoniker)
    taskExecution?: TaskExecutionMoniker;
}

export class WorkspaceTaskRestrictedOperation extends RestrictedOperation {
    taskUid?: string;
}

export class GuestAcceptance {
    accept!: boolean;
    errorCode?: number;
    message?: string;
}

export enum WorkspaceSessionChangeType {
    None = <any>'none', 
    Joined = <any>'joined', 
    Unjoined = <any>'unjoined', 
    Canceled = <any>'canceled', 
    Accepted = <any>'accepted', 
    Rejected = <any>'rejected', 
}

export class WorkspaceSessionChangedEventArgs extends EventArgs {
    changeType!: WorkspaceSessionChangeType;
    sessionNumber!: number;
    @dataFormat(WorkspaceUserProfile)
    userProfile!: WorkspaceUserProfile;
    applicationName!: string;
    disconnectedReason?: WorkspaceDisconnectedReason;
}

export class UserSettings {
    agentAutoStart?: boolean;
    agentUri?: string;
    serviceEndpoint?: string;
    presenceServiceUri?: string;
    teamStatus?: string;
    isInternal?: boolean;
    whatsNewUri?: string;
    whatsNewText?: string;
    @dataFormat(FeatureFlagStore)
    experimentalFeatures?: FeatureFlagStore;
    increasedGuestLimit?: boolean;
    keychainFile?: string;
}

export class TextChange {
    start?: number;
    length?: number;
    @dataFormat(DataFormat.Text)
    newText?: string;
}

export class MessageBase {
    messageType?: MessageType = MessageType.Unknown;
    clientId?: number;
    sendId?: number;
}

export enum MessageType {
    SelectionChange = <any>'selectionChange', 
    TextChange = <any>'textChange', 
    FileOpenRequest = <any>'fileOpenRequest', 
    FileOpenAcknowledge = <any>'fileOpenAcknowledge', 
    FileRelease = <any>'fileRelease', 
    SaveFile = <any>'saveFile', 
    JoinRequest = <any>'joinRequest', 
    JoinAcknowledge = <any>'joinAcknowledge', 
    ReadOnlyChange = <any>'readOnlyChange', 
    Handshake = <any>'handshake', 
    Summon = <any>'summon', 
    LayoutScroll = <any>'layoutScroll', 
    Unknown = <any>'unknown', 
}

export class FileMessageBase extends MessageBase {
    @dataFormat(DataFormat.Path)
    fileName?: WorkspaceFileId;
}

export class JoinRequestMessage extends MessageBase {
}

export class JoinAcknowledgeMessage extends MessageBase {
    joinerId?: number;
    @dataFormat(DataFormat.Path)
    files?: WorkspaceFileId[];
    clientIds?: number[];
}

export class SelectionChangeMessage extends FileMessageBase {
    serverVersionNumber?: number;
    start?: number;
    length?: number;
    isReversed?: boolean;
    forceJumpForClientId?: number;
}

export class LayoutScrollMessage extends FileMessageBase {
    serverVersionNumber?: number;
    start?: number;
    length?: number;
}

export class FileOpenRequestMessage extends FileMessageBase {
    hashCode?: number;
    sendJumpTo?: boolean;
}

export class HandshakeMessage extends FileMessageBase {
    hashCode?: number;
    serverVersionNumber?: number;
}

export class SaveFileMessage extends FileMessageBase {
}

export class FileReleaseMessage extends FileMessageBase {
}

export class TextChangeMessage extends FileMessageBase {
    changeServerVersion?: number;
    @dataFormat(TextChange)
    changes?: TextChange[];
}

export class ReadOnlyChangeMessage extends FileMessageBase {
    isReadOnly?: boolean;
}

export class ServerVersionSnapshot {
    serverVersionNumber?: number;
    @dataFormat(TextChangeMessage)
    message?: TextChangeMessage;
}

export class FileOpenAcknowledgeMessage extends FileMessageBase {
    joinerId?: number;
    isReadOnly?: boolean;
    savedVersionNumber?: number;
    startServerVersionNumber?: number;
    changes?: TextChange[][];
    fallbackText?: string;
    @dataFormat(ServerVersionSnapshot)
    history?: ServerVersionSnapshot[];
    wasUnableToOpen?: boolean;
}

export class SummonMessage extends MessageBase {
}

export enum DocumentChangesNotificationFlags {
    NotifyDidOpenClose = <any>'notifyDidOpenClose', 
    NotifyDidChange = <any>'notifyDidChange', 
    NotifyDidSave = <any>'notifyDidSave', 
    NotifyAll = <any>'notifyAll', 
}

export class CoeditingInformation {
    serverVersion!: number;
    highestLocalTextChange!: number;
    clientId!: number;
    proxyId?: number;
}

export class DocumentFilter {
    language?: string;
    pattern?: string;
}

export class LanguageServerProviderMetadata {
    isLanguageClientProvider?: boolean;
    contentTypes?: string[];
    @dataFormat(DocumentFilter)
    documentFilters?: DocumentFilter[];
}

export class NotificationEventArgs extends EventArgs {
    body?: LspMessage;
}

export class LspMessage {
    method?: string;
    params?: any;
}

export class DebugSession {
    sessionId!: string;
    name!: string;
    processId?: number;
    configurationProperties?: { [key: string]: any; };
    capabilities?: any;
}

export enum DebugSessionChangeType {
    None = <any>'none', 
    Add = <any>'add', 
    Remove = <any>'remove', 
}

export class DebugSessionChangedEventArgs extends EventArgs {
    changeType!: DebugSessionChangeType;
    @dataFormat(DebugSession)
    debugSession!: DebugSession;
}

export class LaunchConfigurationChangedEventArgs extends EventArgs {
    launchConfigurations!: any;
}

export enum ContinueReason {
    Go = <any>'go', 
    StepIn = <any>'stepIn', 
    StepOut = <any>'stepOut', 
    StepOver = <any>'stepOver', 
}

export enum ErrorCodes {
    CouldNotConnectToServer = -32000, 
    OlderThanServer = -32001, 
    NewerThanServer = -32002, 
    OlderThanPeer = -32003, 
    NewerThanPeer = -32004, 
    OlderThanAgent = -32005, 
    NewerThanAgent = -32006, 
    NoIPAddressesDetected = -32010, 
    NoConnectionAddresses = -32011, 
    AutoConnectionFailed = -32012, 
    RelayConnectionFailed = -32013, 
    DirectConnectionFailed = -32014, 
    SessionProtocolError = -32015, 
    SessionAuthenticationFailed = -32016, 
    DirectConnectionNotEnabled = -32020, 
    RelayConnectionNotEnabled = -32021, 
    CollaborationSessionUsersLimitReached = -32022, 
    CollaborationSessionGuestRejected = -32023, 
    CollaborationSessionRequestTimedOut = -32024, 
    CollaborationSessionGuestCanceled = -32025, 
    CollaborationSessionNotFound = -32026, 
    CollaborationSessionEnded = -32027, 
    CollaborationSessionGuestBlocked = -32028, 
    NonSuccessHttpStatusCodeReceived = -32030, 
    KeychainAccessFailed = -32031, 
    UnauthorizedHttpStatusCode = -32032, 
    ForbiddenHttpStatusCode = -32033, 
    RelayConnectionHostFailure = -32040, 
    RelayConnectionGuestFailure = -32041, 
    BrokerNotAuthorized = -32050, 
    RemoteLaunchNotEnabled = -32200, 
    CollaborationSessionGuestRejectedWithSpecificReason = -32300, 
    OperationRejected = -32400, 
    OperationRejectedInReadOnlySession = -32401, 
    OperationRejectedForNotOwner = -32402, 
    FileOperationNotSupported = -32500, 
    ErrorFileAdditionFailed = -32501, 
    ErrorFileDeleteFailed = -32502, 
    ErrorFileRenameFailed = -32503, 
    FileAlreadyExists = -32504, 
}

export enum TraceEventIds {
    None = 0, 
    RpcListeningOnPipe = 1001, 
    AgentLogCreated = 1002, 
    AgentOutput = 2001, 
}

export enum TraceSources {
    Agent = 'Agent', 
    AgentAuth = 'Agent.Auth', 
    AgentCSharpLS = 'Agent.CSharpLS', 
    AgentFile = 'Agent.File', 
    AgentFirewall = 'Agent.Firewall', 
    AgentHttp = 'Agent.Http', 
    AgentProxy = 'Agent.Proxy', 
    AgentPortForwarding = 'Agent.PortFowrading', 
    AgentRpc = 'Agent.Rpc', 
    AgentRpcAuth = 'Agent.Rpc.Auth', 
    AgentRpcFile = 'Agent.Rpc.File', 
    AgentRpcFirewall = 'Agent.Rpc.Firewall', 
    AgentRpcServerSharing = 'Agent.Rpc.ServerSharing', 
    AgentRpcSourceEvent = 'Agent.Rpc.SourceEvent', 
    AgentRpcStream = 'Agent.Rpc.Stream', 
    AgentRpcStreamManager = 'Agent.Rpc.StreamManager', 
    AgentRpcStreamTransport = 'Agent.Rpc.StreamTransport', 
    AgentRpcTerminal = 'Agent.Rpc.Terminal', 
    AgentTerminalConnection = 'Agent.Terminal.Connection', 
    AgentRpcWorkspace = 'Agent.Rpc.Workspace', 
    AgentRpcWorkspaceUser = 'Agent.Rpc.WorkspaceUser', 
    AgentRpcTaskOutput = 'Agent.Rpc.TaskOutput', 
    AgentSsh = 'Agent.Ssh', 
    AgentTSLS = 'Agent.TSLS', 
    AgentWorkspace = 'Agent.Workspace', 
    AgentWorkspaceSessionAccessControl = 'Agent.WorkspaceSession.AccessControl', 
    ClientAgent = 'Client.Agent', 
    ClientCoEditing = 'Client.CoEditing', 
    ClientCoEditingBufferManager = 'Client.CoEditing.BufferManager', 
    ClientCoEditingVSCodeEvent = 'Client.CoEditing.VSCodeEvent', 
    ClientFileProvider = 'Client.FileProvider', 
    ClientLauncher = 'Client.Launcher', 
    ClientRpc = 'Client.Rpc', 
    ClientRpcAgentSession = 'Client.Rpc.AgentSession', 
    ClientRpcAuth = 'Client.Rpc.Auth', 
    ClientRpcFile = 'Client.Rpc.File', 
    ClientRpcPortForwarding = 'Client.Rpc.PortForwarding', 
    ClientRpcServerSharing = 'Client.Rpc.ServerSharing', 
    ClientRpcSourceEvent = 'Client.Rpc.SourceEvent', 
    ClientRpcStream = 'Client.Rpc.Stream', 
    ClientRpcStreamManager = 'Client.Rpc.StreamManager', 
    ClientRpcTerminal = 'Client.Rpc.Terminal', 
    ClientRpcTerminalEndpoint = 'Client.Rpc.TerminalEndpoint', 
    ClientRpcWorkspace = 'Client.Rpc.Workspace', 
    ClientRpcWorkspaceUser = 'Client.Rpc.WorkspaceUser', 
    ClientRpcSessionContext = 'Client.Rpc.SessionContext', 
    ClientRpcContact = 'Client.Rpc.Contact', 
    ClientWorkspace = 'Client.Workspace', 
    ClientRemoteBuild = 'Client.RemoteBuild', 
    ClientCSharpLS = 'Client.CSharpLS', 
    ClientLSP = 'Client.LSP', 
    ClientSharedTerminal = 'Client.SharedTerminal', 
    ClientWorkspaceAccessControl = 'Client.Workspace.AccessControl', 
    ClientAccessControl = 'Client.AccessControl', 
    ClientSearch = 'Client.Search', 
    ClientSourceControl = 'Client.SourceControl', 
    ClientCommentService = 'Client.CommentService', 
    ClientSolutionView = 'Agent.SolutionView', 
    ClientGettingStartedPageContentProvider = 'Client.GettingStartedPageContentProvider', 
    BreakpointManager = 'BreakpointManager', 
    DebugAdapter = 'Debug.Adapter', 
    DebugTargetHostProcess = 'Debug.TargetHostProcess', 
    DebugHost = 'Debug.Host', 
    DebugHostAdapter = 'Debug.HostAdapter', 
    DebugRemote = 'Debug.Remote', 
    DebugSessionHost = 'Debug.SessionHost', 
    DebugRpcSessionHost = 'Debug.Rpc.SessionHost', 
    DebugRpcHostAdapter = 'Debug.Rpc.HostAdapter', 
    DebugRpcHost = 'Debug.Rpc.Host', 
    ForwardingTcpServer = 'ForwardingTcpServer', 
    Telemetry = 'Telemetry', 
    ClientAccessCheck = 'ClientAccessCheck', 
    LSPHost = 'LSP.Host', 
    LSPCoauthoringManager = 'LSP.CoauthoringManager', 
    ReviewsDiffs = 'Reviews.Diffs', 
    VSIX = 'VSIX', 
    CLI = 'CLI', 
    TTY = 'TTY', 
    Settings = 'Settings', 
    API = 'API', 
}


import { CancellationToken, Event } from 'vscode-jsonrpc';


/**
 * Defines a generalized way of reporting progress updates.
 */
export interface Progress<T> {

    /**
     * Report a progress update.
     * @param value A progress item, like a message and/or an
     * report on how much work finished
     */
    report(value: T): void;
}

export interface AccessControlService {
    getAccessControlAsync(
        cancellationToken?: CancellationToken)
        : Promise<AccessControl>;

    readonly onAccessControlChanged: Event<AccessControlEventArgs>;
}

export interface AgentSessionService {
    initializeSessionAsync(
        initializeRequest: AgentSessionRequest,
        cancellationToken?: CancellationToken)
        : Promise<AgentSessionResponse>;

    enableReconnectAsync(
        cancellationToken?: CancellationToken)
        : Promise<string>;

    keepAliveAsync(
        delay: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;
}

export interface AuthenticationService {
    getLoginUriAsync(
        cancellationToken?: CancellationToken)
        : Promise<string>;

    findLoginCodeAsync(
        extensionId: string,
        cancellationToken?: CancellationToken)
        : Promise<string>;

    loginAsync(
        loginTokenOrCode: AuthenticationToken,
        options: AuthenticationOptions,
        cancellationToken?: CancellationToken)
        : Promise<UserInfo>;

    loginAsAnonymousAsync(
        options: AuthenticationOptions,
        cancellationToken?: CancellationToken)
        : Promise<UserInfo>;

    loginWithCachedTokenAsync(
        accountInfo: UserAccountInfo,
        options: AuthenticationOptions,
        cancellationToken?: CancellationToken)
        : Promise<UserInfo>;

    loginWithExternalTokenAsync(
        externalAccountInfo: UserAccountInfo,
        externalToken: AuthenticationToken,
        options: AuthenticationOptions,
        cancellationToken?: CancellationToken)
        : Promise<UserInfo>;

    logoutAsync(
        options: AuthenticationOptions,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getCurrentUserAsync(
        cancellationToken?: CancellationToken)
        : Promise<UserInfo>;

    removeRecentCollaboratorAsync(
        recentCollaboratorId: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    removeAllRecentCollaboratorsAsync(
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getCurrentAuthenticatedUserAsync(
        cancellationToken?: CancellationToken)
        : Promise<AuthenticatedUserInfo>;

    readonly onAuthenticationChanged: Event<AuthenticationChangedEventArgs>;
}

export interface BrokerAuthorizationService {
    authorizeAsync(
        brokerToken: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;
}

export interface BrokerManagerService {
    registerAsync(
        brokerManifest: BrokerManifest,
        cancellationToken?: CancellationToken)
        : Promise<string>;

    tryRevokeAsync(
        brokerToken: string,
        cancellationToken?: CancellationToken)
        : Promise<boolean>;
}

export interface ClientAccessCheck {
    isClientReadOnly()
        : void;

    isClientReadOnly(
        clientId: number)
        : void;

    canPerformOperation(
        operation: RestrictedOperation)
        : void;

    verifyCanPerformOperation(
        operation: RestrictedOperation)
        : void;

    logRejectedOperation(
        operation: RestrictedOperation,
        access: RestrictedOperationAccess)
        : void;

    getGuestSessionId()
        : void;

    isDefaultAccessControlReadOnly()
        : void;

    isUserExplicitlyReadWrite(
        sessionId: number)
        : void;
}

export interface CommentService {
    createCommentThreadAsync(
        commentThread: CommentThread,
        cancellationToken?: CancellationToken)
        : Promise<CommentThread>;

    createCommentAsync(
        comment: Comment,
        cancellationToken?: CancellationToken)
        : Promise<Comment>;

    updateCommentAsync(
        threadId: number,
        commentId: number,
        sessionId: number,
        newText: string,
        cancellationToken?: CancellationToken)
        : Promise<Comment>;

    deleteCommentAsync(
        threadId: number,
        commentId: number,
        sessionId: number,
        cancellationToken?: CancellationToken)
        : Promise<Comment>;

    getAllCommentThreadsAsync(
        cancellationToken?: CancellationToken)
        : Promise<CommentThread[]>;

    getCommentThreadPositionsAsync(
        threadIds: number[],
        cancellationToken?: CancellationToken)
        : Promise<CommentThreadLocation[]>;

    updateLikeAsync(
        threadId: number,
        commentId: number,
        sessionId: number,
        participantId: string,
        isLike: boolean,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onCommentThreadChanged: Event<CommentThreadChangedEventArgs>;
}

export interface ConfigurationService {
    exchangeVersionsAsync(
        agentVersion: AgentVersionInfo,
        clientVersion: ClientVersionInfo,
        cancellationToken?: CancellationToken)
        : Promise<AgentVersionInfo>;

    exchangeSettingsAsync(
        settings: UserSettings,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getSubnetMasksAsync(
        ipAddressBytes: number[],
        cancellationToken?: CancellationToken)
        : Promise<AddressAndMask[]>;
}

export interface FileService {
    registerExternalFilesAsync(
        localPaths: string[],
        vslsPaths: string[],
        cancellationToken?: CancellationToken)
        : Promise<void>;

    listRootsAsync(
        options: FileListOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileRootInfo[]>;

    listAsync(
        paths: string[],
        options: FileListOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileInfo[]>;

    readTextAsync(
        path: string,
        options: FileReadOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileTextInfo>;

    readStreamAsync(
        path: string,
        options: FileReadOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileStreamInfo>;

    writeTextAsync(
        path: string,
        text: string,
        options: FileWriteOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileInfo>;

    writeStreamAsync(
        path: string,
        options: FileWriteOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileStreamInfo>;

    createDirectoryAsync(
        path: string,
        cancellationToken?: CancellationToken)
        : Promise<FileInfo>;

    deleteAsync(
        path: string,
        options: FileDeleteOptions,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    copyAsync(
        sourcePath: string,
        targetPath: string,
        options: FileMoveOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileInfo>;

    moveAsync(
        sourcePath: string,
        targetPath: string,
        options: FileMoveOptions,
        cancellationToken?: CancellationToken)
        : Promise<FileInfo>;

    getFilesAsync(
        options: FileListOptions,
        cancellationToken?: CancellationToken)
        : Promise<string[]>;

    isExcludedAsync(
        path: string,
        options: FileListOptions,
        cancellationToken?: CancellationToken)
        : Promise<boolean>;

    findFilesAsync(
        query: string,
        options: FileListOptions,
        cancellationToken?: CancellationToken)
        : Promise<string[]>;

    getTextSearchResultsAsync(
        options: TextSearchOptions,
        cancellationToken?: CancellationToken)
        : Promise<TextSearchResult[]>;

    getTextSearchResultsWithProgressAsync(
        options: TextSearchOptions,
        progress: Progress<TextSearchResult>,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onFilesChanged: Event<FilesChangedEventArgs>;
}

export interface FirewallService {
    getFirewallStatusAsync(
        cancellationToken?: CancellationToken)
        : Promise<FirewallStatus>;
}

export interface PortForwardingService {
    getSharedServersAsync(
        cancellationToken?: CancellationToken)
        : Promise<SharedServer[]>;

    readonly onSharingStarted: Event<ServerSharingStartedEventArgs>;

    readonly onBrowseSharingStarted: Event<ServerSharingStartedEventArgs>;

    readonly onSharingStopped: Event<ServerSharingStoppedEventArgs>;

    readonly onSharingChanged: Event<ServerSharingChangedEventArgs>;
}

export interface ServerSharingService {
    startSharingAsync(
        port: number,
        sessionName: string,
        browseUrl: string,
        cancellationToken?: CancellationToken)
        : Promise<SharedServer>;

    stopSharingAsync(
        port: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    stopSharingBrowseSessionsAsync(
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getSharedServersAsync(
        cancellationToken?: CancellationToken)
        : Promise<SharedServer[]>;

    updateSessionNameAsync(
        port: number,
        newSessionName: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onSharingStarted: Event<ServerSharingStartedEventArgs>;

    readonly onBrowseSharingStarted: Event<ServerSharingStartedEventArgs>;

    readonly onSharingStopped: Event<ServerSharingStoppedEventArgs>;

    readonly onSharingChanged: Event<ServerSharingChangedEventArgs>;
}

export interface SessionContextService {
    getServiceNamesAsync(
        cancellationToken?: CancellationToken)
        : Promise<string[]>;

    sendSessionStateUpdateToClient(
        value: string)
        : void;

    sendSessionStatusUpdateToClient(
        value: string)
        : void;

    readonly onSessionStateUpdate: Event<SessionUpdateEventArgs>;

    readonly onSessionStatusUpdate: Event<SessionUpdateEventArgs>;
}

export interface SolutionViewService {
    getChildrenNodesAsync(
        parentNode: SolutionWorkspaceNode,
        cancellationToken?: CancellationToken)
        : Promise<SolutionWorkspaceNode[]>;

    getRootNodesAsync(
        cancellationToken?: CancellationToken)
        : Promise<SolutionWorkspaceNode[]>;

    addNewItemAsync(
        parentNode: SolutionWorkspaceNode,
        nodeType: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    renameItemAsync(
        node: SolutionWorkspaceNode,
        newName: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    deleteItemAsync(
        node: SolutionWorkspaceNode,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onSolutionChanged: Event<SolutionChangedEventArgs>;
}

export interface SourceControlService {
    getAllSourceControlsAsync(
        cancellationToken?: CancellationToken)
        : Promise<SourceControlInstance[]>;

    getSourceControlsAsync(
        sourceControlId: string,
        cancellationToken?: CancellationToken)
        : Promise<SourceControlInstance[]>;

    getSourceControlAsync(
        sourceControl: SourceControlIdentifier,
        cancellationToken?: CancellationToken)
        : Promise<SourceControlInstance>;

    getRecentVersionsAsync(
        sourceControl: SourceControlIdentifier,
        cancellationToken?: CancellationToken)
        : Promise<SourceControlVersion[]>;

    getRecentVersionsTillMergeVersionAsync(
        mergeVersionHash: string,
        sourceControl: SourceControlIdentifier,
        cancellationToken?: CancellationToken)
        : Promise<SourceControlVersion[]>;

    getDiffsForVersionAsync(
        sourceControl: SourceControlIdentifier,
        version: string,
        cancellationToken?: CancellationToken)
        : Promise<SourceControlResourceDiff[]>;

    getDiffForResourceAsync(
        resource: SourceControlResourceIdentifier,
        cancellationToken?: CancellationToken)
        : Promise<SourceControlResourceDiff>;

    getResourceAsync(
        resource: SourceControlResourceIdentifier,
        cancellationToken?: CancellationToken)
        : Promise<string>;

    cleanResourcesAsync(
        resources: SourceControlResourceIdentifier[],
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getMergeVersionAsync(
        sourceControlIdentifier: SourceControlIdentifier,
        remoteVersionName: string,
        cancellationToken?: CancellationToken)
        : Promise<SourceControlVersion>;

    getRemoteVersionsNamesAsync(
        sourceControlIdentifier: SourceControlIdentifier,
        cancellationToken?: CancellationToken)
        : Promise<string[]>;

    getCurrentVersionNameAsync(
        sourceControlIdentifier: SourceControlIdentifier,
        cancellationToken?: CancellationToken)
        : Promise<string>;

    readonly onSourceControlChanged: Event<SourceControlChangedEventArgs>;

    readonly onResourceChanged: Event<SourceControlResourceChangedEventArgs>;
}

export interface SourceEventService {
    fireEventAsync(
        sourceId: string,
        jsonContent: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    setSourceDataAsync(
        sourceId: string,
        jsonContent: string,
        fireEvent: boolean,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getSourceDataAsync(
        sourceId: string,
        cancellationToken?: CancellationToken)
        : Promise<string>;

    readonly onEvent: Event<SourceEventArgs>;
}

export interface StreamManagerService {
    getStreamAsync(
        streamName: string,
        condition: string,
        cancellationToken?: CancellationToken)
        : Promise<string>;
}

export interface StreamService {
    getStreamTraitsAsync(
        id: string,
        cancellationToken?: CancellationToken)
        : Promise<StreamTraits>;

    getLengthAsync(
        id: string,
        cancellationToken?: CancellationToken)
        : Promise<number>;

    setLengthAsync(
        id: string,
        length: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    seekAsync(
        id: string,
        offset: number,
        origin: SeekOrigin,
        cancellationToken?: CancellationToken)
        : Promise<number>;

    readBytesAsync(
        id: string,
        count: number,
        cancellationToken?: CancellationToken)
        : Promise<stringBase64>;

    writeBytesAsync(
        id: string,
        bytes: stringBase64,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    disposeStreamAsync(
        id: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;
}

export interface TaskOutputService {
    getTaskOutputsAsync(
        cancellationToken?: CancellationToken)
        : Promise<TaskOutputInfo[]>;

    shareTaskOutputAsync(
        name: string,
        options: TaskOutputOptions,
        cancellationToken?: CancellationToken)
        : Promise<TaskOutputInfo>;

    updateTaskOutputFeedAsync(
        id: number,
        cancellationToken?: CancellationToken)
        : Promise<TaskOutputInfo>;

    closeTaskOutputAsync(
        id: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onTaskOutputShared: Event<TaskOutputEventArgs>;

    readonly onTaskOutputFeedUpdated: Event<TaskOutputEventArgs>;

    readonly onTaskOutputClosed: Event<TaskOutputEventArgs>;
}

export interface TelemetryService {
    initializeAsync(
        settings: TelemetrySettings,
        cancellationToken?: CancellationToken)
        : Promise<TelemetrySettings>;

    getServiceUriAsync(
        cancellationToken?: CancellationToken)
        : Promise<string>;

    readonly onGenericOperation: Event<GenericOperationEventArgs>;
}

export interface TerminalEndpoint {
    readBytesAsync(
        count: number,
        cancellationToken?: CancellationToken)
        : Promise<stringBase64>;

    writeBytesAsync(
        bytes: stringBase64,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readStringAsync(
        cancellationToken?: CancellationToken)
        : Promise<string>;

    writeStringAsync(
        value: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;
}

export interface TerminalService {
    startTerminalAsync(
        options: TerminalOptions,
        cancellationToken?: CancellationToken)
        : Promise<TerminalInfo>;

    getRunningTerminalsAsync(
        cancellationToken?: CancellationToken)
        : Promise<TerminalInfo[]>;

    resizeTerminalAsync(
        terminalId: number,
        cols: number,
        rows: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    stopTerminalAsync(
        terminalId: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    setTerminalReadOnlyForGuestsAsync(
        terminalId: number,
        readOnlyForGuests: boolean,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onTerminalStarted: Event<TerminalEventArgs>;

    readonly onTerminalResized: Event<TerminalEventArgs>;

    readonly onTerminalStopped: Event<TerminalEventArgs>;

    readonly onTerminalReadOnlyChanged: Event<TerminalEventArgs>;
}

export interface TextSearchService {
    getTextSearchResultsAsync(
        options: TextSearchOptions,
        cancellationToken?: CancellationToken)
        : Promise<TextSearchResult[]>;

    getTextSearchResultsWithProgressAsync(
        options: TextSearchOptions,
        progress: Progress<TextSearchResult>,
        cancellationToken?: CancellationToken)
        : Promise<void>;
}

export interface WorkspaceAccessControlService {
    getAccessControlAsync(
        cancellationToken?: CancellationToken)
        : Promise<WorkspaceAccessControl>;

    setAccessControlAsync(
        accessControl: WorkspaceAccessControl,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    requestOperationAccessAsync(
        operation: RestrictedOperation,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    setOperationAccessAsync(
        operation: RestrictedOperation,
        access: RestrictedOperationAccess,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    rejectOperationAsync(
        operation: RestrictedOperation,
        access: RestrictedOperationAccess,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onAccessControlChanged: Event<WorkspaceAccessControlEventArgs>;

    readonly onOperationRejected: Event<RestrictedOperationAccessEventArgs>;

    readonly onOperationAccessChanged: Event<RestrictedOperationAccessEventArgs>;

    readonly onOpeationAccessRequested: Event<RestrictedOperationAccessRequestedEventArgs>;
}

export interface WorkspaceDiagnosticsService {
    getDiagnosticsAsync(
        cancellationToken?: CancellationToken)
        : Promise<DiagnosticEntry[]>;

    readonly onDiagnosticDataChanged: Event<DiagnosticDataChangedEventArgs>;
}

export interface WorkspaceService {
    getWorkspaceAsync(
        workspaceId: string,
        cancellationToken?: CancellationToken)
        : Promise<WorkspaceInfo>;

    listWorkspacesAsync(
        options: WorkspaceListOptions,
        cancellationToken?: CancellationToken)
        : Promise<WorkspaceInfo[]>;

    shareWorkspaceAsync(
        shareInfo: WorkspaceShareInfo,
        cancellationToken?: CancellationToken)
        : Promise<WorkspaceSessionInfo>;

    unshareWorkspaceAsync(
        workspaceId: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    joinWorkspaceAsync(
        joinInfo: WorkspaceJoinInfo,
        cancellationToken?: CancellationToken)
        : Promise<WorkspaceSessionInfo>;

    unjoinWorkspaceAsync(
        workspaceId: string,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    registerServicesAsync(
        serviceNames: string[],
        changeType: CollectionChangeType,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onServicesChanged: Event<WorkspaceServicesChangedEventArgs>;

    readonly onConnectionStatusChanged: Event<WorkspaceConnectionStatusChangedEventArgs>;

    readonly onProgressUpdated: Event<WorkspaceProgressEventArgs>;

    readonly onUserRemoved: Event<EventArgs>;
}

export interface WorkspaceTaskService {
    getSupportedTasksAsync(
        cancellationToken?: CancellationToken)
        : Promise<WorkspaceTask[]>;

    getTaskExecutionsAsync(
        cancellationToken?: CancellationToken)
        : Promise<TaskExecutionMoniker[]>;

    runTaskAsync(
        taskUid: string,
        cancellationToken?: CancellationToken)
        : Promise<RunTaskResult>;

    runDefaultBuildTaskAsync(
        cancellationToken?: CancellationToken)
        : Promise<RunTaskResult>;

    terminateTaskAsync(
        taskExecution: TaskExecutionMoniker,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    readonly onTaskStarted: Event<TaskExecutionStatusEventArgs>;

    readonly onTaskTerminated: Event<TaskExecutionStatusEventArgs>;
}

export interface WorkspaceUserService {
    acceptOrRejectGuestAsync(
        sessionNumber: number,
        acceptance: GuestAcceptance,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    autoAcceptGuestsAsync(
        acceptance: GuestAcceptance,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    removeUserAsync(
        sessionNumber: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    fireProgressUpdatedToGuestAsync(
        progress: WorkspaceProgress,
        sessionNumber: number,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getCountOfGuestsWithSameAccountAsync(
        name: string,
        email: string,
        cancellationToken?: CancellationToken)
        : Promise<number>;

    createGuestDisplayNameAsync(
        userProfile: WorkspaceUserProfile,
        cancellationToken?: CancellationToken)
        : Promise<string>;

    getCachedGuestDisplayNameAsync(
        sessionNumber: number,
        cancellationToken?: CancellationToken)
        : Promise<string>;

    readonly onWorkspaceSessionChanged: Event<WorkspaceSessionChangedEventArgs>;
}

export interface LanguageServerProvider {
    getMetadataAsync(
        cancellationToken?: CancellationToken)
        : Promise<LanguageServerProviderMetadata>;

    requestAsync(
        request: LspMessage,
        coeditingInfo: CoeditingInformation,
        cancellationToken?: CancellationToken)
        : Promise<Object>;

    notify(
        notification: LspMessage)
        : void;

    readonly onNotified: Event<NotificationEventArgs>;
}

export interface DebuggerHostService {
    getCurrentDebugSessionsAsync(
        cancellationToken?: CancellationToken)
        : Promise<DebugSession[]>;

    launchDebugSessionAsync(
        debugConfiguration: Object,
        cancellationToken?: CancellationToken)
        : Promise<void>;

    getLaunchConfigurationsAsync(
        cancellationToken?: CancellationToken)
        : Promise<Object>;

    readonly onDebugSessionChanged: Event<DebugSessionChangedEventArgs>;

    readonly onLaunchConfigurationsChanged: Event<LaunchConfigurationChangedEventArgs>;
}


/**
 * Metadata required to generate proxies for the service interfaces
 * (because TypeScript interfaces cannot be reflected at runtime).
 */
export interface ServiceInfo<T> {
    readonly name?: string;
    readonly methods: string[];
    readonly voidMethods?: string[];
    readonly events: string[];
}

/* tslint:disable:variable-name */

export const AccessControlService: ServiceInfo<AccessControlService> = {
    name: 'accessControl',
    methods: [ 'getAccessControl' ],
    events: [ 'accessControlChanged' ],
};
export const AgentSessionService: ServiceInfo<AgentSessionService> = {
    name: 'agentSessionService',
    methods: [ 'initializeSession', 'enableReconnect', 'keepAlive' ],
    events: [ ],
};
export const AuthenticationService: ServiceInfo<AuthenticationService> = {
    name: 'auth',
    methods: [ 'getLoginUri', 'findLoginCode', 'login', 'loginAsAnonymous', 'loginWithCachedToken', 'loginWithExternalToken', 'logout', 'getCurrentUser', 'removeRecentCollaborator', 'removeAllRecentCollaborators', 'getCurrentAuthenticatedUser' ],
    events: [ 'authenticationChanged' ],
};
export const BrokerAuthorizationService: ServiceInfo<BrokerAuthorizationService> = {
    name: 'brokerAuthorization',
    methods: [ 'authorize' ],
    events: [ ],
};
export const BrokerManagerService: ServiceInfo<BrokerManagerService> = {
    name: 'brokerManager',
    methods: [ 'register', 'tryRevoke' ],
    events: [ ],
};
export const ClientAccessCheck: ServiceInfo<ClientAccessCheck> = {
    methods: [ 'isClientReadOnly', 'isClientReadOnly', 'canPerformOperation', 'getGuestSessionId', 'isDefaultAccessControlReadOnly', 'isUserExplicitlyReadWrite' ],
    voidMethods: [ 'verifyCanPerformOperation', 'logRejectedOperation' ],
    events: [ ],
};
export const CommentService: ServiceInfo<CommentService> = {
    name: 'commentService',
    methods: [ 'createCommentThread', 'createComment', 'updateComment', 'deleteComment', 'getAllCommentThreads', 'getCommentThreadPositions', 'updateLike' ],
    events: [ 'commentThreadChanged' ],
};
export const ConfigurationService: ServiceInfo<ConfigurationService> = {
    name: 'version',
    methods: [ 'exchangeVersions', 'exchangeSettings', 'getSubnetMasks' ],
    events: [ ],
};
export const FileService: ServiceInfo<FileService> = {
    name: 'file',
    methods: [ 'registerExternalFiles', 'listRoots', 'list', 'readText', 'readStream', 'writeText', 'writeStream', 'createDirectory', 'delete', 'copy', 'move', 'getFiles', 'isExcluded', 'findFiles', 'getTextSearchResults', 'getTextSearchResultsWithProgress' ],
    events: [ 'filesChanged' ],
};
export const FirewallService: ServiceInfo<FirewallService> = {
    name: 'firewall',
    methods: [ 'getFirewallStatus' ],
    events: [ ],
};
export const PortForwardingService: ServiceInfo<PortForwardingService> = {
    name: 'portForwarding',
    methods: [ 'getSharedServers' ],
    events: [ 'sharingStarted', 'browseSharingStarted', 'sharingStopped', 'sharingChanged' ],
};
export const ServerSharingService: ServiceInfo<ServerSharingService> = {
    name: 'serverSharing',
    methods: [ 'startSharing', 'stopSharing', 'stopSharingBrowseSessions', 'getSharedServers', 'updateSessionName' ],
    events: [ 'sharingStarted', 'browseSharingStarted', 'sharingStopped', 'sharingChanged' ],
};
export const SessionContextService: ServiceInfo<SessionContextService> = {
    name: 'sessionContext',
    methods: [ 'getServiceNames' ],
    voidMethods: [ 'sendSessionStateUpdateToClient', 'sendSessionStatusUpdateToClient' ],
    events: [ 'sessionStateUpdate', 'sessionStatusUpdate' ],
};
export const SolutionViewService: ServiceInfo<SolutionViewService> = {
    name: 'solutionView',
    methods: [ 'getChildrenNodes', 'getRootNodes', 'addNewItem', 'renameItem', 'deleteItem' ],
    events: [ 'solutionChanged' ],
};
export const SourceControlService: ServiceInfo<SourceControlService> = {
    name: 'sourceControl',
    methods: [ 'getAllSourceControls', 'getSourceControls', 'getSourceControl', 'getRecentVersions', 'getRecentVersionsTillMergeVersion', 'getDiffsForVersion', 'getDiffForResource', 'getResource', 'cleanResources', 'getMergeVersion', 'getRemoteVersionsNames', 'getCurrentVersionName' ],
    events: [ 'sourceControlChanged', 'resourceChanged' ],
};
export const SourceEventService: ServiceInfo<SourceEventService> = {
    name: 'sourceEvent',
    methods: [ 'fireEvent', 'setSourceData', 'getSourceData' ],
    events: [ 'event' ],
};
export const StreamManagerService: ServiceInfo<StreamManagerService> = {
    name: 'streamManager',
    methods: [ 'getStream' ],
    events: [ ],
};
export const StreamService: ServiceInfo<StreamService> = {
    name: 'stream',
    methods: [ 'getStreamTraits', 'getLength', 'setLength', 'seek', 'readBytes', 'writeBytes', 'disposeStream' ],
    events: [ ],
};
export const TaskOutputService: ServiceInfo<TaskOutputService> = {
    name: 'taskOutput',
    methods: [ 'getTaskOutputs', 'shareTaskOutput', 'updateTaskOutputFeed', 'closeTaskOutput' ],
    events: [ 'taskOutputShared', 'taskOutputFeedUpdated', 'taskOutputClosed' ],
};
export const TelemetryService: ServiceInfo<TelemetryService> = {
    name: 'telemetry',
    methods: [ 'initialize', 'getServiceUri' ],
    events: [ 'genericOperation' ],
};
export const TerminalEndpoint: ServiceInfo<TerminalEndpoint> = {
    name: 'terminalEndpoint',
    methods: [ 'readBytes', 'writeBytes', 'readString', 'writeString' ],
    events: [ ],
};
export const TerminalService: ServiceInfo<TerminalService> = {
    name: 'terminal',
    methods: [ 'startTerminal', 'getRunningTerminals', 'resizeTerminal', 'stopTerminal', 'setTerminalReadOnlyForGuests' ],
    events: [ 'terminalStarted', 'terminalResized', 'terminalStopped', 'terminalReadOnlyChanged' ],
};
export const TextSearchService: ServiceInfo<TextSearchService> = {
    name: 'textSearch',
    methods: [ 'getTextSearchResults', 'getTextSearchResultsWithProgress' ],
    events: [ ],
};
export const WorkspaceAccessControlService: ServiceInfo<WorkspaceAccessControlService> = {
    name: 'workspaceAccessControl',
    methods: [ 'getAccessControl', 'setAccessControl', 'requestOperationAccess', 'setOperationAccess', 'rejectOperation' ],
    events: [ 'accessControlChanged', 'operationRejected', 'operationAccessChanged', 'opeationAccessRequested' ],
};
export const WorkspaceDiagnosticsService: ServiceInfo<WorkspaceDiagnosticsService> = {
    name: 'workspaceDiagnostics',
    methods: [ 'getDiagnostics' ],
    events: [ 'diagnosticDataChanged' ],
};
export const WorkspaceService: ServiceInfo<WorkspaceService> = {
    name: 'workspace',
    methods: [ 'getWorkspace', 'listWorkspaces', 'shareWorkspace', 'unshareWorkspace', 'joinWorkspace', 'unjoinWorkspace', 'registerServices' ],
    events: [ 'servicesChanged', 'connectionStatusChanged', 'progressUpdated', 'userRemoved' ],
};
export const WorkspaceTaskService: ServiceInfo<WorkspaceTaskService> = {
    name: 'workspaceTask',
    methods: [ 'getSupportedTasks', 'getTaskExecutions', 'runTask', 'runDefaultBuildTask', 'terminateTask' ],
    events: [ 'taskStarted', 'taskTerminated' ],
};
export const WorkspaceUserService: ServiceInfo<WorkspaceUserService> = {
    name: 'workspaceuser',
    methods: [ 'acceptOrRejectGuest', 'autoAcceptGuests', 'removeUser', 'fireProgressUpdatedToGuest', 'getCountOfGuestsWithSameAccount', 'createGuestDisplayName', 'getCachedGuestDisplayName' ],
    events: [ 'workspaceSessionChanged' ],
};
export const LanguageServerProvider: ServiceInfo<LanguageServerProvider> = {
    methods: [ 'getMetadata', 'request' ],
    voidMethods: [ 'notify' ],
    events: [ 'notified' ],
};
export const DebuggerHostService: ServiceInfo<DebuggerHostService> = {
    name: 'DebuggerHostService',
    methods: [ 'getCurrentDebugSessions', 'launchDebugSession', 'getLaunchConfigurations' ],
    events: [ 'debugSessionChanged', 'launchConfigurationsChanged' ],
};
