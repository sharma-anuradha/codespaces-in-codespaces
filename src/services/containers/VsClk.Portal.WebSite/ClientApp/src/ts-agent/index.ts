
import { WebClient } from './webClient';
import { WorkspaceClient } from './workspaceClient';

import * as vsls from './contracts/VSLS';

import { CancellationToken } from 'vscode';
import { SshChannel } from '@vs/vs-ssh';

import { trace } from '../utils/trace';
import { Signal } from '../utils/signal';
import { SshChannelOpenner } from './sshChannelOpenner';

import { DEFAULT_EXTENSIONS, WEB_EMBED_PRODUCT_JSON, VSLS_API_URI } from '../constants';
import { ICloudEnvironment } from '../interfaces/cloudenvironment';

export class EnvConnector {
    private isConnecting: boolean = false;
    
    private initializeConnectionSignal: Signal<any> = new Signal();

    private async startVscodeServer(workspaceClient: WorkspaceClient): Promise<number> {

        const vscodeServerHostClient = workspaceClient.getServiceProxy<
            VSCodeServerHostService
        >(VSCodeServerHostService);

        const options: VSCodeServerOptions = {
            vsCodeCommit: WEB_EMBED_PRODUCT_JSON.commit,
            quality: WEB_EMBED_PRODUCT_JSON.quality,
            extensions: [...DEFAULT_EXTENSIONS],
            telemetry: true,
        };

        trace(`Starting VSCode server: `, options);

        const remotePort = await vscodeServerHostClient.startRemoteServerAsync(options);

        return remotePort;
    }

    private async forwardVscodeServerPort(remotePort: number, workspaceClient: WorkspaceClient): Promise<vsls.SharedServer> {
        const serverSharingService = workspaceClient.getServiceProxy<vsls.ServerSharingService>(vsls.ServerSharingService);
        const sharedServer = await serverSharingService.startSharingAsync(
            remotePort,
            'VSCodeServerInternal',
            '',
        );

        return sharedServer;
    }

    public async ensureConnection(environmentInfo: ICloudEnvironment, accessToken: string) {
        // if already `connecting` or `connected`, return the result
        if (this.isConnecting) {
            return await this.initializeConnectionSignal.promise;
        }

        this.isConnecting = true;

        const { sessionId, sessionPath } = environmentInfo.connection;

        trace(`Live Share session id: ${sessionId}, workspace path: "${sessionPath}"`);

        const webClient = new WebClient(VSLS_API_URI, accessToken);

        const workspaceClient = new WorkspaceClient(webClient);

        await workspaceClient.connect(sessionId);
        await workspaceClient.authenticate();
        await workspaceClient.join();

        trace(`Connected to VSLS.`);

        const streamManagerClient = workspaceClient.getServiceProxy<vsls.StreamManagerService>(vsls.StreamManagerService);


        const port = await this.startVscodeServer(workspaceClient);

        trace(`Started VSCode server started on port [${port}].`);

        trace(`Forwarding the VSCode port [${port}].`);

        const vscodeServer = await this.forwardVscodeServerPort(port, workspaceClient);

        trace(`Forwarded the VSCode [OK].`);

        trace(`Creating the stream.`);

        this.channelOpenner = workspaceClient.createServerStream(vscodeServer, streamManagerClient);

        trace(`Stream created.`);

        const result = {
            sessionPath,
            port
        };

        this.initializeConnectionSignal.complete(result);

        return result;
    }

    private channelOpenner: SshChannelOpenner;

    public sendHandshakeRequest(requestStr: string): Promise<SshChannel> {
        return new Promise((resolve) => {
            this.sendRequestInternal(requestStr, resolve);
        });
    }
    
    private async sendRequestInternal(requestStr: string, callback: (channel: SshChannel) => any): Promise<SshChannel> {
        if (!this.channelOpenner) {
            throw new Error('Initialize connection first to create the port forwarder.');
        }

        trace('Openning SSH channel.');
        const channel = await this.channelOpenner.openChannel();

        const buf: Buffer = Buffer.from(requestStr);

        trace(`Sending the request: \n${requestStr}\n`);

        await channel.send(buf);
        
        let isOnce = false;
        channel.onDataReceived((e: Buffer) => {
            // the first request on this channel  is for the handshake,
            // ignore all other data messages as the consumer will set up its own listeners.
            if (isOnce) {
                return;
            }

            trace(`Response: \n${e.toString()}\n`);

            isOnce = true;
            callback(channel);
            channel.attemptAdjustWindow(e.length);
        });

        return channel;
    }
}

export interface VSCodeServerOptions {
    vsCodeCommit: string;
    quality: string;
    extensions: string[];
    telemetry: boolean;
}

// The VSCodeServerHost RPC interface is not yet autogenerated in VSLS.ts.
export interface VSCodeServerHostService {
    startRemoteServerAsync(
        input: VSCodeServerOptions,
        cancellationToken?: CancellationToken,
    ): Promise<number>;

    exportLogsAsync(): Promise<string>;
}

// tslint:disable-next-line: variable-name
export const VSCodeServerHostService: vsls.ServiceInfo<VSCodeServerHostService> = {
    name: 'IVSCodeServerHostService',
    methods: ['startRemoteServer', 'exportLogs'],
    events: [],
};
