/// <reference path="./FxEnvironment.d.ts" />
/// <reference path="./FxReactCommon.d.ts" />
/// <reference path="./Html5.d.ts" />
/// <reference path="./jquery.d.ts" />
/// <reference path="./redux.d.ts" />
/// <reference path="./require.d.ts" />

// Compiled with TypeScript 3.9

// FILE: MsPortalFx\Assets\Assets.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    import FxImage = FxBase.Image;
    import FxExtension = MsPortalFx.Extension;
    import FxComposition = FxImpl.Composition.Selectable;
    import DynamicSelection = MsPortalFx.ViewModels.DynamicSelection;
    import DynamicBladeSelection = MsPortalFx.ViewModels.DynamicBladeSelection;
    /**
     * Represents a set of flags for the contracts supported by the asset view model.
     */
    const enum AssetContracts {
        /**
         * No contracts supported by the asset type.
         */
        None = 0,
        /**
         * OBSOLETE - do not remove, do not use.
         */
        ObsoleteAssetInfo = 1,
        /**
         * The asset type supports the browse config contract.
         */
        BrowseConfig = 2,
        /**
         * The asset type supports the supplemental data contract.
         */
        SupplementalData = 4,
        /**
         * The asset type supports the resource menu config contract.
         */
        ResourceMenuConfig = 8,
        /**
         * The asset type supports the resource menu config contract but only for kinds marked as use resource menu.
         */
        KindResourceMenuConfig = 16,
        /**
         * The asset type supports static resource menu overview.
         */
        StaticResourceMenuOverview = 32,
        /**
         * The asset type supports providing resources contract.
         */
        ProvidesResources = 64,
        /**
         * The asset type's resource menu blade can load the resource provided by the extension.
         */
        ExtensionSuppliesResourceForResourceMenu = 128,
        /**
         * The asset type's resource menu blade can ignore the resource.
         */
        NoResourceForResourceMenu = 256,
        /**
         * The asset type has the kind override flags.
         */
        HasKindOverrideFlags = 512,
        /**
         * The asset type has a kind which overrides the use resource menu flag.
         */
        HasKindWhichOverridesUseResourceMenu = 1024,
        /**
         * The asset type has a kind which overrides the display name.
         */
        HasKindWhichOverridesDisplayName = 2048,
        /**
         * The asset type has a kind which overrides the blade.
         */
        HasKindWhichOverridesBlade = 4096,
        /**
         * The asset type has a kind which overrides the icon.
         */
        HasKindWhichOverridesIcon = 8192,
        /**
         * The asset type supports browse using a query from PDL.
         */
        SupportsBrowseQuery = 16384,
        /**
         * The asset type supports a declarative menu.
         */
        SupportsAssetMenu = 32768
    }
    /**
     * Represents a set of flags for the browse requirements for the asset view model.
     */
    const enum BrowseRequirements {
        /**
         * Indicates no permissions are required
         */
        None = 0,
        /**
         * Indicates that co-admin permissions are required.
         */
        CoAdmin = 1
    }
    /**
     * Determines if the given contracts flag set supports a given contract.
     *
     * @param contracts The contracts flag set which contains all the supported contracts.
     * @param contract The asset contract to check.
     * @return Boolean true if the contracts flag set supports the given contract, else false.
     */
    function supportsContract(contracts: number, contract: AssetContracts): boolean;
    /**
     * Determines if the given asset type information supports a given contract.
     *
     * @param assetTypeInformation The asset type information which contains all the supported contracts.
     * @param contract The asset contract to check.
     * @return Boolean true if there is an asset type information, a view model and the contracts supports the given contract, else false.
     */
    function assetTypeInformationSupportsContract(assetTypeInformation: AssetTypeInformation, contract: AssetContracts): boolean;
    /**
     * This represents an asset type display name in it's four forms.
     */
    interface CompositeDisplayName {
        /**
         * The singular, formal-cased display name.
         */
        singular: string;
        /**
         * The plural, formal-cased display name.
         */
        plural: string;
        /**
         * The singular, lower-cased display name.
         */
        lowerSingular: string;
        /**
         * The plural, lower-cased display name.
         */
        lowerPlural: string;
        /**
         * The service display name.
         */
        service?: string;
    }
    /**
     * The asset type interface which represents a fully qualified asset type (extension + asset type).
     */
    interface AssetType {
        /**
         * The extension name for the fully qualified asset type.
         */
        extensionName: string;
        /**
         * The asset type for the fully qualified asset type.
         */
        assetType: string;
    }
    /**
     * The documentation link for the asset type.
     */
    interface Link {
        /**
         * The link title for the asset type.
         */
        title: string;
        /**
         * The link uri for the asset type.
         */
        uri: string;
    }
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    interface AssetTypeInformation extends AssetType {
        /**
         * The asset type's icon image if successful, null otherwise.
         */
        icon: FxImage;
        /**
         * The asset type's display name if successful, null otherwise.
         */
        compositeDisplayName: CompositeDisplayName;
        /**
         * The options for the asset type.
         */
        options?: FxExtension.AssetTypeOptions;
        /**
         * The browse type for the asset type.
         */
        browseType: FxExtension.BrowseType;
        /**
         * The browse link URI for the asset type.
         */
        browseLinkUri?: string;
        /**
         * The entry point of the view model.
         */
        viewModelLocator: MsPortalFx.Extension.ViewModelLocator;
        /**
         * The name of the asset type view model associated with this asset type.
         */
        viewModel: string;
        /**
         * The name of the extension that contains the view model.
         */
        viewModelExtensionName?: string;
        /**
         * The contracts flag for which contracts the asset view model supports.
         */
        contracts: number;
        /**
         * Optional flag to indicate the asset type is from a preview extension.
         * If this flag is not specified, the asset type is NOT from a preview.
         */
        isPreview?: boolean;
        /**
         * The create blade associated with the asset
         */
        noPdlCreateBlade?: string;
        /**
         * The extension with the create blade associated with the asset
         */
        noPdlCreateExtension?: string;
        /**
         * The marketplace item id associated with the asset.
         */
        marketplaceItemId?: string;
        /**
         * The marketplace menu item id associated with the asset.
         */
        marketplaceMenuItemId?: string;
        /**
         * Optional 'private' browse flag which indicates to exclude this asset from the browse UX.
         *
         * @deprecated 04/30/2020 - This has been superseded by options. Please use the 'options' property and the
         * AssetTypeOptions flags.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        privateBrowse?: boolean;
        /**
         * The list of keywords.
         */
        keywords?: string[];
        /**
         * The description of asset type.
         */
        description?: string;
        /**
         * The documentation links for asset type.
         */
        links?: Link[];
        /**
         * The list of hidden commands for the asset type.
         */
        hiddenCommands?: ReadonlyArray<string>;
    }
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    interface ResourceTypeAssetTypeInformation extends AssetTypeInformation {
        /**
         * The resource type.
         */
        resourceType: string;
        /**
         * The API resource type for ARM.
         * This is only valid for tenant-routing resources.
         */
        topLevelTenantAlias?: string;
        /**
         * The API resource type for ARM.
         * This is only valid for end-point-routing resources.
         */
        topLevelResourceTypeAlias?: string;
        /**
         * The ARM API version to use for this resource type.
         * If this is not specified, the latest API version will be used from the ARM manifest file.
         */
        apiVersion?: string;
        /**
         * The flag to hide assets from the resource map.
         * THIS IS OBSOLETE AND WILL ALWAYS BE TRUE UNTIL THIS FLAG IS REMOVED.
         */
        hideOnResourceMap?: boolean;
        /**
         * The routing type for the resource type.
         * If this is not specified, the 'Default' routing type will be used.
         */
        routingType?: FxExtension.ResourceRoutingType;
        /**
         * The blade associated with the resource type.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the resource type.
         */
        bladeExtensionName?: string;
        /**
         * The part associated with the resource type.
         */
        partName?: string;
        /**
         * Optional, an external extension that contains the resource part
         */
        partExtensionName?: string;
        /**
         * The static overview menu item.
         */
        staticOverview?: FxExtension.StaticOverviewDefinition;
        /**
         * The optional array of kinds for this resource type.
         */
        kinds?: FxExtension.ResourceKindDefinition[];
        /**
         * The optional array of proxy routing filters for this resource type.
         */
        proxyRoutingFilters?: FxExtension.ProxyRoutingFilter[];
        /**
         * The option for ARG browse.
         */
        argBrowseOption?: FxExtension.ArgBrowseOptions;
    }
    /**
     * The asset triplet interface which represents a fully qualified asset ID.
     */
    interface AssetTriplet {
        /**
         * The extension name for the fully qualified asset ID.
         */
        extensionName: string;
        /**
         * The asset type for the fully qualified asset ID.
         */
        assetType: string;
        /**
         * The asset ID for the fully qualified asset ID.
         */
        assetId: any;
    }
    /**
     * The asset information interface which represents an asset ID and asset type information for a given resource ID.
     */
    interface AssetInformation extends AssetTypeInformation {
        /**
         * The asset ID if successful, null otherwise.
         */
        assetId: any;
        /**
         * The dynamic selection if successful, null otherwise.
         */
        dynamicSelection: DynamicSelection;
    }
    /**
     * The asset information interface which represents an asset ID and asset type information for a given resource ID.
     */
    interface ResourceAssetInformation extends AssetInformation {
        /**
         * The resource ID.
         */
        resourceId: string;
    }
    /**
     * The asset type information interface which represents the registered asset types and indicates if the set is complete or not.
     */
    interface RegisteredAssetTypesInformation {
        /**
         * Asset type information.
         */
        assetTypesInformation: ResourceTypeAssetTypeInformation[];
        /**
         * Indicates whether the Asset type data is complete i.e. from all the loaded extensions or is partial.
         */
        isPartialSet?: boolean;
    }
    /**
     * The asset blade reference provides the extension and blade name for a blade.
     */
    interface AssetBladeReference {
        /**
         * The name of the blade.
         */
        blade: string;
        /**
         * The name of the extension.
         */
        extension: string;
    }
    /**
     * The dynamic selection and icon interface provides a wrapper for dynamic selection and icon.
     */
    interface DynamicSelectionAndIcon {
        /**
         * The selection.
         */
        selection: DynamicSelection;
        /**
         * The icon.
         */
        icon: FxImage;
        /**
         * Optional flag to indicate the asset type is from a preview extension.
         * If this flag is not specified, the asset type is NOT from a preview.
         */
        isPreview?: boolean;
    }
    /**
     * The resource blade inputs contract provides the inputs for all resource and asset blades.
     */
    interface ResourceBladeInputs {
        /**
         * The ID of the resource or asset for the blade.
         */
        id: any;
    }
    /**
     * Maps a dynamic blade selection to a blade reference.
     *
     * @param bladeSelection The dynamic blade selection.
     * @param onClosed The onClosed callback for the blade.
     * @return The promise that resolves to the blade reference.
     */
    function mapDynamicBladeSelectionToBladeReference<T>(bladeSelection: DynamicBladeSelection, onClosed?: FxImpl.CompositionCore.BladeClosedWithDataHandler<T>): Q.Promise<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Maps an asset ID to a resource ID using the asset type system.
     * Note that this will reject if the asset type does not support mapping to resource ID.
     *
     * @deprecated 2020/04/30 - All asset ID's should be resource ID's and this should no longer be used.
     * The MappingViewModel is no longer implemented by any assets and this can be removed and just use the
     * resource ID directly which includes the resource type.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * @param assetId The fully qualified asset ID.
     * @return A promise that resolves to the resource ID string for the fully qualified asset ID.
     */
    function mapAssetIdToResourceId(assetId: AssetTriplet): Obsolete;
    /**
     * Maps a resource ID to an asset ID using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @return A promise that resolves to the fully qualified asset ID for the resource ID.
     */
    function mapResourceIdToAssetId(resourceId: string): FxPromiseV<AssetTriplet>;
    /**
     * Maps an asset triplet to a blade reference and an icon using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @return A promise that resolves to the fully qualified blade reference and the icon for the asset ID.
     */
    function mapAssetIdToDynamicSelectionAndIcon(assetId: AssetTriplet, forceBladeSelection?: boolean): FxPromiseV<DynamicSelectionAndIcon>;
    /**
     * Maps an asset triplet to a dynamic selection using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @return A promise that resolves to the fully qualified dynamic selection for the asset ID.
     */
    function mapAssetIdToDynamicSelection(assetId: AssetTriplet, forceBladeSelection?: boolean): FxPromiseV<DynamicSelection>;
    /**
     * Maps an asset triplet to blade reference using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @return A promise that resolves to the fully qualified blade reference for the asset ID.
     */
    function mapAssetIdToBladeReference(assetId: AssetTriplet): Q.Promise<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Maps a resource ID to a dynamic selection and an icon using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @return A promise that resolves to the fully qualified dynamic selection and the icon for the resource ID.
     */
    function mapResourceIdToDynamicSelectionAndIcon(resourceId: string, forceBladeSelection?: boolean): FxPromiseV<DynamicSelectionAndIcon>;
    /**
     * Maps a resource ID to a dynamic selection using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @return A promise that resolves to the fully qualified dynamic selection for the resource ID.
     */
    function mapResourceIdToDynamicSelection(resourceId: string, forceBladeSelection?: boolean): FxPromiseV<DynamicSelection>;
    /**
     * Maps a resource ID to blade reference using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param onClosed The onClosed callback for the blade.
     * @return A promise that resolves to the fully qualified blade reference for the resource ID.
     */
    function mapResourceIdToBladeReference(resourceId: string, onClosed?: FxImpl.CompositionCore.BladeClosedWithDataHandler<any>): Q.Promise<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Gets an asset type's information for a given asset type using the asset type system.
     * Note that this will reject if the asset type is not found.
     *
     * @param extensionName The name of the extension that owns the asset type.
     * @param assetType The name of the asset type.
     * @return A promise that resolves to the asset type information structure for the asset type.
     */
    function getAssetTypeInformation(extensionName: string, assetType: string): FxPromiseV<AssetTypeInformation>;
    /**
     * Gets an asset type information for an array of resource types using the asset type system.
     * Note that this will not reject if an asset type is not found for the resource type, but the
     * assetTypeInformation will be null for that resource type.
     *
     * @param resourceTypes The array of names of the resource types.
     * @return A promise that resolves to the asset type information structure for the resource type.
     */
    function getResourceTypeAssetTypeInformation(resourceTypes: string[]): FxPromiseV<ResourceTypeAssetTypeInformation[]>;
    /**
     * Gets the asset information for an array of resource IDs using the asset type system.
     * Note that this will not reject if an asset type is not found for the resource type, but the assetId and
     * assetTypeInformation will be null for that resource ID.
     *
     * @param resourceIds An array of resource IDs.
     * @return A promise that resolves to an array of asset information packets, one for each source resource ID.
     */
    function getResourceAssetInformation(resourceIds: string[]): FxPromiseV<ResourceAssetInformation[]>;
    /**
     * Signals that resources of the specified type have changed and cache for these resources should be updated.
     *
     * @deprecated Do not use, no longer supported. This API has for a long time not executed any code in FX, it is
     * safe to remove this call.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * @param resourceIds An array of resource IDs.
     * @return The promise that resolves when the operation has completed.
     */
    function signalResourcesChanged(resourceIds: string[]): Obsolete;
}
declare module FxImpl.Assets {
    import FxAssets = MsPortalFx.Assets;
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    interface ResourceTypeAssetTypeInformation extends FxAssets.ResourceTypeAssetTypeInformation {
        /**
         * These keys are used for performance improvements.
         */
        lowerCaseResourceType: string;
        lowerCaseAssetType: string;
        lowerCaseExtension: string;
        kindMap?: StringMap<MsPortalFx.Extension.ResourceKindDefinition>;
        defaultKind?: string;
    }
    interface AssetTypeSearchAssetTypeCriteria {
        lowerCaseExtension: string;
        lowerCaseAssetType: string;
    }
    interface AssetTypeSearchResourceTypeCriteria {
        lowerCaseResourceType: string;
    }
    type AssetTypeSearchCriteria = AssetTypeSearchResourceTypeCriteria | AssetTypeSearchAssetTypeCriteria;
    /**
     * Gets the unique id of an asset type/resource type.
     *
     * @param extensionName the extension name
     * @param typeName the type name, could be asset type or resource type
     * @return The the unique id.
     */
    function getAssetTypeOrResourceTypeId(extensionName: string, typeName: string): string;
    /**
     * Gets the unique id of an asset type/resource type.
     *
     * @param windowId The window id of the extension.
     * @param typeName the type name, could be asset type or resource type.
     * @return The unique id.
     */
    function getAssetTypeOrResourceTypeIdByWindowId(windowId: string, typeName: string): string;
}

// FILE: MsPortalFx\Assets\Assets.BrowseConfig.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Grid = FxViewModels.Controls.Lists.Grid;
    /**
     * The column to describe a column in the browse grid.
     */
    interface Column {
        /**
         * The column ID.
         */
        id: string;
        /**
         * The column display name (shows up in UI).
         */
        name: KnockoutObservable<string>;
        /**
         * The column description (shows up in UI).
         */
        description?: KnockoutObservable<string>;
        /**
         * The the item key (source property) for the column.
         */
        itemKey: string;
        /**
         * The format for the column.
         */
        format?: Grid.Format;
        /**
         * The format options for the column.
         */
        formatOptions?: Grid.FormatOptions;
        /**
         * The width for the column.
         */
        width?: KnockoutObservable<string>;
        /**
         * The CSS class for the column.
         */
        cssClass?: string;
        /**
         * Hides the column.
         */
        isHidden?: KnockoutObservableBase<boolean>;
        /**
         * Makes the column activatable.
         */
        activatable?: boolean;
        /**
         * If the column is activatable, this provides the dynamic selection.
         */
        dynamicSelectionProvider?: KnockoutObservableBase<(id: any, item: any) => FxBase.PromiseV<FxViewModels.DynamicSelection>>;
    }
    /**
     * The browse config contains the information for a non-default browse such as columns.
     */
    interface BrowseConfig {
        /**
         * The array of column config definitions.
         */
        columns: Column[];
        /**
         * The array of column IDs for the default columns for the browse grid.
         */
        defaultColumns: (string | ResourceColumnIds)[];
        /**
         * Any additional properties used in HTML templates which will be provided by supplemental data.
         */
        properties?: string[];
        /**
         * Optional command group reference for the item context menu.
         */
        contextMenu?: CommandGroupReference;
        /**
         * Optional info box to display custom text.
         */
        infoBox?: BrowseInfoBox;
    }
    /**
     * The command group reference interface which references a command group by name and optional extension.
     */
    interface CommandGroupReference {
        /**
         * The command group name.
         */
        commandGroup: string;
        /**
         * The optional command group owner extension.  If not specified, the asset type extension is used.
         */
        commandGroupOwner?: string;
    }
    /**
     * The browse info box interface which extensions can provide to display custom information on their browse blades.
     */
    interface BrowseInfoBox {
        /**
         * The image on the info box.
         */
        image: FxBase.Image;
        /**
         * The text.
         */
        text: string;
        /**
         * The link to launch from info box.
         */
        uri?: string;
        /**
         * The blade detail to open from info box.
         */
        blade?: FxViewModels.DynamicBladeSelection;
    }
    /**
     * The contract for the asset type's browse config.
     */
    interface BrowseConfigContract {
        /**
         * Gets the browse config.
         *
         * @return A promise which will be resolved with the browse config.
         */
        getBrowseConfig(): FxBase.PromiseV<BrowseConfig> | Promise<BrowseConfig>;
    }
    /**
     * Pre-defined columns for resource types.
     */
    const enum ResourceColumnIds {
        /**
         * The name resource column.
         */
        Name = 1,
        /**
         * The kind resource column.
         */
        Kind = 2,
        /**
         * The resource group resource column.
         */
        ResourceGroup = 3,
        /**
         * The location resource column.
         */
        Location = 4,
        /**
         * The location ID resource column.
         */
        LocationId = 5,
        /**
         * The resource ID resource column.
         */
        ResourceId = 6,
        /**
         * The resource group ID resource column.
         */
        ResourceGroupId = 7,
        /**
         * The resource type resource column.
         */
        ResourceType = 8,
        /**
         * The subscription resource column.
         */
        Subscription = 9,
        /**
         * The subscription ID resource column.
         */
        SubscriptionId = 10,
        /**
         * The asset type resource column.
         */
        AssetType = 11,
        /**
         * The tags resource column.
         */
        Tags = 12,
        /**
         * IMPORTANT: This is used for test, ALL values must be before this last ID and needs to be updated when values
         * are added.
         */
        LastId = 12
    }
}

// FILE: MsPortalFx\Assets\Assets.ProvidesResources.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    /**
     * The contract for the asset type's provides resources.
     */
    interface ProvidesResourcesContract {
        /**
         * Gets a resource.
         *
         * @param id The resource ID.
         * @return A promise which will be resolved with the resource.
         */
        getResource(id: string): FxBase.PromiseV<HubsExtension.Azure.Resource>;
    }
}

// FILE: MsPortalFx\Assets\Assets.ResourceMenuConfig.d.ts
declare module MsPortalFx.Assets {
    import FxMenu = FxImpl.Controls.Menu;
    import FxSubscription = MsPortalFx.Azure.Subscription;
    /**
     * The group IDs for the build-in menu groups.
     */
    const ManagementGroupId = "management_group";
    const SupportGroupId = "support_group";
    const QuickAccessGroupId = "quickaccess_group";
    const MonitoringGroupId = "monitoring_group";
    /**
     * The item IDs for the build-in menu items.
     */
    const EventLogsItemId = "eventlogs";
    const ExportTemplateItemId = "exporttemplate";
    const MyAccessItemId = "access";
    const ResourceProvidersItemId = "resourceproviders";
    const ResourceHealthItemId = "resourcehealth";
    const ResourceGroupsItemId = "resourceGroups";
    const ResourcesItemId = "resources";
    const SubscriptionCertsItemId = "subcerts";
    const SubscriptionQuotasItemId = "quotas";
    const SupportHelpRequestItemId = "supportrequest";
    const TagsItemId = "tags";
    const LocksItemId = "locks";
    const TroubleshootItemId = "troubleshoot";
    const UsersItemId = "users";
    const PropertiesItemId = "properties";
    const AlertsItemId = "alerts";
    const DiagnosticsItemId = "diagnostics";
    const MetricsItemId = "metrics";
    const LogSearchItemId = "logsearch";
    const ResourceAdvisorItemId = "resourceadvisor";
    const AnalyticsItemId = "analytics";
    /**
     * Defines an item in a group of the menu.
     */
    interface MenuItem extends FxMenu.MenuItem {
    }
    /**
     * Defines a group in the menu.
     */
    interface MenuGroup extends FxMenu.MenuGroup {
        /**
         * Gets or sets if the menu group should be elevated in the menu blade.
         */
        elevated?: boolean;
    }
    /**
     * Defines a group extension in the menu.
     * This is used to extend the built-in groups with additional items.
     *
     * NOTE: The resourceId must be one of the constants for group IDs in this file.
     *       Using a different ID will result in a load rejection.
     */
    interface MenuGroupExtension {
        /**
         * Gets the ID for the built-in group.
         */
        referenceId: string;
        /**
         * The menu items in the group.
         */
        items: MenuItem[];
    }
    type ExtensionResource = FxSubscription | HubsExtension.Azure.ResourceGroup | HubsExtension.Azure.Resource;
    /**
     * The resource information for the resource menu.
     */
    interface ResourceInformation extends ResourceInfo {
        /**
         * The resource or resource group or subscription.
         */
        resource: ExtensionResource;
        /**
         * The resource's subscription information (only valid for non-tenant resources).
         */
        subscription?: FxSubscription;
    }
    /**
     * The information passed to the extension to load the resource.
     */
    interface ResourceInfo {
        /**
         * The resource ID.
         */
        resourceId: string;
    }
    /**
     * The options of the resource menu config.
     */
    interface ResourceMenuOptions {
        /**
         * Enables the setting exporting a template from resources and resource groups.
         */
        enableExportTemplate?: boolean;
        /**
         * Enables the settings for roles and users.
         */
        enableRbac?: boolean;
        /**
         * Enables the settings for help request support.
         */
        enableSupportHelpRequest?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         *
         * @deprecated ResourceMenuOptions.enableSupportTroubleshoot will soon be removed from the SDK. Please use the enableSupportTroubleshootV2 option instead.
         */
        enableSupportTroubleshoot?: Obsolete;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshootV2?: boolean;
        /**
         * Enables the settings for resource health support.
         */
        enableSupportResourceHealth?: boolean;
        /**
         * Enables the settings for the event logs.
         */
        enableSupportEventLogs?: boolean;
        /**
         * Enables the setting for tags.
         */
        enableTags?: boolean;
        /**
         * Enables the setting for standard properties blade.
         */
        enableProperties?: boolean;
        /**
         * Enables the settings for alerts.
         */
        enableAlerts?: boolean;
        /**
         * Enables the settings for diagnostics.
         */
        enableDiagnostics?: boolean;
        /**
         * Enables the settings for metrics.
         */
        enableMetrics?: boolean;
        /**
         * Enables the settings for log analytics.
         */
        enableLogAnalytics?: boolean;
        /**
         * Enables the settings for log search. Disabled if enable logs is enabled.
         */
        enableLogSearch?: boolean;
        /**
         * Enables the settings for locks.
         */
        enableLocks?: boolean;
        /**
         * Enables the settings for resource advisor support.
         */
        enableSupportResourceAdvisor?: boolean;
        /**
         * Enables the settings for Event Grid Publisher support.
         */
        enableEventGridPublisher?: boolean;
        /**
         * Enables workbooks blade in the resource ToC
         */
        enableWorkbooks?: boolean;
        /**
         * Enables analytics blade for logs in the resource ToC
         */
        enableLogs?: boolean;
        /**
         * Enables insights blade in the resource ToC
         */
        enableInsights?: boolean;
    }
    /**
     * The menu group instance type (either a menu group or a menu group extension).
     */
    type MenuGroupInstance = MenuGroup | MenuGroupExtension;
    /**
     * The resource menu configuration.
     */
    interface ResourceMenuConfig {
        /**
         * The resource menu item (overview item).
         */
        overview: MenuItem;
        /**
         * The menu item groups.
         */
        groups: MenuGroupInstance[];
        /**
         * The ID of the default menu item.
         * If this is not provided, the overview item will be the default item.
         */
        defaultItemId?: string;
        /**
         * Optional set of resource menu options.
         */
        options?: ResourceMenuOptions;
        /**
         * Optional observable to return a handled error message or entire error options for showing an "expected" or
         * "handled" error in the blade.
         *
         * Use this method when encountering an expected error state transition which has been designed as part of the
         * user experience and is not the indication of a product bug.
         *
         * This can be set late (after the getMenuConfig call has resolved) to indicate an "expected" error blade with
         * error information such as resource not found or unauthorized where the entire resource menu blade should
         * switch to the handled error UX. This works similar to the handledError() function on a blade.
         *
         * @see fail An observable that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @example <caption>Using handledError to switch to handled error UX</caption>
         *
         * public getResourceMenuConfig(resourceId: string): FxBase.PromiseV<FxAssets.ResourceMenuConfig> {
         *     const handledError = ko.observable<MsPortalFx.ViewModels.ErrorOptions>();
         *     const fail = ko.observable<void | MsPortalFx.ViewModels.ErrorOptions>();
         *     const menuConfig: FxAssets.ResourceMenuConfig = {
         *         overview: getPrinterOverviewItem(),
         *         options: {
         *             enableRbac: true,
         *             enableTags: true,
         *         },
         *         groups: [],
         *         handledError,
         *         fail,
         *     };
         *
         *     // Load the resource and update the menu items in the background.
         *     // In the case of this asset type, the ResourceProvidedBy for the resource menu is marked as
         *     // "NoResource". In this case, the AJAX call to retrieve the printer resource from ARM should
         *     // not be part of the menu config. In this case, the menu config should be returned as
         *     // quickly as possible with as many options completed as possible without the resource (such
         *     // as the overview menu item) and then the menu will be updated with the printer resource
         *     // when loaded. Therefore, the getResource() call is not being included in the returned
         *     // promise below to avoid blocking the UX. The UX can reveal the overview blade and partial
         *     // menu and when the printer is loaded and the menu is updated, the blade will adapt.
         *     dataContext.printerData.getResource(resourceId, "resource menu").then((printerData) => {
         *         // In production code, this code would make changes to the menu (add items, etc).
         *     }).catch((error) => {
         *         // IMPORTANT: Handle the late-failure errors using the common helper.
         *         if (error && error.status === HttpStatusCode.NotFound) {
         *             // Nice notice blade for 404 (not found).
         *             resourceId = MsPortalFx.encodeHtml(resourceId);
         *             const statusMessage = MsPortalFx.encodeHtml((error && (<any>error).content && (<any>error).content.message) || ResourceMenuNotice.unknownResponse);
         *             handledError({
         *                 message: ResourceMenuNotice.notFoundHeader.format(assetTypeName),
         *                 code: error.status,
         *                 details: ResourceMenuNotice.notFoundDescription.format(assetTypeName, resourceId, statusCode, statusMessage).replaceAll("\n", "<br />"),
         *             });
         *         } else {
         *             // Other errors fail the blade.
         *             fail((error && error.message) || error);
         *         }
         *     });
         *
         *     return Q(menuConfig);
         * }
         */
        readonly handledError?: KnockoutReadOnlyObservableBase<string | MsPortalFx.ViewModels.ErrorOptions>;
        /**
         * Optional error to return an async failure to the resource menu blade. This will cause the blade to
         * "sad cloud".
         *
         * This can be set late (after the getMenuConfig call has resolved) to indicate a fatal error where the entire
         * resource menu blade should switch to the fail (sad cloud) UX.
         *
         * @see handledError An observable that doesn't log the error to diagnostics. Use for expected error.
         *
         * (see handledError above for example)
         */
        readonly fail?: KnockoutReadOnlyObservableBase<string | MsPortalFx.ViewModels.ErrorOptions>;
    }
    /**
     * The resource provided by the extension for the resource menu blade.
     */
    interface ExtensionSuppliedResourceInfo {
        /**
         * The resource, subscription or resource group object provided by the extension.
         */
        resource: ExtensionResource;
        /**
         * The resource menu configuration.
         */
        menuConfig: ResourceMenuConfig;
    }
    /**
     * The contract for the asset type's resource menu config.
     */
    interface ResourceMenuWithCallerSuppliedResourceContract {
        /**
         * Gets the resource menu configuration.
         *
         * @param resourceInfo The resource ID and resource|resource group for the menus.
         * @param menuContext This is the value for the 'menucontext' blade parameter supplied via a BladeReference when the ResourceMenuBlade was opened.
         * @return A promise which will be resolved with the resource menu configuration.
         */
        getMenuConfig(resourceInfo: ResourceInformation, menuContext?: string): MsPortalFx.Base.PromiseV<ResourceMenuConfig> | Promise<ResourceMenuConfig>;
    }
    /**
     * The contract for the asset type's resource menu where the resource is provided by the extension.
     */
    interface ResourceMenuWithExtensionProvidedResourceContract {
        /**
         * Gets the resource and the resource menu configuration.
         *
         * @param resourceInfo The resource ID for the menu.
         * @param menuContext This is the value for the 'menucontext' blade parameter supplied via a BladeReference when the ResourceMenuBlade was opened.
         * @return A promise which will be resolved with the resource and resource menu configuration information.
         */
        getResourceAndMenuConfig(resourceInfo: ResourceInfo, menuContext?: string): MsPortalFx.Base.PromiseV<ExtensionSuppliedResourceInfo> | Promise<ExtensionSuppliedResourceInfo>;
    }
    /**
     * The contract for the asset type's resource menu where no resource is provided.
     */
    interface ResourceMenuWithNoResourceContract {
        /**
         * Gets the resource menu configuration.
         *
         * @param resourceInfo The resource ID and resource|resource group for the menus.
         * @param menuContext This is the value for the 'menucontext' blade parameter supplied via a BladeReference when the ResourceMenuBlade was opened.
         * @return A promise which will be resolved with the resource menu configuration.
         */
        getResourceMenuConfig(resourceId: string, menuContext?: string): MsPortalFx.Base.PromiseV<ResourceMenuConfig> | Promise<ResourceMenuConfig>;
    }
}
declare module FxImpl.Assets {
    import FxBase = MsPortalFx.Base;
    import BladeReference = FxImpl.Composition.Selectable.BladeReference;
    import FxExtension = FxImpl.Extension;
    /**
     * Supplies the blade reference for the detail blade opened by a menu item on the resource menu blade.
     *
     * @param lifetime The lifetime of the menu item.
     * @param extensionDescriptor The descriptor of the extension that provided the menu item.
     * @param item The menu item.
     * @return A promise for the blade reference.
     */
    function supplyMenuDetailBladeReferenceAsync(lifetime: FxBase.LifetimeManager, extensionDescriptor: FxExtension.ExtensionDescriptor, item: Controls.Menu.MenuItem): Q.Promise<BladeReference<any>>;
}

// FILE: MsPortalFx\Assets\Assets.SupplementalData.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    /**
     * The supplemental data provides the supplemental data for a single resource.
     */
    interface SupplementalData extends StringMap<any> {
        /**
         * The resource ID for the resource.
         */
        resourceId: string;
        /**
         * Optional command group reference override for the item context menu.
         */
        contextMenu?: CommandGroupReference;
    }
    /**
     * The contract for the asset type's supplemental data.
     */
    interface SupplementalDataContract {
        /**
         * The supplemental data stream observable array is used to stream supplemental data.
         */
        supplementalDataStream: KnockoutObservableArray<SupplementalData>;
        /**
         * Gets the supplemental data for the array of resource IDs.
         * Optionally, a refresh flag will be passed and if its set to true, extension must refresh the cache for supplemental data for the
         * given resource IDs and latest data must be provided.
         * Note: For refresh scenario, extension should also make sure the refresh data is updated in supplemental data stream before resolving
         * the getSupplementalData method's promise.
         *
         * @param resourceIds The array of resource IDs for the supplemental data.
         * @param columns The array of columns for the supplemental data that is required.
         * @param refresh Optionally specify if the supplemental data needs to be refreshed for the specified resource IDs.
         * @return A promise which will be resolved when data is ready to be streamed.
         */
        getSupplementalData(resourceIds: string[], columns: string[], refresh?: boolean): FxBase.Promise | Promise<any>;
        /**
         * A callback to indicate that extension must clear out any cached data and should provide latest data when the next getSupplementalData call is made.
         * Typically this callback is invoked when user clicks the "Refresh" button in the browse blade and portal user explicitly conveys the intent to have the latest data.
         *
         * @return A promise indicating the completion of the refresh operation.
         */
        refreshCache?(): FxBase.Promise | Promise<any>;
    }
    /**
     * Namespace for the supplemental data stream handling.
     */
    module SupplementalDataStreamHelper {
        /**
         * Connects a query view to a supplemental data stream.
         *
         * @param lifetimeManager The lifetime manager for this supplemental data stream.
         * @param view The quey view source for the connection.
         * @param destination The supplemental data stream for the connection.
         * @param isRequestedCallback The callback to determine if the item was requested.
         * @param buildDataCallback The callback to build the supplemental data for the item.
         */
        function ConnectView<TModel, TId>(lifetimeManager: FxBase.LifetimeManager, view: MsPortalFx.Data.QueryView<TModel, TId>, destination: KnockoutObservableArray<SupplementalData>, isRequestedCallback: (item: TModel) => boolean, buildDataCallback: (item: TModel) => SupplementalData): void;
    }
}

// FILE: MsPortalFx\Azure\ArmErrors.d.ts
declare module FxImpl.Azure {
    /**
     * A simplified version of the JQueryXHR error.
     */
    interface SimplifiedError extends Error {
        /**
         * The error ready state.
         */
        readyState: number;
        /**
         * The error status (HTTP code).
         */
        status: MsPortalFx.Base.Net2.HttpStatusCode;
        /**
         * The error status text (HTTP code text).
         */
        statusText: string;
        /**
         * The error code from the response JSON if it exists.
         */
        code: string;
        /**
         * The error stack.
         */
        stack: string;
    }
    /**
     * Error detail returned from ARM
     */
    interface ArmErrorDetails {
        /**
         * The error code.
         */
        code: string;
        /**
         * The error message.
         */
        message: string;
        /**
         * The target entity.
         */
        target: string;
        /**
         * The details.
         */
        details?: ArmErrorDetails[];
    }
    /**
     * The error info
     */
    interface ArmError extends ArmErrorDetails {
        /**
         * The error details.
         */
        details?: ArmErrorDetails[];
    }
    /**
     * Mapped error object with details.
     */
    interface MappedArmError {
        /**
         * The top level error with code.
         */
        error: string;
        /**
         * The nested errors with code if any.
         */
        details: (string | MappedArmError)[];
    }
    /**
     * Parses error object returned from ARM.
     * @param errorObj error object returned from ARM.
     * @param flattenAtLevel optional value that specifies level to flatten error details at, defaults to 1.
     * NOTE: This parameter indicates number of nested levels to be returned in the output object and not the number of nested levels to parse.
     *       Remaining nested details are flattened at this level.
     * @return mapped error object.
     */
    function parseArmError(errorObj: ArmError, codesOnly?: boolean, flattenAtLevel?: number): MappedArmError;
    /**
     * Parses error object returned from ARM to a concatenated string.
     * @param errorObj error object returned from ARM.
     * @param message A base message to use at the beginning of the returned message.
     * @return string containing the concatenated errors returned from ARM.
     */
    function parseArmErrorToMessage(error: ArmError, message?: string): string;
    /**
     * Builds a simplified error object out of a JQueryXHR error. Useful if you're returning errors
     * over the PO-layer.
     *
     * @param jqxhr The JQueryXHR error object.
     * @return The simplified error object.
     */
    function buildSimplifiedError<T>(jqxhr: JQueryXHR<T>): SimplifiedError;
    /**
     * Scrubs error objects.
     *
     * param message The object to scrub.
     * returns The scrubbed object.
     */
    function scrubError(obj: any): any;
}

// FILE: MsPortalFx\Azure\BaseResourceDropDown.d.ts
declare module MsPortalFx.Azure {
    /**
     * Options for validating required permissions.
     */
    interface RequiredPermissions {
        /**
         * The list of required actions/permissions.
         */
        actions: string[];
        /**
         * The message to show in case validation fails.
         */
        message?: string;
    }
    interface CreatorAndDropdDownValue<T> {
        /**
         * Specifies if the value returned should be created
         */
        createNew: boolean;
        /**
         * The value returned from the dropdown
         */
        value: T;
    }
}
declare module FxImpl.Azure {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxPromiseV = FxBase.PromiseV;
    import BaseControl = FxViewModels.Controls.Base.Contract;
    import Forms = FxViewModels.Forms;
    /**
     * BaseResourceDropDown namespace.
     */
    module BaseResourceDropDown {
        interface FilterOptions {
            /**
             * Delimiter used for flattening a hierarchical dataset.
             */
            delimiter?: string;
            /**
             * Filter type for search.
             * List = 0 ; Tree = 1
             */
            datasetType: number;
            /**
             * Filter algorithm to use for search.
             * StringContainsFilterText = 0 ; WordStartsWithFilterText = 1
             */
            algorithmType?: number;
        }
        interface HierarchicalFormOption<T> extends Forms.IOption<T> {
            /**
             * Optional children for storing hierarchical data.
             */
            children?: HierarchicalFormOption<T>[];
            /**
             * Flag for filtering the dropdown option.
             */
            doNotFilter?: KnockoutObservableBase<boolean>;
        }
        /**
         * BaseResourceDropDown options.
         */
        interface Options<T> extends Forms.Base.EditableComboBox.Options<string> {
            /**
             * The form control that hosts the drop down `control`.
             */
            form: Forms.Form.ViewModel<any>;
            /**
             * The edit scope accessor associated with the drop down control.
             */
            accessor: Forms.EditScopeAccessors<T>;
            /**
             * Icons to be shown next to text. Key should correspond to text in values.
             */
            iconLookup?: StringMap<KnockoutObservableBase<string>>;
            /**
             * Icon size in pixels which will correspond to both width and height (default "20px").
             */
            iconSize?: KnockoutObservable<string>;
            /**
             * Options used for filtering text.
             */
            filterOptions?: FilterOptions;
            /**
             * A list of values to be displayed in drop down.
             */
            options: KnockoutObservableArray<HierarchicalFormOption<string>>;
        }
        /**
         * Return options from the FilterComboBoxCreateCallback
         */
        interface FilterComboBoxResult<T> {
            /**
             * The control to place on the form and expose to authors. Use this if it's
             * different from the dropdown.
             */
            control?: BaseControl;
            /**
             * The control for the internal representation of the dropdown
             */
            filterComboBox: any;
            /**
             * An extra valid observable to determine if the control is valid
             */
            valid?: KnockoutObservableBase<boolean>;
            "--noUnusedLocals"?: T | any;
        }
        /**
         * BaseResourceDropDown configuration.
         */
        interface Config<T> {
            /**
             * Flag indicating whether creating new objects through the filter combo control is
             * allowed. Defaults to false.
             */
            allowCreateNew?: boolean;
            /**
             * An observable that blocks loading the items till set to true. Defaults to false.
             */
            blockLoadingItems?: KnockoutObservableBase<boolean>;
            /**
             * An observable updated with the name for the object that should be set as the initial
             * value for the control (and in the edit scope). Defaults to undefined (no initial selection).
             */
            nameForInitialValue?: KnockoutObservableBase<string>;
            /**
             * Returns a sorted list of items sorted in the order of selection preference. This will
             * not affect the presentation order, just the initial selection. If there is no value
             * defined in the edit scope or using the nameForInitialValue property, the dropdown will
             * pick the first valid item in this ordered list. If not supplied, then the original
             * list of values will be used (preserving original presentation order).
             */
            getSortedListForInitialSelection?: () => T[];
            /**
             * A callback that returns a promise resolved with the items for the drop down.
             */
            fetchItems: () => FxPromiseV<ReadonlyArray<T>>;
            /**
             * A callback that acts as a filter that checks whether the name identifies the supplied object.
             */
            filterObjectByName: (item: T, name: string) => boolean;
            /**
             * A callback that transforms the supplied item into a filter combo box option.
             */
            itemToHierarchicalFormOption: (item: T) => HierarchicalFormOption<string>;
            /**
             * The object value to return if no filter value is found
             */
            createNewOption?: KnockoutObservableBase<T>;
            /**
             * Callback to Instantiate FilterComboBox with Base Options
             * Ids could be ambiguous with names, and could lead to unexpected behavior if
             * ids and names are the same. Both will be passed into this function
             */
            filterComboBoxCreateCallback?: Func1<Options<T>, FilterComboBoxResult<T>>;
            /**
             * Filter function to remove items from the drop down. This is run in a computed so any
             * observables used in this function will trigger this filter
             */
            optionsFilter?: Func1<T[], T[]>;
            /**
             * The control to be exposed
             */
            control?: BaseControl;
            /**
             * The default value if none are selected
             */
            nullValue?: T;
        }
    }
    /**
     * The base class implementation for a resource drop down.
     * Extended by the Subscription, Resource Group, and Location Pickers.
     */
    class BaseResourceDropDown<T> {
        /**
         * The control placed on the form.
         */
        control: BaseControl;
        /**
         * An observable indicating whether the field is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservableBase<string>;
        /**
         * An observable indicating whether the field is valid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * An observable that holds the currently selected value.
         */
        value: KnockoutObservableBase<T>;
        protected get _items(): T[];
        protected set _items(val: T[]);
        protected _filterCombo: any;
        protected _itemsObs: KnockoutObservableArray<T>;
        protected _loading: KnockoutObservable<boolean>;
        private _bConfig;
        private _bContainer;
        private _bOptions;
        private _firstLoad;
        private _loadingDeferred;
        private _setOptions;
        /**
         * Instantiates a new base drop down control.
         *
         * @param container The container into which the part containing this control is being placed.
         * @param options The set of options used to initialize the BaseResourceDropDown.
         * @param config The config used to configure the BaseResourceDropDown.
         */
        constructor(container: FxViewModels.ContainerContract, options: BaseResourceDropDown.Options<T>, config: BaseResourceDropDown.Config<T>);
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): Q.Promise<any>;
        /**
         * Triggers validation on the field.
         * @return A promise that is resolved when the validation has been triggered.
         */
        triggerValidation(): Q.Promise<boolean>;
        /**
         * Returns the corresponding object in the drop down list for the given name.
         * @param  name The name to match the object.
         * @return The corresponding object that matches the name.
         */
        getObjectByName(name: string): T;
        protected _loadItems(): void;
        protected _hasPermission(resourceId: string, requiredPermissions: KnockoutObservableBase<MsPortalFx.Azure.RequiredPermissions>, errorMessage: string): FxPromiseV<FxViewModels.ValidationResult>;
    }
}

// FILE: MsPortalFx\Azure\Legal\Legal.d.ts
declare module MsPortalFx.Azure.Legal {
    /**
     * Input/configuration data used by the Legal Terms V2 blade.
     * NOTE: This model is deprecated. Any new code should use LegalTermsConfig instead.
     *
     * @deprecated MsPortalFx.Azure.Legal.DataModel Callers should use LegalTermsConfig instead.
     */
    interface DataModel {
        /**
         * If true, a 'pin to startboard' checkbox will be displayed on the action bar.
         */
        showPinToStartboardCheckbox?: boolean;
        /**
         * Subscription Id.
         */
        subscriptionId: string;
        /**
         * Used to switch the legal terms language.
         */
        legalTermsLanguage: LegalTermsLanguageEnum;
        /**
         * An array of gallery products.
         */
        products?: Product[];
        /**
         * An array of manually defined products. Used for products that don't exists on the gallery.
         */
        inlineProductDescriptions?: InlineProductDescription[];
        /**
         * The pricing tier selections made by the user.
         */
        pricingTierSelections?: PricingTierSelection[];
    }
    /**
     * Input/configuration data used by the Legal Terms V2 blade. In PCLegalTermsV2Blade, this is the type of the config
     * accepted by the parameter provider (via the supplyProviderConfig callback from the parameter collector).
     *
     * For solution
     */
    interface LegalTermsConfig {
        /**
         * Indicates what kind of marketplace item we are displaying legal terms language for.
         */
        legalTermsLanguage: LegalTermsLanguageEnum;
        /**
         * If true, a 'pin to startboard' checkbox will be displayed on the action bar.
         */
        showPinToStartboardCheckbox?: boolean;
        /**
         * The ID of the subscription which is being used to provision the marketplace item.
         */
        subscriptionId: string;
        /**
         * Details of the gallery item whose legal terms are being displayed. Obtain this value from
         * MsPortalFx.Azure.ResourceManager.ArmProvisioner<T>.armProvisioningConfig.galleryCreateOptions.galleryItem.
         * This value may be ommitted only if legalTermsLanguage == LegalTermsLanguageEnum.TemplateDeployment.
         */
        galleryItem?: any;
        /**
         * Describes the plan, promotion code, and other purchase details for each of the 3rd party products the user is buying.
         * For gallery items which do not have pricing or plans (such as solution templates), omit this value
         * and the legal terms blade will display the products extracted from galleryItem.
         */
        productPurchases?: ProductPurchase[];
    }
    /**
     * Describes the plan, promotion code, and other purchase details for each of the 3rd party products the user is buying.
     */
    interface ProductPurchase {
        /**
         * The publisherId (also called publisher namespace) for the product. This corresponds to
         * GalleryCreateOptions.galleryItem.products[i].offerDetails.publisherId.
         */
        publisherId: string;
        /**
         * The publisherId (also called publisher namespace) for the product. This corresponds to
         * GalleryCreateOptions.galleryItem.products[i].offerDetails.offerId.
         */
        offerId: string;
        /**
         * The ID of the plan (or VM SKU) which the user has chose for this product.
         */
        planId: string;
        /**
         * The promotion code which the user is using to purchase this 3rd party product. If no promotion code is being
         * applied then omit this value or set it to null.
         */
        promotionCode?: string;
        /**
         * The IDs of the third-party meters which apply to the plan that the user has purchased. If third party meters don't
         * apply to this type of product or no meters apply to the selected plan then omit this property or set it to an empty array.
         */
        meterIds?: string[];
        /**
         * For app services and data services, this should be set to the localized display name of the selected plan (corresponding to planId),
         * This value will be displayed alongside the offer name at the top of the legal terms blade. For other types of offers (virtual machines, etc)
         * this value should be ommitted.
         */
        servicePlanName?: string;
        /**
         * When the 3rd party product is a VM image this should be set to a FirstPartyVirtualMachinePurchase which describes the SKU / VM size chosen.
         * If the product is not a VM image this value should be omitted.
         */
        firstPartyVirtualMachine?: FirstPartyVirtualMachinePurchase;
    }
    /**
     * Describes the Azure VM SKU/size on which a VM image runs.
     */
    interface FirstPartyVirtualMachinePurchase {
        /**
         * The display name of this VM size/SKU, as it was presented to the user in the VM size picker control.
         */
        skuDisplayName: string;
        /**
         * The type of operating system on which the VM runs.
         */
        operatingSystem: FirstPartyOperatingSystem;
        /**
         * The parameters needed to get the per-unit (hourly) price of this VM SKU using the getSpecsCosts RPC exposed by the
         * billing extension.
         */
        hourlyCost: FirstPartyVirtualMachineCost;
    }
    /**
     * Describes the inputs needed to query the cost of a 1st party virtual machine SKU using the getSpecsCosts RPC
     * exposed by the billing extension.
     */
    interface FirstPartyVirtualMachineCost {
        /**
         * The resource ID of the resource corresponding to this VM in the billing system.
         * This value corresponds to HubsExtension.Azure.Pricing.FirstPartyResource.resourceId.
         */
        resourceId: string;
        /**
         * This is the quantity of the resource which should be used when estimating the resource's
         * cost using the getSpecsCosts RPC. This value corresponds to
         * HubsExtension.Azure.Pricing.FirstPartyResource.quantity.
         */
        quantity: number;
    }
    /**
     * Enumerates the operating systems on which an Azure VM may run.
     */
    enum FirstPartyOperatingSystem {
        Windows = 0,
        Linux = 1
    }
    /**
     * The type of the result returned by the parameter provider in PCLegalTermsV2Blade.
     */
    interface LegalTermsAcceptanceResult {
        /**
         * True if the user consented to the legal terms displayed, and false if the user closed the legal terms
         * blade without consenting.
         */
        isAccepted: boolean;
    }
    /**
     * Pricing tier selection model.
     */
    interface PricingTierSelection {
        /**
         * The spec resource set.
         */
        specResourceSet: SpecResourceSet;
        /**
         * The specs allowed to have zero as a possible cost amount.
         */
        specsToAllowZeroCost: string[];
    }
    /**
     * Data contract for a resource quota set.
     */
    interface SpecResourceSet {
        /**
         * The spec id.
         */
        id: string;
        /**
         * The third party quotas.
         */
        thirdParty?: ThirdPartyResource[];
    }
    /**
     * Data contract for a third party resource.
     */
    interface ThirdPartyResource {
        /**
         * The round-tripped Id.
         */
        id?: string;
        /**
         * The resource publisher Id.
         */
        publisherId: string;
        /**
         * The resource offer Id.
         */
        offerId: string;
        /**
         * The resource offer display name.
         */
        offerDisplayName: string;
        /**
         * The resource plan Id.
         */
        planId: string;
        /**
         * The promotion code.
         */
        promotionCode: string;
        /**
         * The third party meters.
         */
        meters: ThirdPartyMeter[];
    }
    /**
     * Data contract for a third party meter.
     */
    interface ThirdPartyMeter {
        /**
         * The meter ID
         */
        meterId: string;
        /**
         * The meter Name
         */
        meterDisplayName: string;
        /**
         * The meter quantity
         */
        quantity: number;
    }
    /**
     * Used to retrieve the product (offer) information from the gallery.
     */
    interface Product {
        /**
         * Publisher id for the product.
         */
        publisherId: string;
        /**
         * Offer id for the product.
         */
        offerId: string;
        /**
         * Plan id for the product.
         */
        planId: string;
    }
    /**
     * Used in cases where a real gallery product doesn't exists
     * but still product information needs to be shown in the legal terms page.
     */
    interface InlineProductDescription {
        /**
         * Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * Offer display name.
         */
        offerDisplayName: string;
        /**
         * Tells if the product has a free trial.
         */
        hasFreeTrial: boolean;
        /**
         * Tells if the product requires an external license.
         */
        requiresExternalLicense: boolean;
        /**
         * The legal terms HTML.
         */
        legalTerms: string;
        /**
         * The privacy policy HTML.
         */
        privacyPolicy: string;
        /**
         * The other pricing details URI.
         */
        pricingDetailsUri: string;
    }
    /**
     * Input data used by the LegalTermsSubscriptionProgrammaticAccessBlade blade.
     */
    interface SubscriptionProgrammaticAccessDataModel {
        /**
         * Subscription Id.
         */
        subscriptionId: string;
    }
    /**
     * Input data used by the LegalTermsSkuProgrammaticAccessBlade blade.
     */
    interface SkuProgrammaticAccessDataModel {
        /**
         * A gallery product.
         */
        product: Product;
    }
    /**
     * Used to switch the legal terms language in the LegalTermsV2 blade.
     */
    enum LegalTermsLanguageEnum {
        /**
         * Displays the default legal text which applies to single-VM products
         * and dev services.
         */
        Default = 0,
        /**
         * Displays the legal text which applies to solution templates (i.e. multi-VM offers) and
         * custom ARM templates (i.e. via the Template Deployment gallery item).
         */
        TemplateDeployment = 1,
        /**
         * @deprecated LegalTermsLanguageEnum.RequestPricingInformation Do not pass this value.
         */
        RequestPricingInformation = 2,
        /**
         * Displays the legal text which applies when enabling / disabling programmatic access to deploy a product.
         * Only the LegalTermsSkuProgrammaticAccessBlade should pass this value.
         */
        ProgrammaticAccess = 3
    }
}

// FILE: MsPortalFx\Azure\Locations.d.ts
declare module FxImpl.Azure {
    import FxAzure = MsPortalFx.Azure;
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxImpl.Rpc;
    import FxPromiseV = FxBase.PromiseV;
    /**
     * The inputs to the getLocationsForCreateEndPoint function definition.
     */
    interface GetLocationsForCreateEndPointArgs {
        /**
         * The subscription id.
         */
        subscriptionId?: string;
        /**
         * The scope at which to get locations.
         */
        scope?: string;
        /**
         * The list of resource types.
         */
        resourceTypes?: string[];
    }
    /**
     * Internal RPC endpoint to get the display names for locations.
     */
    const getLocationDisplayNamesEndPoint: FxRpc.FuncEndPointDefinition<void, StringMap<string>>;
    /**
     * Internal RPC endpoint to get locations for create.
     */
    const getLocationsForCreateEndPoint: FxRpc.FuncEndPointDefinition<GetLocationsForCreateEndPointArgs, FxAzure.Location[]>;
    /**
     * Internal RPC endpoint to get locations.
     */
    const getLocationsEndPoint: FxRpc.FuncEndPointDefinition<void, FxAzure.Location[]>;
    /**
     * The user settings key to store the list of last used locations in deployments.
     */
    const lastUsedLocationsKey = "deployments_lastUsed_locations";
    /**
     * Returns the list of locations as a dictionary.
     *
     * @param rpcClient The RPC client.
     * @param args Inputs required by the RPC endpoint.
     * @return A promise that resolves with a list of locations.
     */
    function getLocationsForCreate(rpcClient: FxRpc.Client, args: GetLocationsForCreateEndPointArgs): FxPromiseV<FxAzure.Location[]>;
    /**
     * Returns the list of locations as a dictionary.
     *
     * @param rpcClient The RPC client.
     * @return A promise that resolves with a dictionary of location ids mapped to display names.
     */
    function getLocationDisplayNames(rpcClient: FxRpc.Client): Q.Promise<StringMap<string>>;
    /**
     * Returns a sorted list of the most recently used locations in create.
     *
     * @param rpcClient The RPC client.
     * @return A promise that resolves with a sorted list of the most recently used locations in create.
     */
    function getLastUsedLocations(rpcClient: FxRpc.Client): FxPromiseV<string[]>;
    /**
     * Locations comparer for sorting (uses display name).
     * @param locA Location A.
     * @param locB Location B.
     * @return Comparison result.
     */
    function locationsComparer(locA: FxAzure.Location, locB: FxAzure.Location): number;
}
declare module MsPortalFx.Azure {
    import FxImplAzure = FxImpl.Azure;
    /**
     * Returns the list of locations as a dictionary.
     *
     * @return A promise that resolves to a dictionary of locations.
     */
    function getLocations(): Q.Promise<StringMap<string>>;
    /**
     * The enum for which recommended group a location should appear in
     */
    const enum RegionSegment {
        /**
         * Service Provided
         */
        ServiceProvided = "ServiceProvided",
        /**
         * The first group and largest type of locations with the most resource types supported.
         */
        Recommended = "Recommended",
        /**
         * Other locations including RP specific locations
         */
        Other = "Other"
    }
    /**
     * Data contract for a single location.
     */
    interface Location {
        /**
         * The display name of the location.
         */
        displayName: string;
        /**
         * The normalized name of the location.
         */
        name: string;
        /**
         * The fully qualified ID of the location.
         */
        id?: string;
        /**
         * The display name with the Region included
         */
        regionalDisplayName?: string;
        /**
         * Metadata about the location
         */
        metadata?: {
            /**
             * The latitude of the location.
             */
            latitude?: number;
            /**
             * The longitude of the location.
             */
            longitude?: number;
            /**
             * The region type of the location.
             */
            regionType: string;
            /**
             * The region category of the location.
             */
            regionCategory: keyof typeof RegionSegment;
            /**
             * The geography group of the location.
             */
            geographyGroup?: string;
            /**
             * The physical location of the location.
             */
            physicalLocation?: string;
            /**
             * The paired region of the location.
             */
            pairedRegion?: {
                /**
                 * The normalized name of the paired location.
                 */
                name: string;
                /**
                 * The id of the paired location.
                 */
                id: string;
            }[];
        };
    }
    /**
     * Locations namespace.
     */
    module Locations {
        import BaseDropDown = FxImplAzure.BaseResourceDropDown;
        /**
         * DropDown namespace.
         */
        module DropDown {
            /**
             * Location drop down options interface for legacy dropdown backward compatability.
             */
            interface BaseOptions extends BaseDropDown.Options<Location> {
                /**
                 * The observable that holds the subscription id used to filter locations.
                 */
                subscriptionIdObservable: KnockoutObservableBase<string>;
                /**
                 * Optional. The observable that holds the list of resource types used to filter locations.
                 */
                resourceTypesObservable?: KnockoutObservableBase<string[]>;
            }
            /**
             * Locations drop down options.
             */
            interface Options extends BaseOptions {
                filter?: LocationFilter | KnockoutObservableBase<LocationFilter>;
            }
            /**
             * The location filter.
             */
            interface LocationFilter {
                /**
                 * List of allowed locations.
                 * Either this or the disallowed locations can be specified.
                 */
                allowedLocations?: AllowedLocations;
                /**
                 * List of disallowed locations.
                 * Either this or the allowed locations can be specified.
                 */
                disallowedLocations?: DisallowedLocation[];
            }
            /**
             * The allowed locations.
             */
            interface AllowedLocations {
                /**
                 * The list of allowed location names.
                 */
                locationNames: string[];
                /**
                 * @deprecated Locations.Dropdown.AllowedLocations.disabledMessage is deprecated http://aka.ms/portalfx/breaking
                 * Optional, disabled message to show for the disabled locations.
                 */
                disabledMessage?: string;
            }
            /**
             * The disallowed location.
             */
            interface DisallowedLocation {
                /**
                 * The location to disable.
                 */
                name: string;
                /**
                 * Optional, disabled message to show for the disabled location.
                 */
                disabledMessage?: string;
            }
        }
        /**
         * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/LocationDropDown";` http://aka.ms/portalfx/breaking
         */
        const DropDown: Obsolete;
    }
}

// FILE: MsPortalFx\Azure\ResourceFilter.d.ts
declare module MsPortalFx.Internal {
    /**
     * The options to create the resource filter control.
     */
    interface ResourceFilterOptions extends MsPortalFx.Azure.ResourceFilter.Options {
        /**
         * Indicates whether the changes made to the subscription filter are persistent or not.
         */
        isPersistentSubscriptionFilter: boolean;
        /**
         * Indicates whether the subscription dropdown is open and can be used to toggle the state of the dropdown.
         */
        isSubscriptionPopupOpen?: KnockoutObservable<boolean>;
        /**
         * if set, all subscriptions will be shown in the subscription dropdown.
         */
        showAllSubscriptions?: boolean;
        /**
         * Value indicating whether to show the directory dropdown.
         */
        showDirectoryFilter?: boolean;
        /**
         * Indicates whether to update the selected subscriptions( which in case is the list of selected subscriptions in the portal and not the subsription dropdown value) when user clicks on the apply button on the browse dialog pill and not on the subscription dropdown popup close.
         * This is used specifically for Browse scenarios which use dialog pill control for subscriptions.
         */
        deferSelectedSubscriptionsUpdate?: boolean;
        /**
         * if set, the control will be placed inside of a section built using the provided options
         */
        sectionOptions?: {
            /**
             * The name of the section.
             * This will be displayed as a tab header if the section is inside a tab control.
             */
            name?: string;
            /**
             * The disabled state of the control.
             */
            disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The width of the left label in px.
             * Setting this property implies leftLabelPosition = true.
             */
            leftLabelWidth?: number;
            /**
             * A custom css class to apply to the control.
             */
            cssClass?: string | KnockoutObservableBase<string>;
            /**
             * The visible state of the control.
             */
            visible?: boolean | KnockoutObservableBase<boolean>;
            /**
             * Align labels by available size of the blade. (left or above the control).
             */
            smartAlignLabel?: boolean;
        };
    }
}
declare module MsPortalFx.Azure {
    import FxAssets = MsPortalFx.Assets;
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import ListBase = FxImpl.ViewModels.Controls.Lists.Base;
    /**
     * The resource filter control.
     */
    module ResourceFilter {
        /**
         * The options to create resource filter control.
         */
        interface Options {
            /**
             * Value indicating whether to show the filter text box.
             */
            showTextFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the resource type drop down.
             */
            showTypeFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription drop down.
             */
            showSubscriptionFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the resource groups drop down.
             */
            showResourceGroupFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription drop down.
             */
            showLocationFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription summary.
             */
            showSubscriptionSummary?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription summary as tenant-level.
             */
            showTenantLevelSubscriptionSummary?: KnockoutObservableBase<boolean>;
            /**
             * Optional value for selected subscription id.
             */
            selectedSubscriptionId?: KnockoutObservableBase<string>;
            /**
             * Optional value for text filter place holder.
             */
            textFilterPlaceholder?: KnockoutObservableBase<string>;
            /**
             * Optional value for asset types for type filter. This is needed for merged asset types.
             */
            assetTypes?: KnockoutObservableArray<FxAssets.ResourceTypeAssetTypeInformation>;
            /**
             * The viewmodel of a list/grid control that can be controlled by this resource filter.
             * The list will treat the textFilter textbox as a search text box by doing the following:
             *      enter keystrokes: Activate the first result
             *      down arrow keystrokes: Focus the first result
             *      focus and blur: highlight/remove highlight from the first result
             */
            actionHandler?: KnockoutObservableBase<ListBase.ActionHandler> | ListBase.ActionHandler;
            /**
             * The telemetry context of the control e.g. extension/shell
             */
            context?: KnockoutObservableBase<string>;
            /**
             * The flag indicates whether the control should auto-select all resource groups, defaults to true.
             * When set to false, the control will update the RG list but keep selection intact.
             */
            autoSelectAllResourceGroups?: KnockoutObservableBase<boolean>;
        }
        /**
         * The view model for resource filter control.
         */
        class ViewModel extends FxViewModels.Controls.Base.ViewModel implements Options {
            showTextFilter: KnockoutObservableBase<boolean>;
            showTypeFilter: KnockoutObservableBase<boolean>;
            showSubscriptionFilter: KnockoutObservableBase<boolean>;
            showResourceGroupFilter: KnockoutObservableBase<boolean>;
            showLocationFilter: KnockoutObservableBase<boolean>;
            /**
             * The value indicating whether subscriptions are filtered or not.
             */
            subscriptionsFiltered: KnockoutObservable<boolean>;
            /**
             * The See interface.
             */
            showSubscriptionSummary: KnockoutObservableBase<boolean>;
            /**
             * The See interface.
             */
            showTenantLevelSubscriptionSummary: KnockoutObservableBase<boolean>;
            /**
             * The list of selected resource types.
             */
            selectedTypes: KnockoutObservable<string[]>;
            /**
             * The list of selected subscriptions.
             */
            selectedSubscriptions: KnockoutObservable<readonly Subscription[]>;
            /**
             * The list of selected resource groups.
             */
            selectedResourceGroups: KnockoutObservable<string[]>;
            /**
             * The flag indicating whether to use ne or eq operator while quering for resource groups.
             * This is to avoid hitting ARM query limit when user has more than 200 resource groups.
             */
            invertResourceGroupFilter: KnockoutObservable<boolean>;
            autoSelectAllResourceGroups: KnockoutObservableBase<boolean>;
            /**
             * The list of selected subscriptions.
             */
            selectedLocations: KnockoutObservable<string[]>;
            /**
             * The text filter value.
             */
            filterText: KnockoutObservable<string>;
            selectedSubscriptionId: KnockoutObservableBase<string>;
            textFilterPlaceholder: KnockoutObservableBase<string>;
            assetTypes: KnockoutObservableArray<FxAssets.ResourceTypeAssetTypeInformation>;
            context: KnockoutObservableBase<string>;
            /**
             * The viewmodel of a list/grid control that can be controlled by this resource filter.
             * The list will treat the textFilter textbox as a search text box by doing the following:
             *      enter keystrokes: Activate the first result
             *      down arrow keystrokes: Focus the first result
             *      focus and blur: highlight/remove highlight from the first result
             */
            actionHandler: KnockoutObservableBase<ListBase.ActionHandler> | ListBase.ActionHandler;
            /**
             * A flag to determine whether or not the selected subscriptions are loaded and valid.
             * This is initially false, but will be set to true after all subscriptions are retrieved and the selected subscriptions collection is set as a result.
             */
            subscriptionsLoaded: KnockoutReadOnlyObservable<boolean>;
            private _msPortalFxSectionOptions;
            /**
             * A flag to indicate whether the subscription selection changes made to a specific
             * subscription filter control must be saved to the subscription settings.
             */
            isPersistentSubscriptionFilter: boolean;
            /**
             * Indicates whether the subscription dropdown is open and can be used to toggle the state of the dropdown.
             */
            isSubscriptionPopupOpen: KnockoutObservable<boolean>;
            /**
             * if set, all subscriptions will be shown in the subscription dropdown.
             */
            showAllSubscriptions: boolean;
            /**
             * Value indicating whether to show the directory dropdown.
             */
            showDirectoryFilter: boolean;
            /**
             * Indicates whether to update the selected subscriptions on the specific action and not on the subscription dropdown popup close.
             * This is used specifically for Browse scenarios which use dialog pill control for subscriptions.
             */
            deferSelectedSubscriptionsUpdate?: boolean;
            /**
             * Constructs a resource filter view model.
             *
             * @param lifetimeManager Lifetime manager for this view model.
             * @param options The options for the resource filter view model.
             */
            constructor(container: FxBase.LifetimeManager, options?: Options | MsPortalFx.Internal.ResourceFilterOptions);
        }
    }
}

// FILE: MsPortalFx\Azure\ResourceGroups.d.ts
declare module FxImpl.Azure {
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxImpl.Rpc;
    import ResourceGroup = MsPortalFx.Azure.ResourceGroup;
    interface GetResourceGroupsFromSubscriptionArgs {
        subscriptionIds: string[];
        uniqueResourceGroups?: boolean;
    }
    /**
     * Internal RPC endpoint to get the resource groups under a list of subscriptions.
     */
    const getResourceGroupsFromSubscriptionEndPoint: FxRpc.FuncEndPointDefinition<GetResourceGroupsFromSubscriptionArgs, ResourceGroup[]>;
    /**
     * Returns the list of resource groups under a list of subscriptions.
     *
     * @param rpcClient The RPC client.
     * @param subscriptionIds The list of subscription ids.
     * @return A promise that resolves to the list of resource groups.
     */
    function getResourceGroupsFromSubscription(rpcClient: FxRpc.Client, subscriptionIds: string[], uniqueResourceGroups?: boolean): FxBase.PromiseV<ResourceGroup[]>;
}
declare module MsPortalFx.Azure {
    /**
     * Data contract for a single resource group.
     */
    interface ResourceGroup {
        /**
         * Resource group location.
         */
        location: string;
        /**
         * Resource group name.
         */
        name: string;
        /**
         * Resource group provisioning state.
         */
        provisioningState?: string;
        /**
         * The resource id of the resource group. e.g. /subscriptions/123/resourceGroups/${this.name}
         * Available with the fx resource group dropdown.
         */
        resourceId?: string;
    }
    module ResourceGroups {
        import FxAzure = MsPortalFx.Azure;
        import FxBase = MsPortalFx.Base;
        import FxViewModels = MsPortalFx.ViewModels;
        import InternalAzure = FxImpl.Azure;
        import BaseDropDown = InternalAzure.BaseResourceDropDown;
        /**
         * The mode of the dropdown
         */
        enum Mode {
            UseExisting = 0,
            CreateNew = 1
        }
        /**
         * The allowed mode of the dropdown
         */
        enum AllowedMode {
            UseExisting = 0,
            CreateNew = 1,
            Both = 2
        }
        /**
         * The max number of characters allowed for a resource group name.
         */
        const NameMaxLength = 90;
        module Internal {
            function fetchItems(options: DropDown.Options): FxBase.PromiseV<FxAzure.CreatorAndDropdDownValue<ResourceGroup>[]>;
            /**
             * Validates a resource group name. If a subscription is provided, the function will check if
             * a resource group with that name exists for the given subscription.
             *
             * @param resourceGroupName The resource group name.
             * @param subscription The subscription
             * @param existingResourceGroups An optional array of resource groups to do an existence check
             * @param existenceCheckCallback An optional async callback to get existing resource groups
             * @return The ValidationResult object.
             */
            function validateResourceGroupName(resourceGroupName: string, subscriptionId: string, existingResourceGroups?: string[], existenceCheckCallback?: Func<FxBase.PromiseV<FxViewModels.ValidationResult>>, hasPermissions?: Q.Promise<FxViewModels.ValidationResult>): Q.Promise<FxViewModels.ValidationResult>;
        }
        /**
         * Validates a resource group name. If a subscription is provided, the function will check if
         * a resource group with that name exists for the given subscription.
         *
         * @param resourceGroupName The resource group name.
         * @param subscriptionId The subscription
         * @param existingResourceGroups An optional array of resource groups to do an existence check
         * @param existenceCheckCallback An optional async callback to get existing resource groups
         * @return The ValidationResult object.
         */
        function validateResourceGroupName(resourceGroupName: string, subscriptionId: string, existingResourceGroups?: string[], existenceCheckCallback?: Func<FxBase.PromiseV<FxViewModels.ValidationResult>>, hasPermissions?: Q.Promise<FxViewModels.ValidationResult>): FxBase.PromiseV<FxViewModels.ValidationResult>;
        /**
         * The resource group drop down module.
         */
        module DropDown {
            /**
             * Resource group drop down options interface for legacy dropdown backward compatability.
             */
            interface BaseOptions<T> extends BaseDropDown.Options<T> {
                /**
                 * Subscription observable to fetch and validate resource groups against.
                 */
                subscriptionIdObservable: KnockoutObservableBase<string>;
                /**
                 * The default value for a new resource group name. If set, the +New text box will
                 * default to that value. If a resource group already exists with the same value, this
                 * string will be incremented ("val", "val_1", "val_2", etc.). If not set, the text
                 * box will be left blank (default).
                 */
                defaultNewValue?: string;
                /**
                 * The list of required permissions the subscription must have.
                 */
                requiredPermissions?: KnockoutObservableBase<RequiredPermissions>;
            }
            /**
             * Locations drop down options.
             */
            interface Options extends BaseOptions<FxAzure.CreatorAndDropdDownValue<ResourceGroup>> {
                /**
                 * The mode allowed for the resource group dropdown
                 */
                allowedMode?: KnockoutObservableBase<AllowedMode>;
            }
        }
        /**
         * @deprecated MsPortalFx.Azure.ResourceGroups.DropDown. Please use `import { create } from "Fx/Controls/ResourceGroupDropDown";` http://aka.ms/portalfx/breaking
         */
        const DropDown: Obsolete;
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Common.d.ts
declare module MsPortalFx.Azure.ResourceManager {
    import Gallery = Services.Gallery;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxPropertiesPart = FxViewModels.Parts.Properties;
    /**
     * The Gallery-create configuration options.
     */
    interface GalleryCreateOptions {
        /**
         * Gallery item information extracted from the gallery item and passed over to the extension.
         */
        galleryItem: GalleryItemExtract;
        /**
         * The context in which the gallery item was launched.
         */
        launchingContext: LaunchingContext;
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The subscription display name.
         */
        subscriptionDisplayName: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * The resource group location display name.
         */
        resourceGroupLocationDisplayName?: string;
        /**
         * The deployment name.
         */
        deploymentName: string;
        /**
         * The list of URIs for the CSM template files.
         */
        deploymentTemplateFileUris: StringMap<string>;
        /**
         * The list of URIs for the deployment fragments.
         */
        deploymentFragmentFileUris?: StringMap<string>;
    }
    /**
     * Gallery item information extracted from the gallery item and passed over to the extension.
     */
    interface GalleryItemExtract {
        /**
         * The identity of the gallery item.
         */
        id: string;
        /**
         * The item display name.
         */
        itemDisplayName: string;
        /**
         * Gets or sets Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * The item version.
         */
        version: string;
        /**
         * The list of category IDs the gallery item belongs to.
         */
        categoryIds: string[];
        /**
         * Gallery item products.
         */
        products: GalleryItemProduct[];
        /**
         * Gallery item products with no pricing information.
         */
        productsWithNoPricing: GalleryItemProduct[];
        /**
         * The absolute URI of the medium icon for the Marketplace item.
         */
        mediumIconUri?: string;
        /**
         * The item additional artifacts.
         */
        specialArtifacts?: Gallery.Artifact[];
        /**
         * The dictionary of metadata properties to be used by the extension.
         */
        metadata?: StringMap<string>;
    }
    /**
     * Gallery product (offer) model.
     */
    interface GalleryItemProduct {
        /**
         * The product (offer) display name.
         */
        displayName: string;
        /**
         * The publisher display name.
         */
        publisherDisplayName: string;
        /**
         * The uri to the legal terms HTML.
         */
        legalTermsUri: string;
        /**
         * The uri to the privacy policy HTML.
         */
        privacyPolicyUri: string;
        /**
         * The other pricing details URI.
         */
        pricingDetailsUri: string;
        /**
         * The pricing details. Optional.
         * If the product doesn't contain pricing details, then we won't fetch pricing information
         * for it.
         */
        offerDetails?: GalleryItemOfferPricingDetails;
    }
    /**
     * Gallery offer pricing details model.
     * Used to retrieve the pricing information for a gallery offer.
     */
    interface GalleryItemOfferPricingDetails {
        /**
         * The offer id.
         */
        offerId: string;
        /**
         * The publisher id.
         */
        publisherId: string;
        /**
         * The offer plans provided by the publisher.
         */
        plans: GalleryItemOfferPlan[];
    }
    /**
     * Gallery offer plan.
     */
    interface GalleryItemOfferPlan {
        /**
         * The plan id.
         */
        planId: string;
        /**
         * The plan display name.
         */
        displayName: string;
        /**
         * The summary text for the plan.
         */
        summary: string;
        /**
         * The description HTML for the plan.
         */
        description: string;
    }
    /**
     * The context from which a gallery create is kicked off.
     */
    interface LaunchingContext extends StringMap<any> {
        /**
         * The gallery item id.
         */
        galleryItemId: string;
        /**
         * The source entity launching the create flow (blade name, control, etc.). Used for telemetry logging.
         */
        source: string[];
        /**
         * The gallery menu item id.
         */
        menuItemId?: string;
        /**
         * The gallery sub menu item id.
         */
        subMenuItemId?: string;
        /**
         * The gallery item index from the source grid.
         */
        itemIndex?: number;
        /**
         * Unique id for tracking a deployment.
         */
        telemetryId?: string;
        /**
         * Extension version.
         */
        extVersion?: string;
        /**
         * The name of the create blade.
         */
        createBlade?: string;
        /**
         * Indicates if this is a create flow that uses the PCv1/v2 API.
         */
        oldCreateApi?: boolean;
        /**
         * The blade instance id.
         */
        bladeInstanceId?: string;
    }
    /**
     * Represents types of resource move operations supported in the system.
     */
    const enum MoveType {
        /**
         * Move resources across subscriptions and resource groups excluding current subscription.
         */
        Subscription = 0,
        /**
         * Move resources across resource groups only.
         */
        ResourceGroup = 1,
        /**
         * Move resources across subscriptions and resource groups including current subscription.
         */
        SubscriptionAndResourceGroup = 3,
        /**
         * Move resource is not supported.
         */
        None = 4
    }
    /**
     * Returns the move resource blade for editing resource group/subscription properties.
     *
     * @param resourceId resource Id of the resource to be moved.
     * @param moveType supported move types by the resource RP.
     * @return An edit blade for the moving resources across subscriptions/resource groups.
     */
    function getMoveResourceBlade(resourceId: string, moveType: MoveType): FxPropertiesPart.OpenBlade;
    module Internal {
        /**
         * Indicates a gallery item create availability.
         */
        enum GalleryItemAccess {
            /**
             * If the access is not set it means the default rules should be followed.
             */
            NotSet = 0,
            /**
             * This means the item was curated to be allowed regardless of categories.
             * For example in the case of dream spark an item may be allowed if specified in the curation.
             */
            Allowed = 1,
            /**
             * This means the item was curated to not be allowed.
             */
            NotAllowed = 2
        }
        /**
         * Galley item with extended options used by the create flow.
         */
        interface ExtendedGalleryItem extends Gallery.GalleryItem {
            /**
             * Represents a value indicating if an item is allowed or not by the subscription quota according to the curation.
             */
            galleryItemAccess?: GalleryItemAccess;
        }
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Deployments.d.ts
declare module FxImpl.Azure.ResourceManager {
    import RpcCore = FxImpl.Rpc;
    /**
     * The max number of items tracked in the list of last deployed gallery items in user settings.
     */
    let lastDeployedGalleryItemsMaxCount: number;
    /**
     * The max number of locations tracked in the list of last used locations in user settings.
     */
    let lastUsedLocationsMaxCount: number;
    /**
     * Internal RPC endpoint to read uset settings from HubsExtension.
     */
    const readUserSettingsEndPoint: RpcCore.FuncEndPointDefinition<string[], StringMap<any>>;
}
declare module MsPortalFx.Azure.ResourceManager {
    /**
     * The deployment stages.
     */
    enum DeploymentStages {
        /**
         * Initial set up of the template deployment options.
         */
        InitialSetup = 0,
        /**
         * Sanity check for the template deployment options.
         */
        SanityCheck = 1,
        /**
         * Fulfills the prerequisites for a deployment (provisioning a resource group, registering the
         * resource providers, and getting a deployment name).
         */
        FulfillPrerequisites = 2,
        /**
         * Makes sure the resource group exists, and creates one otherwise.
         */
        ProvisionResourceGroup = 3,
        /**
         * Registers the resource providers with the subscription.
         */
        RegisterResourceProviders = 4,
        /**
         * Gets a valid deployment name.
         */
        GetDeploymentName = 5,
        /**
         * Validate a deployment template using ARM's preflight validation API.
         */
        ValidateTemplate = 6,
        /**
         * Submits a deployment request to ARM.
         */
        SubmitDeploymentRequest = 7,
        /**
         * Gets the deployment status from ARM (polling).
         */
        GetDeploymentStatus = 8
    }
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    module DeploymentStates {
        /**
         * Deployment accepted.
         */
        const Accepted = "accepted";
        /**
         * Deployment succeeded.
         */
        const Succeeded = "succeeded";
        /**
         * Deployment failed.
         */
        const Failed = "failed";
        /**
         * Deployment canceled.
         */
        const Canceled = "canceled";
        /**
         * Deployment running.
         */
        const Running = "running";
        /**
         * Deployment deploying.
         */
        const Deploying = "deploying";
        /**
         * Deployment waiting.
         */
        const Waiting = "waiting";
        /**
         * Deployment deleting.
         */
        const Deleting = "deleting";
        /**
         * Deployment deleted.
         */
        const Deleted = "deleted";
    }
    /**
     * ARM template deployment API arguments.
     */
    interface DeploymentApiArgs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The management group id.
         */
        managementGroupId?: string;
        /**
         * The deployment name.
         */
        deploymentName: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The resource id. Supply this to link the notifications to the asset or if the deployment
         * results in a startboard part.
         */
        resourceId?: string;
        /**
         * The context from which a gallery create is kicked off. Used for telemetry logging.
         */
        launchingContext?: LaunchingContext;
        /**
         * Debug info.
         */
        debug?: string;
        /**
         * A key or hash that encodes or corresponds to information about a provisioning request.
         * This must be a valid resource tag value to persist across sessions.
         * View the tag value rules at https://go.microsoft.com/fwlink/?LinkID=2097613.
         */
        provisioningHash?: string;
    }
    /**
     * ARM template deployment options.
     */
    interface TemplateDeploymentOptions extends DeploymentApiArgs {
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * An array of the resource providers to be registered for the subscription.
         */
        resourceProviders: string[];
        /**
         * The parameters for the template deployment (name and value pairs).
         */
        parameters?: StringMap<string | number | boolean | Object>;
        /**
         * The reference parameters for the template deployment.
         */
        referenceParameters?: StringMap<Object>;
        /**
         * The URI for the parameters file. Use this to link to an existing parameters file. Specify
         * this or the parameters and/or referenceParameters properties, but not both.
         */
        parametersLinkUri?: string;
        /**
         * The URI for the ARM template. Specify this or the templateJson property, but not both.
         */
        templateLinkUri?: string;
        /**
         * The inline deployment template JSON. Specify this or the templateLinkUri property, but not both.
         */
        templateJson?: string;
        /**
         * Flag indicating whether to suppress default deployment notifications or not. Defaults to
         * false. This applies only to intermediate local notifications (initialization, submitting
         * the deployment, and starting the deployment). Success and failures will still show as they
         * arrive from the events service.
         */
        suppressDefaultNotifications?: boolean;
        /**
         * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
         */
        deploymentMode?: TemplateDeploymentMode;
        /**
         * Flag indicating that we should run ARM's preflight validation before submitting the template
         * deployment request to ARM. Defaults to false.
         */
        validateTemplate?: boolean;
        /**
         * ARM template validation result.
         */
        validationResult?: TemplateValidationResponse;
    }
    /**
     * ARM template deployment polling options.
     */
    interface TemplateDeploymentPollingOptions extends DeploymentApiArgs {
        /**
         * The correlation id (aka tracking id).
         */
        correlationId: string;
        /**
         * Report all ARM operations as progress. Defaults to false.
         */
        getAllOperations?: boolean;
        /**
         * Timestamp when the deployment request was initiated.
         */
        requestTimestamp: Date;
    }
    /**
     * ARM template deployment result.
     */
    interface TemplateDeploymentResult extends DeploymentApiArgs {
        /**
         * The deployment status code.
         */
        deploymentStatusCode: DeploymentStatusCode;
        /**
         * The correlation id (aka tracking id).
         */
        correlationId: string;
        /**
         * The provisioning state.
         */
        provisioningState: string;
        /**
         * The timestamp when the operation was completed.
         */
        timestamp: Date;
        /**
         * The list of deployment operations.
         */
        operations?: TemplateDeploymentOperation[];
        /**
         * Timestamp when the deployment request was initiated.
         */
        requestTimestamp?: Date;
    }
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperation = Common.Provisioning.TemplateDeploymentOperation;
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperationProperties = Common.Provisioning.TemplateDeploymentOperationProperties;
    /**
     * ARM template deployment error.
     */
    interface TemplateDeploymentError extends FxImpl.Azure.SimplifiedError {
        /**
         * The deployment status code.
         */
        deploymentStatusCode: DeploymentStatusCode;
        /**
         * The ARM template deployment options used in the deployment operation.
         */
        templateDeploymentOptions: TemplateDeploymentOptions;
        /**
         * The correlation id.
         */
        correlationId?: string;
        /**
         * Timestamp when the last notification was published.
         */
        notificationTimestamp: Date;
    }
    /**
     * The ARM template.
     */
    interface DeploymentTemplate {
        /**
         * The template schema URI.
         */
        $schema: string;
        /**
         * The content version for the template.
         */
        contentVersion: string;
        /**
         * The template parameters.
         */
        parameters?: StringMap<TemplateParameter>;
        /**
         * The template variables.
         */
        variables?: StringMap<string>;
        /**
         * The template resources.
         */
        resources: TemplateResource[];
        /**
         * The template outputs.
         */
        outputs?: StringMap<TemplateOutput>;
    }
    /**
     * The template output.
     */
    export import TemplateOutput = Common.Provisioning.TemplateOutput;
    /**
     * The template parameter.
     */
    interface TemplateParameter {
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The list of allowed values for the parameter.
         */
        allowedValues?: any[];
        /**
         * The default value for the parameter.
         */
        defaultValue?: any;
        /**
         * The parameter metadata.
         */
        metadata?: TemplateParameterMetadata;
        /**
         * The minimum value for the parameter.
         */
        minValue?: number;
        /**
         * The max value for the parameter.
         */
        maxValue?: number;
        /**
         * The minimum lenght for the parameter.
         */
        minLength?: number;
        /**
         * The max length for the parameter.
         */
        maxLength?: number;
    }
    /**
     * The template paramteter metadata.
     */
    interface TemplateParameterMetadata {
        /**
         * The description for the parameter shown in an infoballoon.
         */
        description?: string;
        /**
         * The description for the parameter shown in an infoballoon.
         */
        Description?: string;
        /**
         * The display text for the parameter.
         */
        label?: string;
        /**
         * Sublabel for the parameter.
         */
        sublabel?: string;
        /**
         * The parameter group. Allows parameters to be grouped on the form.
         * If set to 'BasicGroup', the parameter will be added above sub/rg/location dropdowns
         */
        group?: string;
    }
    /**
     * The template resource.
     */
    export import TemplateResource = Common.Provisioning.TemplateResource;
    /**
     * The response that ARM returns when a template validate call succeeds.
     */
    export import TemplateValidationResponse = Common.Provisioning.TemplateValidationResponse;
    /**
     * ARM template validation result.
     */
    interface TemplateValidationError {
        /**
         * The error code.
         */
        code: DeploymentStatusCode;
        /**
         * The error message.
         */
        message: string;
        /**
         * The error object.
         */
        error?: any;
        /**
         * The error status.
         */
        status?: number;
    }
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    export import TemplateDeploymentMode = Common.Provisioning.TemplateDeploymentMode;
    /**
     * The deployment status codes.
     */
    enum DeploymentStatusCode {
        /**
         * Template preflight, validation or deployment failure (based on the operation performed).
         */
        Failure = -1,
        /**
         * Deployment was accepted or successful (based on the operation performed).
         */
        Success = 0,
        /**
         * ARM rejected the deployment request.
         */
        DeploymentRequestFailed = 1,
        /**
         * Deployment failed.
         */
        DeploymentFailed = 2,
        /**
         * Deployment status unknown.
         */
        DeploymentStatusUnknown = 3,
        /**
         * An unexpected error occurred while provisioning the resource group.
         */
        ErrorProvisioningResourceGroup = 4,
        /**
         * An unexpected error occurred while submitting the deployment request.
         */
        ErrorSubmittingDeploymentRequest = 5,
        /**
         * An unexpected error occurred while getting the deployment status.
         */
        ErrorGettingDeploymentStatus = 6,
        /**
         * Invalid arguments.
         */
        InvalidArgs = 7,
        /**
         * An unexpected error occurred while registering the resource providers.
         */
        ErrorRegisteringResourceProviders = 8,
        /**
         * Deployment canceled.
         */
        DeploymentCanceled = 9,
        /**
         * Unknown error.
         */
        UnknownError = 10
    }
    /**
     * Deploys an ARM deployment template.
     *
     * @param options The template deployment options.
     * @return A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function deployTemplate(options: TemplateDeploymentOptions): Q.Promise<TemplateDeploymentResult>;
    /**
     * Polls for an ARM deployment updates.
     *
     * @param options The template deployment polling options.
     * @return A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function pollForDeployment(options: TemplateDeploymentPollingOptions): Q.Promise<TemplateDeploymentResult>;
    /**
     * Validates an ARM template.
     *
     * @param options The template deployment options.
     * @returns A promise resolved with the template deployment result.
     */
    function validateTemplate(options: TemplateDeploymentOptions): Q.Promise<TemplateDeploymentOptions>;
    /**
     * The ARM deployments APIs.
     */
    module Deployments {
        /**
         * Deploys an ARM deployment template.
         *
         * NOTE: The returned promise will resolve with the template deployment result when it succeeds.
         * If deployment failed, the promise will be rejected with a template deployment error (expected
         * failure) or an unexpected failure.
         *
         * @param options The template deployment options.
         * @return A promise resolved with the template deployment result, and possibly reports progress
         *      (based on the options).
         */
        function deployTemplate(options: TemplateDeploymentOptions): Q.Promise<TemplateDeploymentResult>;
        /**
         * Polls for an ARM deployment updates.
         *
         * NOTE: The returned promise will resolve with the template deployment result when it succeeds.
         * If deployment failed, the promise will be rejected with a template deployment error (expected
         * failure) or an unexpected failure.
         *
         * @param options The template deployment polling options.
         * @return A promise resolved with the template deployment result, and possibly reports progress
         *      (based on the options).
         */
        function pollForDeployment(options: TemplateDeploymentPollingOptions): Q.Promise<TemplateDeploymentResult>;
        /**
         * Validates an ARM template.
         *
         * @param options The template deployment options.
         * @returns A promise with the template validation result.
         */
        function validateTemplate(options: TemplateDeploymentOptions): Q.Promise<TemplateDeploymentOptions>;
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\LocationPicker.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Location {
    import LocationDropDown = MsPortalFx.Azure.Locations.DropDown;
    /**
     * The data model used by the location picker.
     */
    interface DataModel {
        /**
         * The display name of the location.
         */
        displayName: KnockoutObservableBase<string>;
        /**
         * The normalized name of the location.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The latitude of the location.
         */
        latitude: KnockoutObservableBase<number>;
        /**
         * The longitude of the location.
         */
        longitude: KnockoutObservableBase<number>;
    }
    /**
     * The config used by the location picker.
     */
    interface Config {
        /**
         * The subscription id used to filter locations.
         */
        subscriptionId: string;
        /**
         * The list of resource types used to filter locations.
         */
        resourceTypes: string[];
        /**
         * Optional, location filters.
         */
        filter?: LocationFilter;
    }
    /**
     * The location filters.
     */
    interface LocationFilter extends LocationDropDown.LocationFilter {
    }
    /**
     * The allowed locations.
     */
    interface AllowedLocations extends LocationDropDown.AllowedLocations {
    }
    /**
     * The disallowed location.
     */
    interface DisallowedLocation extends LocationDropDown.DisallowedLocation {
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\ResourceGroupPicker.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.ResourceGroup {
    /**
     * The data model used by the resource group picker.
     */
    interface DataModel {
        /**
         * The id of the resource group.
         */
        id: KnockoutObservableBase<string>;
        /**
         * The name of the resource group.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The resource group location.
         */
        location: KnockoutObservableBase<string>;
    }
    /**
     * The config used by the resource group picker.
     */
    interface Config {
        /**
         * The subscription id used to filter resource groups.
         */
        subscriptionId: string;
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\Specs\Common.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    import SpecPickerTypes = HubsExtension.Azure.SpecPicker.ParameterCollectionV3;
    /**
     * Configuration data for a spec picker blade
     */
    interface InitialData extends SpecPickerTypes.SpecPickerProviderCollectorParameterFromCollector {
    }
    /**
     * Spec data returned from the spec picker blade
     */
    interface Result extends SpecPickerTypes.SpecPickerProviderCollectorParameterFromProvider {
    }
}
declare module FxImpl.Azure.ResourceManager.Pickers.Specs {
    import FxViewModels = MsPortalFx.ViewModels;
    import SpecPicker = MsPortalFx.Azure.ResourceManager.Pickers.Specs;
    import SpecPickerTypes = HubsExtension.Azure.SpecPicker.ParameterCollectionV3;
    import OriginControl = HubsExtension.Azure.SpecPicker.OriginControl;
    /**
     * Options to pass into the CollectorControl
     */
    interface Options {
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @return Initial data for the child blade.
         */
        supplyInitialData(): SpecPicker.InitialData;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         */
        receiveResult?(result: SpecPicker.Result): void;
    }
    /**
     * Base class which interfaces with a spec picker blade.
     */
    class CollectorControl {
        /**
         * ParameterCollector created to interface with the spec picker blade ParameterProvider
         */
        collector: FxViewModels.ParameterCollector<SpecPickerTypes.SpecPickerProviderCollectorParameter>;
        protected controlType: OriginControl;
        /**
         * Constructs a control which launches a spec picker blade and a collector that recieves a spec
         *
         * @param container The container associated with the part or other composition item hosting this parameter collector.
         * @param selectable The selectable associated with the <BladeAction> connected to this Control.
         * @param value The observable to place the Result from the spec picker blade.
         * @param options The options object which contains callbacks for providing initial data and receiving results.
         */
        constructor(container: FxViewModels.ContainerContract, selectable: FxViewModels.Selectable<FxViewModels.DynamicBladeSelection>, value: KnockoutObservableBase<SpecPicker.Result>, options: Options);
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\Specs\InfoBox.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    import Controls = MsPortalFx.ViewModels.Controls;
    import Internal = FxImpl.Azure.ResourceManager.Pickers.Specs;
    module InfoBox {
        interface Options extends Internal.Options, Controls.InfoBox.BaseInfoBoxOptions {
        }
    }
    /**
     * InfoBox which creates a collector and selector that launches a spec picker blade
     */
    class InfoBox extends Internal.CollectorControl {
        /**
         * InfoBox.ViewModel The info box control.
         */
        control: Controls.InfoBox.ViewModel;
        /**
         * KnockoutObservable<Result> The selected spec.
         */
        value: KnockoutObservable<Result>;
        /**
         * Constructs a InfoBox with for a spec ViewModel with a collector to a spec picker blade attached
         *
         * @param container The container associated with the part or other composition item hosting this parameter collector.
         * @param infoBox options that extends both the colector and the BaseInfoBoxOptions
         */
        constructor(container: MsPortalFx.ViewModels.ContainerContract, options: InfoBox.Options);
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\Specs\Selector.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    import Internal = FxImpl.Azure.ResourceManager.Pickers.Specs;
    import FxViewModels = MsPortalFx.ViewModels;
    import Forms = FxViewModels.Forms;
    module Selector {
        /**
         * Data contract options passed into the SpecSelectorCollector
         */
        interface Options extends Internal.Options, Forms.Selector.Options<Result> {
            /**
             * The Form ViewModel for the selector control.
             */
            form: Forms.Form.ViewModel<any>;
            /**
             * The path to the property on the Form data model being set
             * Used instead of accessor
             */
            pathOrAccessor: string | Forms.EditScopeAccessors<Result>;
        }
    }
    class Selector extends Internal.CollectorControl {
        /**
         * Selector.ViewModel The Selector ViewModel created.
         */
        control: Forms.Selector.ViewModel<Result>;
        constructor(container: FxViewModels.ContainerContract, options: Selector.Options);
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Provisioner.d.ts
declare module MsPortalFx.Azure.ResourceManager {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxViewModels = Fx.ViewModels;
    import ParameterCollection = FxViewModels.ParameterCollectionV3;
    import Pricing = HubsExtension.Azure.Pricing;
    import ProvisioningTelemetry = FxImpl.ProvisioningTelemetry;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    import PartReference = MsPortalFx.Composition.PartReference;
    export let armValidateFeatureForced: boolean;
    export interface UIConfig {
        /**
         * (Optional) Prevents the provisioner from discarding the journey. Defaults to false.
         */
        dontDiscardJourney?: boolean;
        /**
         * Given a resourceId, return a part reference for a dashboard part
         */
        supplyDashboardPartReference?: (resourceId: string) => PartReference<any>;
    }
    interface ProvisioningTelemetry {
        readonly correlationId: string;
        readonly resourceId: string;
        readonly deploymentId: string;
        readonly provisioningState: string;
    }
    /**
     * @deprecated ResourceManager.Provisioner. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    export class Provisioner<TData> extends ParameterCollection.Provisioner<TData> {
        /**
         * The selectable to activate the pricing summary blade.
         */
        pricingSelectable: FxViewModels.Internal.Selectable<FxViewModels.DynamicBladeSelection>;
        /**
         * The selectable to activate the ARM errors blade.
         */
        errorsSelectable: FxViewModels.Internal.Selectable<FxViewModels.DynamicBladeSelection>;
        readonly deploymentStartedPromise: KnockoutObservable<Q.Promise<ProvisioningTelemetry>>;
        protected _armOptions: Provisioner.Options<TData>;
        protected _deploymentOptions: TemplateDeploymentOptions;
        private _legalTermsBladeShown;
        private _legalTermsCommitId;
        private _pricingSummaryCommitId;
        private _purchaseInProgress;
        private _showPricingSummary;
        private _showAutomationOptions;
        private _parameterProvider;
        /**
         * Constructs a new instance of an ARM provisioner.
         *
         * @param container The container into which the part containing the provisioner is being placed.
         * @param initialState Initial state of the containing view model.
         * @param options The ARM provisioner options.
         */
        constructor(container: FxViewModels.ContainerContract, initialState: any, options: Provisioner.Options<TData>);
        /**
         * The ARM provisioner configuration passed originally from the collector, to the provisioner,
         * to this provisioning part.
         */
        get armProvisioningConfig(): Provisioner.Config;
        /**
         * Manually start provisioning. This is usually used with collector view models. This must
         * not be used if the provisioner is configured with a provider and an action bar (automatically)
         * triggered). This method uses the 'supplyStartboardInfo' to define a startboard part if you
         * want provisioning to happen on the startboard, or return null or undefined if you want it
         * to run in the background.
         *
         * @param data The provisioning data that will be passed to the provisioning operation.
         * @return A promise that represents the provisioning operation.
         */
        startProvisioning(data: TData): FxBase.PromiseVN<any, any>;
        /**
         * Validates an ARM template.
         *
         * @param options The template deployment options.
         * @returns A promise with the template validation result.
         */
        validateTemplate(templateDeploymentOptions: TemplateDeploymentOptions): FxBase.PromiseVN<TemplateDeploymentOptions, TemplateDeploymentOptions>;
        protected _deployTemplate(templateDeploymentOptions: TemplateDeploymentOptions, container: FxViewModels.ContainerContract): FxBase.PromiseVN<TemplateDeploymentResult, TemplateDeploymentResult>;
        protected _validateTemplate(templateDeploymentOptions: TemplateDeploymentOptions): Q.Promise<TemplateDeploymentOptions>;
        _supplyProvisioningPromise(data: TData, container: FxViewModels.ContainerContract): Q.Promise<any>;
        private _supplyStartboardInfo;
        private _setUpActionBarValidation;
        private _setActionBarProgress;
        protected _getPinToDashboardArgs(data: TData, templateDeploymentOptions: TemplateDeploymentOptions): FxImpl.Hubs.Notifications.PinToDashboardArgs;
        private _setUpActionBarWatcher;
        private _launchTemplateViewerBlade;
        private _launchPricingSelectable;
        private _getPricingBladeInputs;
        protected _traceProvisioningStarted(): Telemetry.TelemetryEvent;
        protected _traceProvisioningEnded(result: any, resolved: boolean): Telemetry.TelemetryEvent;
    }
    export module Provisioner {
        let armValidationTimeout: number;
        /**
         * Azure resource manager provisioning part definition.
         * This is the default part when ARM provisioning is invoked.
         */
        let azureResourceManagerProvisioningPart: ParameterCollection.ExtensionElement;
        /**
         * Interface that defines why the supplyTemplateDeploymentOptions is being called
         */
        const enum GetTemplateDeploymentOptionsMode {
            /**
             * The function is being called to do a create.
             */
            Create = 0,
            /**
             * The function is being called to export the template.
             * No create is being performed.
             */
            ExportTemplate = 1,
            /**
             * The function is being called for validating the options.
             * No create is being performed.
             */
            Validate = 2
        }
        /**
         * ARM provisioning part options.
         */
        interface Options<TData> {
            /**
             * A callback that supplies the template deployment options that will be used in provisioning
             * the deployment of the ARM template.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically, the data is the same data returned to the collector (by the
             *      'mapOutgoingDataForCollector' method). If the provisioner is triggered automatically,
             *      the data is whatever is passed to the 'startProvisioning' method.
             * @param mode The mode for why the function is being called. This function can be
             *      called when a user wants to export the deployment template or when doing an acutal create.
             *      Extensions can use the mode for their own logging purposes. The output of the function
             *      *should* not change based on the mode.
             * @return A promise resolved with the template deployment options.
             */
            supplyTemplateDeploymentOptions: (data: TData, mode: GetTemplateDeploymentOptionsMode) => FxBase.PromiseV<TemplateDeploymentOptions>;
            /**
             * A callback that supplies the provisioner with the startboard info (which provisioning part
             * to use, and which startboard part to mutate into). Use this callback if you want to override
             * the startboard part info defined in the UI definition file of the gallery package.
             *
             * If provisioning is automatically triggered, and if the user wants provisioning to happen
             * on the startboard, the startboard info returned will be used for that purpose. If invalid
             * startboard info is returned, the provisioner will throw an exception and provisioning will
             * fail. Null or undefined are not acceptable.
             *
             * If provisioning is manually triggered, returning null or undefined indicates that you don't
             * want provisioning to happen on the startboard. If you return invalid startboard info, the
             * provisioner will throw an exception. If you return valid startboard info, a provisioning
             * part will be added to the startboard for provisioning to take place.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically (it's hooked up with a provider and an action bar), the data
             *      is the same data returned to the collector (by the 'mapOutgoingDataForCollector'
             *      method). If the provisioner is triggered automatically, the data is whatever was
             *      passed to the 'startProvisioning' method.
             * @return A startboard info object indicating which provisioning part to use and which
             *      startboard the provisioning part will mutate into.
             */
            supplyStartboardInfo?: (data: TData) => ParameterCollection.StartboardInfo;
            /**
             * A callback that supplies the provisioner with the gallery create config options. This is
             * only required when provisioning is manually triggered (config usually comes from the collector
             * in the automatic trigger case).
             *
             * @return The gallery create config options.
             */
            supplyGalleryCreateOptions?: () => GalleryCreateOptions;
            /**
             * The action bar view model. This is the action bar on your provider blade. Defining this
             * property means you also need to define a parameter provider.
             */
            actionBar?: FxViewModels.ActionBars.Base.Contract;
            /**
             * The parameter provider. This is the parameter provider on your provider view model.
             * Defining this property means you also need to define an action bar.
             */
            parameterProvider?: FxViewModels.ParameterProvider<TData, any>;
            /**
             * The features added to a create experience.
             */
            createFeatures?: CreateFeatures;
            /**
             * A callback that supplies the pricing config required by the pricing summary and/or the
             * legal terms blade. This is required if the 'createFeatures' specifies the
             * 'ShowPricingSummary' and/or 'ShowLegalTerms' flags.
             *
             * @return The pricing config required by the pricing blades.
             */
            supplyPricingConfig?: () => Provisioner.PricingConfig;
            /**
             * A callback that gets called if ARM validation succeeds.
             * Allows extensions to run additional validations on the ARM response.
             * This is only called if CreateFeatures.EnableArmValidation is set.
             *
             * @param armValidationResult The ARM validation result.
             * @return A promise that returns a validation result.
             */
            postValidationCallback?: (armValidationResult: any) => FxBase.PromiseV<FxViewModels.ValidationResult>;
        }
        /**
         * The ARM provisioner configuration that a collector can pass to the provider part.
         */
        interface Config extends ParameterCollection.Provisioner.Config {
            /**
             * Gallery-create config options.
             */
            galleryCreateOptions: GalleryCreateOptions;
        }
        /**
         * The features that can be added to a create experience.
         */
        const enum CreateFeatures {
            /**
             * None (default).
             */
            None = 0,
            /**
             * Shows the pricing summary. This adds a "Pricing summary" link next to the create button
             * on the action bar. Clicking the link launches the pricing summary blade.
             */
            ShowPricingSummary = 1,
            /**
             * Shows the legal terms. This launches the legal terms blade once the create button on
             * the create action bar is clicked. Clicking "Buy" on the legal terms blade will kick
             * off create.
             */
            ShowLegalTerms = 2,
            /**
             * Shows the automation options. This cannot be set if the show pricing summary link is also set.
             * This adds a "Automation options" link next to the create button on the action bar.
             * Clicking the link launches the template viewer blade where users can download
             * automation scripts for creating resources
             */
            ShowAutomationOptions = 4,
            /**
             * Do not show the export template option. If explicity opting out of showing export template, this flag should be set.
             * This removes the "Automation options" link next to the create button on the action bar.
             */
            HideExportTemplate = 8,
            /**
             * Opts out of ARM validation.
             */
            DisableArmValidation = 16,
            /**
             * Opts in for ARM validation.
             */
            EnableArmValidation = 32
        }
        /**
         * The ARM provisioner configuration that a collector can pass to the provider part.
         */
        interface PricingConfig {
            /**
             * A callback to supply the pricing info required by the pricing summary and/or legal terms
             * blades.
             */
            supplyPricingInfo: () => Pricing.PricingInfo;
            /**
             * Optional. A boolean observable that shows/hides the pricing summary link. If not supplied,
             * the pricing summary link will always be visible if the 'createFeatures' on the ARM
             * provisioner options specifies the 'ShowPricingSummary' flags.
             */
            showPricingSummaryLink?: KnockoutObservableBase<boolean>;
        }
    }
    export {};
}
declare module FxImpl.Azure.ResourceManager {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxAzure = MsPortalFx.Azure;
    import ParameterCollection = FxViewModels.ParameterCollectionV3;
    import Internal = FxImpl.ViewModels.ParameterCollectionV3;
    import FxProvisioner = FxAzure.ResourceManager.Provisioner;
    import ProvisionerOptions = FxProvisioner.Options;
    import ValidationEvent = ParameterCollection.ValidationEvent;
    /**
     * Internal version of the Provisioner to prevent exposing unnecessary APIs.
     */
    class Provisioner<TData> extends FxProvisioner<TData> implements Internal.Provisioner<TData> {
        constructor(container: FxViewModels.ContainerContract, initialState: any, options: ProvisionerOptions<TData>);
        /**
         * Trace a validation event.
         */
        traceValidation(eventType: ValidationEvent): void;
    }
}

// FILE: MsPortalFx\Azure\Storage.d.ts
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxImpl.Rpc;
    module InternalAzure {
        /**
         * Internal RPC endpoint to get a sas uri for a storage account's queue.
         */
        const getSasUriForQueueEndPoint: FxRpc.FuncEndPointDefinition<Azure.Storage.GetSasUriForQueueOptions, string>;
    }
    module Azure.Storage {
        /**
         * Bit-wise OR permissions attached to the generated sas token.
         */
        const enum SharedAccessQueuePermissions {
            /**
             * Can do nothing to the storage queue.
             */
            None = 0,
            /**
             * Can read from the storage queue.
             */
            Read = 1,
            /**
             * Can add to the storage queue.
             */
            Add = 2,
            /**
             * Can update the storage queue.
             */
            Update = 4,
            /**
             * Can process messages for the storage queue.
             */
            ProcessMessages = 8
        }
        /**
         * Parameters that must be passed when calling the GetQueueSasUri function.
         */
        interface GetSasUriForQueueOptions {
            /**
             * The shared access expiry time, in seconds.
             */
            durationInSeconds: number;
            /**
             * The permissions for the sas token.
             */
            permissions: SharedAccessQueuePermissions;
            /**
             * The storage account name.
             */
            accountName: string;
            /**
             * The primary key for the storage account.
             */
            accountKey: string;
            /**
             * The name of the storage queue for which a sas token will be generated.
             */
            queueName: string;
        }
        /**
         * Returns a sas token uri for the requested queue.
         *
         * @param args Parameters required by the function.
         * @return A promise that resolves to the sas uri string.
         */
        function getSasUriForQueue(args: GetSasUriForQueueOptions): FxBase.PromiseV<string>;
    }
}
declare module "MsPortalFx/Azure/Storage" {
    import Impl = FxImpl.Azure.Storage;
    export = Impl;
}

// FILE: MsPortalFx\Azure\Subscriptions.d.ts
declare module FxImpl.Azure {
    import FxRpc = FxImpl.Rpc;
    import FxGalleryItem = MsPortalFx.Services.Gallery.GalleryItem;
    import Subscription = MsPortalFx.Azure.Subscription;
    /**
     * Validate subscription object, used to validate a list of subscriptions against a gallery item
     * through the Marketplace.
     */
    interface ValidateSubscription {
        /**
         * The gallery item.
         */
        galleryItem: FxGalleryItem;
        /**
         * The subscriptions to validate.
         */
        subscriptions: Subscription[];
    }
    /**
     * Inputs to validating whether a set of subscriptions can perform operations on a given gallery item.
     */
    interface SubscriptionValidationInputs {
        /**
         * The gallery item to validate against.
         */
        galleryItem: FxGalleryItem;
    }
    /**
     * Result of validating whether a set of subscriptions can perform operations on a given gallery item.
     */
    interface SubscriptionValidationResult {
        /**
         * Failure details for subscriptions that did not validate successfully.
         */
        invalidSubscriptions: SubscriptionValidationFailure[];
        /**
         * Error blade to launch if there no valid subscriptions
         */
        noValidSubscriptionsErrorBlade?: MsPortalFx.ViewModels.DynamicBladeSelection;
    }
    /**
     * Failure details for subscriptions that did not validate successfully.
     */
    interface SubscriptionValidationFailure {
        /**
         * Id of the subscription that failed to validate
         */
        subscriptionId: string;
        /**
         * Text to display for the validation failure
         */
        displayText: string;
    }
    /**
     * Inputs to for the canRegisterSubscriptionWithRPs endpoint.
     */
    interface CanRegisterSubWithRPsInputs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The list of resource providers.
         */
        resourceProviders: string[];
    }
    /**
     * Result for the canRegisterSubscriptionWithRPs endpoint.
     */
    interface CanRegisterSubWithRPsResult {
        /**
         * True if the subscription is already registered or can register with all given resource
         * providers. False otherwise.
         */
        success: boolean;
        /**
         * The list of resource providers that the subscription failed to register with. Empty if
         * success is true.
         */
        failedRPs: string[];
        /**
         * The list of resource providers that the subscription is not allowed to register with.
         */
        disallowedRPs: string[];
    }
    interface ObsoleteSubscription extends MsPortalFx.Azure.Subscription {
        /**
         * Friendly name of the azure subscription.
         */
        subscriptionName: string;
        /**
         * Id of the azure subscription.
         */
        subscriptionID: string;
        /**
         * Id of the Active Directory tenant containing this subscription.
         */
        tenantID: string;
        /**
         * The subscription status.
         */
        status: string;
        /**
         * The subscriptions requires rdfe.
         */
        requireRdfe: boolean;
    }
    /**
     * Internal RPC endpoint to get the detailed info for a subscription.
     */
    const getSubscriptionInfoEndPoint: FxRpc.FuncEndPointDefinition<string, Subscription>;
    /**
     * Internal RPC endpoint to get the list of selected subscriptions.
     */
    const getInSessionSelectedSubscriptionsEndPoint: FxRpc.FuncEndPointDefinition<void, readonly Subscription[]>;
    /**
     * Checks if the subscription can register with a list or resource providers (if not already registered).
     * @param subscriptionId The subscription id.
     * @param resourceProviders The resource types.
     * @return Resolves with a list of resource providers that the subscription can't register with
     *     (or an empty array otherwise).
     */
    function canRegisterSubscriptionWithRPs(subscriptionId: string, resourceProviders?: string[]): Q.Promise<CanRegisterSubWithRPsResult>;
    /**
     * Returns a value indicating whether the subscription is a free trial subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a free trial subscription.
     */
    let isFreeTrialSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a DreamSpark subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a DreamSpark subscription.
     */
    let isDreamSparkSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a BizSpark subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a BizSpark subscription.
     */
    let isBizSparkSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a ZeroCap subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a ZeroCap subscription.
     */
    let isZeroCapSubscription: (subscription: Subscription) => boolean;
}
declare module MsPortalFx.Azure {
    /**
     * Data contract for a single Azure subscription.
     */
    interface Subscription {
        /**
         * Unique display name, that includes disabled state aswell as subscription id (if display name is not unique).
         */
        uniqueDisplayName: string;
        /**
         * Friendly name of the azure subscription.
         */
        displayName: string;
        /**
         * Id of the azure subscription.
         */
        subscriptionId: string;
        /**
         * Id of the Active Directory tenant containing this subscription.
         */
        tenantId: string;
        /**
         * The subscription state.
         */
        state: string;
        /**
         * The subscription policies. May be null.
         */
        subscriptionPolicies: SubscriptionPolicies;
        /**
         * The users authorization type for the subscriptions. Values are �Legacy�, �RoleBased�, �Legacy, RoleBased�.
         */
        authorizationSource: string;
    }
    /**
     * Data contract for Azure subscription policies.
     */
    interface SubscriptionPolicies {
        /**
         * The subscription location placement id.
         */
        locationPlacementId: string;
        /**
         * The subscription quota id.
         */
        quotaId: string;
        /**
         * The subscription spending limit Values "On", "Off", "CurrentPeriodOff"
         */
        spendingLimit?: string;
    }
    /**
     * Subscriptions namespace.
     */
    module Subscriptions {
        module DropDown {
            type Options = Obsolete;
        }
        function filterObjectByName(item: Subscription, name: string): boolean;
        function itemToHierarchicalFormOption(item: Subscription): {
            text: KnockoutObservable<string>;
            value: string;
        };
        /**
         * @deprecated MsPortalFx.Azure.Subscriptions.DropDown. Please use `import { create } from "Fx/Controls/SubscriptionDropDown";` http://aka.ms/portalfx/breaking
         */
        const DropDown: Obsolete;
    }
    /**
     * Returns the detailed info for a subscription.
     *
     * @param subscriptions Id of the subscription.
     * @return A promise that resolves to the detailed info for the subscription.
     */
    function getSubscriptionInfo(subscriptionId: string): Q.Promise<Subscription>;
    /**
     * Returns the list of selected subscription.
     *
     * @return A promise that resolves to the list of selected subscriptions.
     */
    function getSelectedSubscriptions(): Q.Promise<ReadonlyArray<Subscription>>;
}

// FILE: MsPortalFx\Azure\Validators.d.ts
declare module MsPortalFx.Azure {
    import Fx = MsPortalFx;
    import FxCustomFormValidation = FxViewModels.CustomFormValidation;
    import FxViewModels = Fx.ViewModels;
    import FxValidation = FxViewModels.Validation;
    import ValidationResult = FxViewModels.ValidationResult;
    /**
     * The options returned by the required permissions callback.
     */
    interface RequiredPermissionsValidatorOptions {
        /**
         * The entity to check the permissions for (must be a resource id, a subscription id, or a
         * resource group id).
         */
        entityId: string;
        /**
         * The actions being to checked.
         */
        actions: string[];
        /**
         * Optional. The message that is shown to the user if the validation fails.
         */
        message?: string;
    }
    /**
     * The required permissions validator callback definition.
     * @param value The value from the control to be validated.
     * @return A promise resolved with the required permission validator options.
     */
    type RequiredPermissionsValidatorCallback = ((value: string) => Q.Promise<RequiredPermissionsValidatorOptions>);
    /**
     * The required permissions validator. Used to check if the current user has permissions to perform
     * a set of actions against an entity.
     */
    class RequiredPermissionsValidator extends FxValidation implements FxCustomFormValidation {
        /**
         * Function that returns whether the data is valid or not.
         */
        validate: (value: any) => Q.Promise<ValidationResult>;
        /**
         *  The message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
        /**
         * Constructs a required permissions validator.
         * @param callback The required permissions validator callback function. The function takes
         *                 the value to be validated as an input, and returns a promise resolved with
         *                 the required permission validator options as an output.
         */
        constructor(callback: RequiredPermissionsValidatorCallback);
    }
    /**
     * The reserved resource name validator. Used to check whether the specified name is permitted
     * for a given resource (validated against ARM).
     */
    class ReservedResourceNameValidator extends FxValidation implements FxCustomFormValidation {
        /**
         * Function that returns whether the data is valid or not.
         */
        validate: (value: any) => Q.Promise<ValidationResult>;
        /**
         *  The message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
        /**
         * Constructs a reserved resource name validator.
         * @param resourceType The resource type. Example "microsoft.resources/subscriptions/resourcegroups".
         * @param message The message that is shown to the user if the validation fails.
         * @param endpoint The ARM endpoint.
         */
        constructor(resourceType: string, message?: string, endpoint?: string);
    }
}

// FILE: MsPortalFx\BackCompat.d.ts

// FILE: MsPortalFx\Base\Base.Callbacks.d.ts
declare module MsPortalFx.Base {
    /**
     * The function that will be invoked when a callback is fired.
     */
    interface Callback<T> {
        (arg: T): void;
    }
    /**
     * Defines a collection of functions that can be invoked in order when an event occurs.
     */
    class Callbacks<T> {
        private _entries;
        private _names;
        /**
         * Constructs a callback list.
         */
        constructor();
        /**
         * Adds a callback to the collection.
         *
         * @param entry The callback to be added.
         * @param name Optional name of the callback (for use in removal).
         * @return The current instance.
         */
        add(entry: Callback<T>, name?: string): Callbacks<T>;
        /**
         * Removes a callback from the collection.
         *
         * @param entry The callback to be removed.
         * @return The current instance.
         */
        remove(entry: Callback<T>): Callbacks<T>;
        remove(entry: string): Callbacks<T>;
        /**
         * Clears all callbacks from the collection.
         *
         * @return The current instance.
         */
        clear(): Callbacks<T>;
        /**
         * Fires the callbacks in order with the given parameter.
         *
         * @return The current instance.
         */
        fire(arg: T): Callbacks<T>;
        private _init;
    }
}

// FILE: MsPortalFx\Base\Base.Constants.d.ts
declare module MsPortalFx.Base.Constants {
    /**
     * Shell/framework name.
     */
    const Shell = "fx";
    /**
     * Extension names for specialized extensions.
     */
    module ExtensionNames {
        /**
         * The name of the well-known hubs extension.
         */
        const Hubs = "HubsExtension";
        /**
         * The name of the billing extension.
         */
        const Billing = "Microsoft_Azure_Billing";
        /**
         * The name of the Azure expert extension.
         */
        const AzureExpert = "Microsoft_Azure_Expert";
        /**
         * The name of the Azure insights extension.
         */
        const AzureInsights = "Microsoft_Azure_Insights";
        /**
         * The name of the Azure monitoring extension.
         */
        const AzureMonitoring = "Microsoft_Azure_Monitoring";
        /**
         * The name of the Azure Active Directory extension.
         */
        const ActiveDirectory = "Microsoft_Azure_AD";
        /**
         * The name of the ClassicResources extension.
         */
        const ClassicResources = "Microsoft_Azure_ClassicResources";
        /**
         * The name of the Marketplace extension.
         */
        const Marketplace = "Microsoft_Azure_Marketplace";
        /**
         * The name of the Resources extension.
         */
        const Resources = "Microsoft_Azure_Resources";
        /**
         * The name of the Support extension.
         */
        const Support = "Microsoft_Azure_Support";
        /**
         * The name of the Websites extension.
         */
        const Websites = "WebsitesExtension";
    }
    /**
     * Asset type names for global asset types.
     */
    module AssetNames {
        /**
         * The resource groups asset type name.
         */
        const ResourceGroups = "ResourceGroups";
        /**
         * The browse "all" asset type name. This is the new ARG browse blade.
         */
        const BrowseAllBlade = "BrowseAll";
        /**
         * The browse resources asset type name. This is the new ARG browse blade.
         */
        const BrowseResourceBlade = "BrowseResource";
        /**
         * The browse resources asset type name. This is the new ARG browse blade.
         * This was an alias to the "Browse" blade that was deprecated.
         *
         * @deprecated Please use BrowseResourceBlade (which has the same value, one-to-one swap).
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const BrowseBlade = "BrowseResource";
        /**
         * The browse "all resources" asset type name.
         */
        const BrowseAllResources = "BrowseAllResources";
        /**
         * The browse "recent resources" asset type name.
         */
        const BrowseRecentResources = "BrowseRecentResources";
        /**
         * The browse "all" asset type name with a default type.
         */
        const BrowseAllBladeWithType = "BrowseAllWithType";
        /**
         * The browse resource groups asset type name.
         */
        const BrowseResourceGroupBlade = "BrowseResourceGroup";
        /**
         * The gallery asset type name.
         */
        const Gallery = "Gallery";
        /**
         * The store provided gallery asset type name.
         */
        const StoreGallery = "StoreGallery";
        /**
         * The deployments asset type name.
         */
        const Deployments = "Deployments";
        /**
         * The arm explorer asset type name.
         */
        const ArmExplorer = "ArmExplorer";
        /**
         * The whats new asset type name.
         */
        const WhatsNew = "WhatsNew";
        /**
         * The browse dynamic resource asset type name.
         */
        const BrowseDynamicResource = "BrowseDynamicResource";
        /**
         * The browse dynamic asset asset type name.
         */
        const BrowseDynamicAsset = "BrowseDynamicAsset";
        /**
         * The subscriptions asset type name.
         */
        const SubscriptionDetail = "Subscription";
        /**
         * The asset type name for a non-asset resource (resource fallback).
         */
        const NonAssetResource = "NonAssetResource";
    }
    /**
     * Resource type names for global resource types.
     */
    module ResourceTypes {
        /**
         * The subscriptions resource type name.
         */
        const Subscriptions = "Microsoft.Resources/subscriptions";
        /**
         * The resource groups resource type name.
         */
        const ResourceGroups = "Microsoft.Resources/subscriptions/resourcegroups";
        /**
         * The placeholder for all resources supported in the portal.
         */
        const AllResources = "Microsoft.Resources/resources";
        /**
         * The placeholder for recent resources supported in the portal.
         */
        const RecentResources = "Microsoft.Resources/recent";
    }
    /**
     * Part names for global parts.
     */
    module PartNames {
        /**
         * Part names for hubs extension parts.
         */
        module Hubs {
            /**
             * The browse resource pinned part which launches browse V2 for a particular resource type.
             */
            const BrowseResourcePinnedPart = "BrowseResourcePinnedPart";
            /**
             * The browse resource group pinned part which launches browse V2 for resource groups.
             */
            const BrowseResourceGroupPinnedPart = "BrowseResourceGroupPinnedPart";
        }
    }
    /**
     * Blade names for global parts.
     */
    module BladeNames {
        /**
         * Blades names for Billing.
         */
        module Billing {
            /**
             * The create subscriptions blade.
             */
            const SubscriptionsBlade = "SubscriptionsBlade";
        }
        /**
         * Blades names for hubs.
         */
        module Hubs {
            /**
             * The create hub blade.
             */
            const CreateHubBlade = "PlusNewBlade";
            /**
             * The browse link blade.
             */
            const BrowseLinkBlade = "BrowseLinkBlade";
            /**
             * The browse resource blade.
             */
            const BrowseResourceBlade = "BrowseResourceBlade";
            /**
             * The browse all resources blade.
             */
            const BrowseAllResourcesBlade = "BrowseAllResourcesBlade";
            /**
             * The browse resource group blade.
             */
            const BrowseResourceGroupBlade = "BrowseResourceGroupBlade";
            /**
             * The browse recent resources blade.
             */
            const BrowseRecentResourcesBlade = "BrowseRecentResourcesBlade";
            /**
             * The asset menu blade.
             */
            const AssetMenuBlade = "AssetMenuBlade";
            /**
             * The unauthorized asset blade.
             */
            const UnauthorizedAssetBlade = "UnauthorizedAssetBlade";
            /**
             * The not found asset blade.
             */
            const NotFoundAssetBlade = "NotFoundAssetBlade";
            /**
             * The unavailable asset blade.
             */
            const UnavailableAssetBlade = "UnavailableAssetBlade";
            /**
             * The resource menu blade.
             */
            const ResourceMenuBlade = "ResourceMenuBlade";
            /**
             * The resource properties blade.
             */
            const ResourceProperties = "ResourceProperties";
            /**
             * The resource group blade.
             */
            const ResourceGroupMapBlade = "ResourceGroupMapBlade";
        }
        /**
         * Blades names for Marketplace.
         */
        module Marketplace {
            /**
             * The create hub blade.
             */
            const GalleryFeaturedMenuItemBlade = "GalleryFeaturedMenuItemBlade";
            /**
             * The create results blade.
             */
            const GalleryResultsListBlade = "GalleryResultsListBlade";
            /**
             * The name of version 2 of the legal terms blade.
             */
            const LegalTermsV2Blade = "PCLegalTermsV2Blade";
        }
    }
    /**
     * Telemetry common constants.
     */
    module Telemetry {
        /**
         * Feature adoption telemetry source.
         */
        const FeatureAdoption = "FeatureAdoption";
        /**
         * Feature obsolete telemetry source.
         */
        const FeatureObsolete = "FeatureObsolete";
    }
    module TelemetrySharing {
        /**
         * Register an extension to receive shell telemetry.
         */
        const RegisterExtension = "TelemetrySharing.registerExtension";
        /**
         * Receives shell telemetry.
         */
        const TraceTelemetry = "TelemetrySharing.traceTelemetry";
    }
    /**
     * Gallery Menu item types.
     */
    module GalleryMenuItems {
        /**
         * Home (everything) menu item id.
         */
        const HomeMenuItem = "home";
    }
    module BladeParameterNames {
        /**
         * Blade input used to identify the edit scope.
         */
        const EditScopeId = "editScopeId";
        /**
         * Optional blade input containing additional config from the component which opened the blade.
         */
        const ReferrerInfo = "referrerInfo";
    }
}

// FILE: MsPortalFx\Base\Base.Debouncer.d.ts
declare module MsPortalFx.Base {
    import FxBase = MsPortalFx.Base;
    /**
     * If you need to implement DebouncerDataMerger, you need to handle both T|T[].
     * default is to use MsPortalFx.merge which call array.prototype.concat to do things correctly.
     */
    interface DebouncerDataMerger<T> {
        (oldData: T | T[], newData: T | T[]): T[];
    }
    interface DebouncerExecutor<T> {
        (data: T[] | string): FxBase.Promise;
    }
    interface DebouncerOptions {
        /**
         * The time period after which each batch of optional data should be processed.
         */
        optionalDataInterval?: number;
        /**
         * The maximum batch size suported by the execution method. It combines both required data and optional data.
         */
        maxBatchSize?: number;
        /**
         * Optional. Returns whether the items should be flushed immediately.
         * This can be used for example if the size of the payload can be proactively calculated / estimated, then if it's above a certain
         * threshold, it can be flushed right away if it's approach the request's max size.
         */
        shouldFlush?: (data: unknown[], optionalData: unknown[]) => boolean;
    }
    interface DebouncerPostOptions {
        uri: string;
        headers?: StringMap<string>;
        isBackgroundTask?: boolean;
        performRetry?: boolean;
        setAuthHeader?: boolean;
        skipTelemetry?: boolean;
    }
    interface IDebouncer<T> {
        execute: (data: T[], optionalData?: boolean) => void;
        flush: () => Q.Promise<void>;
    }
    /**
     * Allows multiple async-operations to be sequenced and batched, while processing only one batch at a time.
     */
    class Debouncer<T> implements IDebouncer<T> {
        /**
         * Returns a function that can be used to merge two sets of data in the debouncer into an array.
         * New data is appended to existing data to return a new array.
         *
         * @return A DebouncerDataMerger function.
         */
        static getMergeIntoArrayDataMerger(): DebouncerDataMerger<any>;
        /**
         * Returns a function that can be used to merge two sets of data in the debouncer into an array.
         * New data is appended to existing data to return a new array.
         *
         * @param uri The URI where the data is to be posted.
         * @param isBackgroundTask Specifies if the deboncer should make background calls.
         * @return A DebouncerExecutor function.
         */
        static getPostArrayExecutor(options: DebouncerPostOptions): DebouncerExecutor<any>;
        /**
         * Updates the data in the queue.
         */
        execute: (data: T[], optionalData?: boolean) => void;
        /**
         * Resolves all tasks in the queue.
         *
         * @return The promise of the last task in the queue.
         */
        flush: () => Q.Promise<void>;
        /**
         * Initializes a new instance of the Debouncer class.
         *
         * @param mergeFunc A function that is invoked to merge two batches of data.
         * This function is invoked when a second batch comes in before the first has been dispatched.
         * It is also invoked when there is an error processing the first batch and a second one is enqueued.
         * This allows the first batch to be piggy-backed with the second.
         * @param executor The function that processes a batch of data.
         * @param interval The time period after which each batch should be processed.
         * @param resetTimerOnUpdate True if it resets timer of calling the update method.
         * @param options Options.
         */
        constructor(mergeFunc: DebouncerDataMerger<T>, executor: DebouncerExecutor<T>, interval?: number, resetTimerOnUpdate?: boolean, options?: DebouncerOptions);
    }
}
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    /** Options for the standard debouncer */
    interface StandardDebouncerOptions {
        /** The uri for uploading data. */
        uri: string;
        /** When true, skip the telemetry for the network call. */
        skipTelemetry?: boolean;
        /** The name of the extension uploading its events */
        extensionName?: string;
        /** The time period after which each batch should be processed. */
        interval?: number;
        /** The maximum number of items in batch before it gets processed. */
        maxBatchSize?: number;
        /** Whether to retry on failure */
        performRetry?: boolean;
        /** When true, sanitizes the data after serializing it. */
        sanitizeData?: boolean;
    }
    /**
     * Returns an instance of the Standard Debouncer.
     * @param options for configuring the standard debouncer.
     */
    function getStandardDebouncer<T>(options: StandardDebouncerOptions): FxBase.IDebouncer<T>;
    /**
     * Returns the standard FX HTTP request headers to be used in any upload.
     * @param extensionName The name of the extension for which the upload is being done.
     * @param extensionVersion The version of the extension.  Defaults to the 'version' value from the environment if not supplied.
     * @return The HTTP request headers.
     */
    function getStandardHeaders(extensionName: string, extensionVersion?: string): ReadonlyStringMap<string>;
}

// FILE: MsPortalFx\Base\Base.Diagnostics.d.ts
declare module MsPortalFx {
    /**
     * Stringifies the specified message.
     */
    function getLogFriendlyMessage(message: any): string;
    function sanitizeMessage(text: string): string;
    module Base.Diagnostics {
        /**
         * Trace level.
         */
        const enum LogEntryLevel {
            /**
             * Custom events.
             */
            Custom = -2,
            /**
             * Debug level.
             */
            Debug = -1,
            /**
             * Verbose level.
             */
            Verbose = 0,
            /**
             * Warning level.
             */
            Warning = 1,
            /**
             * Error level.
             */
            Error = 2
        }
        /**
         * Schema of a log entry.
         */
        interface LogEntry {
            /**
             * Timestamp
             */
            readonly timestamp: number;
            /**
             * Level
             */
            readonly level: LogEntryLevel;
            /**
             * Portal, etc
             */
            readonly area: string;
            /**
             * The message to be logged.
             */
            readonly message: string;
            /**
             * The message code.
             */
            readonly code: number;
            /**
             * Any additional data to be logged.
             */
            readonly args?: ReadonlyArray<any>;
        }
        interface LogBufferFullCallback {
            (entries: LogEntry[]): LogEntry[];
        }
        type LogMessage = string | Error | MsPortalFx.Helpers.JQueryXHRLike<any>;
        interface WriteEntryHelperFunc {
            (level: LogEntryLevel, area: string, entryType: string, message: LogMessage, code: number, restArgs: any[]): void;
        }
        function setWriter(func?: WriteEntryHelperFunc): WriteEntryHelperFunc;
        /**
         * This method registers callbacks to be invoked when errors are logged.
         * This is intended to be used for monitoring purposes only.
         *
         * @param errorCallback Appends a callback to be invoked when a error is logged to the console
         * @param warningCallback Appends a callback to be invoked when a working is logged to the console
         */
        function setupErrorDetection(errorCallback: (entry: LogEntry) => void, warningCallback: (entry: LogEntry) => void): void;
        /**
         * This type defines the shape of the callback method. Parameters are
         * per Base.Diagnostics.Log.error(), the default method that is used.
         */
        type LogFunc = (entry: LogMessage, code?: number, ...restArgs: any[]) => void;
        /**
         * Logging facilities.
         */
        class Log {
            private readonly _area;
            private readonly _type;
            /**
             * Set this value to true if you want failed assertions to break in the debugger.
             */
            debugBreak: boolean;
            /**
             * Creates the logger instance.
             *
             * @param logArea The name of the information area.
             */
            constructor(logArea: string);
            /**
             * Logs event.
             *
             * @param level Information level type.
             * @param area Name of information area.
             * @param message Information that is to be logged.
             * @param restArgs Any other parameters that should be captured.
             */
            static writeEntry(level: LogEntryLevel, area: string, message: LogMessage, ...restArgs: any[]): void;
            /**
             * Logs event.
             *
             * @param level Information level type.
             * @param area Name of information area.
             * @param message Information that is to be logged.
             * @param code The message code.
             * @param restArgs Any other parameters that should be captured.
             */
            static writeEntry2(level: LogEntryLevel, area: string, message: LogMessage, code: number, restArgs?: any[]): void;
            /**
             * Gets the logged entries buffer.
             *
             * @param level The level of entries to return. All entries greater than or equal to this level will be returned.
             * @return An array of log entries.
             */
            static getEntries: (level: LogEntryLevel) => LogEntry[];
            /**
             * Clears the log buffer.
             */
            static clear: () => void;
            /**
             * Flushes the buffer and calls _setBufferFullCallback.
             */
            static flush: () => void;
            /**
             * Specify logging level of messages to console and remotely.
             *
             * @param consoleLevel The level which is to be enabled for the console. If not specified, all levels are enabled.
             * @param remoteLevel The level which is to be enabled for remote logging. If not specified, it will be the same as the console level.
             */
            static initialize(consoleLevel?: LogEntryLevel, remoteLevel?: LogEntryLevel): void;
            /**
             * Disables the log.
             */
            static disable(): void;
            /**
             * Log verbose information.
             *
             * @param entry The message to log.
             * @param restArgs[] Extra information to log with the message.
             */
            verbose(entry: string, ...restArgs: any[]): void;
            /**
             * Log warning information.
             *
             * @param entry The message to log.
             * @param code The message code.
             * @param restArgs[] Extra information to log with the message.
             */
            warning(entry: LogMessage, code?: number, ...restArgs: any[]): void;
            /**
             * Log error information.
             *
             * @param entry The message to log.
             * @param code The message code.
             * @param restArgs[] Extra information to log with the message.
             */
            error(entry: LogMessage, code?: number, ...restArgs: any[]): void;
            /**
             * Log debug information.
             *
             * @param entry The message to log.
             * @param restArgs[] Extra information to log with the message.
             */
            debug(entry: LogMessage, ...restArgs: any[]): void;
            /**
             * Log custom information.
             *
             * @param entry The message to log.
             * @param code The message code.
             * @param restArgs[] Extra information to log with the message.
             */
            custom(entry: string, code?: number, ...restArgs: any[]): void;
            /**
             * Asserts in debug mode.
             *
             * @param assertion A boolean value or a function that returns a boolean value.
             * @param entry The message to log if the assertion is falsy.
             * @param code The message code.
             * @param arg Extra information to log with the message.
             */
            assert(assertion: boolean | Func<boolean>, entry: string, code?: number, arg?: any): void;
            /**
             * Log information.
             *
             * @param level Information level type.
             * @param entry The message to log.
             * @param code The message code.
             * @param args[] Extra information to log with the message.
             */
            writeEntry(level: LogEntryLevel, entry: LogMessage, code: number, args: any[]): void;
            static _setBufferFullCallback: (callback?: LogBufferFullCallback) => void;
        }
        module Internal {
            /**
             * For tests only.
             */
            interface TestParameters {
                maxBufferSize: number;
                verboseDiagnostics: boolean;
            }
            var _testParameters: (parameters?: TestParameters) => TestParameters;
        }
    }
}

// FILE: MsPortalFx\Base\Base.Diagnostics.ErrorReporter.d.ts
declare module FxImpl {
    module Boot {
        const enum MessageKind {
            Initialize = 3,
            UnhandledError = 4,
            ScriptError = 6
        }
    }
}
declare module MsPortalFx.Base.Diagnostics {
    import FxErrors = MsPortalFx.Errors;
    import FxError = FxErrors.Error;
    /**
     * Creates an instance of the logger.
     *
     * @param localRequire The require variable injected in an AMD module. This is defined by TypeScript.
     * If not using AMD, use the Log class constructor to create a log instance directly.
     * @return The Log instance to use for logging.
     */
    function createLog(localRequire: LocalRequire): Log;
    /**
     * Helper function to create Error object to ignore unhandled promise rejection will only log as warning instead of error in the current Frame
     * Note that if this exception throw across the RPC, the other side will still log as Error. Thus will reflect to ErrorTracker.
     * @param message Error object message
     * @param stack Optional stack, if not provided, current stack will be used.
     *
     * @returns Error object
     */
    function createIgnoreUnhandledRejectionError(error: FxError, data?: StringMap<any>): FxError;
    function createIgnoreUnhandledRejectionError(message: string, stack?: string, data?: StringMap<any>): FxError;
    /**
     * Sets the promise error capture period.
     * @param value The period in milliseconds.
     *
     * @returns The previous period.
     */
    function setPromiseErrorCapturePeriod(value?: number): number;
    /**
     * Exported for testing only.
     */
    function clearPromiseErrorCaptureTimeout(): void;
    module ErrorReporter {
        let lastError: Error;
        /**
         * Initializes the error handler
         * @param postLogCallback Function to run after error is logged.
         * @param resetCounter Boolean to reset the special message counter..
         */
        function initialize(postLogCallback?: () => void, forTest?: boolean, additionalInfoCallback?: () => any): void;
        /**
         * Logs the error
         */
        function handleError(evt: ErrorEvent): void;
    }
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Telemetry.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry {
    /**
     * A start telemetry event to be sent to the server.
     */
    interface StartTelemetryEvent {
        /**
         * The timestamp of the event. Automatically filled in by the framework.
         */
        timestamp?: number;
        /**
         * The extension that is logging the event. Automatically filled in by the framework.
         */
        extension?: string;
        /**
         * The source of the telemetry data e.g. navigation, blade.
         */
        source: string;
        /**
         * The action being recorded.
         */
        action: string;
        /**
         * A modifier for the action.
         */
        actionModifier?: string;
        /**
         * The asset type for the telemetry data (optional).
         */
        assetType?: string;
        /**
         * The elapsed time in milliseconds for the event being recorded (optional).
         */
        duration?: number;
        /**
         * A name associated with the event or item that was the target of the event (optional).
         */
        name?: string;
        /**
         * Any additional context.  Automatically added by the framework.
         */
        context?: any;
        /**
         * Whether or not this event should be considered optional. Defaults to false.
         */
        optional?: boolean;
        journeyId?: string;
        /**
         * The service tree id, currently it is logged for consumption by SLO (optional)
         */
        serviceTreeId?: string;
    }
    /**
     * A telemetry event to be sent to the server.
     */
    interface TelemetryEvent extends StartTelemetryEvent {
        /**
         * Any additional information for the event being recorded (optional).
         */
        data?: any;
    }
    /**
     * Trace processor interface for pluggable telemetry service.
     */
    interface TelemetryEventProcessor {
        /**
         * Sends a telemetry data event to the data store.
         */
        trace(evt: TelemetryEvent): void;
        /**
         * Flushes all current telemetry events.
         */
        flush(): Q.Promise<unknown>;
    }
    /**
     * List of constants to be used for Telemetry data points.
     */
    module ActionModifier {
        const Start = "start";
        const Complete = "complete";
        const Reset = "reset";
        const Cancel = "cancel";
        const Mark = "mark";
    }
    module Internal {
        /**
         * Initializes the telemetry system with the built-in event processor.
         *
         * @param extensionName The name of the current extension.
         * @param processors The trace processors to use. The default processors are used if none is specified.
         * @return The previous processor or processors, if any existed.
         */
        function initialize(extensionName: string, processors?: TelemetryEventProcessor[]): TelemetryEventProcessor[];
    }
    /**
     * Initializes the telemetry system with the built-in event processor.
     *
     * @param extensionName The name of the current extension.
     * @return The previous processor or processors, if any existed.
     */
    function initialize(extensionName: string): TelemetryEventProcessor[];
    /**
     * Registers an extension to receive shell telemetry.  Extensions can either specify a custom TelemetryEventProcessor
     * or use the current telemetry configuration.
     *
     * @param processor The optional processor to use when receiving telemetry.
     */
    function registerForShellTelemetry(processor?: TelemetryEventProcessor): void;
    /**
     * Records a telemetry event.
     *
     * @param evt The telemetry event.
     */
    function trace(evt: TelemetryEvent): void;
    /**
     * Starts a timed telemetry data event but does not record it.
     * The end/complete/cancel trace methods will still be logged.
     * This is preferred over startTrace since it has less impact
     * on the network.
     * @param evt The telemetry event.
     */
    function start(evt: StartTelemetryEvent): string;
    /**
     * Starts a timed telemetry data event.
     *
     * @param evt The telemetry event.
     */
    function startTrace(evt: TelemetryEvent): string;
    /**
     * Cancels a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function cancelTrace(key: string, data?: any): number;
    /**
     * Completes a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function completeTrace(key: string, data?: any): number;
    /**
     * Ends a timed telemetry data event with a provided action modifier.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param actionModifier One of the action modifiers of the event.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function endTrace(key: string, actionModifier: string | boolean, data?: any): number;
    /**
     * Resets the stopwatch for a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     */
    function resetTrace(key: string): void;
    /**
     * Flushes all current telemetry events.
     */
    function flush(): Q.Promise<unknown>;
    function addProcessor(processor: TelemetryEventProcessor): void;
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Telemetry.Context.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry.Context {
    /**
     * Base class for providing ambient context information.
     */
    interface ContextValue {
        /**
         * User defined identifier to correlate logical activities through async and component boundaries.
         */
        id: string;
    }
    interface CompositionContext extends ContextValue {
        instanceId: string;
    }
    interface PartContext extends CompositionContext {
        bladeId: string;
        bladeInstanceId: string;
        onBlade: boolean;
        onStartBoard: boolean;
        bladeCustomized: boolean;
    }
    const getPartContext: Func<PartContext>;
    const getBladeContext: Func<CompositionContext>;
    const getJourneyContext: () => ContextValue;
    const getCompositionItemContext: Func<ContextValue>;
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Telemetry.Helpers.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * Adds a watcher to the activated items of the given selectable data and calls the appropriate callbacks.
     *
     * @param lifetimeManager The lifetime manager for the watcher.
     * @param selectableData The selectable data that we are going to watch.
     * @param selectionActivated The callback called when a selection is activated.
     * @param selectionDeactivated The callback called when a selection is deactivated.
     */
    function addActivatedItemsWatcher<T, U>(lifetimeManager: FxBase.LifetimeManager, selectableData: FxViewModels.SelectableSet<T, U>, selectionActivated: (selection: U) => void, selectionDeactivated?: (selection: U) => void): void;
    /**
     * Adds a telemetry trace watcher to the activated items of the given selectable data and traces with the
     * appropriate source action. This takes a callback to prepare the base properties which are then merged into
     * the result telemetry event to be traced.
     *
     * @param lifetimeManager The lifetime manager for the watcher.
     * @param selectableData The selectable data that we are going to watch.
     * @param source The source for the telemetry trace.
     * @param activatedAction The action for the telemetry trace when a selection is activated.
     * @param deactivatedAction The action for the telemetry trace when a selection is deactivated.
     * @param prepareTelemetryBase Callback used internally to prepare the base properties for the telemetry trace.
     */
    function addActivatedItemsTelemetryWatcher<T, U>(lifetimeManager: FxBase.LifetimeManager, selectableData: FxViewModels.SelectableSet<T, U>, source: string, activatedAction: string, deactivatedAction: string, prepareTelemetryBase: (selection: U) => ActivatedItemsTelemetryBase): void;
    interface ActivatedItemsTelemetryBase {
        /**
         * The extension that is logging the event. Automatically filled in by the framework.
         */
        extension?: string;
        /**
         * The asset type for the telemetry data (optional).
         */
        assetType?: string;
        /**
         * Any additional context information for the event being recorded (optional).
         */
        data?: any;
    }
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Upload.d.ts
declare module MsPortalFx.Base.Diagnostics.Upload {
    /**
     * Initializes the uploading of client traces.
     * The traces are posted periodically to the specified server URI.
     * If a null or empty URI is specified the upload is skipped.
     * and the traces are just discarded.
     *
     * @param uploadUri The URI where the buffered messages will be posted.
     */
    function initialize(uploadUri?: string): void;
    function upload(): void;
    /**
     * Immediately execute outstanding data.
     */
    function flush(): MsPortalFx.Base.Promise;
}

// FILE: MsPortalFx\Base\Base.Disposable.d.ts
declare module FxImpl {
    /**
     * An object that tracks and invokes disposal callbacks. This can be used
     * in other classes that wish to implement LifetimeManager.
     */
    class TriggerableLifetimeManager implements MsPortalFx.Base.DisposableLifetimeManager {
        private _disposables;
        private _isDisposed;
        private _isDisposing;
        private _container;
        private _children;
        private _failToDispose;
        private _createStack;
        private _disposeStack;
        constructor();
        /**
         * Gets a value indicating whether or not the lifetime is disposed.
         */
        isDisposed(): boolean;
        registerForDispose: MsPortalFx.Base.RegisterForDisposeFunction;
        createChildLifetime(): MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Causes the instance to regard itself as disposed, and to trigger any
         * callbacks that were already registered.
         */
        dispose(): void;
        _unregisterChildForDispose(disposable: MsPortalFx.Base.Disposable): void;
        _isRegistered(disposable: MsPortalFx.Base.Disposable): boolean;
        _registerForDispose(disposable: MsPortalFx.Base.Disposable): void;
    }
}

// FILE: MsPortalFx\Base\Base.Factory.d.ts
declare module MsPortalFx.Base {
    /**
     * The interface of generic factory class, without any arguments in the creation method.
     *
     * Example: if it is needed to new up an instance of a certain class during the execution of a method,
     * the recommended approach is to inject the factory instance in the constructor,
     * and use the factory to create the instance of interest, in order to achieve the loose coupling
     * with the concrete implementation of the instance of interest.
     * Ref: http://msdn.microsoft.com/en-us/library/ee817667.aspx
     */
    interface ObjectFactory<TProduct> {
        /**
         * Create a product.
         *
         * @return The instance of the product of the specified type.
         */
        create(): TProduct;
    }
    /**
     * The interface of generic factory class, with arguments in the creation method.
     */
    interface ParameterObjectFactory<TProduct, TParam> {
        /**
         * Create a product.
         *
         * @param param The arguments provided for the creation of the product.
         * @return The instance of the product of the specified type.
         */
        create(param: TParam): TProduct;
    }
}

// FILE: MsPortalFx\Base\Base.Helpers.d.ts
declare module MsPortalFx.Base.Net2 {
    /**
     * Internal.
     */
    interface JQueryPromiseXhr<T> {
        catch(catchCallback: (reason?: any) => any): JQueryPromiseXhr<T>;
        finally(finallyCallback: () => any): JQueryPromiseXhr<T>;
    }
}
declare module MsPortalFx.Helpers {
    interface XMLHttpRequestLike {
        getResponseHeader(header: string): string;
        getAllResponseHeaders(): string;
        readyState: number;
        status: number;
        statusText: string;
        responseText?: string;
    }
    function isXMLHttpRequestLike(jqXHR: any): boolean;
    interface JQueryXHRLike<T> extends XMLHttpRequestLike {
        always(alwaysCallback: () => void): void;
        state(): string;
        then(doneCallbacks: (data: T, textStatus: string, jqXHR: JQueryXHRLike<T>) => void, failCallbacks?: (jqXHR: JQueryXHRLike<T>, textStatus: string, errorThrown: any) => void, progressCallbacks?: () => void): void;
    }
    let ajax: <T>(settings: JQueryAjaxSettings<T>) => JQueryXHRLike<T>;
    const selector: JQueryStatic;
    const Callbacks: {
        (flags?: string): JQueryCallback;
        <T>(flags?: string): JQueryCallback1<T>;
        <T1, T2>(flags?: string): JQueryCallback2<T1, T2>;
        <T1_1, T2_1, T3>(flags?: string): JQueryCallback3<T1_1, T2_1, T3>;
        <T1_2, T2_2, T3_1, T4>(flags?: string): JQueryCallback4<T1_2, T2_2, T3_1, T4>;
        (flags?: string): JQueryCallback;
        <T_1>(flags?: string): JQueryCallback1<T_1>;
        <T1_3, T2_3>(flags?: string): JQueryCallback2<T1_3, T2_3>;
        <T1_4, T2_4, T3_2>(flags?: string): JQueryCallback3<T1_4, T2_4, T3_2>;
        <T1_5, T2_5, T3_3, T4_1>(flags?: string): JQueryCallback4<T1_5, T2_5, T3_3, T4_1>;
    };
    const Deferred: {
        (fn?: (d: JQueryDeferred<never, never, never>) => void): JQueryDeferred<never, never, never>;
        <TDeferred extends _JQueryDeferred = JQueryDeferred<never, never, never>>(fn?: (d: TDeferred) => void): TDeferred;
        new (fn?: (d: JQueryDeferred<never, never, never>) => void): JQueryDeferred<never, never, never>;
        new <TDeferred_1 extends _JQueryDeferred = JQueryDeferred<never, never, never>>(fn?: (d: TDeferred_1) => void): TDeferred_1;
    };
    /**
     * Returns a promise that is resolved wiht an optional value.
     *
     * @param value Optional value to resolve with.
     * @return A resolved promise.
     */
    function resolve<TValue>(value: TValue): JQueryPromiseV<TValue>;
    function resolve(): JQueryPromise;
    /**
     * Returns a promise that is rejected with an optional reason.
     *
     * @param reason Optional reason to reject with.
     * @return A rejected promise.
     */
    function reject<TReject>(reason: TReject): JQueryPromiseR<TReject>;
    function reject(): JQueryPromise;
}

// FILE: MsPortalFx\Base\Base.Image.d.ts
declare module MsPortalFx.Base {
    /**
     * Data type used for rendering images's.
     */
    interface Image {
        /**
         * Stores the type of image (custom SVG/image or a built in SVG).
         */
        readonly type: number;
        /**
         * Stores the SVG element, or URI to image file.
         */
        readonly data?: string;
        /**
         * Stores the palette of the element.
         */
        readonly palette?: number;
        /**
         * Stores the options of the element.
         */
        readonly options?: ImageOptions;
    }
    interface ImageOptions {
        /**
         * Stores the palette of the element.
         */
        palette?: number;
        /**
         * Title attribute of the svg.
         */
        title?: string;
        /**
         * Description of the svg.
         */
        description?: string;
        /**
         * Badge
         */
        badge?: MsPortalFx.Base.ImageBadge;
        /**
         * Adds a single custom class, must start with msportalfx or the extension prefix for CSS: "ext-".
         */
        customClass?: string;
    }
    /**
     * Data type used for rendering a images's badge.
     */
    interface ImageBadge {
        /**
         * Badge icon.
         */
        image: MsPortalFx.Base.Image;
        /**
         * Override the default width, must be in a percentage ie (width: 10).
         */
        width?: number;
    }
    const enum ImagePalette {
        None = 0,
        White = 1,
        Black = 2,
        Blue = 3,
        Green = 4,
        Gray = 5,
        Inherit = 99,
        Disabled = 100
    }
}

// FILE: MsPortalFx\Base\Base.Images.d.ts
declare module MsPortalFx.Base.Images {
    import FxBase = MsPortalFx.Base;
    import ImageOptions = FxBase.ImageOptions;
    import FxBaseImages = MsPortalFx.Base.Images;
    type ImageFunc = (options?: ImageOptions | number) => Image;
    function CustomImageWithBadge(customImage: FxBase.Image, badge: FxBase.ImageBadge): Image;
    function CustomImageWithOptions(customImage: FxBase.Image, options: ImageOptions): Image;
    /**
     * Generates a properly formatted image datatype from a image's URI.
     * For use with the 'image' custom data-binding & custom png/jpeg/gifs/etc.
     *
     * @param URI to image resource.
     * @return properly formatted image datatype for consumtion by the 'image' data-binding.
     */
    function ImageUri(uri: string): Image;
    /**
     * Generates a circle svg with the provided number inside.
     * Supports values 0 - 99.
     *
     * @param value to display in the SVG.
     * @return circular svg with a number sized to fit inside..
     */
    function Number(value: number, options?: ImageOptions): Image;
    const Add: ImageFunc;
    /** @deprecated Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const AddAlternate: Obsolete;
    /** @deprecated Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const AddBoxed: Obsolete;
    const AddTeamMember: ImageFunc;
    const AddTile: ImageFunc;
    const Alert: ImageFunc;
    const AllServices: ImageFunc;
    const ArrowDown: ImageFunc;
    const ArrowLeft: ImageFunc;
    const ArrowRight: ImageFunc;
    const ArrowUp: ImageFunc;
    const Attachment: ImageFunc;
    const AvatarDefault: ImageFunc;
    const AvatarUnknown: ImageFunc;
    const AzurePortal: ImageFunc;
    const AzureQuickstart: ImageFunc;
    const Backlog: ImageFunc;
    const Blank: ImageFunc;
    const Book: ImageFunc;
    const Canceled: ImageFunc;
    const Capture: ImageFunc;
    const CaretDown: ImageFunc;
    const CaretUp: ImageFunc;
    const Check: ImageFunc;
    const Clock: ImageFunc;
    /** @deprecated Use Images.Copy instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Clone: Obsolete;
    const CloudUpload: ImageFunc;
    const Code: ImageFunc;
    const Collapse: ImageFunc;
    const Columns: ImageFunc;
    const Commit: ImageFunc;
    /** @deprecated Use Images.Commit instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Commits: Obsolete;
    const Connect: ImageFunc;
    const Console: ImageFunc;
    const Copy: ImageFunc;
    const Customize: ImageFunc;
    const Delete: ImageFunc;
    const Diagnostics: ImageFunc;
    const DirectoryFilter: ImageFunc;
    const DirectoryFilteredSet: ImageFunc;
    const Disable: ImageFunc;
    /** @deprecated Use Images.Disable instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Disabled: Obsolete;
    const Discard: ImageFunc;
    const Disconnect: ImageFunc;
    const DoubleChevron: ImageFunc;
    const Download: ImageFunc;
    const Edit: ImageFunc;
    /** @deprecated Use Images.Edit instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const EditInverted: Obsolete;
    const Ellipsis: ImageFunc;
    const Error: ImageFunc;
    const Expand: ImageFunc;
    const Favorite: ImageFunc;
    const Feedback: ImageFunc;
    const File: ImageFunc;
    const Filter: ImageFunc;
    const FilterRemove: ImageFunc;
    const FolderAlternate: ImageFunc;
    /** @deprecated Use Images.Disable instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const ForPlacementOnly: Obsolete;
    const Gear: ImageFunc;
    /** @deprecated Use Images.Gear instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const GearAlternate: Obsolete;
    const GetMoreLicense: ImageFunc;
    const GetStarted: ImageFunc;
    const Globe: ImageFunc;
    const Go: ImageFunc;
    const Guide: ImageFunc;
    const Hamburger: ImageFunc;
    const HeartPulse: ImageFunc;
    const Help: ImageFunc;
    const HideItems: ImageFunc;
    const History: ImageFunc;
    const Hyperlink: ImageFunc;
    const Inactive: ImageFunc;
    const Info: ImageFunc;
    const Insert: ImageFunc;
    /** @deprecated Use Images.Download instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const InstallVisualStudio: Obsolete;
    const Key: ImageFunc;
    const LaunchCurrent: ImageFunc;
    const Line: ImageFunc;
    const Link: ImageFunc;
    const Lock: ImageFunc;
    const Log: ImageFunc;
    const Mail: ImageFunc;
    const Message: ImageFunc;
    const Monitoring: ImageFunc;
    const Move: ImageFunc;
    /** @deprecated Use Images.Polychromatic.NotificationBell instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const NotificationBell: Obsolete;
    const Notifications: ImageFunc;
    /** @deprecated Use Images.Error instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const NumberError: Obsolete;
    /** @deprecated Use Images.Check instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const NumberSuccess: Obsolete;
    const Paused: ImageFunc;
    const Pending: ImageFunc;
    const Person: ImageFunc;
    const PersonWithFriend: ImageFunc;
    const Pin: ImageFunc;
    /** @deprecated Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Plus: Obsolete;
    const Postpone: ImageFunc;
    const PowerUp: ImageFunc;
    const Properties: ImageFunc;
    const Publish: ImageFunc;
    const Query: ImageFunc;
    const Question: ImageFunc;
    const Queued: ImageFunc;
    /** @deprecated Use Images.AzureQuickstart instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const QuickStart: Obsolete;
    const Redo: ImageFunc;
    const Refresh: ImageFunc;
    const Reimage: ImageFunc;
    const Release: ImageFunc;
    const Request: ImageFunc;
    const ResourceFlat: ImageFunc;
    const Retain: ImageFunc;
    const Save: ImageFunc;
    const SaveAll: ImageFunc;
    const Search: ImageFunc;
    /** @deprecated Use Images.Gear instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Settings: Obsolete;
    const ShowItems: ImageFunc;
    const Signout: ImageFunc;
    const SmileyHappy: ImageFunc;
    const SmileyNeutral: ImageFunc;
    const SmileySad: ImageFunc;
    const Star: ImageFunc;
    const Start: ImageFunc;
    const StatusUpsell: ImageFunc;
    const Stop: ImageFunc;
    const Subtract: ImageFunc;
    const Support: ImageFunc;
    const Swap: ImageFunc;
    /** @deprecated Use Images.Tags instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Tag: Obsolete;
    const Tags: ImageFunc;
    const Tasks: ImageFunc;
    const Tools: ImageFunc;
    /** @deprecated Use Images.Info instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Tour: Obsolete;
    const TrendDown: ImageFunc;
    const TrendUp: ImageFunc;
    const Triangle: ImageFunc;
    const Undo: ImageFunc;
    const Unlock: ImageFunc;
    const Unpin: ImageFunc;
    const Upload: ImageFunc;
    const Variables: ImageFunc;
    const View: ImageFunc;
    const Warning: ImageFunc;
    const WebHostingPlan: ImageFunc;
    const Wrench: ImageFunc;
    const Chevron: ImageFunc;
    const Close: ImageFunc;
    const ShellCustomize: ImageFunc;
    const Dots: ImageFunc;
    const ExitPeekMode: ImageFunc;
    const Fullscreen: ImageFunc;
    const ShellGear: ImageFunc;
    const HeaderDots: ImageFunc;
    const Maximize: ImageFunc;
    const Mini: ImageFunc;
    const Minimize: ImageFunc;
    const PeekMode: ImageFunc;
    const Restore: ImageFunc;
    const Share: ImageFunc;
    const Trash: ImageFunc;
    const TrashOutline: ImageFunc;
    const TripleArrow: ImageFunc;
    /** @deprecated Use Images.Logos.Git instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const GitLogo: Obsolete;
    /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
    const GitLogoBox: Obsolete;
    /** @deprecated Use Images.Logos.VisualStudio instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const VisualStudio: Obsolete;
    /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
    const VisualStudioLogoBox: Obsolete;
    /**
     * Logos icons.
     */
    module Logos {
        const Bitbucket: ImageFunc;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const BitbucketBox: Obsolete;
        const Channel9: ImageFunc;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CodePlex: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CodePlexBox: Obsolete;
        const Dropbox: ImageFunc;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DropboxBox: Obsolete;
        const ExternalRepositoryBox: ImageFunc;
        const Git: ImageFunc;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const GitBox: Obsolete;
        const GitHub: ImageFunc;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const GitHubBox: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Microsoft: Obsolete;
        const MicrosoftSquares: ImageFunc;
        const Redis: ImageFunc;
        const StackOverflow: ImageFunc;
        const VisualStudio: ImageFunc;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const VisualStudioBox: Obsolete;
    }
    /**
     * Animated loading indicators.
     */
    module Loading {
        const EllipsisSquare: FxBaseImages.ImageFunc;
        const Spinner: () => Image;
        /** @deprecated Use Images.Loading.Spinner instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Loader: Obsolete;
    }
    /**
     * Emoticon icons.
     * @deprecated Images.Emoticon is deprecated
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module Emoticon {
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Happy: Obsolete;
    }
    /**
     * Themes
     */
    module Themes {
        const Azure: FxBaseImages.ImageFunc;
        const Blue: FxBaseImages.ImageFunc;
        const Dark: FxBaseImages.ImageFunc;
        const Light: FxBaseImages.ImageFunc;
    }
    /**
     * Multicolor/Polychromatic images.
     */
    module Polychromatic {
        const ActiveDirectory: ImageFunc;
        const Advisor: ImageFunc;
        const AllServices: ImageFunc;
        const ApiManagement: ImageFunc;
        const AppInsights: ImageFunc;
        const Automation: ImageFunc;
        const AvailabilitySet: ImageFunc;
        const Backlog: ImageFunc;
        const Backup: ImageFunc;
        const BillingHub: ImageFunc;
        const BizTalk: ImageFunc;
        const BlobBlock: ImageFunc;
        const BlobPage: ImageFunc;
        const Branch: ImageFunc;
        const Browser: ImageFunc;
        const Bug: ImageFunc;
        const Builds: ImageFunc;
        const Cache: ImageFunc;
        const Cdn: ImageFunc;
        const Certificate: ImageFunc;
        const Chart: ImageFunc;
        const ClearDBDatabase: ImageFunc;
        const Clock: ImageFunc;
        const CloudService: ImageFunc;
        const Code: ImageFunc;
        const Commit: ImageFunc;
        const Controls: ImageFunc;
        const ControlsHorizontal: ImageFunc;
        const CostAlerts: ImageFunc;
        const CostAnalysis: ImageFunc;
        const CostBudgets: ImageFunc;
        const Counter: ImageFunc;
        const Cubes: ImageFunc;
        const CustomDomain: ImageFunc;
        const Dashboard: ImageFunc;
        const Database: ImageFunc;
        const DevConsole: ImageFunc;
        const Discs: ImageFunc;
        const Download: ImageFunc;
        const ErrorIcon: ImageFunc;
        const EventGrid: ImageFunc;
        const EventHub: ImageFunc;
        const Extensions: ImageFunc;
        const File: ImageFunc;
        const Files: ImageFunc;
        const FolderBlank: ImageFunc;
        const FolderCube: ImageFunc;
        const FolderWebsite: ImageFunc;
        const Ftp: ImageFunc;
        const Functions: ImageFunc;
        const Gear: ImageFunc;
        const Globe: ImageFunc;
        const GlobeError: ImageFunc;
        const GlobeSuccess: ImageFunc;
        const GlobeWarning: ImageFunc;
        const Grid: ImageFunc;
        const Guide: ImageFunc;
        const Heart: ImageFunc;
        const Image: ImageFunc;
        const Info: ImageFunc;
        const InputOutput: ImageFunc;
        const Insights: ImageFunc;
        const IpAddress: ImageFunc;
        const JourneyHub: ImageFunc;
        const Key: ImageFunc;
        const LaunchPortal: ImageFunc;
        const Learn: ImageFunc;
        const LoadBalancer: ImageFunc;
        const LoadTest: ImageFunc;
        const Location: ImageFunc;
        const Log: ImageFunc;
        const LogAnalytics: ImageFunc;
        const LogDiagnostics: ImageFunc;
        const LogStreaming: ImageFunc;
        const ManagementPortal: ImageFunc;
        const Media: ImageFunc;
        const MediaFile: ImageFunc;
        const Mobile: ImageFunc;
        const MobileEngagement: ImageFunc;
        const Module: ImageFunc;
        const Monitoring: ImageFunc;
        const NetworkInterfaceCard: ImageFunc;
        const Notification: ImageFunc;
        const NotificationBell: ImageFunc;
        const OperationalInsights: ImageFunc;
        const Owl: ImageFunc;
        const Power: ImageFunc;
        const Powershell: ImageFunc;
        const PowerUp: ImageFunc;
        const Preview: ImageFunc;
        const ProcessExplorer: ImageFunc;
        const ProductionReadyDb: ImageFunc;
        const QuickStart: ImageFunc;
        const RemoteApp: ImageFunc;
        const ResourceDefault: ImageFunc;
        const ResourceGroup: ImageFunc;
        const ResourceGroupList: ImageFunc;
        const ResourceLinked: ImageFunc;
        /** @deprecated Use Images.Polychromatic.ResourceGroupList instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ResourceList: Obsolete;
        const ResourceRole: ImageFunc;
        const Scale: ImageFunc;
        const Scheduler: ImageFunc;
        const Search: ImageFunc;
        const SearchGrid: ImageFunc;
        const ServerFarm: ImageFunc;
        const ServiceBus: ImageFunc;
        const SiteRecovery: ImageFunc;
        const SqlDatabase: ImageFunc;
        const SqlDataBaseServer: ImageFunc;
        const SSD: ImageFunc;
        const SslCustomDomains: ImageFunc;
        const Storage: ImageFunc;
        const StorageAzureFiles: ImageFunc;
        const StorageContainer: ImageFunc;
        const StorageQueue: ImageFunc;
        const Store: ImageFunc;
        const StorSimple: ImageFunc;
        const StreamAnalytics: ImageFunc;
        const Support: ImageFunc;
        const Table: ImageFunc;
        const Tags: ImageFunc;
        const TeamProject: ImageFunc;
        const TfsVcRepository: ImageFunc;
        const Toolbox: ImageFunc;
        const TrafficManager: ImageFunc;
        const Versions: ImageFunc;
        const VirtualMachine: ImageFunc;
        const VirtualNetwork: ImageFunc;
        const WebEnvironment: ImageFunc;
        const WebHosting: ImageFunc;
        const WebJobs: ImageFunc;
        const Website: ImageFunc;
        const WebsitePower: ImageFunc;
        const WebsiteStaging: ImageFunc;
        const WebSlots: ImageFunc;
        const WebTest: ImageFunc;
        const Workbooks: ImageFunc;
        const Workflow: ImageFunc;
        const AddSubscription: ImageFunc;
        const ContentErrorGeneric: ImageFunc;
        const ContentErrorNotFound: ImageFunc;
        const ContentErrorUnauthorized: ImageFunc;
        const CornerCheck: ImageFunc;
        const DefaultBlade: ImageFunc;
        const ManageAccess: ImageFunc;
        const StudentTools: ImageFunc;
        const PolyTrafficManagerDisabled: FxBaseImages.ImageFunc;
        const PolyTrafficManagerEnabled: FxBaseImages.ImageFunc;
        const TrafficManagerDisabled: FxBaseImages.ImageFunc;
        const TrafficManagerEnabled: FxBaseImages.ImageFunc;
    }
    /**
     * Shell icons module
     * @deprecated Images.Shell is deprecated, all icons within can be found in Images.* or Images.Polychromatic.*
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module Shell {
        /** @deprecated This icon has been moved to Images.Chevron. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Chevron: Obsolete;
        /** @deprecated This icon has been moved to Images.Close. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Close: Obsolete;
        /** @deprecated This icon has been moved to Images.ShellCustomize. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Customize: Obsolete;
        /** @deprecated This icon has been moved to Images.Dots. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Dots: Obsolete;
        /** @deprecated This icon has been moved to Images.ExitPeekMode. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ExitPeekMode: Obsolete;
        /** @deprecated This icon has been moved to Images.Fullscreen. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Fullscreen: Obsolete;
        /** @deprecated This icon has been moved to Images.ShellGear. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Gear: Obsolete;
        /** @deprecated This icon has been moved to Images.HeaderDots. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const HeaderDots: Obsolete;
        /** @deprecated This icon has been moved to Images.Maximize. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Maximize: Obsolete;
        /** @deprecated This icon has been moved to Images.Mini. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Mini: Obsolete;
        /** @deprecated This icon has been moved to Images.Minimize. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Minimize: Obsolete;
        /** @deprecated This icon has been moved to Images.PeekMode. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const PeekMode: Obsolete;
        /** @deprecated This icon has been moved to Images.Restore. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Restore: Obsolete;
        /** @deprecated This icon has been moved to Images.Share. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Share: Obsolete;
        /** @deprecated This icon has been moved to Images.Trash. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Trash: Obsolete;
        /** @deprecated This icon has been moved to Images.TrashOutline. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const TrashOutline: Obsolete;
        /** @deprecated This icon has been moved to Images.TripleArrow. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const TripleArrow: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.AddSubscription. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const AddSubscription: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.ContentErrorGeneric. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ContentErrorGeneric: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.ContentErrorNotFound. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ContentErrorNotFound: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.ContentErrorUnauthorized. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ContentErrorUnauthorized: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.CornerCheck. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CornerCheck: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.DefaultBlade. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DefaultBlade: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.ManageAccess. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ManageAccess: Obsolete;
        /** @deprecated This icon has been moved to Images.Polychromatic.StudentTools. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const StudentTools: Obsolete;
        /** @deprecated Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Add: Obsolete;
        /** @deprecated Use Images.Filter instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Filter: Obsolete;
        /** @deprecated Use Images.Pin instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Pin: Obsolete;
        /** @deprecated Use Images.Save instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Save: Obsolete;
        /** @deprecated Use Images.ArrowDown instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ArrowWideDown: Obsolete;
        /** @deprecated Use Images.ArrowUp instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ArrowWideUp: Obsolete;
        /** @deprecated Use Images.CaretDown instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Collapse: Obsolete;
        /**
         * Shell.JumpBar icons module
         * @deprecated Images.Shell.JumpBar is deprecated.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        module JumpBar {
            /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Home: Obsolete;
            /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Alerts: Obsolete;
            /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Journey: Obsolete;
            /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Browse: Obsolete;
            /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Billing: Obsolete;
            /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Create: Obsolete;
        }
    }
    /**
     * Status badges.
     */
    module StatusBadge {
        const Canceled: FxBaseImages.ImageFunc;
        const Critical: FxBaseImages.ImageFunc;
        const Disabled: FxBaseImages.ImageFunc;
        const Error: FxBaseImages.ImageFunc;
        const Failed: FxBaseImages.ImageFunc;
        const Info: FxBaseImages.ImageFunc;
        const None: FxBaseImages.ImageFunc;
        const Pending: FxBaseImages.ImageFunc;
        const Stopped: FxBaseImages.ImageFunc;
        const Success: FxBaseImages.ImageFunc;
        const Unknown: FxBaseImages.ImageFunc;
        const Update: FxBaseImages.ImageFunc;
        const Upsell: FxBaseImages.ImageFunc;
        const Warning: FxBaseImages.ImageFunc;
        module Outline {
            const Canceled: FxBaseImages.ImageFunc;
            const Critical: FxBaseImages.ImageFunc;
            const Disabled: FxBaseImages.ImageFunc;
            const Error: FxBaseImages.ImageFunc;
            const Failed: FxBaseImages.ImageFunc;
            const Info: FxBaseImages.ImageFunc;
            const None: FxBaseImages.ImageFunc;
            const Pending: FxBaseImages.ImageFunc;
            const Stopped: FxBaseImages.ImageFunc;
            const Success: FxBaseImages.ImageFunc;
            const Unknown: FxBaseImages.ImageFunc;
            const Update: FxBaseImages.ImageFunc;
            const Upsell: FxBaseImages.ImageFunc;
            const Warning: FxBaseImages.ImageFunc;
        }
        module Solid {
            const Error: FxBaseImages.ImageFunc;
            const Info: FxBaseImages.ImageFunc;
            const Warning: FxBaseImages.ImageFunc;
            const Unknown: FxBaseImages.ImageFunc;
        }
    }
    /**
     * Part gallery
     * @deprecated Images.PartGallery is deprecated.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module PartGallery {
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CollectionPartWithRollup: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CollectionSummary: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DonutChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DonutChartPartial: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Extensions: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const GridWithMoreData: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Map: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MultiLineChartMultiTrendLine: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MultiScatterChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MultiStackedBarChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MutliLineChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const PricingTier: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const QuotaGauge: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ResourceMap: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleAreaChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleAreaChartSingleThreshold: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleAreaChartSingleTrendline: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleBarChartLarge: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleBarChartSmall: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleLineChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleScatterChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleScatterSingleThreshold: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleValueGauge: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SplitBarChart: Obsolete;
        /** @deprecated Please refer to https://aka.ms/portalfx/breaking for more details. */
        const StackedAreaChart: Obsolete;
    }
}

// FILE: MsPortalFx\Base\Base.KnockoutExtensions.d.ts
interface KnockoutFxExt<T> {
    /**
     * Waits for the observable to change value once. Automatically unsubscribes to the observable after the single value change.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The subscription callback.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     * @return The subscription. Can be manually unsubscribed before the next change.
     */
    fxOnce(this: KnockoutSubscribable<T>, lifetime: MsPortalFx.Base.LifetimeManager, callback: (val: T) => void, predicate?: (val: T) => boolean): KnockoutSubscription<T>;
    /**
     * Async awaits for the observable to change value once
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     * @return The promise that is used for setting up the binding with a subscription attached. This promise will throw
     *         if the subscription is disposed before the promise gets resolved.
     */
    fxAwait(this: KnockoutSubscribable<T>, lifetime: MsPortalFx.Base.LifetimeManager, predicate?: (val: T) => boolean): Q.Promise<T> & {
        subscription: KnockoutSubscription<T>;
    };
}
interface KnockoutObservableBase<T> extends KnockoutFxExt<T> {
}
interface KnockoutSubscribable<T> extends KnockoutFxExt<T> {
}
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    /**
     * Subscribes to observable array edit notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The callback that will be invoked when edits are made to the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayEdits(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, callback: (edits: KnockoutArrayEdit<T>[]) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array add and delete notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param addedCallback The callback that will be invoked when an item is added to the array.
     * @param deletedCallback The callback that will be invoked when an item is deleted from the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayChanges(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, addedCallback: (addedItem: T) => void, deletedCallback: (deletedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array bulk changes.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The callback that will be invoked once with all the adds and deletes corresponding to an array change.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayBulkChanges(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, callback: (addedItems: T[], deletedItems: T[]) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array add notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param addedCallback The callback that will be invoked when an item is added to the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayAdds(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, addedCallback: (addedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array delete notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param deletedCallback The callback that will be invoked when an item is deleted from the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayDeletes(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, deletedCallback: (deletedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Maps the array into the destination array.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param mapping The callback that will be invoked to map a source item to a destination item.
     * @param destination The observable array that the source array is mapped into.  If not provided a new array is created.
     * @return The destination array is returned.
     */
    mapInto<U>(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, item: T) => U, destination?: KnockoutObservableArray<U>): KnockoutObservableArray<U>;
}
interface KnockoutObservableArrayDisposable<T> extends KnockoutObservableArray<T>, KnockoutDisposable {
}
interface KnockoutArraySplice<T> {
    /**
     * The start index for the splice.
     */
    start: number;
    /**
     * The count of items to be deleted by the splice.
     */
    deleteCount: number;
    /**
     * The items to be added by the splice.
     */
    items: T[];
    /**
     * Indicates that the deleted and added items of this splice are simply moving within the array.
     * When not set the deleted items are being removed and the added items are newly added.
     * This flag is undefined unless the splices are created with the identifyMoves option.
     */
    move?: boolean;
}
declare module ko.utils {
    /**
     * Creates edits with adjusted indexes for sequenced application.
     *
     * @param edits The original unadjusted edits.
     * @return A new set of edits with adjusted indexes for sequential insertion/deletion.
     */
    function adjustArrayEdits<T>(edits: KnockoutArrayEdit<T>[]): KnockoutArrayEdit<T>[];
    /**
     * Creates edits with adjusted indexes for sequenced application.
     *
     * @param edits The original unadjusted edits.
     * @param target The array to target.
     * @param mapFuns Maps edit items to target array items when creating new entries for the target array.
     * @return A new set of edits with adjusted indexes for sequential insertion/deletion.
     */
    function adjustArrayEdits<T, U>(edits: KnockoutArrayEdit<T>[], target: U[], mapFunc: (value: T) => U): KnockoutArrayEdit<U>[];
    /**
     * Merges the knockout array edits into splices that can be applied to a target array.
     * This does the work of adjusting the indexes similar to adjustArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param identifyMoves Creates seperate splices for items that are moved within the array.
     * @return Returns an array of splices that can be applied to a target array.
     */
    function createArraySplices<T>(edits: KnockoutArrayEdit<T>[], identifyMoves?: boolean): KnockoutArraySplice<T>[];
    /**
     * Merges the knockout array edits into splices that can be applied to the target array.
     * This does the work of adjusting the indexes similar to adjustArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param target The array to target.
     * @param mapFuns Maps edit items to target array items when creating new entries for the target array.
     * @return Returns an array of splices that can be directly applied to the target array.
     */
    function createArraySplices<T, U>(edits: KnockoutArrayEdit<T>[], identifyMoves: boolean, target: U[], mapFunc: (value: T) => U): KnockoutArraySplice<U>[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @return Returns an array of the removed items.
     */
    function applyArraySplices<T>(target: T[], splices: KnockoutArraySplice<T>[]): T[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @return Returns an array of the removed items.
     */
    function applyArraySplices<T>(target: KnockoutObservableArray<T>, splices: KnockoutArraySplice<T>[]): T[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @param mapFunc Maps splice items to target items.
     * @return Returns an array of the removed items.
     */
    function applyArraySplices<T, U>(target: U[], splices: KnockoutArraySplice<T>[], mapFunc: (value: T) => U): U[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @param mapFunc Maps splice items to target items.
     * @return Returns an array of the removed items.
     */
    function applyArraySplices<T, U>(target: KnockoutObservableArray<U>, splices: KnockoutArraySplice<T>[], mapFunc: (value: T) => U): U[];
    /**
     * Establishes a two-way binding between the specified observables.
     *
     * @param lifetimeManager
     * @param The first observable whose initial value take precedence while setting up the binding.
     * @param The second observable.
     * @return The subscriptions that are used for setting up the binding. Dispose these subscriptions to disconnect
     * the binding.
     */
    function twoWayBinding<T>(lifetime: MsPortalFx.Base.LifetimeManager, source: KnockoutObservableBase<T>, destination: KnockoutObservableBase<T>): MsPortalFx.Base.DisposableLifetimeManager;
    /**
     * Wraps a value (not an array) in an observable or return the value if it already was observable
     *
     * @param value The value to wrap.
     */
    function wrap<T>(value: T | KnockoutObservableBase<T>): KnockoutObservableBase<T>;
    /**
     * Wraps an array in an observable or return the value if it already was an observable array
     *
     * @param value The array to wrap.
     */
    function wrapArray<T>(array: T[] | KnockoutObservableArray<T>): KnockoutObservableArray<T>;
    /**
     * Unwraps a property value specified by a path.
     * Stops evaluation if any intermediate property in the path returns a falsey value.
     *
     * @param value The value to read the property from.
     * @param path The property path using . delimeters.
     * @param unwrapLast Indicates if the last value of the path should be unwrapped.  The default is true.
     * @return The value of the property or undefined if not evaluated.
     */
    function unwrapObservablePath(value: any, path: string, unwrapLast?: boolean): any;
    /**
     * Peeks a property value specified by a path.
     * Stops evaluation if any intermediate property in the path returns a falsey value.
     *
     * @param value The value to read the property from.
     * @param path The property path using . delimeters.
     * @param peekLast Indicates if the last value of the path should be peeked.  The default is true.
     * @return The value of the property or undefined if not evaluated.
     */
    function peekObservablePath(value: any, path: string, peekLast?: boolean): any;
}
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    /**
     * Internal high performance ApplyArrayEdits.  Apply minimum amount splice call given arrayEdits.
     *
     * @param underlyingArray The array to target.
     * @param edits ArrayEdits return by ko.utils.compareArray.
     * @param Options addition argument.
     *          spliceFunc: allow custom splice-like function to be pass in.  Othersize, Array.splice is the default to perform on the array.
     *          inplaceFixup: if the arrayEdits index haven't fix up yet.  pass true to adjust arrayEditIndex while look for the minimum splice to called.  It will not change arrayEdit.index
     * @return spliceCalls : return the number of splice performed on target Array.
     */
    let quickApplyArrayEdits: <T>(underlyingArray: T[], arrayEdits: KnockoutArrayEdit<T>[], options?: {
        spliceFunc?: typeof Array.prototype.splice;
        inplaceFixup?: boolean;
    }) => number;
    /**
     * Merges the knockout array edits into splices that can be applied to the target array.
     * This does the work of adjusting the indexes similar to fixupArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param identifyMoves Creates seperate splices for items that are moved within the array.
     * @param target The array to target.
     * @param mapFunc Maps edit items to target array items when creating new entries for the target array.
     * @return Returns an array of splices that can be directly applied to the target array.
     */
    function createArraySplicesInternal<T, U>(edits: KnockoutArrayEdit<T>[], identifyMoves: boolean, target?: U[], mapFunc?: (value: T[]) => U[]): KnockoutArraySplice<U>[];
    /**
     * Subscribes to observable array edit notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param source The array to subscribe to.
     * @param callback The callback that will be invoked when edits are made to the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    function subscribeArrayEdits<T>(lifetime: FxBase.LifetimeManager, source: KnockoutReadOnlyObservableArray<T> | KnockoutProjectableComputedArray<T>, callback: (edits: KnockoutArrayEdit<T>[]) => void, context?: any): KnockoutSubscription<T>;
}

// FILE: MsPortalFx\Base\Base.KnockoutExtensions.Lifetime.d.ts
declare module ko {
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T, U>(lifetime: LifetimeManager, dependency: KnockoutObservableBase<U>, func: (dependencyValue?: U) => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: LifetimeManager, dependencies: KnockoutObservableBase<any>[], func: ((...dependenciesValues: any[]) => T) | (() => T), context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: LifetimeManager, dependency: KnockoutObservableBase<any>, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: LifetimeManager, dependencies: KnockoutObservableBase<any>[], options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Sets up a reactor, i.e., something that watches for changes to a set of observables
     * or computeds, and takes some action each time any of them changes.
     *
     * @param lifetime The lifetime of the reactor, meaning that it will automatically be disposed when the lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param evaluator A callback function that reads one or more observables/computeds and takes some action.
     *                  This will be invoked once initially, and then any time any dependency changes.
     *                  The set of dependencies may change arbitrarily on each evaluation.
     */
    function reactor<T>(lifetime: LifetimeManager, dependency: KnockoutObservableBase<T>, evaluator: (dependencyValue?: T) => void): void;
    function reactor<T>(lifetime: LifetimeManager, dependencies: KnockoutObservableBase<any> | KnockoutObservableBase<any>[], evaluator: (...dependenciesValues: any[]) => void): void;
    function reactor<T>(lifetime: LifetimeManager, evaluator: () => void): void;
}

// FILE: MsPortalFx\Base\Base.KnockoutExtensions.Lifetime.ambient.d.ts
interface KnockoutSubscribable<T> {
    /**
     * Subscribes to receive notification when the observable/computed changes value.
     *
     * @param lifetime The lifetime of the subscription, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param callback The callback to be invoked when the observable/computed changes value.
     * @param target If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param topic If specified, determines which kind of change notification to respond to.
     *              You can omit this if you simply want notifications when the observable/computed changes value.
     *              See Knockout documentation for more details.
     * @return A subscription instance. Note that you don't need to dispose this manually if the 'lifetime' object will itself get disposed.
     */
    subscribe(lifetime: MsPortalFx.Base.LifetimeManager, callback: (newValue: T) => void, target?: any, topic?: string): KnockoutSubscription<T>;
    /**
     * Subscribes to receive notification when the observable/computed changes value and run subscription once.
     *
     * @param lifetime The lifetime of the subscription, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param callback The callback to be invoked when the observable/computed changes value.
     * @param target If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param topic If specified, determines which kind of change notification to respond to.
     *              You can omit this if you simply want notifications when the observable/computed changes value.
     *              See Knockout documentation for more details.
     * @return A subscription instance. Note that you don't need to dispose this manually if the 'lifetime' object will itself get disposed.
     */
    subscribeAndRun(lifetime: MsPortalFx.Base.LifetimeManager, callback: (newValue: T) => void, target?: any, topic?: string): KnockoutSubscription<T>;
    /**
     * Waits for the observable to change value once. Automatically unsubscribes to the observable after the single value change.
     *
     * @param lifetime The lifetime manager for the subscription, and will run if the current value meets the predicate
     * @param callback The subscription callback.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     *        Defaults to (val) => !!val
     * @return The subscription. Can be manually unsubscribed before the next change.
     */
    fxOnceAndRun(lifetime: MsPortalFx.Base.LifetimeManager, callback: (val: T) => void, predicate?: (val: T) => boolean): KnockoutSubscription<T>;
    /**
     * Async awaits for the observable to change value once, and will resolve if the current value meets the predicate
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     *        Defaults to (val) => !!val
     * @return The promise that is used for setting up the binding with a subscription attached. This promise will throw
     *         if the subscription is disposed before the promise gets resolved.
     */
    fxAwaitAndRun(lifetime: MsPortalFx.Base.LifetimeManager, predicate?: (val: T) => boolean): Q.Promise<T> & {
        subscription: KnockoutSubscription<T>;
    };
}
interface KnockoutComputedStatic {
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T, U>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<U>, func: (dependencyValue?: U) => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], func: ((...dependenciesValues: any[]) => T) | (() => T), context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<any>, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates a Knockout computed instance.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, func: () => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates a Knockout computed instance.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
}
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    /**
     * Produces a new array by mapping each item in the source array.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the mapped array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param mapping A function that transforms input array entries to output array entries.
     * @return A computed array value representing the mapping result.
     */
    map<TResult>(lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, value: T) => TResult): KnockoutProjectableComputedArray<TResult>;
    /**
     * Produces a new array by filtering the source array according to a predicate.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the filtered array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param predicate A predicate that determines which entries should be included in the output array.
     * @return A computed array value representing the mapping result.
     */
    filter(lifetime: MsPortalFx.Base.LifetimeManager, predicate: (value: T) => boolean): KnockoutProjectableComputedArray<T>;
}
interface KnockoutProjectableComputedArray<T> extends KnockoutComputed<T[]> {
    /**
     * Produces a new array by mapping each item in the source array.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the mapped array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param mapping A function that transforms input array entries to output array entries.
     * @return A computed array value representing the mapping result.
     */
    map<TResult>(lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, value: T) => TResult): KnockoutProjectableComputedArray<TResult>;
    /**
     * Produces a new array by filtering the source array according to a predicate.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the filtered array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param predicate A predicate that determines which entries should be included in the output array.
     * @return A computed array value representing the mapping result.
     */
    filter(lifetime: MsPortalFx.Base.LifetimeManager, predicate: (value: T) => boolean): KnockoutProjectableComputedArray<T>;
}

// FILE: MsPortalFx\Base\Base.Net.d.ts
declare module FxImpl {
    let authTokenDomainValidator: ReturnType<typeof getDomainValidator>;
    let extensionName: string;
    const enum HeaderNames {
        AcceptLanguage = "Accept-Language",
        AuthN = "Authorization",
        CacheControl = "Cache-Control",
        CacheTag = "x-ms-cache-tag",
        EffectiveLocale = "x-ms-effective-locale",
        ExtensionFlags = "x-ms-extension-flags",
        FailureCause = "x-ms-failure-cause",
        LoggedOut = "x-ms-force-login",
        PathAndQuery = "x-ms-path-query",
        Pragma = "Pragma",
        SessionId = "x-ms-client-session-id",
        Version = "x-ms-version",
        VersionMismatch = "x-ms-version-mismatch",
        CommandName = "x-ms-command-name",
        RequestId = "x-ms-client-request-id"
    }
    /**
     * Gets the ARM endpoint.
     */
    function getArmEndpoint(): string;
    /**
     * Gets a domain validator with the specified set of trusted domains.
     * @param trustedDomains The list of trusted domains provided by the extension.
     */
    function getDomainValidator(trustedDomains: string[]): {
        hasTrustedDomains: boolean;
        validateDomain: (uri: string) => boolean;
    };
    /**
     * Validates that the specified domain is trusted.
     * @param domainLowerCase The domain to validate.
     */
    function validateDomain(domainLowerCase: string): boolean;
}
declare module MsPortalFx.Base {
    import Fx = MsPortalFx;
    import Impl = FxImpl;
    import FxHelpers = Fx.Helpers;
    import FxImplExtension = Impl.Extension;
    import FxBase = Fx.Base;
    module Net2 {
        /**
         * The HTTP status codes matches the .NET HttpStatusCode enumeration.
         */
        const enum HttpStatusCode {
            Continue = 100,
            SwitchingProtocols = 101,
            Ok = 200,
            Created = 201,
            Accepted = 202,
            NonAuthoritativeInformation = 203,
            NoContent = 204,
            ResetContent = 205,
            PartialContent = 206,
            Ambiguous = 300,
            MultipleChoices = 300,
            Moved = 301,
            MovedPermanently = 301,
            Found = 302,
            Redirect = 302,
            RedirectMethod = 303,
            SeeOther = 303,
            NotModified = 304,
            UseProxy = 305,
            Unused = 306,
            RedirectKeepVerb = 307,
            TemporaryRedirect = 307,
            BadRequest = 400,
            Unauthorized = 401,
            PaymentRequired = 402,
            Forbidden = 403,
            NotFound = 404,
            MethodNotAllowed = 405,
            NotAcceptable = 406,
            ProxyAuthenticationRequired = 407,
            RequestTimeout = 408,
            Conflict = 409,
            Gone = 410,
            LengthRequired = 411,
            PreconditionFailed = 412,
            RequestEntityTooLarge = 413,
            RequestUriTooLong = 414,
            UnsupportedMediaType = 415,
            RequestedRangeNotSatisfiable = 416,
            ExpectationFailed = 417,
            UpgradeRequired = 426,
            TooManyRequests = 429,
            InternalServerError = 500,
            NotImplemented = 501,
            BadGateway = 502,
            ServiceUnavailable = 503,
            GatewayTimeout = 504,
            HttpVersionNotSupported = 505
        }
        function isRetryable(xhr: FxHelpers.XMLHttpRequestLike): boolean;
        /**
         * Contract for parameters returned by the cachedAjax function
         */
        interface AjaxCachedResult<T> {
            cachedAjax?: boolean;
            data?: T;
            modified?: boolean;
            textStatus?: string;
            cacheTagValue?: string;
            jqXHR?: JQueryXHR<T>;
        }
        /**
         * Authorization options for targeted tokens.
         */
        interface AuthorizationOptions {
            /**
             * The resource name to get the token for.
             */
            resourceName: string;
        }
        /**
         * Internal.
         */
        interface JQueryPromiseXhr<T> {
            always(...alwaysCallbacks: Array<{
                (): void;
            }>): JQueryPromiseXhr<T>;
            done(...doneCallbacks: Array<JQueryPromiseXHRDoneCallback<T>>): JQueryPromiseXhr<T>;
            fail(...failCallbacks: Array<JQueryPromiseXHRFailCallback<T>>): JQueryPromiseXhr<T>;
            progress(...progressCallbacks: Array<{
                (): void;
            }>): JQueryPromiseXhr<T>;
            finally(...alwaysCallbacks: Array<{
                (): void;
            }>): JQueryPromiseXhr<T>;
            state(): string;
            promise(target?: any): JQueryPromiseXhr<T>;
            then(doneCallbacks: JQueryPromiseXHRDoneCallback<T>, failCallbacks?: JQueryPromiseXHRFailCallback<T>, progressCallbacks?: {
                (): void;
            }): JQueryPromise;
            then<UValue>(doneCallbacks: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UValue;
            }, failCallbacks?: JQueryPromiseXHRFailCallback<T>, progressCallbacks?: {
                (): void;
            }): JQueryPromiseV<UValue>;
            then<UValue, UReject>(doneCallbacks: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UValue;
            }, failCallbacks?: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UReject;
            }, progressCallbacks?: {
                (): void;
            }): JQueryPromiseVR<UValue, UReject>;
            then<UReject>(doneCallbacks: JQueryPromiseXHRDoneCallback<T>, failCallbacks?: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UReject;
            }, progressCallbacks?: {
                (): void;
            }): JQueryPromiseR<UReject>;
        }
        /**
         * The contract of a JQueryPromise that is returned by Base.Net2.ajax.
         */
        interface NetAjaxSettings<T> extends JQueryAjaxSettings<T> {
            /**
             * Determines whether the ajax request is part of a background task.
             * If true the request is executed one at a time so only one background task is in flight at a time.
             */
            isBackgroundTask?: boolean;
            /**
             * Determines whether to check compatibility between the server and browser version headers.
             * If undefined, the check is done automatically for all relative URIs, but skipped for absolute URIs.
             */
            checkVersion?: boolean;
            /**
             * Determines whether to retry the ajax call if one of the following conditions is met:
             *  1. Failure appears to be coming from an intermediary proxy
             *  2. Request times out
             *  3. Response status code is 500
             *  By default it use fibonacci to make sure fast initial retries. with times, it waits will be longer. (for default,  12 retries)
             *  1, 1, 2, 3, 5, 8, 13, ... the max wait time: sum(fibonacci (0 -11)) is 232.  232 * 400ms =  92800 (about 1.5 minutes.)
             */
            performRetry?: boolean;
            /**
             *  If performRetry === true, this is the maximum duration that it will retried if the ajax (Date.now() - ajaxStartRequest) < maxRetryDuration.
             */
            maxRetryDuration?: number;
            /**
             * If this option is set to a string (typically "api/invoke") and the input URI is an absolute URI,
             * the URI is parsed and the path and query is set on the x-ms-path-query header that is used when talking to
             * external services (ARM). Using this header instead of the path and query string of the URI helps amortize
             * the overhead of the CORS OPTIONS calls. Typically we can get down to 1 OPTIONS call for all calls to ARM
             * down from the typical of one per request.
             */
            invokeApi?: string;
            /**
             * Determines whether to automatically obtain and append an authorization header.
             * If undefined, the authorization header is appendended automatically for all relative URIs,
             * but skipped for absolute URIs.
             *
             * Set to true to append the default authorization header.
             * Set to { resourceName: 'audienceName'} to append an authorization token targeted at a specific audience.
             */
            setAuthorizationHeader?: boolean | AuthorizationOptions;
            /**
             * Data to append a request header as x-ms-command-name for ARM calls.
             *
             * Set to a non-empty string to append the header. The value should be 60 characters or less and will be trimmed
             * if longer.  This data will also used as AjaxError's additional data for diagnostic purpose.
             */
            setTelemetryHeader?: string;
            /**
             * If this option is undefined or false and the response returns 403 containing 'x-ms-failure-cause: gateway' header,
             * will result in retrying the request with 'cache-control: none' header. This is done to bypass server side caching
             * by external services (ARM).
             */
            skipRetryOnForbidden?: boolean;
            /**
             * Determines whether to avoid all headers that are included by the framework.
             */
            useRawAjax?: boolean;
            /**
             * Determines whether to return the detailed error (this is set to true) or the simple string error.
             */
            detailedError?: boolean;
            /**
             * The response type of the request
             */
            responseType?: string;
            /**
             * Determines whether to skip telemetry collection from the network request. The default is false.
             */
            skipTelemetry?: boolean;
            /**
             * The original URI which will be set if we switch the uri to use invokeApi.
             */
            originalUri?: string;
            /**
             * The URI to make the request to.
             */
            uri: string;
            /**
             * Optional boolean flag to use the FX ARM endpoint if the URI above is a relative URI.
             */
            useFxArmEndpoint?: boolean;
            /**
             * Skips the domain validation check. This should not be set to true unless you are sure that the domain
             * you are using is known to be a trusted domain.
             */
            skipDomainValidation?: boolean;
            /**
             * Disable the network connection error dialog when there is an unknown network error. An unknown network
             * is usually raised when the browser surfaces a status code 0.
             */
            ignoreUnknownNetworkError?: boolean;
        }
        /**
         * The contract for the detailed error values when the detailedError flag is set on the AJAX settings. This
         * replaces the simple string error value with a composite object which includes the simple error value and
         * the response text.
         */
        interface NetAjaxDetailedError {
            /**
             * The error which would have been the simple error value.
             */
            error: string;
            /**
             * The response text in the case of an error.
             */
            responseText: string;
        }
        /**
         * The base contract for extended information provided by responses of ajax calls.
         */
        interface BaseResponse<T> {
            /**
             * The XHR of the response.
             */
            jqXHR: JQueryXHR<T>;
            /**
             * The text status.
             */
            textStatus?: string;
        }
        /**
         * The contract for extended information provided by responses of succeeded ajax calls.
         */
        interface Response<T> extends BaseResponse<T> {
            /**
             * The content of the response.
             */
            content: T;
        }
        /**
         * The contract for extended information provided by responses of failed ajax calls.
         */
        interface ErrorResponse<T> extends BaseResponse<T> {
            errorThrown: string;
        }
        /**
         *  Extensions can opt out of the automatic ajax version check if their data APIs are not
         *  compatible for some reason.
         */
        function disableAjaxServerVersionCheck(): void;
        /**
         * Extensions can set a callback which will be called when an Ajax call that results
         * in a server error response. This method allows the callback method to be set.
         * The callback method shoud be of type AjaxLogFunc which matches the same shape as
         * Base.Diagnostics.Log.error().
         *
         * @param callback The function called when an Ajax call results in a server error response.
         * @param sanitizeCallback Custom callback to sanitize uri and pathAndQuery. The default sanitizer
         * uses MsPortalFx.sanitizeMessage.
         */
        function setAjaxLogFunc(callback: FxBase.Diagnostics.LogFunc, sanitizeCallback?: (input: string) => string): void;
        /**
         * Extensions can set a the function that will be called for executing Ajax call.
         *
         * @param func The function called to invoke an Ajax call.
         */
        function setAjaxFunc(func: typeof FxHelpers.ajax): void;
        module Internal {
            interface Environment {
                betweenRetry: number;
            }
            let environment: Environment;
            /**
             * Internal helper function for getting the ARM endpoint.
             * Use getEndpoints() in Fx/Ajax to get well known endpoints.
             */
            function getArmEndpoint(): string;
            /**
             * Performs an ajax request with the appropriate headers set. (Internal use only.)
             *
             * @param settings The settings that are to be passed to the ajax call.
             * @return A promise for the ajax call.
             */
            function ajaxExtended<T>(settings: NetAjaxSettings<T>): Q.Promise<Response<T>>;
            /**
             * Internal class. Do not use.
             */
            class AjaxCaller {
                ajaxStatus: KnockoutObservable<FxImplExtension.ExtensionStatus>;
                unknownErrorStatusCode: number;
                skipVersionCheck: boolean;
                private _initialized;
                private _acceptLanguage;
                private _effectiveLocale;
                private _getAuthTokenFunc;
                private _version;
                private _extensionFlags;
                private _stall;
                private _unknownErrors;
                private _backgroundTask;
                initialize(version: string, getAuthorizationTokenFunc: (options?: FxImplExtension.GetAuthorizationTokenOptions) => Q.Promise<string>, extensionFlags?: any, effectiveLocale?: string): void;
                postJSON<T>(settings: NetAjaxSettings<T>, data: any): Q.Promise<T>;
                oldPostJSON<T>(settings: NetAjaxSettings<T>, data: any): Obsolete;
                ajaxExtended<T>(settings: NetAjaxSettings<T>): Q.Promise<Response<T>>;
                oldAjax<T>(settings: NetAjaxSettings<T>): Obsolete;
                ajax<T>(settings: NetAjaxSettings<T>): Q.Promise<T>;
                private _executeAjaxCall;
                cachedAjax<T>(settings: NetAjaxSettings<T>): Q.Promise<AjaxCachedResult<T>>;
                oldCachedAjax<T>(settings: NetAjaxSettings<T>): Obsolete;
                private _worker;
            }
            /**
             * Internal function. Do not use.
             */
            function reset(): void;
        }
        /**
         * Performs an ajax request with the appropriate headers set.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @return A promise for the ajax call.
         */
        function postJSON<T>(settings: NetAjaxSettings<T>, data: any): Q.Promise<T>;
        /**
         * Performs an ajax request using caching with the appropriate headers set.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @return A promise for the ajax call.
         */
        function ajax<T>(settings: NetAjaxSettings<T>): Q.Promise<T>;
        /**
         * Performs an ajax request using caching with the appropriate headers set and returns XML Http Response.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @return A promise for the ajax call including XML Http Response.
         */
        function ajaxExtended<T>(settings: NetAjaxSettings<T>): Q.Promise<Response<T>>;
        /**
         * Internal. Do not use.
         */
        function getSingleton(): Net2.Internal.AjaxCaller;
        /**
         * Performs an ajax POST request.
         *
         * @param settings The settings that are to be passed to the ajax call.
         *                 uri is the only required parameter in settings.
         *                 The contentType, data, and type properties of the settings will be overwritten with the right values for posting JSON.
         * @param data The data to be sent to the server. The data will be run through JSON.stringify before posting (even if it is alaready a string).
         * @return A promise for the ajax call.
         */
        function cachedAjax<T>(settings: NetAjaxSettings<T>): Q.Promise<AjaxCachedResult<T>>;
        /**
         * Invalidate the cache header for cachedAjax.
         *
         * @param headers Set of ajax headers.
         */
        function invalidateCacheHeader(headers: any): void;
        /**
         * Set the cache header value for cachedAjax.
         *
         * @param headers Set of ajax headers.
         * @return mutated result with cache tag header set.
         */
        function setCacheHeader(headers: any, cacheTagValue: string): any;
        /**
         * Initialize the Base.Net module.
         *
         * @param getAuthorizationTokenFunc The callback that returns the authorization token.
         */
        function initialize(getAuthorizationTokenFunc: (options?: FxImplExtension.GetAuthorizationTokenOptions) => Q.Promise<string>): void;
        /**
         * Gets the logged out promise.
         *
         * @return The status of the Ajax (logged out, or .
         */
        let status: KnockoutComputed<FxImplExtension.ExtensionStatus>;
        /**
         * Disables AJAX version checking.
         *
         */
        function disableVersionCheck(): void;
    }
    /**
     * @deprecated MsPortalFx.Base.Net is deprecated. Please use MsPortalFx.Base.Net2 or Fx/Ajax instead. Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module Net {
        /**
         * @deprecated Net.HttpsStatusCode is deprecated, please use MsPortalFx.Base.Net2.HttpStatusCode. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const enum HttpStatusCode {
            Continue = 100,
            SwitchingProtocols = 101,
            Ok = 200,
            Created = 201,
            Accepted = 202,
            NonAuthoritativeInformation = 203,
            NoContent = 204,
            ResetContent = 205,
            PartialContent = 206,
            Ambiguous = 300,
            MultipleChoices = 300,
            Moved = 301,
            MovedPermanently = 301,
            Found = 302,
            Redirect = 302,
            RedirectMethod = 303,
            SeeOther = 303,
            NotModified = 304,
            UseProxy = 305,
            Unused = 306,
            RedirectKeepVerb = 307,
            TemporaryRedirect = 307,
            BadRequest = 400,
            Unauthorized = 401,
            PaymentRequired = 402,
            Forbidden = 403,
            NotFound = 404,
            MethodNotAllowed = 405,
            NotAcceptable = 406,
            ProxyAuthenticationRequired = 407,
            RequestTimeout = 408,
            Conflict = 409,
            Gone = 410,
            LengthRequired = 411,
            PreconditionFailed = 412,
            RequestEntityTooLarge = 413,
            RequestUriTooLong = 414,
            UnsupportedMediaType = 415,
            RequestedRangeNotSatisfiable = 416,
            ExpectationFailed = 417,
            UpgradeRequired = 426,
            TooManyRequests = 429,
            InternalServerError = 500,
            NotImplemented = 501,
            BadGateway = 502,
            ServiceUnavailable = 503,
            GatewayTimeout = 504,
            HttpVersionNotSupported = 505
        }
        /**
         * @deprecated Net.AjaxCachedResult is deprecated, please use MsPortalFx.Base.Net2.AjaxCachedResult<T>. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface AjaxCachedResult<T> extends Obsolete {
        }
        /**
         * @deprecated Net.AuthorizationOptions is deprecated, please use MsPortalFx.Base.Net2.AuthorizationOptions. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface AuthorizationOptions extends Obsolete {
        }
        /**
         * @deprecated Net.JQueryPromiseXhr is deprecated, please use MsPortalFx.Base.Promise. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface JQueryPromiseXhr<T> extends Obsolete {
        }
        /**
         * @deprecated Net.AjaxSettings is deprecated, please use MsPortalFx.Base.Net2.NetAjaxSettings. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface NetAjaxSettings<T> extends Obsolete {
        }
        /**
         * @deprecated Net.NetAjaxDetailedError is deprecated, please use MsPortalFx.Base.Net2.NetAjaxDetailedError. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface NetAjaxDetailedError extends Obsolete {
        }
        /**
         * @deprecated Net.disableAjaxServerVersionCheck is deprecated, please use MsPortalFx.Base.Net2.invalidateCacheHeader. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const disableAjaxServerVersionCheck: Obsolete;
        /**
         * @deprecated Net.postJSON is deprecated, please use MsPortalFx.Base.Net2.postJSON. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const postJSON: Obsolete;
        /**
         * @deprecated Net.ajax is deprecated, please use MsPortalFx.Base.Net2.ajax. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const ajax: Obsolete;
        /**
         * @deprecated Net.cachedAjax is deprecated, please use MsPortalFx.Base.Net2.cachedAjax. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const cachedAjax: Obsolete;
        /**
         * @deprecated Net.invalidateCacheHeader is deprecated, please use MsPortalFx.Base.Net2.invalidateCacheHeader. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const invalidateCacheHeader: Obsolete;
        /**
         * @deprecated Net.setCacheHeader is deprecated, please use MsPortalFx.Base.Net2.setCacheHeader. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const setCacheHeader: Obsolete;
        /**
         * @deprecated Net.initialize is deprecated, please use MsPortalFx.Base.Net2.initialize. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const initialize: Obsolete;
        /**
         * @deprecated Net.status is deprecated, please use MsPortalFx.Base.Net2.status. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        let status: Obsolete;
        /**
         * @deprecated Net.disableVersionCheck is deprecated, please use MsPortalFx.Base.Net2.disableVersionCheck. Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const disableVersionCheck: Obsolete;
    }
}

// FILE: MsPortalFx\Base\Base.Promises.d.ts
declare module MsPortalFx.Base.Internal {
    /**
     * An object that supports "then". Treated as a promise.
     */
    interface ThenableV<TValue> {
        then(onFulfill: (value: TValue) => any): any;
    }
    /**
     * The base type of a promise.
     */
    interface PromiseBase<TPromise, TProgressFunc, TValue> {
        /**
         * Registers callbacks to be invoked when the promise is settled.
         *
         * @param onFulfill A callback to be invoked when the promise is fulfilled.
         * @param onReject A callback to be invoked when the promise is rejected.
         * @return A new promise.
         */
        then<UValue>(onFulfill: (value: TValue) => ThenableV<UValue> | UValue, onReject?: (reason?: any) => any): PromiseV<UValue>;
        /**
         * Registers a callback to be invoked when the promise is rejected.
         *
         * @param onReject A callback to be invoked when the promise is rejected.
         * @return A new promise.
         */
        catch<UValue>(onReject: (reason?: any) => UValue | ThenableV<UValue>): PromiseV<any>;
        /**
         * Registers a callback to be invoked when the promise is settled.
         *
         * @return A new promise.
         */
        finally(finallyCallback: () => void): TPromise;
        /**
         * Registers a callback to be invoked when the promise issues progress notification.
         *
         * @param progressCallback A callback to be invoked when the promise issues progress notification.
         * @return A new promise.
         */
        progress(progressCallback: TProgressFunc): TPromise;
    }
}
declare module MsPortalFx.Base {
    /**
     * A promise representing an activity that may complete asynchronously. This may be a Q Promise, or
     * any other object that is compliant with the Promises/A+ spec {@link http://promises-aplus.github.io/promises-spec/}.
     */
    interface PromiseV<TValue> extends Internal.PromiseBase<PromiseV<TValue>, () => void, TValue> {
    }
    type Promise = PromiseV<any>;
    /**
     * A promise representing an activity that may complete asynchronously. This may be a Q Promise, or
     * any other object that is compliant with the Promises/A+ spec {@link http://promises-aplus.github.io/promises-spec/}.
     */
    interface PromiseN<TProgress> extends Internal.PromiseBase<PromiseN<TProgress>, (progressInfo: TProgress) => void, never> {
    }
    /**
     * A promise representing an activity that may complete asynchronously. This may be a Q Promise, or
     * any other object that is compliant with the Promises/A+ spec {@link http://promises-aplus.github.io/promises-spec/}.
     */
    interface PromiseVN<TValue, TProgress> extends Internal.PromiseBase<PromiseVN<TValue, TProgress>, (progressInfo: TProgress) => void, TValue> {
    }
}
declare module MsPortalFx.Base.Promises {
    import CanceledError = MsPortalFx.Errors.CanceledError;
    /**
     * Promise states constants.
     */
    module PromiseStates {
        /**
         * Fulfilled.
         */
        const fulfilled = "fulfilled";
        /**
         * Rejected.
         */
        const rejected = "rejected";
    }
    /**
     * Wraps a promise to make to make it cancelable.
     * Does not call catch or finally handlers when canceled.
     * See also makeCancelable which does the same with different semantics.
     *
     * Creates a wrapper class around the underlying promise that handles calls to
     * then, progress, finally, and catch.  The wrapper is returned to look like the same
     * type as the underlying promise.  However, method calls beyond those mentioned
     * previously will crash.
     *
     * The wrapper verifies cancelation status before calling any handler attached.  If
     * the status is canceled it will not call the handler.
     *
     * Cancelation does not effect the promise resolution.  If the promise was succeeding
     * when canceled the chained promises will be resolved successfully without calling
     * the handlers.  If the promise was failing when canceled the chainded promises will
     * be rejected with the failure and the handlers will not be called.
     *
     * Here are the semantics in code form:
     *
     * wrapWithCancelablePromise(promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will not be called if the cancelationToken is canceled before it
     * }).finally(() => {
     *     // Cleanup that will not be called if the cancelationToken is canceled before it
     * });
     *
     * @param underlyingPromise Promise to add cancelation to.
     * @param cancelationToken Cancellation token.
     * @return Cancelable promise.
     */
    function wrapWithCancelablePromise<T extends PromiseV<any>>(underlyingPromise: T, cancelationToken: CancelationToken): T;
    /**
     * Wraps a promise to make to make it cancelable.
     * Calls catch and finally handlers when canceled.
     * See also wrapWithCancelablePromise which does the same with different semantics.
     *
     * Creates a deferred promise that wraps the underlying promise results.  The returned
     * promise is a Q promise.  The promise will return similarly cancelable promises
     * for each fulfillment or progress handler that is attached.  Catch and finally handlers
     * will not be cancelable and stop the cancelable promise chain.
     *
     * This method aggresively cancels promises.  When canceled all pending chained promises
     * are immediately rejected with a cancelation error.  Work that is pending will keep running
     * to completion or failure but will not change the promise resolution.
     *
     * Here are the semantics in code form:
     *
     * makeCancelable(promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will be called if there is a failure or cancelation.
     *     // When canceled the error will be an MsPortalFx.Errors.CanceledError as specified by token.cancel(error)
     * }).finally(() => {
     *     // Cleanup that will always be called
     * });
     * or
     * makeCancelable(() => promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will be called if there is a failure or cancelation.
     *     // When canceled the error will be an MsPortalFx.Errors.CanceledError as specified by token.cancel(error)
     * }).finally(() => {
     *     // Cleanup that will always be called
     * });
     *
     * If you have cleanup where you need to do one thing if successful and another if failed/canceled you can
     * attach a then(fulfill, reject) with both fulfill and reject handlers.  Specifying the reject handler will
     * terminate the cancelable chain.
     *
     * @param promiseOrTaskToExecuate
     *     If type is a Promise to add cancelation to.
     *     If Type is a function < taskToExecute () => Promise> to add cancelation to.  Note: If cancelation token is already canceled, it make sure taskToExecute will not be executed.
     * @param cancelationToken Cancellation token.
     * @return Cancelable promise.
     */
    const makeCancelable: <T>(promiseOrTaskToExecute: PromiseV<T> | (() => PromiseV<T> | T), cancelationToken: MsPortalFx.Base.Promises.CancelationToken) => Q.Promise<T>;
    /**
     * Cancels the promise if the lifetime is disposed or null prior to resolution or rejection.
     *
     * If canceled the promise will be rejected with MsPortalFx.Errors.CancelationError.
     * @param lifetime The lifetime that causes cancelation.  May be null indicating the lifetime was already disposed.
     * @param promiseOrTaskToExecuate
     *     If type is a Promise to add cancelation to.
     *     If Type is a function <taskToExecute: () => PromiseV<T>> to add cancelation to.  If cancelation token is already canceled, it make sure taskToExecute will not be executed.
     * @param message The cancelation error message.
     * @return Promise that will be rejected with a CancelationError if disposed before the promise parameter is resolved or rejected.
     */
    function cancelOnDispose<T>(lifetime: MsPortalFx.Base.LifetimeManager, promiseOrTaskToExecute: PromiseV<T> | (() => PromiseV<T> | T), message?: string): Q.Promise<T>;
    /**
     * An object that defines whether or not its associated CancelablePromise instances
     * have been canceled. Once the 'canceled' flag is set, it cannot be unset.
     */
    class CancelationToken {
        /**
         * Gets the cancellation reason.
         */
        cancelation: KnockoutReadOnlyObservable<CanceledError>;
        /**
         * True if the associated CancelablePromise instances have been canceled; false otherwise.
         */
        get canceled(): boolean;
        /**
         * Ensures the CancelationToken has been set so that associated CancelablePromise instances have been canceled.
         *
         * @param cancelation Optional error for specifying the cancelation when using makeCancelable.
         * @return The first cancelation applied.
         */
        cancel(cancelation?: CanceledError): CanceledError;
    }
}

// FILE: MsPortalFx\Base\Base.ProxiedObservables.d.ts
declare module MsPortalFx.Base.ProxiedObservables {
    /**
     * Gets an object to used to store data for the given object. Returns undefined if no object can be provided.
     *
     * @param obj The object with which the returned object is associated.
     * @return An object.  Can be null if metadataContainer is null;
     */
    const dataContainer: (obj: any) => StringMap<any>;
    /**
     * Gets an object to used to store disposable data for the given object. Returns undefined if no object can be provided.
     *
     * @param obj The object with which the returned object is associated.
     * @return An object.  Can be null if metadataContainer is null;
     */
    const disposableDataContainer: (obj: any) => StringMap<Disposable>;
    /**
     * Returns data from the given object with the given key.
     * Or Set value for the given object with the given key.
     *
     * @param obj The object with which the returned object is associated.
     * @param key The key for the data.
     * @param value The value to write.
     * @return The value.
     */
    const data: (obj: any, key: string, value?: any) => any;
    /**
     * Returns data from the given object with the given key.
     * Or Set value for the given object with the given key.
     *
     * @param obj The object with which the returned object is associated.
     * @param key The key for the data.
     * @param value The value to write.
     * @return The value.
     */
    const disposableData: <T extends Disposable>(obj: any, key: string, value?: T) => T;
    /**
     * Marks an object as non-serializable. An error is raised for non-serializable objects that are proxied across.
     *
     * @param obj The object to be marked non-serializable.
     */
    function markNonSerializable(obj: Object): void;
}

// FILE: MsPortalFx\Base\Base.ProxiedObservablesV2.d.ts
declare module FxImpl.Po {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    export interface ObservableMutation {
        count: number;
        history?: ChangeDescriptor[];
    }
    /**
     * WeakMapShim is a implementation of the WeakMap wrapper.
     * WeakMapShim.create play the trick for it.
     *  In the debug mode, it provide better tracking data.
     *  In non debug mode, it provide the fall back on the browser which doesn't support Weakmap.
     *
     * @param obj The object to be marked non-serializable.
     */
    export interface WeakMapLike<TKey extends object, TValue> {
        get(obj: TKey): TValue;
        set(obj: TKey, container: TValue): void;
    }
    export const enum PropertyFreezeLevel {
        None = 0,
        NotDeletable = 1,
        ReadOnly = 2
    }
    export interface MetadataContainerBase {
        /**
         * When this property is been set, the corresponding object cannot be serialize.
         */
        isNonSerializableCallStack?: string;
        /**
         * This flag indicates whether remote mutation is disallowed.
         */
        disallowRemoteMutations?: boolean;
    }
    /**
     * Specifies the promise state.
     */
    export const enum PromiseState {
        Pending = 0,
        Resolved = 1,
        Rejected = 2,
        Max = 3
    }
    /**
     * Specifies the data type of the serialized data.
     */
    const enum DataType {
        Observable = 0,
        ObservableArray = 1,
        Error = 2,
        Object = 3,
        Date = 4,
        RegExp = 5,
        Promise = 6,
        Deferred = 7,
        Function = 10,
        Array = 11,
        Computed = 12,
        ArrayBuffer = 13,
        Removed = 14,
        Max = 15
    }
    /**
     * Specifies how an array element was modified with respect to the array.
     */
    export const enum ArrayChangeKind {
        /**
         * The element was added.
         */
        Added = 0,
        /**
         * The element was deleted.
         */
        Deleted = 1
    }
    /**
     * Defines the metadata data structure.
     * In one iframe, one object have only one metadata.
     *
     */
    export interface Metadata extends MetadataContainerBase {
        /** Metadata also been used to store original array. When serializing observable array, Po will
         * shallow clone its underlying array and save it to metadata, we call it original array, the
         * original array will be used when handle array change.
         *   For example:
         *   1. var arr1 = ko_observableArray([1, 2]);
         *   2. When serializing arr1, Po will save [1, 2] to its metadata:
         *        metadata[poManager.arrayId] = originalArray;
         *   3. When observableArray been updated:
         *        arr1.push(3);
         *   4. PoManager will compare arr1.peek() with originalArray and get the differences
         *   5. PoManager will send the differences to another po:
         *        [{ k: add, i: 2, v: ["3"]]
         */
        [key: string]: any | any[];
        /**
         * The id that identifies this proxied object. One object have unique id within browser.
         */
        id: string;
        /**
         * The desired value when apply observable change.
         */
        desiredValue?: any;
        disallowRemoteMutations?: boolean;
        /**
         * This map is used to store all array's owners. When an array been set to observable, the observable become the owner of that array.
         * One array can belong to multiple observables, one observable can only own one array.
         *
         * For example:
         *   const arr = [];
         *   const ob = ko.observable(arr); // ob is the owner of arr
         *
         * This property is only applicable in development mode and only applies to arrays.
         */
        arrayOwners?: StringMap<string>;
    }
    /**
     * Defines the jquery promise value metadata data structure.
     */
    export interface JQueryPromiseValueMetadata {
        value?: any;
    }
    /**
     * Defines serialization result.
     */
    export interface SerializationResult extends Array<any> {
    }
    /**
     * Defines release event descriptor.
     * Use abbreviations because this object been sent across iframes
     *
     * The lifecycle of gc:
     *  1. Primary Po starts gc process, loops map and finds out all objects which doesn't referenced by rootObject.
     *  2. Primary Po sends pending disposed object ids (iIds) to secondary Po.
     *  3. Secondary Po dispose objects and sends cIds to Primary Po.
     *  4. Primary Po disposes pending disposed objects.
     */
    export interface ReleaseEventDescriptor {
        /**
         * The root object id.
         * This property being used to release the single root object, when
         * this property set, all other property will be undefined. for example: {rId:"00-0.content.title"}
         */
        rId?: string;
        /**
         * The initial ids.
         */
        iIds?: string[];
        /**
         * The confirmed ids.
         */
        cIds?: string[];
    }
    /**
     * Defines release event descriptor.
     * Use abbreviations because this object been sent across iframes
     * The description of a change of an array, this interface been used inside ChangeDescriptor.
     */
    export interface ArrayChange {
        /**
         * The array change kind
         * How the array element was changed.
         */
        k: ArrayChangeKind;
        /**
         * The index indicate where the array element was changed.
         */
        i: number;
        /**
         * The new value of the array element if the element was added.
         */
        v?: SerializationResult;
    }
    /**
     * Defines a change of an observable/observableArray.
     * Use abbreviations because this object been sent across iframes
     */
    export interface ChangeDescriptor {
        /**
         * The proxied observable object id, this value is unique within browser.
         */
        id: string;
        /**
         * The new object change (set to observable), this property being used when observable updated.
         */
        o?: SerializationResult;
        /**
         * The array changes, this property being used when observable array updated.
         */
        a?: ArrayChange[];
        /**
         * The full array, this property being used to recover observable array after simultaneous changes.
         */
        fa?: SerializationResult[];
        /**
         * The change number of the observable/observable array.
         */
        cn: number;
        /**
         * The serial number of the observable array.
         * It's undefined by default, this number will incremental update when there is simultaneous change
         */
        sn?: number;
    }
    /**
     * Defines promise event descriptor.
     * Use abbreviations because this object been sent across iframes
     */
    export interface PromiseEventDescriptor {
        /**
         * The promise id, this value is unique within browser
         */
        id: string;
        /**
         * The promise state
         */
        s: PromiseState;
        /**
         * The promise value
         */
        v?: SerializationResult;
    }
    /**
     * Defines function invocation descriptor.
     * Use abbreviations because this object been sent across iframes
     */
    export interface ProxyFunctionInvocationDescriptor {
        /**
         * The function call id.
         * One function can be called multiple times in a short period of time, use funcCallId to identify the different calls.
         */
        cid: string;
        /**
         * The function id, this value is unique within browser
         */
        fid: string;
        /**
         * "this" pointer of the function call.
         */
        t: SerializationResult;
        /**
         * The function call arguments.
         */
        a: SerializationResult[];
    }
    /**
     * The common interface that all promise implementations share
     */
    export interface AnyPromise<T = void> {
        /**
         * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
         * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed until the promise returned from callback is finished.
         */
        finally(finallyCallback: () => any): AnyPromise<T>;
        /**
         * The then method from the Promises/A+ specification, with an additional progress handler.
         */
        then<TResult>(onFulfill: (value: T) => TResult | AnyPromise<never>, onReject?: (reason: any) => TResult): AnyPromise<TResult>;
        then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value?: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): AnyPromise<TResult1 | TResult2>;
        /**
         * A sugar method, not avaiable on native promises
         */
        progress?(onProgress: (progress: any) => any): AnyPromise<T>;
    }
    /**
     * The common interface that any deferred implementation exposes
     */
    export interface AnyDeferred<T> {
        promise: AnyPromise<T>;
        resolve(value?: T | AnyPromise<T>): void;
        reject(reason?: any): void;
        /**
         * Native promises do not implement notify so this is a optional property
         */
        notify?(value?: any): void;
    }
    export const enum PromiseImplementationType {
        NativePromise = 0,
        Q = 1,
        JQuery = 2
    }
    export interface PromiseAdapter {
        /**
         * The data type
         */
        type: DataType.Deferred | DataType.Promise;
        /**
         * The implementation type
         * This is used to recreate the same promise implementation in the client
         */
        implementation: PromiseImplementationType;
        deferred: AnyDeferred<any>;
        promise: AnyPromise<any>;
        getState(): PromiseState;
        getValue(): any;
        always(finallyCallback: (value: any) => any): void;
    }
    export const enum ExceptionCode {
        UnsupportedPromiseCompleteState = 100,
        UnsupportedPromiseState = 101,
        UnsupportedAdapterPromiseState = 102,
        UnsupportedFunctionResultKind = 103,
        UnsupportedReferenceDataType = 104,
        UnsupportedDataTypeForSerialization = 105,
        UnsupportedArrayChangeKind = 106,
        UnsupportedFixupDataType = 107,
        UnsupportedDataTypeForDeserialization = 108,
        FailedToReleaseRootObject = 202,
        FailedToGetPromiseValue_CannotFindMetadata = 203,
        FailedToApplyObservableChange_InvalidDescriptor = 204,
        FailedToApplyRelease_InvalidDescriptor = 205,
        FailedToReleaseRootObject_TheInputIsNotARootObjectId = 206,
        FailedToGetObject_ObjectHasBeenFreed = 207,
        FailedToInvokeFunction_DeserializeThisFailed = 209,
        FailedToDecide_PrimaryLocalWindowIdEqualsToRemoteWindowId = 210,
        FailedToReset_SomePoNotBeenDispose = 211,
        FailedToDeserialize_ObjectHasBeenReleased = 212,
        FailedToDeserialize_CircularReferenceDetected = 213,
        FailedToDeserialize_CannotFindPrototype = 214,
        FailedToApplyObservableChange_DisallowRemoteMutations = 216,
        FailedToSerialize_ObjectIsNonSerializable = 217,
        FailedToDeserialize_InputIsNotValid = 218,
        FailedToSerialize_ObjectMetadataIsNotClean = 219,
        CannotFindObject_onFunctionPromise = 220,
        CannotFindObject_ApplyPromiseChanges = 221,
        CannotFindObject_ProxyFunction = 222,
        CannotFindObject_ApplyChange = 224,
        CannotFindObject_InvokeFunction = 225,
        CannotFindObject_IsDisallowRemoteMutations = 226,
        FailedToSerialize_ObjectUsedReservedCharacterAsKey = 227,
        FailedToSerialize_ObjectUsedReservedCharacterAsValue = 228,
        FailedToSerialize_DisallowRemoteMutationsCannotBeChangedFromTrueToFalse = 229,
        FailedToMoveObject_ConfirmSecondaryPoGc = 231,
        CannotFindObject_FixupObject = 232,
        CannotFindObject_FixupObservableOrObservableArray = 233,
        CannotFindObject_FixupDeferredOrPromise = 234,
        CannotFindMetadata_HandleUnderlyingArrayChanges = 235,
        CannotFindMetadata_PromiseProgress = 236,
        CannotFindMetadata_PromiseAlways = 237,
        CannotFindMetadata_ApplyPromiseChanges = 238,
        CannotFindMetadata_Release = 239,
        CannotFindMetadata_ApplyObservableArrayChanges = 240,
        FailedToSerialize_EncounteredException = 241,
        FailedToApplyPromiseChange_DisallowRemoteMutations = 242,
        CannotFindObject_FixupArray = 243,
        FailedToApplyPromiseChange_PromiseHasBeenResolvedOrRejected = 244,
        CannotFindObject_DeserializeObject = 245,
        CannotFindMetadata_RecordObservableChange = 246,
        DetectedSimultaneousChange = 301,
        DetectedCycleSubscription = 302,
        DetectedNonArrayValueInObservableArray = 303,
        DetectedProxyBufferedChangesDidNotBeenCalled = 305,
        DetectedProxiedArrayBeenModified = 306,
        DetectedObservableMutatedInefficiently = 307,
        DetectedArrayOwnersIsNull = 308
    }
    /**
     * The serialization result contains all data, which including password as well
     * Use this function to remove all strings from serialization result. The result can be safely log
     * @param serializationResult
     */
    function removeUserStringValues(serializationResult: SerializationResult): SerializationResult;
    function isIgnoredSimultaneousErrorBucketId(bucketId: string): boolean;
    function handleException(exceptionCode: ExceptionCode, detailMessage: string, parameter?: any, logOnly?: boolean): void;
    function hasFreed(poManager: ProxiedObjectManager, id: string): boolean;
    export interface FunctionCallMetadata {
        promise: PromiseAdapter;
        objs: any[];
    }
    /**
     * Execute garbage collect in primary po manager.
     *
     * The lifecycle of gc:
     *  1. Primary Po starts gc process, loops map and finds out all objects which doesn't referenced by rootObject.
     *  2. Primary Po sends pending disposed object ids (iIds) to secondary Po.
     *  3. Secondary Po dispose objects and sends cIds to Primary Po.
     *  4. Primary Po disposes pending disposed objects.
     */
    function executeGc(poManager: ProxiedObjectManager, immediate?: boolean): void;
    /**
     * Provides functions that serialize and deserialize object.
     * - One iframe can have multiple poManager instances.
     * - One connection must have two poManager instance, one in each iframe.
     * - In one iframe, one object can belong to multiple poManagers.
     */
    export class ProxiedObjectManager {
        /**
         * The new reference count. This property is only valid in primary PO.
         * This number increase after every object/array/function being added to the PO, it will be set to 0 after gc.
         */
        nc: number;
        /**
         * The disposed root object count. This property is only valid in primary PO.
         * This number increase after every root object been disposed, it will be set to 0 after gc.
         */
        dc: number;
        disposed: boolean;
        /**
         * One ProxiedObjectManager has one id, and the id is unique across the entire web browser.
         * It's also the prefix of all object ids which serialized by this ProxiedObjectManager.
         */
        id: string;
        /**
         * The changeNumberId, one ProxiedObjectManager has one changeNumberId, and the changeNumberId is unique across the entire web browser.
         * The changeNumberId be used to get/set observable changeNumber, the usage is like: metadata[poManager.changenumber];
         *
         * For example:
         *  1. There are two ProxiedObjectManagers in one iframe, po1 and po2
         *  2. The po1.changeNumberId = "c-1", po2.changeNumberId = "c-2".
         *  3. One knockout observable belongs to both po1 and po2. Mostly, this observable have different change numbers in different po Managers.
         *  3. This observable's metadata will look like metadata = {id:"13","c-1":19,"c-2":3}.
         *  4. metadata[po1.changeNumberId] will return its changeNumber in po1, metadata[po2.changeNumberId] will return its changeNumber in po2.
         */
        cnId: string;
        /**
         * The serialId, one ProxiedObjectManager has one serialId, and the serialId is unique across the entire web browser.
         * The serialId be used to get/set the observable serial number, the usage is: metadata[poManager.lostSyncId] = true;
         */
        sId: string;
        /**
         * The arrayId, one ProxiedObjectManager has one arrayId, and the arrayId is unique across the entire web browser.
         * The arrayId be used to get/set original array from metadata
         */
        aId: string;
        /**
         * The knockout subscription id, one ProxiedObjectManager has one koSubId, and the koSubId is unique across the entire web browser.
         * The koSubId be used to get/set knockout subscription to pureComputed object
         */
        kId: string;
        /**
         * The promise subscription id, one ProxiedObjectManager has one promise self inflicted number id, and the promiseSId is unique across the entire web browser.
         * The promise subscription id be used to get/set promise self inflicted number. The self inflicted number design is the same as POv1.
         */
        pId: string;
        /**
         * Indicate whether current poManager is primary. One connection must have two poManagers, one is primary and another is secondary.
         *
         * The differences between primary poManager and secondary poManager:
         *   1. Only primary poManager triggers gc() and logs GC telemetry
         *   2. When there is a simultaneous change, apply the value from primary poManager, discard the value from secondary poManager
         */
        isPrimary: boolean;
        raiseRemoteException: Action1<string | Error>;
        /**
         * The change listener
         */
        onChange: Action1<ChangeDescriptor>;
        /**
         * The promise listener
         */
        onPromise: Action1<PromiseEventDescriptor>;
        /**
         * The proxy function invocation listener
         */
        onFunction: Action1<ProxyFunctionInvocationDescriptor>;
        /**
         * The release listener
         */
        onRelease: Action2<ReleaseEventDescriptor, void>;
        /**
         * The operation history
         */
        ops: any[];
        /**
         * A hash-table to have one to one mapping between objectId and object.
         * Object won't be collected by WebBorwser when it belongs to map. The purpose of ProxiedObjectManager.gc() is to remove unused objects from map.
         */
        map: StringMap<any>;
        pending: StringMap<any>;
        roots: StringMap<any>;
        receivedChanges: StringMap<number>;
        funcCalls: StringMap<FunctionCallMetadata>;
        freedIds: string[];
        revivedIds: StringMap<any>;
        /**
         * The remote window id, used for log
         */
        rWinId: string;
        /**
         * Generate id function
         */
        gId: Func<string>;
        /**
         * Generate function call id function
         */
        gFuncCallId: Func<string>;
        /**
         * The gc interval handle.
         * This property is only been set in primary PO.
         */
        gcH: number;
        /**
         * The gc initialIds from primary po
         * This property is only been set in secondary po
         */
        gcIIds: string[];
        /**
         * A map to have gc initialIds
         * This property is only been set in secondary po
         */
        gcIIdMap: StringMap<boolean>;
        /**
         * The last GC timer.
         * This property is only been set in primary PO, the timer start when GC completed.
         */
        gcLt: Func<number>;
        /**
         * Indicate whether current gc is immediate GC, this value will be log to GC telemetry
         * This property is only been set in primary PO.
         */
        gcI: boolean;
        /**
         * The telemetry trace key, this property is only valid in primary PO.
         * This property is only been set in primary PO.
         */
        gcTk: string;
        changeListener: FxImpl.Rpc.ChangeListener;
        constructor();
        /**
         * Serialize the input data.
         * Below is the required pattern to call serialize() function
         *    1. const result = poManager.serialize(data);
         *    2. proxy(result)
         *    3. poManager.proxyingBufferedChanges()
         *
         * @param data The input data to be serialized
         * @param disallowRemoteMutations Indicate whether the knockout observable updates can come from the remote object.
         * @param fullFreezeInDevMode Indicate whether full freeze the object. When this property set to true, PO will execute Object.preventExtensions(data).
         *        The "fullFreezeInDevMode" only been used in dev mode. Below is the pseudo code in PO:
         *          if (developmentMode && enableDiagnostics) {
         *              if (fullFreezeInDevMode) {
         *                  Object.freeze(data);
         *                  Object.preventExtensions(data);
         *              } else {
         *                  Object.freeze(data);
         *              }
         *           }
         */
        serialize(data: any, disallowRemoteMutations?: boolean, fullFreezeInDevMode?: boolean): SerializationResult;
        /**
         * Proxy buffered changes. This function must be called after serialization completed.
         * Serialization may trigger chanegs, those changes will be buffered. e.g.
         *    var object = {
         *        observable: ko.observable(1),
         *        computed: ko.pureComputed(() => {
         *            object.observable(2); // object.observable will be updated during serialization
         *        })
         *    };
         *
         *   serialize(object)
         */
        proxyBuffer(): void;
        deserialize(encodedData: SerializationResult, remoteWindowId?: string): any;
        applyPromise(descriptor: PromiseEventDescriptor): void;
        applyChange(descriptor: ChangeDescriptor): void;
        applyRelease(descriptor: ReleaseEventDescriptor): void;
        invoke(descriptor: ProxyFunctionInvocationDescriptor): void;
        /**
         * Release an input object. In Pov2, release function can only release rootObject.
         * For example: after user closed a blade, this method will been called multiple times to release all PartViewModels.
         * @param object The input object to be released
         */
        release(object: any): void;
        /**
         * Dispose poManager and its references
         */
        dispose(): void;
    }
    function decidePrimary(localWindowId: string, remoteWindowId: string): boolean;
    export function createPoMgr(metadataIdPrefix: string, raiseRemoteException: Action1<MsPortalFx.Errors.Error>, changeListener: Action2<ChangeDescriptor, void>, promiseEventListener: Action2<PromiseEventDescriptor, void>, proxyFunctionInvocationListener: Action2<ProxyFunctionInvocationDescriptor, void>, releaseListener: Action2<ReleaseEventDescriptor, void>, localWindowId: string, remoteWindowId: string, notScheduleGc?: boolean): ProxiedObjectManager;
    /**
     * Once an object been serialized/deseialized. poManager will generate a metadata and save the
     * entire entry to metdataMap. This function allows external module get metadata by object
     * @param obj The input object.
     * @returns The metadata of input object.
     */
    export function getMetadata(obj: any): Metadata;
    export function getMetadataId(obj: any): string;
    /**
     * Get or create empty metadata
     * @param obj The input object.
     * @returns The metadata of input object.
     */
    export function getOrCreateMetadata(obj: any): Metadata;
    /**
     * Marks that the given object is disallowed from being mutated by its remote copy.
     */
    export function disallowRemoteMutations(obj: any): void;
    export interface Options {
        enableCompatibilityMode?: boolean;
        enableDiagnostics?: boolean;
        periodicGcIntervalInMs?: number;
        periodicGcThreshold?: number;
        immediateGcThreshold?: number;
        enableGcTelemetry?: boolean;
        disableObservableMutationPerformanceCheck?: boolean;
    }
    export const exportForDevMode: {
        bucketIdRegex: RegExp;
        bucketIdReplacement: string;
        splitter: string;
        removeUserStringValues: typeof removeUserStringValues;
        log: FxBase.Diagnostics.Log;
        hasFreed: typeof hasFreed;
        handleException: typeof handleException;
        isIgnoredSimultaneousErrorBucketId: typeof isIgnoredSimultaneousErrorBucketId;
        gc: typeof executeGc;
        decidePrimary: typeof decidePrimary;
        observableMutationWarningLimit: number;
        options: {
            enableCompatibilityMode: boolean;
            enableDiagnostics: boolean;
            periodicGcIntervalInMs: number;
            periodicGcThreshold: number;
            immediateGcThreshold: number;
            enableGcTelemetry: boolean;
        };
        createPromiseAdapter: (promiseOrDeferred: any) => PromiseAdapter;
        getMetadataByPoManager: (obj: any, poManager: Po.ProxiedObjectManager) => Metadata;
        override: (options: Options) => void;
        resetOptions: () => void;
        reset: () => void;
        isDisallowRemoteMutations: (object: any) => boolean;
        getObservableMutationsInCurrentTick: () => StringMap<ObservableMutation>;
    };
    /**
     * Return some objects and variables for diagnostics purpose.
     */
    export function getDiagnostics(): {
        compatibilityMode: boolean;
        diagnostics: boolean;
        metadataMap: WeakMapLike<Object, Metadata>;
        jQPromise: WeakMapLike<Object, JQueryPromiseValueMetadata>;
        managers: ProxiedObjectManager[];
    };
    export {};
}

// FILE: MsPortalFx\Base\Base.QExtensions.d.ts
declare module Q {
    interface Promise<T> {
        /**
         * Catches errors that are instances of the specified error type.
         * If not of the specified type the error continues to propagate.
         *
         * Works for all errors of type Error and derivations of Error
         * on non-proxied promises.  For proxied promises it will only
         * work on errors of types deriving from MsPortalFx.Errors.Error.
         *
         * .catchError(MsPortalFx.Errors.CanceledError, (error) => {
         *     // error is a CanceledError of somthing deriving from it
         * })
         *
         * @param errorType The type of errors to catch.
         * @param onError The error handler.
         * @return Promise that is resolved or rejected according to the error handler.
         */
        catchError<U, E extends MsPortalFx.Errors.Error>(errorType: MsPortalFx.Errors.ErrorType<E>, onError: (error: E) => U | IPromise<U>): Promise<U>;
    }
}
declare module FxImpl.QExtensions {
}

// FILE: MsPortalFx\Base\Base.Resources.d.ts
declare module MsPortalFx {
    module Base.Resources {
        function initialize(): void;
        /**
         * Gets the image URIs from the given node using the image root.
         *
         * @param node The node which contains the node image strings.
         * @return Copy of the node with the node image strings converted to URIs.
         */
        function getImages<T>(node: T): T;
        /**
         * Returns whether the given URI is an absolute URI.
         *
         * @param uri The URI.
         * @return A boolean value indicating whether the URI is absolute.
         */
        const isUriAbsolute: typeof MsPortalFx.isUriAbsolute;
        /**
         * Gets the path to the named content.
         *
         * @param uri The uri of the content.
         * @param coerceAbsoluteUri Forces the returned uri to be an absolute uri. The default value is true.
         * @return The uri.
         */
        function getContentUri(uri: string, coerceAbsoluteUri?: boolean): string;
        /**
         * Gets the path to the named script file
         *
         * @param uri The uri of the script file.
         * @return The uri.
         */
        function getScriptUri(uri: string): string;
        /**
         * Gets the path to the application relative uri.
         *
         * @param uri The application relative uri.
         * @return The uri.
         */
        function getAppRelativeUri(uri: string): string;
        /**
         * Gets the absolute uri from the given uri.
         *
         * @param uri The application relative uri.
         * @return The uri.
         */
        function getAbsoluteUri(uri: string): string;
        /**
         * Gets the path to the named content with the version segment.
         *
         * @param uri The uri of the content.
         * @param coerceAbsoluteUri Forces the returned uri to be an absolute uri. The default value is true.
         * @return The uri.
         */
        function getVersionlessContentUri(uri: string, coerceAbsoluteUri?: boolean): string;
        /**
         * Internal only. For use by Resource generation code.
         */
        function _getImageMap(fileHierarchy: Array<any>, className: string): StringMap<string>;
    }
    /**
     * Internal only. For use by Resource generation code.
     */
    const getImages: typeof Base.Resources._getImageMap;
}

// FILE: MsPortalFx\Base\Base.Rpc2.d.ts
declare module FxImpl.Rpc {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import Diagnostics = FxBase.Diagnostics;
    import LifetimeManager = FxBase.LifetimeManager;
    import TelemetryContextInternal = FxImpl.TelemetryContext;
    import Disposable = FxBase.Disposable;
    import Po = FxImpl.Po;
    export const enum Constants {
        RegistrationTimeoutInMs = 30000,
        RpcCallTimeoutInMs = 300000,
        WindowUnloadTimeoutInMs = 240000
    }
    const enum RoutedMessageKind {
        TransferPort = 0,
        Reset = 1,
        Shutdown = 2,
        Exception = 3,
        Log = 4,
        RefCount = 5,
        StatelessRpcInvoke = 6,
        StatelessRpcReturn = 7,
        StatelessRpcError = 8,
        PoAcquireObjectRequest = 9,
        PoAcquireObjectResponseError = 10,
        PoConnectionEvent = 11,
        _ = 12
    }
    export interface MessageContext {
        readonly callStack: string;
        readonly srcWindowId: string;
        readonly destWindowId: string;
    }
    export interface HandlerContext<TPort> extends MessageContext {
        readonly srcInstanceIndex: number;
        readonly ltm: MsPortalFx.Base.LifetimeManager;
        readonly port: TPort;
    }
    export interface HandlerPortObject<TMetadata, TObject> {
        readonly metadata: TMetadata;
        readonly obj: ReadonlyArray<TObject>;
    }
    export interface HandlerPort<THandlerData, TInvokerData, TProxiedObject> {
        transferObjects(handlerData: THandlerData, proxiedObjects: ReadonlyArray<TProxiedObject>): void;
        releaseObject(obj: any): void;
        onMessage(handler: (metadata: TInvokerData) => void): void;
    }
    export interface InvokerPort<TInvokerData, THandlerData, TProxiedObject, TValue> {
        readonly value: TValue;
        readonly isChannelEnabled: boolean;
        postMessage(msg: TInvokerData): void;
        onObject(handler: (obj: HandlerPortObject<THandlerData, TProxiedObject>) => void): void;
        dispose(): void;
        onDispose(callback: Action1<TValue>): void;
    }
    interface MultiplexedMessage<TKind> {
        readonly kind: TKind;
        readonly data: any;
    }
    interface RoutedMessage extends MessageContext {
        readonly srcInstanceIndex: number;
        readonly data: MultiplexedMessage<RoutedMessageKind>;
    }
    export interface MessageEventLike<T> {
        readonly data: T;
        readonly ports: ReadonlyArray<MessagePort>;
    }
    export interface MessagePortLike<T> {
        postMessage(message: T, transferList?: MessagePort[]): void;
        onmessage: (evt: MessageEventLike<T>) => void;
        close(): void;
    }
    export let messageContext: MessageContext;
    export function createCallStack(stack: string, context?: MessageContext, endPointName?: string): string;
    export function getCurrentCallStack(force?: boolean): string;
    export class DisposableValue<T> implements Disposable {
        readonly value: T;
        private _disposeCallbacks;
        constructor(value: T);
        private getValue;
        dispose(): void;
        onDispose(callback: Action1<T>): void;
    }
    export class RpcChannel<T> extends DisposableValue<MessagePortLike<T>> {
        private readonly _port;
        constructor(_port: MessagePortLike<T>);
        onMessage(onmessage: (evt: MessageEventLike<T>) => void): void;
        postMessage(message: T, transferList?: MessagePort[]): void;
    }
    export interface FuncEndPointHandler<T, R, TConnection> {
        (arg: T, handlerContext: HandlerContext<TConnection>, ltm: LifetimeManager): Q.Promise<R> | Promise<R> | R;
    }
    export type AllowedOrigins = string | string[];
    export interface EndPointRegistrationOptions<T, R, TConnection> {
        /**
         * A list of extension names that can be allowed to invoke this RPC callback. If a falsey value is specific, then all extensions are allowed to invoke this callback.
         */
        readonly allowedOrigin: AllowedOrigins;
        /**
         * The callback function of the RPC callback.
         */
        readonly handler: FuncEndPointHandler<T, R, TConnection>;
    }
    export interface ProxiedObjectEndPointRegistrationOptions<T, R> extends EndPointRegistrationOptions<T, R, unknown> {
        /**
         * Indicates whether remote changes are allowed.
         */
        readonly allowRemoteChanges: boolean;
    }
    export type LoadChannelFunction = (windowId: string, instanceIndex: number) => RpcChannel<any>;
    export class MessageDispatcher<T, TContext> {
        private readonly _handler;
        private readonly _outerList;
        private readonly _sourceList;
        private _outerListIndex;
        private _innerListIndex;
        constructor(_handler: Action2<T, TContext>);
        private _processInnerList;
        private _processOuterList;
        addItem(item: ReadonlyArray<T>, source: TContext): void;
        isEmpty(): boolean;
    }
    interface Sender<TData, TDestination> {
        (data: TData, destination: TDestination): void;
    }
    export interface LogMessage {
        readonly level: Diagnostics.LogEntryLevel;
        readonly code: number;
        readonly area: string;
        readonly message: string;
    }
    interface InvokerPortMessage<T> {
        readonly connectionId: number;
        readonly data: T;
    }
    const enum HandlerPortMessageFlags {
        None = 0,
        HasInitialMessagePayload = 1,
        HasChannelMessagePayload = 2,
        IsChannelEnabled = 4
    }
    interface HandlerPortMessage {
        readonly channelObjects: ReadonlyArray<Po.SerializationResult>;
        readonly connectionId: number;
        readonly flags: HandlerPortMessageFlags;
        readonly initialObject: Po.SerializationResult;
        readonly metadata: any;
    }
    class InvokerPortContext<TInvokerData, THandlerData, TProxiedObject, TValue> extends DisposableValue<TValue> implements InvokerPort<TInvokerData, THandlerData, TProxiedObject, TValue> {
        private readonly _poMgr;
        private readonly _telemetryContext;
        private readonly _sendInvokerPortMessage;
        readonly isChannelEnabled: boolean;
        private readonly _connectionId;
        private readonly _handlerBuffer;
        private _messageHandler;
        constructor(_poMgr: Po.ProxiedObjectManager, _telemetryContext: TelemetryContextInternal.State, _sendInvokerPortMessage: Sender<InvokerPortMessage<TInvokerData>, void>, message: HandlerPortMessage);
        handleMessage(message: HandlerPortMessage): any;
        postMessage(data: TInvokerData): void;
        onObject(handler: Action1<HandlerPortObject<THandlerData, TProxiedObject>>): void;
    }
    export interface ChangeListener {
        onRemoteChange: (observable: KnockoutReadOnlyObservableBase<any>, path: string) => void;
    }
    export interface StartOptions {
        readonly instanceIndex: number;
        readonly loadChannelFunction: LoadChannelFunction;
        readonly originId: string;
        readonly shellChannel: RpcChannel<ReadonlyArray<RoutedMessage>>;
        readonly windowRedirectMap: ReadonlyStringMap<string>;
    }
    export class Client {
        private readonly _registrationTimeoutInMs;
        private _dispatcher;
        private _rpcEndPoints;
        private _poEndPoints;
        private _rpcClient;
        private _poClient;
        private _windowAcquirer;
        private _windowRedirectMap;
        constructor(_registrationTimeoutInMs: number);
        /**
         * Registers an RPC callback
         */
        registerRpcEndPoint<T, R>(name: string, options: EndPointRegistrationOptions<T, R, unknown>): void;
        /**
         * Registers an object factory function that can be used to create objects that are to be proxied to the caller.
         */
        registerObjectFactory<T, R>(name: string, options: ProxiedObjectEndPointRegistrationOptions<T, R>): void;
        log(destination: string, data: LogMessage): void;
        /**
         * Invokes an RPC callback that does return a value.
         *
         * @param name A string that uniquely identifies the object type.
         * @param destination The extension of where the object is to be acquired.
         * @param arg Arguments passed to the object factory handler.
         */
        invokeRpc<R>(name: string, destination: string, arg: any): Q.Promise<R>;
        /**
         * Acquires a proxied object from the given destination extension.
         *
         * @param name A string that uniquely identifies the object type.
         * @param destination The extension of where the object is to be acquired.
         * @param arg Arguments passed to the object factory handler.
         * @param onObjectAcquired A callback being called with the acquired object before additional messages are processed.
         */
        acquireObject<T, R, TInvokerData = void, THandlerData = void, TProxiedObject = void>(name: string, destination: string, arg: T): Q.Promise<InvokerPortContext<TInvokerData, THandlerData, TProxiedObject, R>>;
        getTotalRefCountTo(windowId: string): KnockoutObservable<number>;
        acquireWindow(windowId: string, durationInSeconds?: number): DisposableValue<void>;
        terminateWindow(windowId: string): void;
        start(options: StartOptions): void;
        reset(): void;
        dispose(): void;
        onObservableChange(lifetime: MsPortalFx.Base.LifetimeManager, destination: string, changeListener: ChangeListener): void;
        private _assertReady;
    }
    /**
     * The RPC client that can used to register and invoke RPC callbacks.
     */
    export let client: Client;
    export function start(options: StartOptions): void;
    export class EndPointDefinition {
        readonly name: string;
        constructor(name: string);
    }
    export class ActionEndPointDefinition<T> extends EndPointDefinition {
        register(client: Client, allowedOrigin: AllowedOrigins, handler: FuncEndPointHandler<T, void, unknown>): void;
        invoke(client: Client, destination: string, arg: T): Q.Promise<void>;
    }
    export class FuncEndPointDefinition<T, R> extends EndPointDefinition {
        register(client: Client, allowedOrigin: AllowedOrigins, handler: FuncEndPointHandler<T, R, unknown>): void;
        invoke(client: Client, destination: string, arg: T): Q.Promise<R>;
    }
    export class ProxiedObjectTypeDefinition<T, R> extends EndPointDefinition {
        registerObjectFactory(client: Client, options: ProxiedObjectEndPointRegistrationOptions<T, R>): void;
        acquireObject(client: Client, destination: string, arg: T): Q.Promise<DisposableValue<R>>;
    }
    export {};
}

// FILE: MsPortalFx\Base\Base.Scheduler.d.ts
declare module MsPortalFx.Base {
    function setDataPerf(enable: boolean): void;
    /**
     * devMode only test helper
     */
    function setSchedulerRunTask(newRunTask: () => Q.Promise<any>): () => Q.Promise<any>;
    /**
     * devMode only test helper
     */
    function resetSchedulerRunTask(): void;
    interface ScheduledTask {
        /**
         * Optional if delayInMs is not specified. The absolute time the task should execute.
         */
        absoluteTime?: number;
        /**
         * Optional if absoluteTime is not specified. The delay before the task executes.
         */
        delayInMs?: number;
        /**
         * Determines if the task is asynchronous.
         */
        isAsync?: boolean;
        /**
         * Name of the task.
         */
        name?: string;
        /**
         * Optional. Not compatible with absolute time. Should not be used if task is async.
         * (instead, call scheduleTask again on completion of the async task).
         * If set to true the task will be automatically rescheduled after completion (or failure).
         */
        recurring?: boolean;
        /**
         * Function to call that executes the task.
         */
        scheduledTask: Function;
        /**
         * Arguments to pass to the scheduled task.
         */
        args?: any[];
        /**
         * Optional. If true, diagnostic output for this task will not be logged.
         */
        silent?: boolean;
    }
    class Scheduler {
        /**
         * Schedules a task
         */
        static scheduleTask(task: ScheduledTask, allowDuplicates?: boolean): void;
        /**
         * Deletes a scheduled task
         */
        static deleteTask(task: ScheduledTask): void;
    }
}

// FILE: MsPortalFx\Base\Base.Security.d.ts
declare module MsPortalFx.Base.Security {
    import FxBase = MsPortalFx.Base;
    import InternalExtension = FxImpl.Extension;
    /**
     * Interface for options used to get authorization tokens.
     */
    interface GetAuthorizationTokenOptions {
        readonly resourceName: string;
    }
    /**
     * Interface for authentication tokens received by the extension.
     */
    interface AuthorizationToken {
        /**
         * The authorization header needed to make API calls to a service.
         */
        readonly header: string;
        /**
         * The time at which the token expires.
         */
        readonly expiresAt: number;
    }
    interface GetAuthorizationTokenResponse {
        /**
         * The authorization token.
         */
        readonly token?: AuthorizationToken;
        /**
         * Any errors in obtaining the token.
         */
        readonly error?: string;
        /**
         * An error details if any errors in obtaining the token.
         */
        readonly errorMessage?: string;
    }
    interface UserInfo {
        /**
         * Email name of the identity.
         */
        readonly email: string;
        /**
         * Boolean indicating if the user is an OrgID user.
         */
        readonly isOrgId: boolean;
        /**
         * The object id of the user..
         */
        readonly objectId: string;
        /**
         * The principal id of the user..
         */
        readonly principalId: string;
        /**
         * Whether or not the user is a Company Administrator
         */
        readonly isTenantAdmin: boolean;
        /**
         * First name of the identity.
         */
        readonly givenName: string;
        /**
         * Last name of the identity.
         */
        readonly surname: string;
        /**
         * The identity's directory.
         */
        readonly directoryId: string;
        /**
         * The identity's directory name.
         */
        readonly directoryName: string;
        /**
         * The identity's unique directory name, that show both directory and domain name when directory name isn't unique.
         */
        readonly uniqueDirectoryName: string;
        /**
         * The tenant's domain name.
         */
        readonly domainName: string;
        /**
         * The identity's country.
         */
        readonly countryCode: string;
    }
    /**
     * Interface for authentication tokens cache.
     */
    interface IAuthTokenCache {
        /**
         * Gets a security token needed to make API calls to a back end service.
         *
         * @param options Optional options containing the resource name of the extension wants access to.
         * @return A security token for the named service or if no such token is available undefined.
         */
        getToken(options: InternalExtension.GetAuthorizationTokenOptions): Q.Promise<AuthorizationToken>;
        /**
         * Gets the timestamp a resources token will expire at.
         *
         * @param resourceName The resource to get token expiration for.
         * @return The timestamp a token will expire at or if no such token is available undefined.
         */
        getTokenExpiresAt(resourceName: string): number;
    }
    /**
     * Creates an instance of the authentication token cache.
     *
     * @param getTokenFunc function that returns authentication tokens.
     * @param seedData initial seed data for the cache.
     * @return An instance of the authentication token cache.
     */
    function createAuthTokenCache(getTokenFunc: (options?: InternalExtension.GetAuthorizationTokenOptionsExtended) => Q.Promise<MsPortalFx.Base.Security.GetAuthorizationTokenResponse>, seedData?: StringMap<AuthorizationToken>): IAuthTokenCache;
    /**
     * Gets the security token an extension uses to make calls against
     * secured back end services.
     *
     * @param options Options that control which token is obtained.
     * @return A security token for the named service or if no such token is available undefined.
     * @remarks Do not cache or resuse the returned token as there is no way to tell when it will expire.
     *          Always calling it makes sure your extension picks up a new token when it is refreshed by the shell.
     */
    function getAuthorizationToken(options?: GetAuthorizationTokenOptions): FxBase.PromiseV<AuthorizationToken>;
    /**
     * Gets the signed in user and directory info.
     *
     * @return The info for the currently signed in user and directory.
     */
    function getUserInfo(): FxBase.PromiseV<UserInfo>;
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an entity.
     * secured back end services.
     *
     * @param entityId The entity to check for permissions. The entity ID MUST be a resource ID, a subscription ID or a resource group ID.
     * @param actions The actions being to checked.
     * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function hasPermission(entityId: string, actions: string[]): Q.Promise<boolean>;
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an asset.
     * secured back end services.
     *
     * @param assetId The asset to check for permissions. The asset MUST have an associated resource type.
     * @param actions The actions being to checked.
     * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function assetHasPermission(assetId: MsPortalFx.Assets.AssetTriplet, actions: string[]): FxBase.PromiseV<boolean>;
}
declare module FxImpl.Security {
    import FxBase = MsPortalFx.Base;
    import FxSecurity = FxBase.Security;
    import InternalExtension = FxImpl.Extension;
    import FxAuthorizationToken = FxSecurity.AuthorizationToken;
    import FxGetAuthorizationTokenResponse = FxSecurity.GetAuthorizationTokenResponse;
    const tokenErrors: {
        /**
         * Unknown error
         */
        unknown: string;
        /**
         * Extension is not allowed to get tokens
         */
        accessDenied: string;
        /**
         * The session has expired, no new tokens will be issued
         */
        sessionEnded: string;
        /**
         * The active token has expired, no new tokens can be issued
         */
        credentialsExpired: string;
        /**
         * The call to get tokens returned with a network error (status code 0).
         */
        networkError: string;
        /**
         * The user is required to use MFA.
         */
        requiresMFA: string;
        /**
         * Users account is disabled.
         */
        accountDisabled: string;
        /**
         * A null token was issued
         */
        nullToken: string;
        /**
         * The portal's requests are getting throttled by AAD
         */
        tooManyRequests: string;
    };
    /**
     * Represents the result of obtaining all tokens for an extension.
     * Note: this must match the ExtensionTokens class defined in ExtensionTokens.cs
     */
    interface ExtensionTokens {
        /**
         * The dictionary of resources and their access tokens.
         */
        readonly resourceByTokenMap: ReadonlyStringMap<FxSecurity.AuthorizationToken>;
    }
    /**
     * Internal interface for authentication tokens cache.
     */
    interface IAuthTokenCacheInternal extends FxSecurity.IAuthTokenCache {
        /**
         * Updates the resource token cache with the given list of resource tokens.
         *
         * @param extensionTokens The list of all tokens for all resources.
         * @param telemetryMarker The telemetry trace marker for logging purposes.
         */
        setAllTokensForExtensionHandler(extensionTokens: ExtensionTokens, telemetryMarker: string): void;
    }
    /**
     * Implementation for IAuthTokenCache
     */
    class AuthTokenCacheImpl implements IAuthTokenCacheInternal {
        private readonly _getTokenWorker;
        private _cachedTokenMap;
        private _stalledPromise;
        constructor(getTokenFunc: (options?: InternalExtension.GetAuthorizationTokenOptionsExtended) => Q.Promise<FxGetAuthorizationTokenResponse>, seedData?: StringMap<FxAuthorizationToken>);
        getToken(options: InternalExtension.GetAuthorizationTokenOptions): Q.Promise<FxAuthorizationToken>;
        getTokenExpiresAt(resourceName: string): number;
        /**
         * Updates the resource token cache with the given list of resource tokens.
         *
         * @param extensionTokens The list of all tokens for all resources.
         * @param telemetryMarker The telemetry trace marker for logging purposes.
         */
        setAllTokensForExtensionHandler(extensionTokens: ExtensionTokens, telemetryMarker: string): void;
        private _refreshTokenWorker;
        private _refreshTokenWorkerInternal;
    }
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an entity.
     * secured back end services.
     *
     * @param entityId The entity to check for permissions. The entity ID MUST be a resource ID, a subscription ID or a resource group ID.
     * @param actions The actions being to checked.
     * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function hasPermission(entityId: string, actions: string[]): FxBase.PromiseV<boolean>;
    const DEV: {
        getTokenRefreshBeforeExpiryTimespanInMs: () => number;
        setTokenRefreshBeforeExpiryTimespanInMs: (value: number) => void;
    };
}

// FILE: MsPortalFx\Base\Base.Themes.d.ts
declare module MsPortalFx.Base.Themes {
    const enum ThemeMode {
        Light = 0,
        Dark = 1
    }
    const enum HighContrastMode {
        Off = 0,
        Light = 1,
        Dark = 2
    }
    interface Theme {
        /**
         * Theme color code.
         */
        colorCode: string;
        /**
         * Theme sample image uri.
         */
        imageUri: string;
        /**
         * Theme sample image svg.
         */
        svg: Base.Image;
        /**
         * Theme name.
         */
        name: string;
        /**
         * Theme title.
         */
        title: string;
        /**
         * Theme mode.
         */
        mode?: ThemeMode;
    }
}

// FILE: MsPortalFx\Base\Base.UriBuilder.d.ts
declare module MsPortalFx.Base {
    /**
     * Provides basic query string manipulation functions.
     */
    class QueryStringBuilder {
        private _qs;
        private _qsMap;
        private readonly _leadingSeparator;
        /**
         * Initializes a new instance of the query string builder.
         *
         * @param qs The initial query string.
         * @param leadingSeparator The leading character of the query string. ? by default.
         */
        constructor(qs?: string, leadingSeparator?: string);
        /**
         * Removes all query string values.
         *
         * @return The QueryStringBuilder instance.
         */
        clear(): QueryStringBuilder;
        /**
         * Sets multiple parameters in the query string. Overwrites any existing values.
         *
         * @param keys The object that represents the key value pairs.
         * @return The QueryStringBuilder instance.
         */
        setParameters(keys: ReadonlyStringMap<any>): QueryStringBuilder;
        private _getParameterIndex;
        /**
         * Sets a parameter in the query string. Overwrites any existing values.
         *
         * @param key The key of the parameter.
         * @param value The value of the parameter.
         * @return The QueryStringBuilder instance.
         */
        setParameter(key: string, value: any): QueryStringBuilder;
        /**
         * Gets the value of a parameter in the query string.
         *
         * @param key The key of the parameter.
         * @return The value of the parameter. Undefined if the value doesn't exist.
         */
        getParameter(key: string): string;
        /**
         * Gets all values of the query string as a stringmap.
         *
         * @return StringMap of all query string key/value pairs.
         */
        getParameters(): StringMap<any>;
        /**
         * Removes multiple parameters from the query string.
         *
         * @param keys The keys of the parameter.
         * @return The QueryStringBuilder instance.
         */
        removeParameters(keys: string[]): QueryStringBuilder;
        /**
         * Removes a parameter from the query string.
         *
         * @param key The key of the parameter.
         * @return The QueryStringBuilder instance.
         */
        removeParameter(key: string): QueryStringBuilder;
        /**
         * Returns a string representation of the URI.
         *
         * @param includeLeadingSeparator Whether to emit the leading ?. Defaults to true.
         * @return A string representation of the URI.
         */
        toString(includeLeadingSeparator?: boolean): string;
    }
    /**
     * Provides basic URI manipulation functions.
     */
    class UriBuilder {
        private _oq;
        /**
         * Gets or sets the path part of the URI. This includes the protocol, domain, port, and virtual path.
         */
        path: string;
        /**
         * Gets or sets the query string part of the URI. This is represented as key value pairs.
         */
        query: QueryStringBuilder;
        /**
         * Gets or sets the fragment of the URI. This includes everything after the # separator in the URI.
         */
        fragment: string;
        /**
         * Initializes a new instance of the URI.
         */
        constructor(uri?: string);
        /**
         * Gets the original query string associated with the URI.
         * Avoids any data loss that might be associated with encoding/decoding of the query string.
         */
        getOriginalQuery(): string;
        /**
         * Returns a string representation of the URI.
         */
        toString(): string;
        getScheme(): string;
        /**
         * Gets the authority part of the URI (Ex: www.test.com:880).
         */
        getAuthority(): string;
        /**
         * Gets the scheme and authority part of the URI (Ex: http://www.test.com:880).
         * @param normalizeScheme Specifies whether implicit scheme/protocol should be expanded to be that of the
         * current location.
         * @return A string that covers the schema and authority of the URI.
         */
        getSchemeAndAuthority(normalizeScheme?: boolean): string;
        /**
         * Gets the relative path of the URI.
         * Ex: Given a URI http://www.test.com:880/test/mypath returns /test/mypath.
         */
        getRelativePath(): string;
        /**
         * Sets the relative path of the URI.
         * Ex: Given a URI http://www.test.com:880/test/mypath and a parameter otherPath.
         * It will change the URI to http://www.test.com:880/otherPath.
         */
        setRelativePath(relativePath: string): void;
    }
}

// FILE: MsPortalFx\Base\Base.Version.d.ts
declare module MsPortalFx.Base {
    /**
     * Runtime represention of a version number.
     */
    interface Version {
        /**
         *  The major component of the version number.
         */
        major: number;
        /**
         * The minor component of the version number.
         */
        minor: number;
        /**
         * The build component of the version number.
         */
        build: number;
        /**
         * The revision component of the version number.
         */
        revision: number;
        /**
         * Serializes this version number to a string represntion.
         * The build and revision components of the version are optional and are omitted from the string if
         * they are not defined.
         *
         * @return String represention of the version number in the format major.minor[.build[.revision]].
         */
        toString(): string;
        /**
         * Compares this instance to another version.
         *
         * @param version The version which is this instance is being compared to
         * @return 0 if both versions are the same, -1 if this instance is a smaller version, 1 if this instance is a larger version.
         */
        compareTo(version: Version): number;
    }
    /**
     * Parses a version string and returns the runtime represention of the version number.
     * Version strings are in the format "major.minor[.build[.revision]]".
     * Build and revision are optional components in the version.   major and minor are required.
     * All component values cannot be negative and must be valid integers.
     * There cannot be more than 4 components in the string.
     *
     * @param version string represention of a version.
     * @return The runtime represention of the version number.
     * @throws Will throw a Error if the string is not a valid version string.
     */
    function getVersionFromString(version?: string): Version;
    /**
     * Tries to convert the string representation of a version number to an equivalent
     * MsPortalFx.Base.Version object, and returns a result that indicates whether the conversion
     * succeeded and the version object if it did.
     *
     * A string that contains a version number to convert.
     */
    function tryParseVersion(version: string): Version;
}

// FILE: MsPortalFx\Base\Internal\Base.Diagnostics.Net.d.ts
declare module FxImpl.NetDiagnostics {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxHelpers = Fx.Helpers;
    import NetAjaxSettings = FxBase.Net2.NetAjaxSettings;
    export interface Request {
        readonly requestId: string;
        readonly commandName: string;
        readonly status: RequestStatus;
        readonly duration?: number;
        readonly size?: number;
    }
    const enum RequestStatus {
        Pending = "Pending",
        Completed = "Completed"
    }
    export interface NetworkActivityRecording {
        readonly data: ReadonlyArray<Request>;
        readonly isFinished: true;
    }
    export interface NetworkTelemetry {
        (jqXHR: FxHelpers.XMLHttpRequestLike, isError?: boolean): void;
    }
    export function startNetworkRecording(bladeInstanceId: string, onNextAjax: () => void): Func<NetworkActivityRecording>;
    export function createTelemetry<T>(settings: NetAjaxSettings<T>): NetworkTelemetry;
    export function registerTelemetrySubmissionHandler(): void;
    export function getPerformanceTelemetry(): PerformanceTelemetry;
    export function getBootstrapTelemetry(): BootstrapTelemetry;
    export {};
}

// FILE: MsPortalFx\Base\Internal\Base.Intl.d.ts
declare module MsPortalFx.Intl {
    interface NumberFormatOptions {
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        localeMatcher?: string;
        /**
         * The formatting style to use. Possible values are "decimal" for plain number formatting, "currency" for currency formatting, and "percent" for percent formatting; the default is "decimal".
         */
        style?: string;
        /**
         * The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB. There is no default value; if the style is "currency", the currency property must be provided.
         */
        currency?: string;
        /**
         * How to display the currency in currency formatting. Possible values are "symbol" to use a localized currency symbol such as €, "code" to use the ISO currency code, "name" to use a localized currency name such as "dollar"; the default is "symbol".
         */
        currencyDisplay?: string;
        /**
         * Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators. Possible values are true and false; the default is true.
         */
        useGrouping?: boolean;
        /**
         * The minimum number of integer digits to use. Possible values are from 1 to 21; the default is 1.
         */
        minimumIntegerDigits?: number;
        /**
         * The minimum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information).
         */
        minimumFractionDigits?: number;
        /**
         * The maximum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0.
         */
        maximumFractionDigits?: number;
        /**
         * The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1.
         */
        minimumSignificantDigits?: number;
        /**
         * The maximum number of significant digits to use. Possible values are from 1 to 21; the default is minimumSignificantDigits.
         */
        maximumSignificantDigits?: number;
    }
    interface DateTimeFormatOptions {
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        localeMatcher?: string;
        /**
         * The representation of the weekday. Possible values are "narrow", "short", "long".
         */
        weekday?: string;
        /**
         * The representation of the era. Possible values are "narrow", "short", "long".
         */
        era?: string;
        /**
         * The representation of the year. Possible values are "numeric", "2-digit".
         */
        year?: string;
        /**
         * The representation of the month. Possible values are "numeric", "2-digit", "narrow", "short", "long".
         */
        month?: string;
        /**
         * The representation of the day. Possible values are "numeric", "2-digit".
         */
        day?: string;
        /**
         * The representation of the hour. Possible values are "numeric", "2-digit".
         */
        hour?: string;
        /**
         * The representation of the minute. Possible values are "numeric", "2-digit".
         */
        minute?: string;
        /**
         * The representation of the second. Possible values are "numeric", "2-digit".
         */
        second?: string;
        /**
         * The representation of the time zone name. Possible values are "short", "long".
         */
        timeZoneName?: string;
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        formatMatcher?: string;
        /**
         * Whether to use 12-hour time (as opposed to 24-hour time). Possible values are true and false; the default is locale dependent.
         */
        hour12?: boolean;
        /**
         * The time zone to use. The only value implementations must recognize is "UTC"; the default is the runtime's default time zone. Implementations may also recognize the time zone names of the IANA time zone database, such as "Asia/Shanghai", "Asia/Kolkata", "America/New_York".
         */
        timeZone?: string;
    }
}

// FILE: MsPortalFx\Base\Internal\Internal.Base.Diagnostics.Telemetry.Context.d.ts
declare module FxImpl.TelemetryContext {
    import TelemetryContext = MsPortalFx.Base.Diagnostics.Telemetry.Context;
    import ContextValue = TelemetryContext.ContextValue;
    enum ContextType {
        Part = 0,
        Blade = 1,
        CompositionItem = 2
    }
    /**
     * The current values for all provided context types.
     */
    interface ContextValues extends StringMap<ContextValue> {
    }
    /**
     * Allows saving and restoring all context state when logical operations begin and end.
     */
    interface State {
    }
    /**
     * Contributes data of the specified type to the current context.
     *
     * @param contextType The type of context.
     * @param value Value of the context.
     */
    function setContextValue(contextType: ContextType, value: ContextValue): void;
    /**
     * Removes the most recent value for this context type.
     *
     * @param name The type of context.
     */
    function resetContextValue(contextType: ContextType): void;
    /**
     * Provide a context value during an operation.
     *
     * @param action The operation to execute.
     * @param contextType The type of context.
     * @param value Value of the context.
     * @return The return value of the operation.
     */
    const provideContext: <T>(action: () => T, contextType: ContextType, value: ContextValue) => T;
    /**
     * Gets the most recent value for this context type.
     *
     * @param contextType The type of context.
     * @return The value if one.
     */
    function getCurrentValue<T extends ContextValue>(contextType: ContextType): T;
    /**
     * Gets all of the most recent values for all context types.
     *
     * @return The values.
     */
    function getCurrentValues(): ContextValues;
    /**
     * Returns the current state that can be restored later.
     *
     * @return The state.
     */
    function getState(): State;
    /**
     * Provide a state during an operation.
     *
     * @param action The operation to execute.
     * @param state The state.
     * @return The return value of the operation.
     */
    const usingState: <T>(action: () => T, state: State) => T;
}

// FILE: MsPortalFx\Base\Internal\ObservableMap.d.ts
declare module MsPortalFx.Base.Internal {
    /**
     * An observable map. This interface is immutable.
     * All method except latch SHOULD prefix with "_" such that PO should not expose the other side of iFrame.  None should use any of these methods across iframe.
     */
    interface IObservableMap<T> {
        /**
         * Equivalent to doing () on an observable. Triggers updates in computeds, etc.
         * This is intentional to expose latch as KnockoutObservable such that the other IFrame can get access to the data as a method call.
         *
         *
         * @return The underlying map.
         */
        latch: KnockoutReadOnlyObservableBase<StringMap<T>>;
        /**
         * Returns the item associated with key in the map.
         *
         * @param key The key to look up.
         * @return The item associated with the key value pair.
         */
        lookup(key: string): T;
        /**
         * Iterates through each object in the observable map.
         *
         * @param callback The function that gets called on each item in the map.
         */
        forEach(callback: (value: T, key: string) => void, thisArg?: any): void;
        /**
         * Determines whether all the members of an array satisfy the specified test.
         *
         * @param callbackfn A function that accepts up to two arguments. The every method calls the callbackfn function for each element in the map until the callbackfn returns false, or until the end of the map.
         * @return True if the callback function returns true for all map elements, false otherwise.
         */
        every(callbackfn: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * Determines whether the specified callback function returns true for any element of a map.
         *
         * @param callbackfn A function that accepts up to two arguments. The some method calls the callbackfn function for each element in the map until the callbackfn returns true, or until the end of the map.
         * @return True if the callback function returns true for at least one map element, false otherwise.
         */
        some(callbackfn: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * Creates an Array<T> from the elements of the map.
         * @return The instance of the array with flattened map elements.
         */
        toArray(): Array<T>;
        /**
         * Creates a projection of the observable map.
         *
         * @param transform A function that transforms object in this map into objects in the projection.
         * @param transform A function that transforms object in this map into objects in the projection, optionally using the old generated value.
         * @return The projected map.
         */
        map<U>(lifetimeManager: MsPortalFx.Base.LifetimeManager, transform: (value: T, oldValue?: U) => U): IObservableMap<U>;
        /**
         * Gets the number of items in the observable map.
         */
        count: number;
        /**
         * Disposes of the map. Don't call this. Any maps that need cleaning up will require a lifetime manager.
         */
        dispose(): void;
        /**
         * Subscribes to an observable map.
         *
         * @param lifetimeManager The manager responsible for disposing of the subscription.
         * @param callback Called when the map changes.
         * @param target See observable subscribe function.
         * @param topic See observable subscribe function.
         * @return The subscription to the map.
         */
        subscribe(lifetimeManager: Base.LifetimeManager, callback: (newValue: StringMap<T>) => void, target?: any, topic?: string): KnockoutSubscription<StringMap<T>>;
    }
    /**
     * An observable map. This interface is mutable.
     * All method SHOULD prefix with "_" none of the object method expected to be executed in the other iFrame.
     */
    interface IMutableObservableMap<T> extends IObservableMap<T> {
        /**
         * Associates the passed key with the passed value.
         *
         * @param the key of the key/value pair.
         * @param the value of the key/value pair.
         */
        put(key: string, value: T): void;
        /**
         * Prevents any knockout notifications until the passed callback executes.
         * Anytime you need to push lots of key value pairs, you should do it in the passed callback.
         * This function also locks any dependant maps (projections or unions) so they too only fire one
         * update.
         *
         * @param callback the function to call before notifying subsribers.
         */
        modify(callback: () => void): void;
        /**
         * Removes all items from the observable map.
         */
        clear(): void;
        /**
         * Removes the key/value pair from the map. Throws if the key is not present in the map.
         *
         * @param key The key (and its corresponding value) to remove from the map.
         */
        remove(key: string): void;
    }
    /**
     * An observable map/dictionary. When you add or remove key value pairs, it notifies subscribers.
     * Can be used in computeds and like any other observable except that you use .latch() to read the map
     * and put, remove, and clear to mutate the map.
     */
    class ObservableMap<T> implements IMutableObservableMap<T> {
        /**
         * Actual string map that stores the values.
         */
        _modifyMap: StringMap<T>;
        /**
         * Maps, dependent on this one.
         */
        _dependantMaps: ObservableMap<any>[];
        /**
         * The internal workings of observable map. For access the readonly observable, please use latch()
         */
        private _observable;
        private _isInModifyBlock;
        put(key: string, value: T): void;
        lookup(key: string): T;
        modify(callback: () => void): void;
        latch: KnockoutObservable<StringMap<T>>;
        clear(): void;
        get count(): number;
        remove(key: string): void;
        forEach(callback: (value: T, key: string) => void, thisArg?: any): void;
        some<ThisArg>(callback: (this: ThisArg, value: T, key: string) => boolean, thisArg?: ThisArg): boolean;
        every(callback: (value: T, key: string) => boolean, thisArg?: any): boolean;
        toArray(): Array<T>;
        dispose(): void;
        subscribe(lifetimeManager: Base.LifetimeManager, callback: (newValue: StringMap<T>) => void, target?: any, topic?: string): KnockoutSubscription<StringMap<T>>;
        map<U>(lifetimeManager: MsPortalFx.Base.LifetimeManager, transform: (value: T, oldValue?: U) => U): IObservableMap<U>;
        /**
         * Adds a map as a dependant. Whenever the user adds or removes a key, this change gets reflected
         * in all dependant maps.
         *
         * @param map The map that depends on us. Generic parameter is any instead of T because projections are generally a different type.
         */
        _addDependantMap(map: ObservableMap<any>): void;
        /**
         * Removes a dependant observable map. The map will no longer receive updates from this map.
         *
         * @param map The map to remove as a dependancy. Generic parameter is any instead of T because projections are generally a different type.
         */
        _removeDependantMap(map: ObservableMap<any>): void;
        /**
         * Called when an an upstream map adds a key value pair.
         *
         * @param key The added key.
         * @param value The added value. Type is any because projections may have a different type than the parent map.
         */
        _putNotification(key: string, value: any): void;
        /**
         * Called when an upstream map removes a key.
         *
         * @param key The key removed.
         */
        _removeNotification(key: string): void;
        /**
         * Called when an upstream map removes all keys
         *
         * @param map The map being cleared.
         */
        _clearNotification(map: IObservableMap<any>): void;
        private _validateKey;
    }
    /**
     * A projection of an observable map. Whenever a key/value pair gets added to the base map,
     * a transformed object with the same key gets added to the projection. Removing from or clearing
     * the base map reflects in the projection as well.
     * Map.project is an easier was to create these.
     */
    class ObservableMapProjection<T, U> extends ObservableMap<U> {
        private _transform;
        private _map;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, map: ObservableMap<T>, transform: (value: T) => U);
        /**
         * See parent.
         */
        dispose(): void;
        /**
         * Projections are immutable. Throws an exception.
         */
        put(key: string, value: U): void;
        /**
         * Projections are immutable. Throws an exception.
         */
        remove(key: string): void;
        /**
         * Projections are immutable. Throws an exceptions.
         */
        clear(): void;
        /**
         * See parent.
         */
        _putNotification(key: string, value: T): void;
        /**
         * See parent.
         */
        _removeNotification(key: string): void;
        /**
         * See parent.
         */
        _clearNotification(map: IObservableMap<any>): void;
    }
    /**
     * Contains the union of key/value pairs on any number of other maps.
     */
    class ObservableMapUnion<T> extends ObservableMap<T> {
        private _maps;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, ...maps: IObservableMap<T>[]);
        dispose(): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        put(key: string, value: T): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        remove(key: string): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        clear(): void;
        /**
         * See parent.
         */
        _putNotification(key: string, value: T): void;
        /**
         * See parent.
         */
        _removeNotification(key: string): void;
        /**
         * See parent.
         */
        _clearNotification(map: IObservableMap<any>): void;
    }
}

// FILE: MsPortalFx\Blades.d.ts
declare module MsPortalFx.Blades {
    /**
     * Represents the different display states of the blade.
     */
    const enum DisplayState {
        /**
         * The blade is minimized.
         */
        Minimized = 0,
        /**
         * The blade is displayed in its regular format.
         */
        Normal = 1,
        /**
         * The blade is maximized.
         */
        Maximized = 2
    }
    module Internal {
        enum DisplayState {
            Minimized = 0,
            Normal = 1,
            Maximized = 2
        }
        enum BladeWidth {
            Small = 0,
            Medium = 1,
            Large = 2,
            XLarge = 3,
            Menu = 51
        }
        enum BladeStyle {
            Action = 1,
            Info = 2,
            Create = 3,
            Context = 4,
            Help = 5,
            Basic = 6,
            ContextAction = 7,
            BasicWithCommands = 8,
            Hub = 9,
            HubSubMenu = 10,
            ResourceSetting = 11,
            App = 12
        }
    }
}

// FILE: MsPortalFx\Blades\BladeStyle.d.ts
declare module MsPortalFx.Blades {
    const enum BladeStyle {
        /**
         * The action blade, the one that has commands. This is also the default blade.
         */
        Action = 1,
        /**
         * The information blade.
         */
        Info = 2,
        /**
         * The blade style for the create scenario, which contains an action bar.
         */
        Create = 3,
        /**
         * The blade style for the filter scenario.
         */
        Context = 4,
        /**
         * The blade style for help content.
         */
        Help = 5,
        /**
         * The blade that displays basic information and has no padding around its content.
         */
        Basic = 6,
        /**
         * The context blade style with commands.
         */
        ContextAction = 7,
        /**
         * The blade that displays basic information and has no padding around its content. Allows for commands.
         */
        BasicWithCommands = 8,
        /**
         * The blade style for hub.
         */
        Hub = 9,
        /**
         * The blade style for hub submenu.
         */
        HubSubMenu = 10,
        /**
         * The blade style for settings blade.
         */
        ResourceSetting = 11,
        /**
         * The app blade.
         */
        App = 12
    }
}

// FILE: MsPortalFx\Blades\BladeWidth.d.ts
declare module MsPortalFx.Blades {
    const enum BladeWidth {
        /**
         * A small blade width, using 3 azure grid columns.
         */
        Small = 0,
        /**
         * A medium blade width, using 6 azure grid columns. This is the default width when unspecified.
         */
        Medium = 1,
        /**
         * A large blade width, using 9 azure grid columns.
         */
        Large = 2,
        /**
         * An extra large blade width, using 12 azure grid columns.
         */
        XLarge = 3,
        /**
         * A blade width used for rendering a blade with a menu.
         */
        Menu = 51
    }
}

// FILE: MsPortalFx\Composition\Composition.Blade.d.ts
declare module FxImpl.Composition.BladeContainer {
    import FxViewModels = MsPortalFx.ViewModels;
    import ActionBarBaseViewModel = FxViewModels.ActionBars.Base.ViewModel;
    /**
     * This class is purely implementation and should never be referenced by extensions
     */
    class BladeContainer extends FxViewModels.PartContainer {
        constructor(internal: FxImpl.ViewModels.FrameworkPartViewModelContract, options?: FxViewModels.PartContainerOptions);
        /**
         * This is a public property on the class, but it is prefixed with a _ so it is not proxied to the shell.
         * This property is accessed by parameter provider to listen for output from the actionbar.
         */
        _actionBar: KnockoutObservable<ActionBarBaseViewModel>;
    }
    function bindActionBar(container: BladeContainer, viewModel: any): void;
}

// FILE: MsPortalFx\Composition\Composition.Configuration.d.ts
declare module MsPortalFx.Composition.Configuration {
    import FxPromise = MsPortalFx.Base.Promise;
    namespace Part {
        /**
         * This is the Part Configuration API which is available as 'container.activateConfiguration()'.
         *
         * This Configuration is an opt-in means of expanding upon the Part such that:
         * - 'onInvoke'/'onInputsSet' is passed both:
         *   - parameters (passable from caller, bindable to values at the Dashboard level) and
         *   - settings (internal, persisted state that is never passed from caller or acquired from the Dashbaord).
         * - Parameter values can be overridden by the user (via configuration in the Context Pane).  When overridden, values passed by the
         * caller or acquired from the Dashboard via binding are ignored.
         */
        interface Contract<TParameters, TSettings> {
            /**
             * A means of extracting all current parameter/settings values along with their metadata.
             * Typically, this is called in a 'supplyInitialData' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @return Current Configuration values along with value metadata.
             */
            getValues(): ValuesWithMetadata<TParameters, TSettings>;
            /**
             * A means of atomically committing Configuration changes, typically from a ParameterProvider Blade.
             * Typically, this is called from a 'receiveResult' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @param newValues New Configuration values and value metadata reflecting the new state of the Part Configuration.
             * @return A Promise reflecting the saving of the parameters/settings changes.
             */
            updateValues(newValues: ValuesWithMetadata<TParameters, TSettings>): FxPromise;
        }
        /**
         * Options passed to 'container.activateConfiguration()'.
         */
        interface Options<TParameters, TSettings> {
            "--noUnusedLocals"?: TParameters | TSettings | any;
            [others: string]: any;
        }
        /**
         * A representation of the current values in a Part's Configuration, along with metadata for each value.
         * Useful for passing to a "Configure..." ParameterProvider Blade for user-editing of Configuration values.
         * Also useful for returning from this same "Configure..." ParameterProvider Blade to the calling Part.
         */
        interface ValuesWithMetadata<TParameters, TSettings> {
            /**
             * TParameters-typed values that will be supplied to this Part's 'onInvoke'/'onInputsSet'.  In addition to TParameters, this
             * includes metadata describing each parameter value.
             */
            parameters: ParameterValuesWithMetadata<TParameters>;
            /**
             * TSettings typed Part settings that will be supplied to this Part's 'onInvoke'/'onInputsSet'.
             */
            settings: TSettings;
        }
        /**
         * TParameters-typed values that will be supplied to this Part's 'onInvoke'/'onInputsSet'.  In addition to TParameters, this
         * includes metadata describing each parameter value.
         */
        interface ParameterValuesWithMetadata<TParameters> {
            /**
             * The parameter values.
             */
            values: TParameters;
            /**
             * Currently relevant for Parts only (and not for Blades).
             * Metadata covering each of the parameter values.
             */
            metadata: StringMap<ParameterMetadata>;
        }
    }
    namespace Blade {
        /**
         * Options passed to 'container.activateConfiguration()'.
         */
        interface Options<TSettings> {
            "--noUnusedLocals"?: TSettings | any;
            [others: string]: any;
        }
        /**
         * This is the Blade Configuration API which is available as 'container.activateConfiguration()'.
         *
         * This Configuration is an opt-in means of expanding upon the Blade such that:
         * - 'onInvoke'/'onInputsSet' is passed:
         *   - settings (internal, persisted state).
         */
        interface Contract<TSettings> {
            /**
             * A means of extracting all current settings values along with their metadata.
             * Typically, this is called in a 'supplyInitialData' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @return Current Configuration values along with value metadata.
             */
            getValues(): ValuesWithMetadata<TSettings>;
            /**
             * A means of atomically committing Configuration changes, typically from a ParameterProvider Blade.
             * Typically, this is called from a 'receiveResult' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @param newValues New Configuration values and value metadata reflecting the new state of the Blade Configuration.
             * @return A Promise reflecting the saving of the parameters/settings changes.
             */
            updateValues(newValues: ValuesWithMetadata<TSettings>): FxPromise;
        }
        /**
         * A representation of the current values in a Blade's Configuration, along with metadata for each value.
         * Useful for passing to a "Configure..." ParameterProvider Blade for user-editing of Configuration values.
         * Also useful for returning from this same "Configure..." ParameterProvider Blade to the calling Blade.
         */
        interface ValuesWithMetadata<TSettings> {
            /**
             * TSettings typed Blade settings that will be supplied to this Blade's 'onInvoke'/'onInputsSet'.
             */
            settings: TSettings;
        }
    }
    /**
     * Per-parameter metadata returned from 'config.getValues()' or supplied by the extension when calling 'config.updateValues()'.
     */
    interface ParameterMetadata {
        /**
         * Reflects whether the corresponding Part is currently situated on a Dashboard and, if so, whether this parameter value can
         * be bound to values at the Dashboard-level.  For the extension, a non-empty array here should determine whether -- in the
         * "Configure..." Context Pane -- the user should be presented with UI to choose whether to bind to a Dashboard-level value.
         */
        bindingSources: ParameterBindingSource[];
        /**
         * Used only if the 'bindingSources' array above is non-empty.
         * Re: 'config.getValues()', indicates whether this pContractarameter value is currently bound to a value from the containing Dashboard.
         * Re: 'config.updateValues()', determines whether this parameter value should be bound to a value from the containing Dashboard.
         * If 'activeBindingSourceName' is not supplied, then any user-specified value for this parameter will be used to override
         * the value that would otherwise be acquired via binding from the containing Dashboard.
         */
        activeBindingSourceName: string;
        /**
         * Re: 'config.updateValues()', determines whether this updated parameter value should be applied to the containing dashboard.
         * This value is used only if the 'bindingSources' array is non-empty and 'activeBindingSourceName' names a binding source from
         * 'bindingSources'.
         */
        applyUpdatedValueToActiveBindingSource?: boolean;
    }
    /**
     * A description of a Dashboard-level property to which a parameter can be bound.
     */
    interface ParameterBindingSource {
        /**
         * The runtime name of the property at the Dashboard level.
         */
        name: string;
        /**
         * Indicates whether this Dashboard-level property accepts value updates (see
         * 'ParameterMetadata.applyUpdatedValueToActiveBindingSource').
         */
        acceptsValueUpdates: boolean;
    }
    /**
     * Part/Blade parameter and settings values.
     */
    interface Values<TParameters, TSettings> {
        /**
         * Parameter values.
         */
        parameters: TParameters;
        /**
         * Settings values.
         */
        settings: TSettings;
    }
    /**
     * Represents either an absolute or relative time range.
     */
    interface TimeRange {
        /**
         * An absolute time range.
         */
        absolute?: {
            /**
             * The start of the time range.
             */
            from: Date;
            /**
             * The end of the time range.
             */
            to: Date;
        };
        /**
         * A relative time range.
         */
        relative?: {
            /**
             * The duration for the relative time range.
             */
            duration: number;
            /**
             * The time unit for the duration of the relative time range.
             */
            timeUnit: TimeUnit;
        };
    }
    /**
     * Values represent units of time.  Used in TimeRange.
     */
    const enum TimeUnit {
        Minute = 0,
        Hour = 1,
        Day = 2,
        Week = 3,
        Month = 4,
        Year = 5
    }
    /**
     * A parameter value type that a Part can acquired from its Dashboard via binding.
     */
    type ValueType = string;
    /**
     * A value type that for TimeRange.
     */
    const TimeRangeValueType = "MsPortalFx.Composition.Configuration.ValueTypes.TimeRange";
}
declare module FxImpl.Composition {
    import FxPromise = MsPortalFx.Base.Promise;
    import FxCompositionConfiguration = MsPortalFx.Composition.Configuration;
    /**
     * The signature for a callback that informs the Part/Blade that its Configuration has changed value in some way.
     */
    type ConfigurationChangedHandler = (values: FxCompositionConfiguration.Part.ValuesWithMetadata<any, any>, callOnUpdateWithChanges: boolean) => FxPromise;
    /**
     * See the MsPortalFx.Composition.Configuration.Contract for details.
     */
    class Configuration<TParameters extends StringMap<any>, TSettings extends StringMap<any>> implements FxCompositionConfiguration.Part.Contract<TParameters, TSettings>, FxCompositionConfiguration.Blade.Contract<TSettings> {
        private _persistedValues;
        private _configChangedHandler;
        /**
         * Constructs a Configuration object.
         *
         * @param options Options that determine the behavior of the Configuration object.
         * @param configChangedHandler A callback that notifies when the Part/Blade's Configuration has changed in some way.
         */
        constructor(options: FxCompositionConfiguration.Part.Options<TParameters, TSettings>, configChangedHandler: ConfigurationChangedHandler);
        /**
         * This will be called by the FX/Shell once the Part has been bound into its containing dashboard/Blade.
         *
         * @param values Parameter and settings values including metadata describing whether parameters are bound/bindable
         * to the containing dashboard or Blade.
         */
        setValues(values: FxCompositionConfiguration.Part.ValuesWithMetadata<any, any>): void;
        getValues(): FxCompositionConfiguration.Part.ValuesWithMetadata<TParameters, TSettings>;
        updateValues(newValues: FxCompositionConfiguration.Part.ValuesWithMetadata<TParameters, TSettings>, callOnUpdateWithChanges?: boolean): FxPromise;
    }
}

// FILE: MsPortalFx\Composition\Composition.PartReference.d.ts
declare module MsPortalFx.Composition {
    interface PartReferenceOptions {
        /**
         * The name of the extension that owns the part.
         */
        extensionName?: string;
        /**
         * The initial size of the part.
         */
        initialSize?: MsPortalFx.Parts.PartSize;
        /**
         * If initialSize is Custom, this specifies the number of grid rows to cover.
         */
        initialHeight?: number;
        /**
         * If initialSize is Custom, this specifies the number of grid columns to cover.
         */
        initialWidth?: number;
    }
    /**
     * Identifies the part that is referenced
     */
    class PartReference<TParameters> {
        /**
         * The name of the part.
         */
        partName: string;
        /**
         * Parameters that are passed to the target part
         */
        parameters: TParameters;
        /**
         * Options to create the target part
         */
        options: PartReferenceOptions;
        /**
         * PartReference constructor
         *
         * @param partName partName of the referenced part
         * @param parameters parameters that are passed to the target part
         * @param options options that are used to create the target part
         */
        constructor(partName: string, parameters: TParameters, options?: PartReferenceOptions);
    }
    /**
     * Identifies the part that is referenced
     */
    class ResourcePartReference {
        /**
         * The id of the resource to pin.
         */
        resourceId: string;
    }
}

// FILE: MsPortalFx\Composition\Composition.Selectable2.d.ts
declare module FxImpl {
    /**
     * Method for accessing the interface which is used as a channel of communication between
     * the shell and the public facing SDK Apis that extension use.
     *
     * @param viewModel framework view model that the shell interface is attached to. This view model is the public facing API.
     * @param initialValue if not null, the shell interface is initialized with the provided object.
     * @returns The internal communication interface.
     */
    function shellInterface<T>(viewModel: any, initialValue?: T): T;
    module CompositionCore {
        /**
         * Supplies the reason a Blade was closed, for instance, to the opening BladeReference's 'onClosed' callback.
         */
        const enum BladeClosedReason {
            /**
             * The blade was closed in reaction to some user navigation.
             */
            UserNavigation = 1,
            /**
             * The child blade closed itself programmatically.
             */
            ChildClosedSelf = 2
        }
        /**
         * The function typing for 'onClosed' callbacks for Blades.
         */
        type BladeClosedHandler = (reason: BladeClosedReason) => void;
        /**
         * The function typing for 'onClosed' callbacks for Blades, returning data from the Blade to the callback.
         */
        type BladeClosedWithDataHandler<TData> = (reason: BladeClosedReason, data: TData) => void;
        /**
         * A view model that represents a click target that opens a link.
         */
        export import ClickableLink = MsPortalFx.ViewModels.ClickableLink;
        /**
         * Options supplied when adding an operation to a Blade or Part.
         */
        interface OperationOptions {
            /**
             * If true, indicates that the Part UI should be blocked (non-interactive) until the operation finishes.
             */
            blockUi: boolean;
            /**
             * The type of blocking shield that will appear if UI is blocked.
             */
            shieldType?: ShieldType;
        }
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = MsPortalFx.ViewModels.ShieldType;
        /**
         * A list of in-progress operations for the Blade or Part.  These control the Blade or Part loading indicator.
         */
        interface OperationList {
            /**
             * Adds an operation to the list.
             *
             * @param promise A promise representing the operation to be added.
             * @param options Additional options describing how the operation should be visualized.
             */
            add(promise: MsPortalFx.Base.Promise, options?: OperationOptions): void;
            /**
             * Removes an operation from the list.
             *
             * @param promise The promise matching the operation to remove.
             */
            remove(promise: MsPortalFx.Base.Promise): void;
            /**
             * Updates the options associated with an operation list entry.
             *
             * @param promise The promise matching the operation to update.
             * @param options New options for the operation.
             */
            update(promise: MsPortalFx.Base.Promise, options: OperationOptions): void;
            /**
             * Describes the options associated with an operation list entry.
             *
             * @param promise The promise matching the operation to update.
             * @return Options associated with the operations.
             */
            getOptionsForOperation(promise: MsPortalFx.Base.Promise): OperationOptions;
        }
        /**
         * A description of a Blade that should be opened when a target is clicked.
         * BladeLink is preferred to other callback-style APIs that use "container.openBlade(...)",
         * since BladeLink works with the browser's "open in new tab/window" and "copy link" support.
         */
        type BladeReference = Composition.Selectable.BladeReference<any>;
        /**
         * Options supplied when constructing a blade link capable of opening in a new tab too.
         */
        interface BladeLink {
            /**
             * Blade reference of blade to be opened.
             */
            readonly bladeReference: BladeReference | KnockoutObservableBase<BladeReference>;
            /**
             * The callback triggered after the link is opened via left-click or 'Enter' key. This is not called when opened in a new tab/window.
             *
             * @param keypress Indicates if the link is opened by keypress.
             */
            readonly onLinkOpened?: (keypress: boolean) => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
        }
        /**
         * Options supplied when constructing a resource blade link capable of opening in a new tab too.
         */
        interface ResourceLink {
            /**
             * Resource id.
             */
            readonly resourceId: string | KnockoutObservableBase<string>;
            /**
             * The callback triggered after the link is opened via left-click or 'Enter' key. This is not called when opened in a new tab/window.
             *
             * @param keypress Indicates if the link is opened by keypress.
             */
            readonly onLinkOpened?: (keypress: boolean) => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
        }
    }
    module Composition.Selectable {
        /**
         * Identifies the target blade that is to be opened
         */
        class BladeReference<TParameters> {
            private _msPortalFxCallbacks;
            /**
             * BladeReference constructor
             *
             * @param parameters parameters that are passed to the target blade
             */
            constructor(parameters: TParameters, callbacks?: any);
            /**
             * Parameters that are passed to the target blade
             */
            parameters: TParameters;
            /**
             * Create a copy of this blade reference with new parameters
             *
             * @param parameters new set of parameters to pass to the child blade
             */
            clone(parameters: TParameters): BladeReference<TParameters>;
        }
        /**
         * Callbacks for PDL generated blades
         */
        interface PdlBladeCallbacks<TOutputs> {
            /**
             * This method is invoked when outputs are returned from a child blade
             */
            onOutputsChanged: (outputs: TOutputs) => void;
        }
        /**
         * Properties which describe the blade that is too be opened
         */
        interface PdlBladeMetadata {
            /**
             * List of outputs to receive from the child blade
             */
            outputParameters?: string[];
            /**
             * If true this blade is opened as a context blade
             */
            isContextBlade?: boolean;
            /**
             * if the blade will be opened in the context pane, true open as context, false open as detail blade
             */
            persistentContextPane?: boolean;
        }
        /**
         * Options for configuring the PdlBladeReference class
         */
        interface PdlBladeReferenceOptions<TParameters, TOutputs> {
            /**
             * Parameters to pass to the child blade
             */
            parameters?: TParameters;
            /**
             * Callbacks to invoke
             */
            callbacks?: PdlBladeCallbacks<TOutputs>;
            /**
             * Optional callback that is invoked when the blade is closed.
             */
            onClosed?: CompositionCore.BladeClosedWithDataHandler<any>;
        }
        /**
         * Base class for PDL generated blade references.
         * Extension authors should not be directly creating this class
         */
        class PdlBladeReference<TParameters, TOutputs> extends BladeReference<TParameters> {
            /**
             * Name of the blade
             */
            bladeName: string;
            /**
             * Name of the extension which this contains the blade
             */
            extensionName: string;
            /**
             * Options for this blade reference
             */
            options: PdlBladeReferenceOptions<TParameters, TOutputs>;
            /**
             * Descriptor contains blade attributes
             */
            metadata: PdlBladeMetadata;
            constructor(bladeName: string, extensionName?: string, options?: PdlBladeReferenceOptions<TParameters, TOutputs>, metadata?: PdlBladeMetadata);
        }
        /**
         * Base class for generated provisioning blade references.
         * Extension authors should not be directly creating instances of this class
         */
        class ProvisioningBladeReference<TParameters, TResults> extends PdlBladeReference<TParameters, TResults> {
            constructor(bladeName: string, extensionName?: string, marketplaceId?: string, options?: PdlBladeReferenceOptions<TParameters, TResults>, metadata?: PdlBladeMetadata);
        }
        interface ParameterProviderOptions<TParameters, TResult, TConfig> extends PdlBladeReferenceOptions<TParameters, void> {
            /**
             * A callback that supplies initial data for the parameter provider
             * in the child blade each time it opens.
             *
             * Note that the object received by the parameter provider will be a
             * deep clone of the value you give, rather than the original instance,
             * because it is passed (and sometimes stored) in a serialized form.
             *
             * @return Initial data for the child blade.
             */
            supplyInitialData?(): TResult;
            /**
             * A callback that supplies additional configuration options for the
             * provider each time it opens. You can use this to pass non-editable
             * data, for example configuring how a form will be displayed.
             *
             * @return Arbitrary configuration options for the child blade.
             */
            supplyProviderConfig?(): TConfig;
            /**
             * A callback to be invoked when the child blade supplies a result
             * and closes.
             *
             * @param result The result given by the child blade.
             * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
             */
            receiveResult?(result: TResult): void;
            /**
             * Provides an easy way to integrate a parameter collector with an EditScope.
             *
             * The collector will supply initial data to the provider from this edit scope
             * property, and will automatically insert the provider's output into this edit
             * scope property. The net result is that your parameter collector will act as
             * an editor for the specified edit scope property.
             *
             * If you specify this option, do not also specify either supplyInitialData or
             * receiveResult.
             */
            editScopeAccessor?: MsPortalFx.ViewModels.Forms.EditScopeAccessors<TResult>;
        }
        class ParameterProviderBladeReference<TParameters, TResult, TConfig> extends PdlBladeReference<TParameters, void> {
            constructor(bladeName: string, extensionName: string, options: ParameterProviderOptions<TParameters, TResult, TConfig>, metadata?: PdlBladeMetadata);
        }
        /**
         * Base class for selectable objeccts
         */
        abstract class SelectableBase<TBladeReference extends BladeReference<any>> {
            /**
             * Renavigate changes the blade which is currently opened.  It can be used to change the blade parameters
             * for a existing blade (rebinding) or open a different blade
             *
             * @param bladeReference Descriptor of the new blade to navigate too
             */
            renavigateActivatedBlade(bladeReference: TBladeReference): void;
        }
        /**
         * Configuration to pass to the selectable constructor
         */
        interface Selectable2Options<TBladeReference> {
            /**
             * This callback is invoked by the portal when a new blade is to be opened
             * in response to a user-invoked navigation.
             *
             * @return A blade reference that describes the blade to open.  This value cannot be null or undefined.
             */
            supplyBladeReference?: () => TBladeReference;
            /**
             * This callback is invoked by the portal when a new blade is to be opened
             * asychronously in response to a user-invoked navigation.
             *
             * @return A promise that returns a blade reference that describes the blade to open.  This value cannot be null or undefined.
             */
            supplyBladeReferenceAsync?: () => Q.Promise<TBladeReference> | Promise<TBladeReference>;
        }
        /**
         * Selectable class that is used to open blades in response to user clicks
         */
        class Selectable2<TBladeReference extends BladeReference<any>> extends SelectableBase<TBladeReference> {
            constructor(options: Selectable2Options<TBladeReference>);
        }
        /**
         * View models which are selectable implement this interface
         */
        interface SelectableViewModel {
            configureSelectable<TBladeReference extends BladeReference<any>>(options: Selectable2Options<BladeReference<any>>): Selectable2<TBladeReference>;
        }
        /**
         * Click handler
         */
        type OnClickHandler = (evt: MsPortalFx.ViewModels.FxMouseEvent) => void;
        /**
         * List click handler
         */
        type OnListClickHandler<T> = (selectedItem: T) => void;
    }
    const BladeReference: typeof Composition.Selectable.BladeReference;
    type SelectableViewModel = Composition.Selectable.SelectableViewModel;
    const enum SelectableFlags {
        None = 0,
        IsSelectable = 1,
        ActivateAsync = 2
    }
    const enum BladeReferenceSource {
        None = 0,
        Fetch = 1,
        Renavigate = 2,
        OpenBlade = 3,
        PendingRequest = 4
    }
    /**
     * Represents the tuple of config and initial state that is sent to
     * a provider blade.
     */
    interface InitialProviderBladeConfig<TResult, TConfig> {
        initialState: TResult;
        config: TConfig;
    }
    const enum ShellInterfaceType {
        /**
         * The interface type used to facility communication
         * between Fx.Composition.Selectable2 (extension selectable 2 API) and Base.Selectable2 (shell)
         *
         * 0x5332 is the ascii codes for 'S2';
         */
        Selectable2 = 21298,
        /**
         * The interface used for consumption by a internal shell collector instance
         */
        ParameterProviderBladeReference = 20560,
        /**
         * The interface used for consumption by a internal shell marketplace instance
         *
         * 0x4D50 is the ascii codes for 'MP';
         */
        ProvisioningBladeReference = 19792
    }
    /**
     * This is the interface through which the shell interacts with
     * the ParameterProviderBladeReference instance
     */
    interface ParameterProviderShellContract<TResult, TConfig> {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         * This member is used to pin the initial config that is passed to the blade.
         * This is to ensure the config PO proxy is not prematurely garbaged collected
         */
        bladeConfig: KnockoutObservable<InitialProviderBladeConfig<TResult, TConfig>>;
        /**
         * This method is invoked by the shell to get the inital config before opening the new blade on question.
         */
        getBladeConfig(seletedItem?: any): InitialProviderBladeConfig<TResult, TConfig>;
        /**
         * This method is invoked by the shell when a result is returned from the provider blade
         */
        receiveResult(result: TResult): void;
    }
    /**
     * This is the interface through which the shell interacts with
     * the ProvisioningBladeReference instance
     */
    interface MarketplaceShellContract {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         * marketplace id
         */
        marketplaceId: string;
    }
    const enum OpenBladeRequestFlags {
        /**
         * Open the blade in a context pane
         */
        OpenInContextPane = 1,
        /**
         * Open the blade as a subjourney
         */
        OpenAsSubJourney = 2,
        /**
         * Open the blade in place (only for menu blade content currently)
         */
        OpenInPlace = 4
    }
    interface OpenBladeRequest<TBladeReference> {
        /**
         * The reason the request is being issued to the blade opener
         */
        reason: BladeReferenceSource;
        /**
         * Blade reference
         */
        bladeReference: TBladeReference;
        /**
         * tracking id for this request
         *   Used for -
         *     Notification of open blade completion
         *     Lifetime management of callbacks (same blade reference/callback used to open same blade more than one time)
         *     Diagnostics/debugging
         */
        operationId: any;
        /**
         * various open blade flags
         */
        flags: OpenBladeRequestFlags;
        /**
         * Optional metadata attached to the open blade request by the control
         */
        controlMetadata?: any;
        /**
         * for selectable set, the selected item associated with the request
         */
        selectedItem?: any;
        /**
         * for async operations this is the initial width to use for the loading blade
         */
        initialWidth?: MsPortalFx.Blades.BladeWidth;
        /**
         * Optional name used in telemetry to identify which control is opening the blade
         */
        telemetryName?: string;
    }
    interface OpenBladeResult {
        operationId: any;
        success: boolean;
    }
    interface OpenBladeShellInterface<TBladeReference extends Composition.Selectable.BladeReference<any>> {
        /**
         * current blade reference that was assigned by extension to this selectable
         */
        request: KnockoutObservable<OpenBladeRequest<TBladeReference>>;
        /**
         * the result of the last open blade request.
         * this is pushed from the shell and read by the extension iFrame
         */
        result: KnockoutObservable<OpenBladeResult>;
    }
    /**
     * This is the channel through which the selectable communicates with the shell.
     *
     * Not the word interface mabye confusing here.   This is not a reference to the TypeScript type.
     */
    interface SelectableShellInterface<TBladeReference extends Composition.Selectable.BladeReference<any>> extends OpenBladeShellInterface<TBladeReference> {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         * flags indicate capabilities
         */
        flags: SelectableFlags;
        /**
         * this method is invoked when shell requires a open blade request to open a new blade
         * A open blade request contains the blade reference + additional metadata
         */
        fetchRequest: (operationId: any) => OpenBladeRequest<TBladeReference> | Q.Promise<OpenBladeRequest<TBladeReference>>;
    }
    /**
     * This interface is the internal contract between the shell ahd the selectable view model.
     * A selectable view model is a dual honed object that supports both the legacy selectable and the new selectable.
     * This type exists for backward compat reasons.  New features probably don't need to implement this.
     *
     * This is internal implementation detail and not intended to be accessed directly by extensions.
     */
    interface SelectableViewModelContract {
        _msPortalFxIsSelectableViewModel: boolean;
        _msPortalFxSelectable: MsPortalFx.ViewModels.Selectable<any>;
        _msPortalFxSelectable2: Composition.Selectable.Selectable2<Composition.Selectable.BladeReference<any>>;
    }
    /**
     * Initializes a view model which contains a selectable.
     * Also provides a generic implementation of SelectableViewModel interface as well via a mixin.
     *
     * @param viewModel A view model that is hosting a selectable.
     * @param selectable Legacy support for selectable v1
     */
    function initializeSelectableViewModel(viewModel: SelectableViewModel, selectable: MsPortalFx.ViewModels.Selectable<any>): void;
    /**
     * Assigns a legacy selectable to a selectable view model.  To be during view model construction.
     *
     * @param viewModel the selectable view model that supports both selectable and selectable 2
     * @param selectable The legacy selectable instance
     */
    function assignSelectable(viewModel: SelectableViewModel, selectable: MsPortalFx.ViewModels.Selectable<any>): void;
    /**
     * Tries to get the internal selectable viewmodel interface for a selectable view model.
     *
     * @param viewModel The view mode for which we want to get the internal interface.
     * @returns null if the view model is not a selectable view model
     */
    function tryGetSelectableViewModelContract(viewModel: SelectableViewModel): SelectableViewModelContract;
    /**
     * Returns true if the view model is a selectable view model.
     */
    function isSelectableViewModel(viewModel: any, requireSelectable2?: boolean): viewModel is SelectableViewModelContract;
    /**
     * Returns true if view model is a selectabe 2 instance
     */
    function isSelectable2(viewModel: any): viewModel is Composition.Selectable.Selectable2<Composition.Selectable.BladeReference<any>>;
    /**
     * Helper method used by the shell to invoke a callback on a blade reference
     */
    function invokeCallback<TBladeReference extends Composition.Selectable.BladeReference<any>>(bladeReference: TBladeReference, name: string, parameters: any[]): void;
}
declare module "Fx/Composition/Selectable" {
    import Impl = FxImpl.Composition.Selectable;
    export = Impl;
}

// FILE: MsPortalFx\Controls\Menu.d.ts
declare module FxImpl {
    import FxComposition = FxImpl.Composition.Selectable;
    import Selectable = FxComposition.Selectable2;
    module Controls.Menu {
        /**
         * Attributes common to all items and groups in the menu.
         */
        interface MenuItemBase {
            /**
             * Gets the ID for the item.
             */
            id: string;
            /**
             * The display text for the item.
             */
            displayText: string | KnockoutObservableBase<string>;
            /**
             * A space-delimited list of keywords associated to the item.
             */
            keywords?: string | string[];
        }
        /**
         * Defines an item in a group of the menu.
         */
        interface MenuItem extends MenuItemBase, FxComposition.Selectable2Options<FxComposition.BladeReference<any>> {
            /**
             * The icon associated to the menu item.
             */
            icon: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
            /**
             * A value indicating whether or not the item is enabled.
             */
            enabled?: KnockoutObservableBase<boolean>;
            /**
             * A value indicating whether or not the item should be visible in the menu.
             */
            visible?: KnockoutObservableBase<boolean>;
            /**
             * The tooltip for the menu item.
             */
            tooltip?: string | KnockoutObservableBase<string>;
        }
        /**
         * Defines a group in the menu.
         */
        interface MenuGroup extends MenuItemBase {
            /**
             * The menu items in the group.
             */
            items: MenuItem[];
        }
        /**
         * The options for the menu.
         */
        interface Options {
            /**
             * Defines the overview item.
             */
            overview?: MenuItem;
            /**
             * The ID of the item to be selected by default.
             */
            defaultId?: string;
        }
    }
    interface MenuItem extends Controls.Menu.MenuItem {
        /**
         * The group that the item belongs to.
         */
        group: string;
        /**
         * The aggregated list of keywords for the menu item.
         */
        aggregatedKeywords: string;
    }
    interface MenuData {
        /**
         * The unpivoted list of menu items from all groups.
         */
        items: KnockoutObservableArray<MenuItem>;
        /**
         * A map of selectables associated to menu items.
         */
        selectableMap: KnockoutObservable<StringMap<Selectable<any>>>;
        /**
         * The Promise for the default ID.
         */
        options: KnockoutObservable<FxImpl.Controls.Menu.Options>;
        /**
         * Promise for the overview item.
         */
        overviewPromise: MsPortalFx.Base.PromiseV<MenuItem>;
    }
}

// FILE: MsPortalFx\Data\Data.AtomizationOptions.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies atomization context options.
     * If supplied, as objects sharing the same entity ID are added to the cache, only a single object instance will be used for a given entity ID.
     */
    interface AtomizationOptions {
        /**
         * Supplies the atomization context id used for cached DataSets.
         * If 'null' or 'undefined' is supplied, a default atomization context will be used.
         * Otherwise, 'atomizationContextId' identifies the atomization context to be used.
         */
        atomizationContextId?: string;
    }
}

// FILE: MsPortalFx\Data\Data.DataCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A base interface for QueryCache and EntityCache.
     */
    interface DataCache<TData, TParams> {
        "--noUnusedLocals"?: TData | TParams | any;
        [others: string]: any;
    }
}

// FILE: MsPortalFx\Data\Data.DataCacheConfig.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies configuration options for a DataCacheLoader.
     */
    interface DataCacheLoaderConfig<TEntity, TParams> {
        "--noUnusedLocals"?: TEntity | any;
        /**
         * Provides a URI from which data should be retrieved. The URI is a function
         * of the supplied parameters.
         *
         * Note that 'sourceUri' and 'loader' are mutually exclusive. One of these
         * must be specified, but not both.
         *
         * @param params Parameters describing the data to be retrieved. For EntityCaches, this will be the entity ID. For QueryCaches, it will be query parameters.
         * @return The URI from which data should be retrieved.
         */
        sourceUri?(params: TParams): string;
        /**
         * If true, requests issued by this DataCache will include the user's authorization header.
         *
         * This cannot be used in conjunction with supplyData, because in that case, you are taking manual control over the
         * requests that are issued.
         */
        setAuthorizationHeader?: boolean;
        /**
         * If specified, overrides how query params are mapped to cache entries.
         *
         * If you specify this, ensure that any two logically different parameter objects map to different
         * strings, and that any two logically equivalent parameter objects map to the same string.
         *
         * If not specified here, and not overridden in a custom DataCacheLoader, the default behavior
         * is to regard cache entries as equivalent if and only if they map to the same URI, not differentiating
         * by HTTP method or any other HTTP headers.
         */
        serializeParams?(params: TParams): string;
        /**
         * Specifies the HTTP method that should be used when retrieving data from
         * the configured 'sourceUri'. The default data cache loader uses 'GET' if no
         * 'httpMethod' is configured.
         *
         * Note that you can only specify an 'httpMethod' if you have specified a 'sourceUri',
         * in other words, if you are not supplying a custom loader object.
         */
        httpMethod?: string;
        /**
         * Optional. If provided, the default data loader will use any registered
         * metadata for the entity type to share entity instances across caches.
         */
        entityTypeName?: string;
        /**
         * If true, causes the loader to poll the server for updates. Defaults to false, meaning that the
         * data will only be fetched when first requested or explicitly refreshed.
         */
        poll?: boolean;
        /**
         * Specifies the interval, in milliseconds, between polls. If not set, the recommended default polling interval will be used.
         * This option only takes effect if polling is enabled. The minimum allowed value is 10000.
         */
        pollInterval?: number;
        /**
         * By default, each time the loader polls the server, it updates the local dataset to match the record order
         * in the server's response. Setting this flag to true means that the loader should skip that behavior and
         * instead preserve the client's existing record order when polling.
         */
        pollPreservesClientOrdering?: boolean;
        /**
         * If specified, the DataCache loader should call this to obtain raw JSON data to be merged into the cache.
         * A typical implementation simply performs an ajax request. Usually, the parameters (httpMethod, uri, etc.)
         * are determined by the corresponding options on your DataCacheConfig, but if you implement a custom DataCache
         * loader, then it's possible to vary these programmatically.
         *
         * @param httpMethod The HTTP method to be used.
         * @param uri The URI from which data should be fetched.
         * @param headers Any HTTP headers that should be sent with the request.
         * @param data Any data to be sent in the body of the request.
         * @param params The parameters describing the cache entry for which data is being fetched.
         * @param entryLifetime A lifetime manager object representing the duration that the entry remains in the cache.
         * @return A promise representing the completion of the request. The promise's result value should be a JavaScript object or array representing the response.
         */
        supplyData?(httpMethod: string, uri: string, headers: StringMap<any>, data: any, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): MsPortalFx.Base.Promise;
        /**
         * If specified, the DataCache loader will call this each time any data is fetched. This callback
         * should translate the response object into a data array, and optionally, navigation metadata.
         *
         * @param responseData The response object to be processed.
         * @return A DataCacheProcessedResponse representing the data, and optionally navigation metadata.
         */
        processServerResponse?(responseData: any): DataCacheProcessedResponse;
        /**
         * If supplied, as objects sharing the same entity ID are added to the cache, only a single object instance will be used for a given entity ID.
         */
        atomizationOptions?: AtomizationOptions;
    }
    /**
     * Supplies configuration options for a DataCache (an EntityCache or QueryCache).
     */
    interface DataCacheConfig<TEntity, TParams> extends DataCacheLoaderConfig<TEntity, TParams> {
        /**
         * An object that can supply data for a DataCache.
         *
         * Note that 'sourceUri' and 'loader' are mutually exclusive. One of these
         * must be specified, but not both.
         */
        loader?: DataCacheLoader<TEntity, TParams>;
        /**
         * @deprecated DataCacheConfig.evictionDelay - Please do not use this option. It is deprecated and will be removed. Instead, set
         * the 'extendEntryLifetimes' option to 'true'.
         *
         * Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         */
        evictionDelay?: number;
        /**
         * If true, cache entries will be retained in memory for a framework-controlled period even when
         * no other objects are referring to them. This makes the cache perform better: future 'fetch'
         * operations are more likely to be satisfied without needing to wait for HTTP requests.
         *
         * We recommend that you always enable this option. Please ensure that none of your other code
         * relies on cache entries being evicted synchronously.
         */
        extendEntryLifetimes?: boolean;
        /**
         * For debugging/diagnostic purposes, this is the name of the DataCache included in any error logging done for this DataCache.
         */
        cacheName?: string;
    }
    /**
     * Represents data that may be merged into a cache.
     */
    interface DataCacheProcessedResponse {
        /**
         * The item object, or items array, that should be merged into the cache.
         */
        data: any;
        /**
         * Optional navigation metadata corresponding to the cache entry. This supports
         * navigation in standard controls, such as paging in grids.
         */
        navigationMetadata?: DataNavigationMetadata;
        /**
         * An optional collection of partial errors returned by the server, possibly in
         * addition to any data received successfully.
         */
        partialErrors?: MsPortalFx.Data.PartialError[];
    }
    /**
     * Options for configuring a DataView.
     */
    interface DataViewConfig<TEntity, TParams> extends FxImpl.Data.ObjectViewConfig<TEntity, TParams> {
    }
}

// FILE: MsPortalFx\Data\Data.DataCacheLoader.d.ts
declare module MsPortalFx.Data {
    /**
     * A promise that completes with a DataSet instance, and also knows ahead of time what the DataSet instance's
     * name will be.
     */
    interface DataSetPromise extends MsPortalFx.Base.PromiseV<Data.DataSet> {
        dataSetName: string;
    }
    /**
     * An object that can supply data for a DataCache.
     */
    class DataCacheLoader<TEntity, TParams> {
        protected _dataType: string;
        private _uriForParams;
        private _httpMethod;
        private _polls;
        private _pollInterval;
        protected _atomizationOptions: AtomizationOptions;
        private _serializeParams;
        private _supplyData;
        private _processServerResponse;
        private _preservesClientOrder;
        private _setAuthHeader;
        /**
         * Constructs an instance of DataCacheLoader<TEntity, TParams>.
         *
         * @param config Configuration options specifying how the data should be loaded.
         */
        constructor(config: DataCacheLoaderConfig<TEntity, TParams>);
        /**
         * Returns a boolean reflecting whether this DataCacheLoader will do background polling refresh
         * of its cached data.
         */
        _doesPoll(): boolean;
        /**
         * Provides an arbitrary string representation of the specified query parameters. Any two
         * logically different parameter objects must map to different strings. Any two logically
         * equivalent parameter objects must map to the same string.
         *
         * @param params The query parameters to be serialized.
         * @return A string representation of the parameters.
         */
        serializeParams(params: TParams): string;
        /**
         * Begins loading a DataSet corresponding to the specified query parameters. The resulting
         * DataSet must have the specified name.
         *
         * Subclasses of DataCacheLoader may override this method to customise the loader options
         * that get passed on to the loadDataSet method.
         *
         * @param dataSetName A name for the resulting DataSet.
         * @param params Parameters representing the data to be loaded.
         * @param entryLifetime Lifetime object of the cache entry being created.
         * @return A DataSetPromise instance.
         */
        loadDataSetForParams(dataSetName: string, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): DataSetPromise;
        /**
         * Begins loading a DataSet corresponding to the specified loader options. The resulting
         * DataSet must have the specified name.
         *
         * @param dataSetName A name for the resulting DataSet.
         * @param dataSetLoaderOptions Options describing the URI, HTTP headers, etc., to be used in the request.
         * @return A DataSetPromise instance.
         */
        loadDataSet(dataSetName: string, dataSetLoaderOptions: DataSetLoaderOptions): DataSetPromise;
        /**
         * Begins a new request that will cause the specified DataSet to have its data observably refreshed.
         *
         * @param dataSetPromise A DataSetPromise that, when completed, refers to the DataSet to be disposed.
         * @return A promise that completes when the refresh has completed.
         */
        refreshDataSet(dataSetPromise: DataSetPromise): Base.PromiseV<FetchData>;
        /**
         * Notifies the loader that the specified DataSet is no longer in use. Any polling for the DataSet
         * will be stopped, and it may be released from memory.
         *
         * @param dataSetPromise A DataSetPromise that, when completed, refers to the DataSet to be disposed.
         */
        disposeDataSet(dataSetPromise: DataSetPromise): void;
        /**
         * Obtains the named data set, if it is already loaded and populated.
         *
         * @param dataSetName The name of the DataSet.
         * @return The DataSet instance if it is already loaded, otherwise null.
         */
        getLoadedDataSet(dataSetName: string): MsPortalFx.Data.DataSet;
        /**
         * Determines whether or not the specified data set is awaiting a response to an already-issued request.
         * @param dataSetName The name of the data set.
         * @return True if a request is in flight; false otherwise.
         */
        isLoadingDataSet(dataSetName: string): boolean;
        protected _getDataSetLoaderOptions(dataSetName: string, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): DataSetLoaderOptions;
    }
    class DataCacheLoader2<TEntity, TParams> extends DataCacheLoader<TEntity, TParams> {
        /**
         * Constructs an instance of DataCacheLoader2<TEntity, TParams>.
         *
         * @param config Configuration options specifying how the data should be loaded.
         */
        constructor(config: DataCacheLoaderConfig<TEntity, TParams>);
        /**
         * Creates a DataSet in the underlying loader, populating the DataSet with some initial data.
         *
         * @param dataSetName The name of the DataSet.
         * @param params Parameters representing the data to be loaded.
         * @param data Initial data for the DataSet.
         * @param entryLifetime Lifetime object of the cache entry being created.
         * @return The DataSet in the underlying loader
         */
        establishDataSet(dataSetName: string, params: TParams, data: any, entryLifetime: MsPortalFx.Base.LifetimeManager): Data.DataSet;
    }
}

// FILE: MsPortalFx\Data\Data.DataProvider.d.ts
declare module MsPortalFx.Data.DataProvider {
    /**
     * The contract of DataProvider.
     */
    interface DataProvider {
        /**
         * processResult function is an option for Data.Loader.
         */
        processResult?: ProcessResultFunction;
        /**
         * shapeQuery function.
         */
        shapeQuery?: ShapeQueryFunction;
    }
}

// FILE: MsPortalFx\Data\Data.DataProvider.DataContractJsonSerializer.d.ts
declare module MsPortalFx.Data.DataProvider {
    let DataContractJsonSerializer: DataProvider;
}

// FILE: MsPortalFx\Data\Data.DataProvider.OData.d.ts
declare module MsPortalFx.Data.DataProvider {
    interface ODataQuery {
        /**
         * String result should be filtered with.
         */
        $filter?: string;
        /**
         * Name of property by which result should be ordered.
         */
        $orderby?: string;
        /**
         * Number of entries that should be skipped.
         */
        $skip?: number;
        /**
         * Cap number of result entries.
         */
        $top?: number;
        /**
         * Should include result entries count.
         */
        $inlinecount?: string;
    }
    let OData: DataProvider;
}

// FILE: MsPortalFx\Data\Data.DataSet.d.ts
declare module MsPortalFx.Data {
    import Fx = MsPortalFx;
    import DataSetMergeOptions = Fx.Data.DataSetMergeOptions;
    /**
     * DataSet is a simple data abstraction exposing managed values through single property.
     */
    class DataSet {
        private _type;
        private _data;
        private _navigationMetadata;
        private _partialErrors;
        private _lifetime;
        _atomizationContext: FxImpl.Data.AtomizationContext;
        /**
         * Creates a data set.
         *
         * @param type The type of the data to be cached in the data set.
         * @param lifetime Data set lifetime object.
         * @param atomizationOptions Atomization options, if not provided, data set will not be atomized.
         */
        constructor(type?: string, lifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: MsPortalFx.Data.AtomizationOptions);
        /**
         * The data cached in this data set.
         */
        get data(): any;
        /**
         * Lifetime manager of this data set. Only atomized data sets have lifetime managers.
         */
        get lifetime(): MsPortalFx.Base.LifetimeManager;
        /**
         * Type of data cached in this data set.
         */
        get type(): string;
        /**
         * Navigation metadata, if available, for this data set.
         */
        get navigationMetadata(): KnockoutObservable<DataNavigationMetadata>;
        /**
         * Error information associated with this data set.
         */
        get partialErrors(): KnockoutObservableArray<MsPortalFx.Data.PartialError>;
        /**
         * Locks a data item such that the item cannot be updated or deleted during merge. This is done to guard
         * against fetched server data overwriting client-side-only creates and updates.
         *
         * @param item The data item to be locked.
         * @param editKind The kind of client-side edit that preceded this lock.
         */
        static lockItem(item: any, editKind: EditKind): void;
        /**
         * Indicates whether any items within the data set have been recently unlocked and not yet subsequently merged
         * from server data.
         *
         * @param data The data to be examined for unmerged client changes.  If null or not supplied, all data cached
         * in the data set will be considered.
         * @return A boolean indicating whether the data has unmerged client changes.
         */
        static hasUnmergedClientChanges(data: any): boolean;
        /**
         * Unlocks a data item so that the item can be updated or deleted during merge. This is done once a client-side
         * create/update has been acknowledged by the server.
         *
         * @param item The data item to be unlocked.
         * @param rememberLockUntilMerged Indicates that the lock is to be remembered as an indicator of an item that
         * is not synchronized with respect to its server-side counterpart.  See 'hasUnmergedClientChanges'.  Defaults
         * to 'true' if not supplied.
         */
        static unlockItem(item: any, rememberLockUntilMerged: boolean): void;
        /**
         * Determines if a data item is locked.
         *
         * @param item The data item.
         * @return A boolean value indicating whether the data item is locked.
         */
        static isLockedItem(item: any): boolean;
        /**
         * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
         *
         * @param dataSetOrArray The data set or array cached within a data set for which the id properties will be determined.
         * @return An array of property names or null.
         */
        static getIdPropertyNames(dataSetOrArray: any): string[];
        /**
         * Gets the name of that data item property that uniquely identifies a data item among its peers in a cached array.
         *
         * @param dataSetOrArray The data set or array cached within a data set for which the id property will be determined.
         * @return A property name or null.
         */
        static getIdPropertyName(dataSetOrArray: any): string;
        /**
         * Merges new data onto a discrete array/object contained in the data set.
         * This method should not be used with DataSets that are enabled for data atomization.
         * For scenarios using data atomization, use the "merge" instance method on DataSet.
         *
         * @param source The new data to be merged onto cached data.
         * @param target The cached data onto which the new data will be merged.
         * @param mergeOptions An optional object describing merge options.
         */
        static mergeWithoutAtomization(source: any, target: any, mergeOptions?: DataSetMergeOptions): void;
        /**
         * Adds an item in an observable manner to an array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param sourceArray Objects to be inserted into array. These objects will be cloned and appropriately decorated before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param lock Indicates whether the item should be locked. Defaults to true.
         * @param targetArray Target array in DataSet.
         */
        addItems(index: number, sourceArray: any[], mergeOptions?: DataSetMergeOptions, lock?: boolean, targetArray?: KnockoutObservableArray<any>): void;
        /**
         * Adds an item in an observable manner to an array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param sourceArray Objects to be inserted into array. These objects will be cloned and appropriately decorated before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param lock Indicates whether the item should be locked. Defaults to true.
         * @param targetArray Target array in DataSet.
         */
        addItems(index: number, sourceArray: any[], mergeOptions?: DataSetMergeOptions, lock?: boolean, targetArray?: any[]): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param howMany How many elements should be removed from the array.
         * @param type Target's type. If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param targetArray Target array in DataSet.
         */
        removeItems(index: number, howMany?: number, type?: string, targetArray?: KnockoutObservableArray<any>): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param howMany How many elements should be removed from the array.
         * @param type Target's type. If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param targetArray Target array in DataSet.
         */
        removeItems(index: number, howMany?: number, type?: string, targetArray?: any[]): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param item Item to be removed from within target array.
         * @param type Type of the item.
         * @param targetArray Target array from which item will be removed. If not provided, operation will be performed on data set root.
         */
        removeItem(item: any, type?: string, targetArray?: any): void;
        /**
         * Sets property of a target with a given value.
         *
         * @param propertyName Name of a property on target object in DataSet.
         * @param source Value object, which target[propertyName] will be set to.
         * This object will be cloned and associated with enity type metadata before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param target Target object in DataSet.
         */
        setProperty(propertyName: string, source: any, mergeOptions?: DataSetMergeOptions, target?: any): void;
        /**
         * Merges new data into the data set.
         *
         * @param source The new data to be merged into this data set.
         * @param mergeOptions An optional object describing merge options.
         */
        merge(source: any, mergeOptions?: DataSetMergeOptions): void;
        /**
         * Indicates whether any items within the data set have been recently unlocked and not yet subsequently merged
         * from server data.
         *
         * @param data The data to be examined for unmerged client changes.  If null or not supplied, all data cached
         * in the data set will be considered.
         * @return A boolean indicating whether the data has unmerged client changes.
         */
        hasUnmergedClientChanges(): boolean;
    }
}

// FILE: MsPortalFx\Data\Data.DataSetMergeOptions.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes possible MsPortalFx.Data.DataSet merge options.
     */
    interface DataSetMergeOptions {
        /**
         * When merging an array, indicates that the ordering of the new array should be preserved.
         */
        preserveNewItemsOrdering?: boolean;
        /**
         * Indicates that items are not to be removed from arrays during this merge.
         */
        preventItemRemoval?: boolean;
        /**
         * The time at which the fetch for the new data was initiated. New data will only be merged into the cache
         * if it was sourced after its cached counterpart was unlocked.
         */
        fetchStart?: number;
        /**
         * A name used to tag diagnostic output from this merge.
         */
        dataSetName?: string;
        /**
         * The type of the data being merged (if not supplied during construction).
         */
        type?: string;
    }
}

// FILE: MsPortalFx\Data\Data.EditScope.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplied at construction time, reflects the kind of EditScope instance that will be created.
     */
    enum EditScopeKind {
        /**
         * A copy of the input data becomes 'editScope.root', the editable data to which UI is bound.
         */
        Copy = 0,
        /**
         * The input data itself becomes 'editScope.root', the editable data to which UI is bound.
         */
        InPlace = 1
    }
    /**
     * Reflects the edit state of an item.
     */
    enum EditState {
        /**
         * The item has not been edited since it was loaded from the server.
         */
        None = 0,
        /**
         * The item is one that was created in memory but not yet created on the server.
         */
        Created = 1,
        /**
         * The item is one that is marked for deletion but not yet deleted on the server.
         */
        Deleted = 2,
        /**
         * The item is one whose property values have been updated in memory but not yet saved to the server.
         */
        Updated = 3
    }
    /**
     * Editable copy of input data, which can then be utilized in editable, revertable view models.
     */
    interface EditScope<TData> extends MsPortalFx.Base.Disposable {
        /**
         * The editable, revertable copy of the input data.
         */
        root: TData;
        /**
         * Is 'true' if the EditScope contains edited entities (entities in 'Updated', 'Deleted' or 'Created' states).
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Is 'true' if the EditScope is currently refreshing (its 'refresh' method has been called and the
         * corresponding operation is in progress).
         */
        refreshing: KnockoutObservableBase<boolean>;
        /**
         * Is 'true' if the EditScope is currently saving its changes (its 'saveChanges' method has been called and the
         * corresponding operation is in progress).
         */
        saving: KnockoutObservableBase<boolean>;
        /**
         * Marks an entity in the EditScope as being deleted, putting the entity in the 'Deleted' state.
         *
         * @param entity The entity.
         */
        markForDelete(entity: Object): void;
        /**
         * Creates a new empty entity that can be added to the given array of entities when the edits are saved.
         *
         * @param entityArray The entity array to which the new, empty entity will be added.
         * @return The empty entity that has not yet been added to the given array of entities.
         */
        create<TEntity>(entityArray: TEntity[]): TEntity;
        /**
         * Creates a new empty entity that can be added to the given array of entities when the edits are saved.
         *
         * @param entityArray The entity array to which the new, empty entity will be added.
         * @return The empty entity that has not yet been added to the given array of entities.
         */
        create<TEntity>(entityArray: KnockoutObservableBase<TEntity[]>): TEntity;
        /**
         * Adds a created entity to the given array of entities when the edits are saved.
         * The entity is added in the array of created entities retrieved using 'getCreated'.  The entity will
         * be in the 'Created' state.
         *
         * @param entity The entity to be added to the array of created entitites.
         * @param entityArray The entity array to which the new, empty entity will be added.
         */
        addCreated<TEntity>(entity: TEntity, entityArray: TEntity[]): void;
        /**
         * Adds a created entity to the given array of entities when the edits are saved.
         * The entity is added in the array of created entities retrieved using 'getCreated'.  The entity will
         * be in the 'Created' state.
         *
         * @param entity The entity to be added to the array of created entitites.
         * @param entityArray The entity array to which the new, empty entity will be added.
         */
        addCreated<TEntity>(entity: TEntity, entityArray: KnockoutObservableBase<TEntity[]>): void;
        /**
         * Reverts any creates, updates, deletes applied to this entity, return it to the 'None' edit state.
         * Created entities are removed from their 'getCreated' entities array.  Updated entities are restored
         * to their original values.  Deleted entities are no longer marked for delete.
         *
         * @param entity The entity being reverted.
         */
        revert(entity: Object): void;
        /**
         * Reverts any creates, updates, deletes applied to the EditScope.
         * Created entities are removed from their 'getCreated' entities array.  Updated entities are restored
         * to their original values.  Deleted entities are no longer marked for delete.
         */
        revertAll(): void;
        /**
         * Gets an observable EditState value, reflecting the create/update/delete state of the supplied entity.
         *
         * @param entity The entity being reverted.
         * @return The observable EditState value.
         */
        getEditState(entity: Object): KnockoutObservableBase<EditState>;
        /**
         * Gets the original data for a given editable entity or editable array of entities.
         *
         * @param entityOrEntityArray The editable entity or array of entities.
         * @return The data reflecting the original state of the editable data.
         */
        getOriginal(entityOrEntityArray: any): any;
        /**
         * Gets an array of created entities that will be created in the entity array when the EditScope edits are saved.
         *
         * @param entityArray The entity array to which entities have been added via 'create'.
         * @return The array of entities in the 'Created' state.
         */
        getCreated<TEntity>(entityArray: TEntity[]): KnockoutObservableArray<TEntity>;
        /**
         * Gets an array of created entities that will be created in the entityArray when the EditScope edits are saved.
         *
         * @param entityArray The entity array to which entities have been added via 'create'.
         * @return The array of entities in the 'Created' state.
         */
        getCreated<TEntity>(entityArray: KnockoutObservableBase<TEntity[]>): KnockoutObservableArray<TEntity>;
        /**
         * This method is available only on EditScopes created via EditScopeKind.CopyInputDataToMakeEditableData.
         *
         * Updates the EditScope so that 'editScope.root' (the editable data) reflects the current values in the
         * original data.
         *
         * This method should be used:
         * - To load original data asynchronously after the EditScope has been created and bound into view models.
         * - To incrementally load more or different original data into the EditScope ("show more" or "sort" in a grid).
         */
        mergeFromOriginal(): void;
        /**
         * Applies updates to EditScope data in such a way that updates are not confused with user-enacted edits and,
         * thus, do not dirty the EditScope.
         *
         * When this method completes, editable and original entities will both reflect their refreshed state.
         * User-enacted property-level updates will be over-written by newly loaded values.
         */
        refresh(): MsPortalFx.Base.Promise;
        /**
         * Initiates an async save operation to commit EditScope edits to a server.  Requires that the corresponding
         * EditScopeCache has been configured with a 'saveEditScopeChanges' callback.
         *
         * When the operation completes, the EditScope will be back in a non-dirty state, reflecting the now-saved
         * data.
         */
        saveChanges(): MsPortalFx.Base.Promise;
        /**
         * Resets the value of an EditScope observable, in a manner where the reset is not confused as a user-authored
         * edit.
         */
        resetValue<TValue>(accessor: EditScopeAccessors<TValue>, newValue: EditScope.ResetValue<TValue>): void;
        /**
         * For a given entity array, returns an array representation that includes the user's edits.  Here:
         * - 'Created' entities are appended and;
         * - 'Updated' entities are represented with user-edited property values and;
         * - 'Deleted' entities are excluded.
         * Additionally, this method returns discrete arrays of 'Created', 'Updated' and 'Deleted' entities (to save
         * explicit calls to 'editScope.getCreated()' and filtering based on 'editScope.getEditState()').
         */
        getEntityArrayWithEdits<TEntity>(entityArray: TEntity[] | KnockoutObservableBase<TEntity[]>): EntityArrayWithEdits<TEntity>;
        /**
         * Applies any differences between 'sourceArray' and 'targetArray' as user edits to the supplied EditScope
         * 'targetArray'.
         *
         * If 'targetArray' is an EditScope entity array (that is, an array described by type metadata that includes
         * '{ entityType: true }'), then differences are applied as follows:
         * - 'Created' entities: Any entities that are exclusive to 'sourceArray' (that is, not in 'targetArray') will be
         * represented as 'Created' entities (see 'editScope.addCreated()' and 'editScope.getCreated()').
         * - 'Updated' entities: For entities common to 'sourceArray' and 'targetArray', updated property values in the
         * entity from 'sourceArray' will be applied to the corresponding entity in 'targetArray'.
         * - 'Deleted' entities: Any entities missing from 'sourceArray' (that is, are in 'targetArray' only) will be
         * represented in 'targetArray' as 'Deleted' entities.
         *
         * If 'targetArray' is an EditScope array that is not entity-typed (not described by type metadata at all or
         * described by type metadata that doesn't include '{ entityType: true }'), then the items in 'targetArray' will
         * be replaced entirely by those in 'sourceArray'.  In this case, 'sourceArray' and 'targetArray' are treated
         * like single values.
         *
         * It is recommended that 'targetArray' be modeled as an entity array, as then, user edits can be persisted in
         * a small, space-efficient format.  In contrast, any user edit to a non-entity typed array requires that the
         * persisted edit include the entire array contents (which can be large).
         */
        applyArrayAsEdits<TItem>(sourceArray: TItem[], targetArray: TItem[]): void;
        /**
         * Applies any differences between 'sourceArray' and 'targetArray' as user edits to the supplied EditScope
         * 'targetArray'.
         *
         * If 'targetArray' is an EditScope entity array (that is, an array described by type metadata that includes
         * '{ entityType: true }'), then differences are applied as follows:
         * - 'Created' entities: Any entities that are exclusive to 'sourceArray' (that is, not in 'targetArray') will be
         * represented as 'Created' entities (see 'editScope.addCreated()' and 'editScope.getCreated()').
         * - 'Updated' entities: For entities common to 'sourceArray' and 'targetArray', updated property values in the
         * entity from 'sourceArray' will be applied to the corresponding entity in 'targetArray'.
         * - 'Deleted' entities: Any entities missing from 'sourceArray' (that is, are in 'targetArray' only) will be
         * represented in 'targetArray' as 'Deleted' entities.
         *
         * If 'targetArray' is an EditScope array that is not entity-typed (not described by type metadata at all or
         * described by type metadata that doesn't include '{ entityType: true }'), then the items in 'targetArray' will
         * be replaced entirely by those in 'sourceArray'.  In this case, 'sourceArray' and 'targetArray' are treated
         * like single values.
         *
         * It is recommended that 'targetArray' be modeled as an entity array, as then, user edits can be persisted in
         * a small, space-efficient format.  In contrast, any user edit to a non-entity typed array requires that the
         * persisted edit include the entire array contents (which can be large).
         */
        applyArrayAsEdits<TItem>(sourceArray: TItem[], targetArray: KnockoutObservableBase<TItem[]>): void;
    }
    /**
     * A snapshot representation of an user-edited entity array, where the representation includes 'Created' entities
     * but doesn't include 'Deleted' entities.  This representation is suitable for returning from a ParameterProvider
     * Blade back to a corresponding ParameterCollector, where the array can be applied to the ParameterCollector's
     * EditScope using 'editScope.applyArrayAsedits()'.
     */
    interface EntityArrayWithEdits<TEntity> {
        /**
         * An array representation of an entity array where:
         * - 'Created' entities are appended and;
         * - 'Updated' entities are represented with edited property values and;
         * - 'Deleted' entities are not represented at all (are excluded).
         */
        arrayWithEdits: TEntity[];
        /**
         * 'Created' entities in the containing entity array.  These could otherwise be accessed using
         * 'editScope.getCreated()'.
         */
        createdEntities: TEntity[];
        /**
         * 'Updated' entities in the containing entity array.  These could otherwise be determined using
         * 'editScope.getEditState()' and filtering entities that are in the 'Updated' state.
         */
        updatedEntities: TEntity[];
        /**
         * 'Deleted' entities in the containing entity array.  These could otherwise be determined using
         * 'editScope.getEditState()' and filtering entities that are in the 'Deleted' state.
         */
        deletedEntities: TEntity[];
    }
    /**
     * A description of an entity edited in the EditScope.  An array of these is supplied as part of an EditScope
     * 'saveChanges' operation.  See EditScopeCacheOptions.saveEditScopeChanges.
     */
    interface EditScopeEdit {
        /**
         * Reflects the kind of edit for this entity (create, update or delete).
         */
        editState: EditState;
        /**
         * The type name of the edited entity.
         */
        entityTypeName: string;
        /**
         * The edited entity.
         */
        entity: any;
    }
    /**
     * Different actions to be taken -- after an EditScope 'saveChanges' operation completes successfully --
     * to reflect the user's now-saved edits in the EditScope.  See EditScopeCacheOptions.saveEditScopeChanges.
     */
    enum AcceptEditScopeChangesAction {
        /**
         * When this action is returned, the user's client-side edits are accepted as the new EditScope values once
         * the 'saveChanges' operations completes successfully.  It assumed that these client-side edits reflect the state
         * saved to the server.
         */
        AcceptClientChanges = 0,
        /**
         * When this action is returned, the user's client-side edits accumulated in the EditScope are
         * discarded/reverted once the 'saveChanges' operation completes successfully.  This is useful for scenarios
         * where a user completes a form and clicks 'add' to add an item to a collection, then the form clears
         * to allow for the addition of successive items.
         */
        DiscardClientChanges = 1,
        /**
         * When this action is returned, the EditScope will be implicitly refreshed once the 'saveChanges' operation completes
         * successfully.  The user's client-side edits will be discarded in favor of those newly saved values returned
         * from the server during the 'refresh' operation.
         */
        RefreshFromServerImplicitly = 2,
        /**
         * When this action is returned, it is assumed that the 'dataToUpdate' parameter to the 'saveEditScopeChanges'
         * callback was updated from the server data by the callback.  In this case, it is assumed that this update
         * reflects both the user's edits and any server-generated values related to the save.  The user's client-side
         * edits will be discarded in favor of those values returned from the server.
         */
        ServerChangesAppliedManually = 3,
        /**
         * When this action is returned, it is expected that the 'dataToMerge' property is additionally supplied and
         * that it contains the newly saved server data.  In this case, it is assumed that 'dataToMerge' reflects both
         * the user's edits and any server-generated values related to the save.  The user's client-side edits will be
         * discarded in favor of those values returned from the server.
         */
        ServerDataReturned = 4
    }
    /**
     * The promise returned from 'saveEditScopeChanges' on 'EditScopeCache' can resolve with an object of this type.
     * This object describes how/whether user edits are to be accepted as the new, post-'saveChanges' values in the
     * EditScope.
     */
    interface AcceptEditScopeChangesOptions<TData> {
        /**
         * A description of what to do with user edits when the EditScope 'saveChanges' operation concludes.
         */
        action: AcceptEditScopeChangesAction;
        /**
         * When 'action' is 'AcceptEditScopeChangesAction.ServerDataReturned', this is the server data that is be
         * accepted as the new EditScope data.  It is assumed that this data reflects both the user's saved edits
         * as well as any server-generated values related to the save.  The user's client-side edits will be discarded
         * in favor of the values in 'dataToMerge'.
         */
        dataToMerge?: TData;
    }
    /**
     * Represents a pair of functions that can be evaluated to acquire corresponding 'original' and 'editable'
     * observables from an EditScope.
     */
    interface EditScopeAccessors<TValue> {
        /**
         * A function that will return an observable containing the original value for the field.
         */
        getOriginalObservable: (lifetime: MsPortalFx.Base.LifetimeManager) => KnockoutObservableBase<TValue>;
        /**
         * A function that will return an observable containing the editable value for the field.
         */
        getEditableObservable: (lifetime: MsPortalFx.Base.LifetimeManager) => KnockoutObservableBase<TValue>;
    }
}
declare module MsPortalFx.Data.EditScope {
    /**
     * See EditScope's 'resetValue' method.  This represents the values with which to reset a pair of corresponding
     * 'original' and 'editable' EditScope observables.
     */
    interface ResetValue<TValue> {
        /**
         * The new value for the EditScope observable that is being reset with EditScope's 'resetValue'
         * method.  This becomes the value of both the 'editable' and 'original' versions of the data.
         */
        newInputValue: TValue;
        /**
         * Optional.  This should be a different value than 'newInputValue'.  This value will be applied to the
         * 'editable' version data, putting the enclosing entity into an 'Updated' state (since the 'original'
         * and 'editable' values will be different).
         */
        newEditableValue?: TValue;
    }
}
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import Metadata = Fx.Data.Metadata;
    import EditState = Fx.Data.EditState;
    import MergeVisitorOptions = FxImpl.Data.MergeVisitorOptions;
    import AcceptEditScopeChangesOptions = Fx.Data.AcceptEditScopeChangesOptions;
    import EditScopeKind = Fx.Data.EditScopeKind;
    import PromiseV = Fx.Base.PromiseV;
    /**
     * The flag specifying that some edits can be non-persistent. This applies, for example, to passwords.
     * We consider removing non-persistent objects but decided to keep code supporting it for a while and use this flag for it.
     * The flag should be used for tests only to keep the code for a while.
     * Do not use the flag in PROD code.
     * TODO: Should be removed later with RDTask 4285673:[IaaSV2] Get rid of non-persistent properties at all
     *       (also _shouldPersistObjectPropertyEdits, _removeNonPersistedPropertySentinels, and dependent code)
     */
    let allowNonPersistentEdits: boolean;
    /**
     * Serializable edits collected by an EditScope.
     */
    interface EditScopeEdits {
        /**
         * A version number for the serialization format used to serialize the edits.
         */
        version?: number;
        /**
         * The serializable edits.
         */
        edits: EditScopeEdit[];
    }
    /**
     * A single, serializable edit collected by an EditScope.
     */
    interface EditScopeEdit {
        /**
         * Reflects whether this edit is a create, update or delete.
         */
        state: EditState;
        /**
         * A reference to the entity to which the edit pertains.
         * For 'Updated' and 'Deleted', this is the entity being updated or deleted.
         * For 'Created', this is the entity that nests an entity-typed array into which nested entities are being
         * created.
         */
        entityReference: EntityReference;
        /**
         * For creates in entity array, this is the dot-delimited path into the entity object used to locate
         * the nested array.
         */
        entityPath?: string;
        /**
         * For creates in entity array, these are serialized representations of the created entities.
         */
        createdEntities?: string[];
        /**
         * For entity updates, this is a serialized representation of the entity updates.
         */
        entityUpdates?: string;
    }
    /**
     * A serializable reference to an entity.  Used to create a serializable description of an entity edit.
     */
    interface EntityReference {
        /**
         * The type of the entity.
         */
        type: string;
        /**
         * The id of the entity.
         */
        id: string;
    }
    /**
     * Internal EditScope interface with which we serialize/deserialize EditScope edits.
     */
    interface EditScope<TData> extends Fx.Data.EditScope<TData> {
        /**
         * Gets edits in an EditScope in a serializable form.
         * @return The serializable edits.
         */
        getEdits(): EditScopeEdits;
        /**
         * An observable that signals when 'getEdits()' have changed (and should be saved to user settings).
         * @return The observable whose value changes when 'getEdits()' have changed.
         */
        editsChanged: KnockoutObservableBase<void>;
        /**
         * Applies edits to an EditScope.
         * @param edits The deserialized edits.
         * @return A boolean indicating whether the edits could be applied.  Returns 'false' if the underlying original
         * data has changed in such a way that the edits couldn't be applied.
         */
        applyEdits(edits: EditScopeEdits): boolean;
        /**
         * A boolean reflecting whether the EditScope has been disposed.
         */
        isDisposed: boolean;
    }
    /**
     * Options supplied when instantiating an EditScope.
     */
    interface EditScopeOptions<TData> {
        /**
         * Reflects the kind of EditScope instance that will be created via Internal.Data.EditScope.createEditScope().
         * If not supplied, the default value is EditScopeKind.Copy.
         */
        kind?: EditScopeKind;
        /**
         * Optional name of a type describing the data.  If neither 'typeName' nor 'typeMetadata' is supplied, it is
         * assumed that the data being edited consists of a single entity (with no provision for nesting entities).
         */
        typeName?: string;
        /**
         * Optional type metadata describing the data.  If neither 'typeName' nor 'typeMetadata' is supplied, it is
         * assumed that the data being edited consists of a single entity (with no provision for nesting entities).
         */
        typeMetadata?: Metadata.Metadata;
        /**
         * Optional callback that will be called when the EditScope 'refresh' method is called.  With the callback,
         * the EditScope data can be updated directly via 'dataToUpdate' or the callback can resolve its returned
         * promise with the data for EditScope to merge.
         */
        refresh?: (dataToUpdate: TData) => PromiseV<TData>;
        /**
         * Optional callback that will be called when the EditScope 'saveChanges' method is called.  Once the edits
         * have been saved to the server, the callback can choose to update the EditScope data with saved server data
         * (although this is an uncommon scenario).  To do so, it should resolve its promise with options describing
         * how to merge the saved server data.
         */
        save?: (editScope: Fx.Data.EditScope<TData>, edits: Fx.Data.EditScopeEdit[], dataToUpdate: TData) => PromiseV<AcceptEditScopeChangesOptions<TData>>;
    }
    /**
     * An interface from which Form's EditScopeAccessors will inherit.  Used to identify those EditScopeAccessors
     * that always return observables contained in the EditScope, making these EditScopeAccessors usable by
     * EditScope's 'resetValue' method.
     */
    interface InternalEditScopeAccessors {
        /**
         * Identifies EditScopeAccessors that are usable by the EditScope.resetValue() method.
         */
        returnsObservablesFromEditScope: boolean;
    }
    /**
     * Constructs an EditScope instance.
     *
     * @param data Model data from which an editable copy will be created.
     * @param options Optional options with which the EditScope will be created.
     * @return The created EditScope instance.
     */
    function createEditScope<TData>(lifetimeManager: MsPortalFx.Base.LifetimeManager, data: TData, options?: EditScopeOptions<TData>): EditScope<TData>;
    function logEditsToConsole(edits: EditScopeEdits): void;
    let nonPersistedPropertySentinel: string;
    /**
     * Options supplied when constructing a ApplyEntityArrayAsEditsVisitor.
     */
    interface ApplyEntityArrayAsEditsVisitorOptions<TEntity> extends MergeVisitorOptions {
        /**
         * Delegates to the caller the responsibility of treating the add of an entity to an entity array
         * in the course of applying edits from the source entity array to the target entity array.
         */
        handleAdd: (entityToAdd: TEntity) => void;
        /**
         * Delegates to the caller the responsibility of treating the delete of an entity from an entity array
         * in the course of applying edits from the source entity array to the target entity array.
         */
        handleDelete: (entityToDelete: TEntity) => void;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A ref-counted cache of EditScopes.
     */
    interface EditScopeCache<TData, TParams> extends MsPortalFx.Base.Disposable {
        /**
         * Creates an EditScopeView that is used by a view model to fetch EditScope instances.
         *
         * @param lifespan Reflects the lifetime of the caller.  This is used to determine when cached EditScopes are no
         * longer referenced.
         * @return An EditScopeView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager): EditScopeView<TData, TParams>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         * @return A promise that resolves when callback has been called on all editScopes.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<TData>) => void): MsPortalFx.Base.Promise;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeCache.Create.d.ts
declare module MsPortalFx.Data.EditScopeCache {
    /**
     * Creates a new instance of EditScopeCache for specified options.
     */
    function createNew<T, TId>(options: MsPortalFx.Data.EditScopeCacheOptions<T, TId>): MsPortalFx.Data.EditScopeCache<T, TId>;
    /**
     * @deprecated EditScopeCache.create is deprecated.
     * Creates a new instance of EditScopeCache for specified options.
     */
    function create<T, TId>(options: MsPortalFx.Data.EditScopeCacheOptions<T, TId>): MsPortalFx.Data.EditScopeCache<T, TId>;
}

// FILE: MsPortalFx\Data\Data.EditScopeCacheOptions.d.ts
declare module MsPortalFx.Data {
    import FxBase = MsPortalFx.Base;
    /**
     * Options supplied to EditScopeCache.createNew.
     */
    interface EditScopeCacheOptions<TData, TParams> {
        /**
         * Determines the kind of EditScope that will be created.  Defaults to
         * EditScopeKind.CopyInputDataToMakeEditableData.
         */
        kind?: EditScopeKind;
        /**
         * Type metadata name. Only necessary for EditScopes that contain more than simply a root-level entity
         * (rather, that contain nested entities).
         */
        entityTypeName?: string;
        /**
         * Generates a string that will be used as the cache key for a cached EditScope.  This function should return a
         * unique string for every distinct 'params' in use.
         *
         * @param params Parameters identifying the EditScope data.
         * @return A string represention of the parameters.
         */
        serializeParams?: (params: TParams) => string;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForNewData)
         * this data cache (a QueryCache or EntityCache) is used to retrieve data that will be used as the original
         * data for the new EditScope.
         */
        dataCache?: EditScopeInputDataCache<TData, TParams>;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForNewData)
         * this function returns an instance of type TData that will be used as the original data for the new EditScope.
         * If this function is not supplied, then Metadata.create(entityTypeName) will be used to create an object
         * (and not an array) of type TData.
         *
         * @return Data to be used as the original data for the new EditScope. This can be an object, an array or an
         * observable array of the type described by 'entityTypeName'.
         */
        supplyNewData?: () => TData;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForExistingData)
         * this function retrieves existing data identified by 'params'. This data will be used as the original
         * data for the EditScope.
         * In most cases, it is simpler to supply the 'dataCache' option to retrieve existing data, since
         * QueryCache/EntityCache instances can be simply configured to load server data.
         *
         * @param params Parameters used to retrieve data.
         * @param lifetime An object that issues a notification when the cache entry is evicted. Use this to clean up
         * any resources held by the cache entry.
         * @return A promise resolved with the data.
         */
        supplyExistingData?: (params: TParams, lifetime: MsPortalFx.Base.LifetimeManager) => FxBase.PromiseV<TData>;
        /**
         * Optional callback that will be called when the EditScope 'refresh' method is called.  With the callback,
         * the EditScope data can be updated directly via 'dataToUpdate' or the callback can resolve its returned
         * promise with the data for EditScope to merge.
         *
         * @param params Parameters identifying the EditScope.
         * @param lifetime An object that issues a notification when the refresh is completed.  Typical use it to use
         * 'lifetime' to acquire an EntityView or QueryView with which to refresh EditScope input data.
         * @param dataToUpdate The data which the callback can manually update to reflect server changes.
         * @return A promise reflecting when new server data has been loaded.  If the promise is resolved with new
         * data, the new data will be merged into the EditScope.  Otherwise, it will be assumed that 'dataToUpdate'
         * was updated manually to reflect the latest state of the data on the server.
         */
        refreshEditScope?: (params: TParams, lifetime: FxBase.LifetimeManager, dataToUpdate: TData) => FxBase.PromiseV<TData>;
        /**
         * Optional callback that will be called when the EditScope 'saveChanges' method is called, delegating to the
         * extension to save EditScope edits to their server.
         *
         * @param params Parameters identifying the EditScope.
         * @param editScope The EditScope whose changes are being saved.
         * @param edits A description of the edits accumulated by the EditScope.
         * @param lifetime This should be used in the uncommon case where the extension chooses to -- once the server
         * has accepted the changes -- refresh the EditScope data from the server via a second HTTP call.  Typically,
         * 'lifetime' would be used to acquire an EntityView or QueryView with which to refresh EditScope data once the
         * HTTP call to save has completed.
         * @param dataToUpdate This should be used in the uncommon case where the extension chooses to -- once the server has
         * accepted the changes -- refresh the EditScope data (either based on the HTTP response from the save operation
         * or via a second HTTP call).  Importantly, this covers the case of server-generated values related to the save
         * operation.  'dataToUpdate' is the data which the callback can manually update to reflect the new server data.
         * @return A promise reflecting when the EditScope changes have been saved to the server (and, optionally, the
         * callback has obtained the newly saved data from the server).  The promise can be resolved with a
         * object describing how/whether to reflect the user's now-saved edits as the new values in the EditScope.
         * If the promise is resolved with no value, the user's client-side edits will be accepted and the EditScope
         * will simply be marked as not dirty.
         */
        saveEditScopeChanges?: (params: TParams, editScope: EditScope<TData>, edits: EditScopeEdit[], lifetime: FxBase.LifetimeManager, dataToUpdate: TData) => FxBase.PromiseV<AcceptEditScopeChangesOptions<TData>>;
        /**
         * An optional callback triggered when the EditScope is created and added to the cache.
         *
         * @param lifetime An object that issues a notification when the cached entry is evicted/disposed. Use this to
         * clean up any resources that share the same lifetime as the cached EditScope.
         */
        onEditScopeCreated?: (lifetime?: FxBase.LifetimeManager, editScope?: EditScope<TData>) => any;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeInputDataCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A cache of query results for a specific type of data and query parameters, suitable for use as input
     * data to an EditScopeCache.
     */
    interface EditScopeInputDataCache<TData, TParams> {
        /**
         * A boolean reflecting whether this DataCache is one that polls for server changes. Not proxyable
         */
        _doesPoll(): boolean;
        /**
         * Creates a DataView that provides a convenient way to retrieve data from the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new DataView. A
         * typical example is a PartContainer instance - supplying one means that the DataView's entries may be released
         * when the corresponding Part is removed from the UI.
         * @return A DataView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager): EditScopeInputDataView<TData, TParams>;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeInputDataView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of a single entry from an underlying EditScopeInputDataCache. The 'data' property represents the
     * value(s) returned from the most recently issued (and completed) 'fetch' or 'refresh' call.
     */
    interface EditScopeInputDataView<TData, TParams> {
        /**
         * Sets the DataView's current query parameters, changing what data it exposes.  The data will be fetched from
         * the underlying cache, which may or may not already have it in memory.
         *
         * If you call 'fetch' while an earlier load is still in progress, the older load will be superseded,
         * meaning that its promise will never complete.  This is so you do not need manual code to stop superseded
         * promise handlers from performing actions that are now irrelevant.
         *
         * @param params Query parameters describing the data to be fetched.  If you supply null/undefined, then the
         * preceding query will be superseded, but no new query will be begun - the DataView will therefore become
         * empty.
         * @return A promise that completes when the load has completed.
         */
        fetch(params: TParams): MsPortalFx.Base.Promise;
        /**
         * Instructs the underlying data cache to re-fetch and update whatever data is currently being exposed by this
         * instance.
         *
         * If a request is currently in progress, this does not trigger a further request.  So, it is safe to invoke
         * 'refresh' immediately after a 'fetch' if you want to be sure to fetch fresh data and not accept existing
         * cached data.
         *
         * @return A promise that completes when the refresh is done.  Or, if a request was already in progress, a
         * promise that completes when the existing request completes.
         */
        refresh(): MsPortalFx.Base.Promise;
        /**
         * The data loaded for this view.
         *
         * @return The loaded data of type TData (or null/undefined if the data has not been loaded).
         */
        data: TData;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeView.d.ts
declare module MsPortalFx.Data {
    import FxPromise = MsPortalFx.Base.Promise;
    interface EditScopeViewContract<TData, TParams> {
        /**
         * An observable containing an EditScope instance reflecting the last successful call to 'fetchForNewData' or
         * 'fetchForExistingData'.
         */
        editScope: KnockoutObservable<EditScope<TData>>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId'. This view's observable 'editScope'
         * property will be set with the fetched EditScope.
         */
        fetchForNewData(editScopeId: string): FxPromise;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId' and 'query'. This view's observable
         * 'editScope' property will be set with the fetched EditScope.
         */
        fetchForExistingData(editScopeId: string, params?: TParams): FxPromise;
    }
    /**
     * Options for configuring an EditScopeView.
     */
    interface EditScopeViewConfig<TData, TParams> extends FxImpl.Data.ObjectViewConfig<EditScope<TData>, FxImpl.Data.EditScopeKey<TParams>> {
    }
    /**
     * An EditScopeView is a view used to supply EditScopes to a view model. The view's observable 'editScope' changes
     * value to reflect asynchronous calls to 'fetchForNewData' and 'fetchForExistingData'.
     */
    class EditScopeView<TData, TParams> extends FxImpl.Data.ObjectView<EditScope<TData>, FxImpl.Data.EditScopeKey<TParams>> implements EditScopeViewContract<TData, TParams> {
        /**
         * An observable containing an EditScope instance reflecting the last successful call to 'fetchForNewData' or
         * 'fetchForExistingData'.
         */
        get editScope(): KnockoutObservable<EditScope<TData>>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId'. This view's observable 'editScope'
         * property will be set with the fetched EditScope.
         */
        fetchForNewData(editScopeId: string): FxPromise;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId' and 'query'. This view's observable
         * 'editScope' property will be set with the fetched EditScope.
         */
        fetchForExistingData(editScopeId: string, params?: TParams): FxPromise;
    }
}

// FILE: MsPortalFx\Data\Data.EntityCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A cache of entities of a specific type.
     */
    class EntityCache<TEntity, TId> extends FxImpl.Data.DataCache<TEntity, TId> implements EditScopeInputDataCache<TEntity, TId>, DataCache<TEntity, TId> {
        private _findCachedEntity;
        /**
         * Constructs an instance of EntityCache<TEntity, TId>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: EntityCacheConfig<TEntity, TId>);
        /**
         * Constructs an instance of EntityCache<TEntity, TId>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: DataCacheConfig<TEntity, TId>);
        /**
         * Creates an EntityView that provides a convenient way to retrieve entities from
         * the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EntityView. A typical example is a
         * PartContainer instance - supplying one means that the EntityView's entries may be released when the corresponding Part is
         * removed from the UI.
         * @param config Additional options for configuring the EntityView.
         * @return An EntityView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TId>): EntityView<TEntity, TId>;
        protected _tryFindDataInRelatedCache(id: TId, entryLifetime: MsPortalFx.Base.LifetimeManager): TEntity;
        protected _getDataFromDataSet(dataSet: DataSet): KnockoutObservableBase<TEntity[]>;
    }
}

// FILE: MsPortalFx\Data\Data.EntityCacheConfig.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies configuration options for an EntityCache.
     */
    interface EntityCacheConfig<TEntity, TId> extends DataCacheConfig<TEntity, TId> {
        /**
         * A description of how to locate an entity already loaded into a related DataCache.
         * This is a performance optimization that allows calls to 'entityView.fetch()' to quickly return
         * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
         * resources.
         */
        findCachedEntity?: FindCachedEntityInQueryCacheOptions<TEntity, TId> | FindCachedEntityInDataCacheOptions<TEntity, TId, any, any>;
    }
    /**
     * A description of how to locate an entity already loaded into a related QueryCache<TEntity>.
     * This is a performance optimization that allows a call to 'entityView.fetch()' to quickly return
     * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
     * resources.
     */
    interface FindCachedEntityInQueryCacheOptions<TEntity, TId> {
        /**
         * A QueryCache caching arrays of entities of the same 'TEntity' type.
         */
        queryCache: QueryCache<TEntity, any>;
        /**
         * A function that determines whether a given entity matches an id.
         *
         * @param entity The entity.
         * @param id The ID to compare against this entity's ID.
         * @return True if the entity's ID matched 'id'.
         */
        entityMatchesId(entity: TEntity, id: TId): boolean;
    }
    /**
     * A description of how to locate an entity already loaded into a related DataCache (a QueryCache or EntityCache).
     * This is a performance optimization that allows a call to 'entityView.fetch()' to quickly return
     * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
     * ARM resources.
     */
    interface FindCachedEntityInDataCacheOptions<TEntity, TId, TData, TParams> {
        /**
         * A DataCache caching entities of the same 'TEntity' type, nested in some array or as an object property value.
         */
        dataCache: DataCache<TData, TParams>;
        /**
         * A function used to find -- within a cache entry -- the entity matching a given 'id'.
         *
         * @param cacheEntryParams The parameters which serve as the key of the cache entry.
         * @param cacheEntryData The data of the cache entry.
         * @param id The ID of the entity to find.
         * @return The entity within the cache entry or 'null' if the entity is not found in this cache entry.
         */
        findMatchingEntityInCacheEntry(cacheEntryParams: TParams, cacheEntryData: TData, id: TId): TEntity;
    }
}

// FILE: MsPortalFx\Data\Data.EntityView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of a single entity from an underlying EntityCache. The
     * 'item' observable property remains constant but its contents change whenever
     * you request a different entity ID or when that entity's data is updated.
     */
    class EntityView<TEntity, TId> extends FxImpl.Data.DataView<TEntity, TId> implements EditScopeInputDataView<TEntity, TId> {
        private _item;
        /**
         * Internal constructor. Extensions should not invoke this directly. Instead,
         * create an EntityCache and then use its 'createView' method to obtain an EntityView.
         *
         * @param dataSource Internal. Extensions should not use this EntityView constructor directly.
         * @param lifetime Internal. Extensions should not use this EntityView constructor directly.
         * @param config Internal. Extensions should not use this EntityView constructor directly.
         */
        constructor(dataSource: FxImpl.Data.DataViewSource<TEntity, TId>, lifetime: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TId>);
        /**
         * An observable property whose value is the current entity retrieved from the underlying cache.
         * The value is 'null' until the first entity is retrieved.
         *
         * Use the EntityView's 'fetch' method to specify an entity ID that, when loaded, will give the data for this property.
         *
         * Use the EntityView's 'refresh' method to cause this property's data to be updated via a new server request.
         */
        get item(): KnockoutObservable<TEntity>;
        get data(): TEntity;
    }
}

// FILE: MsPortalFx\Data\Data.ErrorNotificationTarget.d.ts
declare module MsPortalFx.Data {
    /**
     * Represents an object that receives notifications about errors encountered in the data layer.
     */
    interface ErrorNotificationTarget extends MsPortalFx.Base.LifetimeManager {
        /**
         * Issues a notification that a 'not found' error was encountered in the data layer.
         *
         * @param message Optional error message to be used in place of the default.
         */
        notFound?(message?: string): void;
    }
}

// FILE: MsPortalFx\Data\Data.Loader.d.ts
declare module MsPortalFx.Data {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import FxBaseNet = FxBase.Net2;
    function setCustomMinimumPoolInterval(poolInterval: number): void;
    function resetCustomMinimumPoolInterval(): void;
    /**
     * Specifies the rate at which the data loader should poll the server for updates.
     */
    enum PollFrequency {
        /**
         * The data loader will not poll for updates.
         */
        Never = 1,
        /**
         * The data loader will poll at the recommended rate.
         */
        Normal = 2
    }
    /**
     * FetchData is the interface for return of name: datasetName, value as DataSet
     */
    interface FetchData extends NameValue<string, DataSet> {
    }
    /**
     * Fetch parameters for fetch start callback.
     */
    interface FetchStartParameters {
        /**
         * The name of the data set
         */
        dataSetName: string;
        /**
         * The fetch promise.
         */
        promise: FxPromiseV<FetchData>;
        /**
         * A flag to distinguish Shell.Data.Loader.getData from polling refresh.
         */
        isClientInitiated: boolean;
    }
    /**
     * Fetch parameters for fetchData function of a Loader.
     */
    interface FetchParameters {
        /**
         * Additional data for a performed fetch.
         */
        data: any;
        /**
         * Additional headers for a performed fetch.
         */
        headers: any;
    }
    /**
     * Loader specific options.
     */
    interface LoaderOptions {
        /**
         * Computes HTTP parameters in preparation for a fetch of server data.
         */
        getFetchParameters?: (dataSetName: string, lastFetchState: any, fetchingSameData: boolean) => FetchParameters;
        /**
         * Function that performs actual data retrieval from a data source.
         */
        fetchData?: (dataSetName: string, uri: string, ajaxData: any, ajaxHeaders: any) => FxPromise;
        /**
         * List of functions processing fetch results of a loader.
         */
        processResult?: Array<ProcessResultFunction>;
    }
    /**
     * Options that control how a DataSet is loaded.
     */
    interface DataSetLoaderOptions {
        /**
         * The URI from which data will be fetched for this data set.
         */
        uri: string;
        /**
         * An optional HTTP method to be used when making requests for this data set.
         */
        httpMethod?: string;
        /**
         * An optional, object-typed value that is passed as the 'data' option to the ajax call.
         */
        ajaxData?: any;
        /**
         * An optional, object-typed value that is passed as the 'headers' option to the ajax call.
         */
        ajaxHeaders?: any;
        /**
         * An optional boolean with a default value of false. If true, will always initiate a fetch from the server, even when this call returns cached data.
         */
        forceCacheRefresh?: boolean;
        /**
         * Adds a fetchStart event handler to the resulting data set, called whenever a fetch from the server is initiated for this data set.  A promise for the fetch is supplied to the handler.
         */
        fetchStartListener?: MsPortalFx.Base.Callbacks<FetchStartParameters>;
        /**
         * The frequency at which the loader should poll the server for updates.
         */
        pollFrequency?: PollFrequency;
        /**
         * Should preserve new items ordering during merge operations on data set.
         */
        preserveNewItemsOrdering?: boolean;
        /**
         * Loader specific options.
         */
        loaderOptions?: LoaderOptions;
        /**
         * An optional type string used to retrieve metadata for use during merging of fetched data.
         */
        type?: string;
        atomizationOptions?: AtomizationOptions;
        /**
         * Lifetime referrer of a data set for use in atomization garbage collection mechanism.
         */
        dataSetLifetime?: MsPortalFx.Base.LifetimeManager;
        /**
         * A name for the resulting DataSet.
         */
        dataSetName?: string;
        /**
         * Determines whether to automatically obtain and append an authorization header.
         * If undefined, the authorization header is appendended automatically for all relative URIs,
         * but skipped for absolute URIs.
         *
         * Set to true to append the default authorization header.
         * Set to { resourceName: 'audienceName'} to append an authorization token targeted at a specific audience.
         */
        setAuthorizationHeader?: boolean | FxBaseNet.AuthorizationOptions;
    }
    /**
     * Polling intervals definitions.
     */
    interface PollingIntervals {
        [interval: string]: number;
        /**
         * Fast polling interval.
         */
        fastPollingInterval?: number;
        /**
         * Normal polling interval.
         */
        pollingInterval?: number;
        /**
         * Slow polling interval.
         */
        slowPollingInterval?: number;
    }
    class Loader {
        static _internal: {
            setDefaultPollingIntervals: (intervals: any) => void;
        };
        /**
         * Fetches data from the cache or server. This is an asynchronous function.
         * Shell.Data.Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: jQueryDeferred, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName The name of the data set being retrieved.
         * If not supplied, the data set name will be inferred the URI supplied as options.uri.
         * @param options An options object.
         * @return A promise reflecting the success or failure of this asynchronous call.
         * The promise is resolved with parameters:
         *   * dataSetName: The name of the data set.
         *   * dataSet: The data set containing the data retrieved.
         * The promise is rejected with parameters:
         *   * dataSetName: The name of the data set.
         *   * jqXHR: The jQuery XmlHttpRequest object used for the server fetch.
         *   * textStatus: A string describing the error type.
         *   * errorThrown: Any error thrown in JavaScript in the course of processing the server fetch.
         */
        static getData(options: DataSetLoaderOptions): FxPromiseV<FetchData>;
        static getData(dataSetName: string, options: DataSetLoaderOptions): FxPromiseV<FetchData>;
        /**
         * Refreshes data in the data set, using the URI, data and headers supplied in the most recent
         * call to Shell.Data.Loader.getData.
         * @param dataSetName Data set name.
         * @return A promise reflecting the success or failure of the server fetch.
         */
        static forceRefresh(dataSetName: string): FxPromiseV<FetchData>;
        /**
         * Retrieves a data set from a local, in-memory cache. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: FxPromise, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param create Create a new data set (with no initial value/data) if one is not present in the cache. Defaults to 'false'.
         * @param initialData Initial data merged into data set.
         * @param dataSetLifetime Data set lifetime manager.
         * @param atomizationOptions Data set atomization options.
         * @return The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet(dataSetName: string, create?: boolean, initialData?: any, dataSetLifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: AtomizationOptions): DataSet;
        /**
         * Retrieves a data set from a local, in-memory cache. The data set will be created if it doesn't already exist. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: FxPromise, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param dataSetType Type of the data set.
         * @param initialData Initial data merged into data set.
         * @param dataSetLifetime Data set lifetime manager.
         * @param atomizationOptions Data set atomization options.
         * @return The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet(dataSetName: string, dataSetType?: string, initialData?: any, dataSetLifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: AtomizationOptions): DataSet;
        /**
         * Retrieves a data set from a local, in-memory cache. The data set will be created if it doesn't already exist. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: FxPromise, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param create Create a new data set (with no initial value/data) if one is not present in the cache. Defaults to 'false'.
         * @param initialData Initial data merged into data set.
         * @param options Options used to create the DataSet, if necessary.
         * @return The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet2(dataSetName: string, create: boolean, options: DataSetLoaderOptions, initialData: any): any;
        /**
         * Determines whether or not the specified data set is awaiting a response to an already-issued request.
         * @param dataSetName The name of the data set.
         * @return True if a request is in flight; false otherwise.
         */
        static hasRequestInFlight(dataSetName: string): boolean;
        /**
         * Disposes and clears the data set from that set managed by Shell.Data.Loader.
         * @param dataSetName Data set name.
         */
        static disposeDataSet(dataSetName: string): void;
        /**
         * Enables or disables data refresh at the 'fast' refresh interval, often reflecting that the
         * data set is currently being viewed.
         * @param dataSetName Data set name.
         * @param fast If true, the 'fast' refresh interval is selected for this data set.
         */
        static setFastPolling(dataSetName: string, fast: boolean): void;
        /**
         * Pauses data refresh by increasing a reference count
         */
        static pausePolling(): void;
        /**
         * Resumes data refresh by decreasing a reference count.
         */
        static resumePolling(): void;
        /**
         * Supplies a set of default loader options that will be used when loading data sets.
         * @param loaderOptions The default loader options.
         */
        static setDefaultLoaderOptions(loaderOptions: LoaderOptions): void;
        /**
         * Helper to get current MinimumPoolingInterval (used in Data.DataCacheLoder.ts)
         */
        static getMinPollingInterval: () => number;
        /**
         * Supplies a set of polling intervals used to control the rate at which a data set is implicitly
         * refreshed from the server.
         * @param dataSetName Data set name.
         * @param pollingIntervals An object with optional 'fastPollingInterval', 'pollingInterval' and
         * 'slowPollingInterval' properties, all Number-typed and in milliseconds.
         */
        static setPollingIntervals(pollingIntervals: PollingIntervals): void;
        static setPollingIntervals(dataSetName: string, pollingIntervals: PollingIntervals): void;
        /**
         * Reset the polling intervals to default setting that can void the effect by setPollingIntervals
         */
        static resetPollingIntervals(dataSetName?: string): void;
    }
    module Loader.Internal {
        function disposeAllCachedDataSetsForTests(): void;
    }
}

// FILE: MsPortalFx\Data\Data.LockState.d.ts
declare module MsPortalFx.Data {
    /**
     * An enumeration type representing the kinds of client-side edits to which MsPortalFx.Data.DataSet.lockItem
     * applies.
     */
    enum EditKind {
        /**
         * "Add" type of edit.
         */
        Add = 0,
        /**
         * "Update" type of edit.
         */
        Update = 1
    }
    /**
     * Defines client-side lock state of an element stored in MsPortalFx.Data.DataSet.
     */
    interface LockState {
        /**
         * Lock type of edit.
         */
        editKind?: MsPortalFx.Data.EditKind;
        /**
         * Date when unlocked.
         */
        unlockedAt?: number;
    }
}

// FILE: MsPortalFx\Data\Data.Metadata.d.ts
declare module MsPortalFx.Data.Metadata {
    /**
     * Interface describing on of possible type representations of elements stored in MsPortalFx.Data.DataSet.
     */
    interface MetadataProperty {
        /**
         * Type of the property.
         */
        itemType?: string;
        /**
         * Indicates whether property is an array.  Default is 'false'.
         */
        isArray?: boolean;
        /**
         * Indicates whether property is a date.
         */
        isDate?: boolean;
        /**
         * Determines if edits are tracked by EditScope.  Default is 'true'.  If 'false', property value cannot be used with form fields.
         */
        trackEdits?: boolean;
        /**
         * Determines if edits are persisted to User Settings.  Set to 'false' for properties like passwords.  Default is 'true'.
         */
        persistEdits?: boolean;
    }
    /**
     * Interface describing metadata of elements stored in MsPortalFx.Data.DataSet.
     * This interface corresponds with 'TypeMetadata' C# type.
     */
    interface Metadata {
        /**
         * Name of the type.
         */
        name?: string;
        /**
         * List of id properties of a type.
         */
        idProperties?: string[];
        /**
         * List of properties in type.
         */
        properties?: {
            [property: string]: MetadataProperty;
        };
        /**
         * Reflects whether this type is an entity type.  An entity type is one that can be edited and reverted
         * independently from any nesting or nested model data.
         */
        entityType?: boolean;
        /**
         * Indicates whether instances of this type each of a globally unique id.
         */
        hasGloballyUniqueId?: boolean;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeName' C# type.
     */
    interface CompressedTypeName {
        /**
         * Index of a part in namespace array.
         */
        namespaceIndex: number;
        /**
         * Type name.
         */
        name: string;
    }
    /**
     * Contract for compressed type property metadata with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeProperty' C# type.
     */
    interface CompressedTypeProperty {
        /**
         * Index of a type in namespace array.
         */
        typeIndex: number;
        /**
         * Value indicating whether property is enumerable or not.
         */
        isArray: boolean;
        /**
         * Value indicating whether property is a date.
         */
        isDate: boolean;
        /**
         * Determines if edits are tracked by EditScope.  Default is 'true'.  If 'false', property value cannot be used with form fields.
         */
        trackEdits: boolean;
        /**
         * Determines if edits are persisted to user settings.  Set to 'false' for properties like passwords.  Default is 'true'.
         */
        persistEdits: boolean;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeMetadata' C# type.
     */
    interface CompressedTypeMetadata {
        /**
         * Type name.
         */
        name: CompressedTypeName;
        /**
         * List of properties in type.
         */
        properties: {
            [property: string]: CompressedTypeProperty;
        };
        /**
         * List of id properties of a type.
         */
        idProperties: string[];
        /**
         * Reflects whether this type is an entity type.  An entity type is one that can be edited and reverted
         * independently from any nesting or nested model data.
         */
        entityType?: boolean;
        /**
         * Indicates whether the entity has a globally unique ids.
         */
        hasGloballyUniqueId?: boolean;
    }
    /**
     * Data visitation callbacks.
     */
    interface TypedDataVisitorCallbacks {
        /**
         * Callback triggered whenever an array is found on travelsal path.
         */
        visitArray: (data: any, type: string) => void;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypesMetadata' C# type.
     */
    interface CompressedTypesMetadata {
        /**
         * Namespaces array.
         */
        namespaces: string[];
        /**
         * List of metadata.
         */
        metadata: CompressedTypeMetadata[];
        /**
         * Index of root type in types array.
         */
        rootTypeIndex: number;
    }
    /**
     * Gets metadata corresponding to a given type name.
     *
     * @param type The name of the type.
     * @return Metadata for the type.
     */
    function getTypeMetadata(type: string): Metadata;
    /**
     * Gets the type of a property.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @return The type name of the property.
     */
    function getPropertyType(type: string, propertyName: string): string;
    /**
     * Gets the type of a property.
     *
     * @param typeMetadata Metadata for the type containing the property.
     * @param propertyName The property name.
     * @return The type name of the property.
     */
    function getPropertyType(typeMetadata: Metadata, propertyName: string): string;
    /**
     * Gets type metadata of a property from a given metadata object.
     *
     * @param typeMetadata Metadata object.
     * @param property Property of which metadata is to be found.
     * @return Metadata of a given property.
     */
    function getPropertyTypeMetadata(typeMetadata: Metadata, property: string): Metadata;
    /**
     * Gets the property metadata.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @return The property metadata.
     */
    function getPropertyMetadata(type: string, propertyName: string): MetadataProperty;
    /**
     * Gets the cardinality of a property.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @return Value of the property.isArray value.
     */
    function getPropertyCardinality(type: string, propertyName: string): boolean;
    /**
     * Gets the type of a property.
     *
     * @param typeMetadata Metadata for the type containing the property.
     * @param propertyName The property name.
     * @return Value of the property.isArray value.
     */
    function getPropertyCardinality(typeMetadata: Metadata, propertyName: string): boolean;
    /**
     * Gets the property names for a given type.
     *
     * @param typeMetadata Metadata for the type.
     * @return An array of property names.
     */
    function getProperties(typeMetadata: Metadata): string[];
    /**
     * Gets a boolean reflecting whether the type has at least one id property.
     *
     * @param typeMetadata Metadata describing the type of the item.
     * @return Whether the Metadata has an id.
     */
    function typeHasId(typeOrTypeMetadata: Metadata.Metadata | string): boolean;
    /**
     * Gets a string reflecting the identity of a supplied item.
     *
     * @param item The data item.
     * @param type The type name.
     * @return A string representation of the identity of the item.
     */
    function getItemId(item: Object, typeOrMetadata: Metadata | string): string;
    /**
     * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
     *
     * @param metadata Type metadata.
     * @return An array of property names or null.
     */
    function getIdPropertyNames(metadata: Metadata.Metadata): string[];
    /**
     * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
     *
     * @param typeName Type name.
     * @return An array of property names or null.
     */
    function getIdPropertyNames(typeName: string): string[];
    /**
     * An utility function that decorates an array or object with typing.
     *
     * @param data The array or object.
     * @param type The type name.
     */
    function decorateWithType(data: any, type: string): void;
    /**
     * Typed data visitation.
     *
     * @param data Data to be visited.
     * @param type Type of visited data.
     * @param callbacks Callbacks to be triggered while traversing.
     */
    function visitTypedData(data: any, type: string, callbacks: TypedDataVisitorCallbacks): void;
    /**
     * Determines the item type of an array.
     *
     * @param array The array (observable or native).
     * @return The item type name.
     */
    function getArrayItemType(array: any): string;
    /**
     * Creates an object of a specified type.
     *
     * @param typeOrMetadata Type of the object to be created.
     * @return The object with undefined-valued property values.
     */
    function createEmptyObject(type: string): any;
    /**
     * Creates an object of a specified type.
     *
     * @param typeOrMetadata Type of the object to be created.
     * @return The object with undefined-valued property values.
     */
    function createEmptyObject(metadata: Metadata): any;
    /**
     * Returns a boolean reflecting whether this type is an entity type.
     *
     * @param typeOrMetadata Type to be created.
     * @return A boolean reflecting whether this type is an entity type.
     */
    function typeIsEntityType(typeMetadata: Metadata.Metadata): boolean;
    /**
     * Sets type information for a supplied type name.
     * Note that there is no provision to unset type metadata, as the assumption is that each extension will have
     * a small, static number of model types.
     *
     * @param type The type name.
     * @param metadata The type information.
     */
    function setTypeMetadata(type: string, metadata: Metadata): void;
    /**
     * Sets type information for a collection of types.
     * Use Microsoft.Portal.Framework.ExtensionData.TypeMetadataGenerator to produce the compressed 'typesMetadata'
     * consumed by this function.
     *
     * @param typesMetadata Compressed type information for a collection of types.
     * @return Type information for the first type name, which by convention is the root type of the collection of types.
     */
    function setTypesMetadata(typesMetadata: CompressedTypesMetadata): Metadata;
    module Internal {
        /**
         * Clears type metadata for all types.
         */
        function clearAllTypesMetadata(): void;
    }
}

// FILE: MsPortalFx\Data\Data.ObjectCache.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides configuration for an ObjectCache object.
     */
    interface ObjectCacheConfig<TKey, TValue> {
        /**
         * Provides a string representation of the specified cache key. Every distinct cache
         * key must have a distinct string representation.
         *
         * @param key The cache key to serialize.
         * @return A string represention of the cache key.
         */
        serializeKey(key: TKey): string;
        /**
         * Given a key, this function supplies a value for a newly created cache entry. This function will be invoked
         * only when creating new cache entries.
         *
         * @param key The cache key.
         * @param entryLifetime An object that issues a notification when the cache entry is evicted. Use this to clean up any resources held by the cache entry.
         * @return The cache value.
         */
        supplyValue(key: TKey, entryLifetime: MsPortalFx.Base.LifetimeManager): TValue;
        /**
         * A variation of 'supplyValue'.  This function should only return a non-null value if that value is already
         * cached on the client (in some underlying or related cache).  When a cache entry is created using this
         * function, for telemetry purposes, this will be considered a cache hit.  This function will be invoked only
         * when creating new cache entries.
         *
         * @param key The cache key.
         * @param entryLifetime An object that issues a notification when the cache entry is evicted. Use this to clean up any resources held by the cache entry.
         * @return The cache value.
         */
        tryFindValueInRelatedCache?(key: TKey, entryLifetime: MsPortalFx.Base.LifetimeManager): {
            value: TValue;
        };
        /**
         * Optional. Invoked to notify that the given entry is being ejected from the cache.
         *
         * @param entry The entry being ejected.
         * @param key The cache key for the entry being ejected.
         */
        onEntryDisposed?(entry: TValue, key: TKey): void;
        /**
         * @deprecated ObjectCacheConfig.evictionDelay - Please do not use this option. It is deprecated and will be removed. Instead, set
         * the 'extendEntryLifetimes' option to 'true'.
         *
         * Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         *
         */
        evictionDelay?: number;
        /**
         * If true, cache entries will be retained in memory for a framework-controlled period even when
         * no other objects are referring to them. This makes the cache perform better: future 'fetch'
         * operations are more likely to be satisfied without needing to wait for HTTP requests.
         *
         * We recommend that you always enable this option. Please ensure that none of your other code
         * relies on cache entries being evicted synchronously.
         */
        extendEntryLifetimes?: boolean;
    }
    /**
     * A reference-counted cache of objects of a specific type.
     */
    class ObjectCache<TKey, TValue> {
        private _referrerPropertyName;
        private _referrerUniqueId;
        private _supplyValue;
        private _tryFindValueInRelatedCache;
        private _serializeKey;
        private _entries;
        /**
         * Constructs an instance of ObjectCache.
         *
         * @param config Configuration for the instance.
         */
        constructor(config: ObjectCacheConfig<TKey, TValue>);
        /**
         * Retrieves a value from the cache. If the value was not already cached, it will be created,
         * added to the cache, and then returned.
         *
         * @param key Cache key for the item to retrieve.
         * @param referrer Associates the cache entry with this referrer, so it will remain cached at least until this object notifies that it was disposed.
         * Pass null to avoid participating in the refcounting.
         * @return The cached value.
         */
        getValue(key: TKey, referrer: MsPortalFx.Base.LifetimeManager): TValue;
        /**
         * Ensures that the cache contains an entry for the specified key. If the cache already contains an entry for the specified
         * key, nothing will happen (the entry will not be overwritten).
         *
         * @param key Cache key for the item.
         * @param value The value to be inserted if there was no existing entry.
         * @param referrer Associates the cache entry with this referrer, whether or not it already exists in the cache.
         */
        insertValueIfNotPresent(key: TKey, value: TValue, referrer: MsPortalFx.Base.LifetimeManager): void;
        /**
         * Determines whether or not the cache contains an entry for the specified key.
         *
         * @param key Cache key for the item.
         * @return True if the entry is present; false otherwise.
         */
        hasEntry(key: TKey): boolean;
        /**
         * Removes any association between the specified key and referrer, or does nothing if there was no such association.
         * Once a cache entry has no remaining referrers, it will be removed from the cache.
         *
         * @param key Cache key for the item.
         * @param referrer The referrer to be dissociated from the cache entry.
         */
        dissociateEntry(key: TKey, referrer: MsPortalFx.Base.LifetimeManager): void;
        /**
         * Dissociates all referrers from the entry and evicts the entry from the cache. Does not wait
         * for any eviction delay.
         *
         * @param key The entry to be evicted.
         */
        immediatelyEvictEntry(key: TKey): void;
        /**
         * Invokes a callback for each entry currently in the cache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEntry(callback: (key: TKey, value: TValue) => void): void;
        /**
         * Disposes the cache, so that it releases references to all entries. Once this is done,
         * that cache can no longer store new entries.
         */
        dispose(): void;
        private _getOrCreateReferrerId;
    }
}

// FILE: MsPortalFx\Data\Data.PartialError.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes a partial error returned while attempting to fetch data.
     */
    interface PartialError {
    }
}

// FILE: MsPortalFx\Data\Data.ProcessedResult.d.ts
declare module MsPortalFx.Data {
    /**
     * The contract of data that's passed as in/out parameter for ProcessResultFunction.
     */
    interface ProcessedResult {
        /**
         * The result from the AJAX request passed in subsequent Data.Loader result processor functions.
         * This is the data that would be merged into the data set.
         */
        data?: any;
        /**
         * Describes the state of navigable data, for example specifying the
         * total number of items or the token needed to fetch further data.
         */
        navigationMetadata?: DataNavigationMetadata;
        /**
         * An optional collection of partial errors returned by the server, possibly in
         * addition to any data received successfully.
         */
        partialErrors?: MsPortalFx.Data.PartialError[];
        /**
         * Determines type of data to be merged into the data set.
         * Can alternatively be supplied as an option to MsPortalFx.Data.Loader.getData.
         */
        type?: string;
        /**
         * Clients can return select response headers and return them here.
         */
        fetchState?: any;
    }
    /**
     * The contract of Data.Loader result processing function.
     */
    interface ProcessResultFunction {
        /**
         * Function that decides whether to merge data in Data.Loader once retrieved. It also shapes the data, type
         * and fetch state before the actual merge happens.
         *
         * @param dataSetName Name of the data set for which data is being fetched.
         * @param result Object passed along the Data.Loader chain of result processors to subsequent
         *     ProcessResultFunction functions calls. Once all functions are called, this object contains the type of
         *     the data to be merged as well as state that is to be saved between this and subsequent server fetches.
         * @param lastFetchState Fetch state returned by the previous fetch for this data set.
         * @param fetchingSameData A boolean indicating that the URI/data/headers have not changed from those used for
         *     the previous fetch for this data set.
         * @param entityType Specifies the type of entities in the data set, or null if unknown.
         * @return Return false if 'result.data' is to be discarded and subsequent result processor functions are not
         *     called. Return true to continue calling subsequent result processor functions. The last such return
         *     value determines whether the fetch result is to be merged into the data set. See ProcessResultOutput
         *     type documentation for details on how 'result' object is used later to determine further actions if
         *     ProcessResultFunction returns true.
         */
        (dataSetName: string, result: ProcessedResult, lastFetchState: any, fetchingSameData: boolean, entityType: string): boolean;
    }
}

// FILE: MsPortalFx\Data\Data.Query.d.ts
declare module MsPortalFx.Data {
    interface DataSourcePaging {
        /**
         * How many results should be skipped.
         */
        skip?: number;
        /**
         * How many results should be returned.
         */
        take?: number;
    }
    /**
     * Representation of a remote data query.
     */
    interface Query {
        /**
         * Paging options.
         */
        paging?: DataSourcePaging;
        /**
         * Direction of sorting (ascending or descending).
         */
        sort?: any;
        /**
         * Filter format: [{ property: ..., operator: ..., value: ...}, ...]
         */
        filter?: any;
        /**
         * Should query return total number of elements on endpoint side
         */
        includeTotalCount?: any;
    }
    /**
     * The contract of for shaping queries sent to extension endpoint.
     */
    interface ShapeQueryFunction {
        /**
         * Function that shapes representation of the data query to a format that can be included in an HTTP call to fetch server data.
         *
         * @param query Representation of a remote data query.
         * @return Representation of the query used for the HTTP call for server data.
         */
        (query: Query): any;
    }
}

// FILE: MsPortalFx\Data\Data.QueryCache.d.ts
declare module MsPortalFx.Data {
    /**
     * Options to define how a navigator is created from a QueryCache.
     */
    interface CreateNavigatorOptions<TEntity, TMappedEntity> {
        /**
         * A callback that will be used to produce the 'items' collection on the
         * resulting data navigator. You can use this to project the source entities
         * into a different data format. You should use an observable mapping, for
         * example sourceItems.map(...), so that the navigator can remain up-to-date
         * as it moves through the underlying data.
         *
         * @param lifespan A lifetime object that signals when you should release any resources held by your mapping.
         * @param sourceItems The navigator's underlying items to be mapped.
         * @return The mapped array.
         */
        createMapping?(lifespan: MsPortalFx.Base.LifetimeManager, sourceItems: KnockoutObservableArray<TEntity>): KnockoutObservableBase<TMappedEntity[]>;
    }
    /**
     * A cache of query results for a specific type of entity and query parameters.
     * Note: In the base class, this class is marked as non-serializable re: PO.
     */
    class QueryCache<TEntity, TQueryParams> extends FxImpl.Data.DataCache<KnockoutObservableBase<TEntity[]>, TQueryParams> implements EditScopeInputDataCache<KnockoutObservableBase<TEntity[]>, TQueryParams>, DataCache<KnockoutObservableBase<TEntity[]>, TQueryParams> {
        private _navigationOptions;
        /**
         * Constructs an instance of DataCache<TEntity, TParams>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: MsPortalFx.Data.QueryCacheConfig<TEntity, TQueryParams>);
        /**
         * Creates a QueryView that provides a convenient way to retrieve query results from
         * the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new QueryView. A typical example is a
         * PartContainer instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed
         * from the UI.
         * @param config Additional options for configuring the QueryView.
         * @return A QueryView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TQueryParams>): QueryView<TEntity, TQueryParams>;
        /**
         * Creates a RemoteDataNavigator that can query and navigate through data supplied by the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held. A typical example is a PartContainer
         * instance - supplying one means that the cache entries may be released when the corresponding Part is removed from the UI.
         * @return A RemoteDataNavigator instance.
         */
        createNavigator(lifespan: MsPortalFx.Base.LifetimeManager): RemoteDataNavigator<TEntity, TQueryParams>;
        /**
         * Creates a RemoteDataNavigator that can query and navigate through data supplied by the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held. A typical example is a PartContainer
         * instance - supplying one means that the cache entries may be released when the corresponding Part is removed from the UI.
         * @param options Options influencing the resulting data navigator.
         * @return A RemoteDataNavigator instance.
         */
        createNavigatorWithOptions<TMappedEntity>(lifespan: MsPortalFx.Base.LifetimeManager, options: CreateNavigatorOptions<TEntity, TMappedEntity>): RemoteDataNavigator<TMappedEntity, TQueryParams>;
        /**
         * Any navigation options configured for this QueryCache.
         */
        navigationOptions: MsPortalFx.Data.QueryCacheNavigationOptions<TEntity, TQueryParams>;
        _findMatchingEntity<TId>(comparer: (entity: TEntity, id: TId) => boolean, id: TId): TEntity;
        protected _getDataFromDataSet(dataSet: DataSet): KnockoutObservableBase<TEntity[]>;
    }
    /**
     * Supplies configuration options for a QueryCache.
     */
    interface QueryCacheConfig<TEntity, TParams> extends DataCacheConfig<TEntity, TParams> {
        /**
         * Describes how any QueryViews based on this cache can navigate through the data.
         */
        navigation?: QueryCacheNavigationOptions<TEntity, TParams>;
    }
    /**
     * Describes how any QueryViews based on a QueryCache are able to navigate through the data.
     */
    interface QueryCacheNavigationOptions<TEntity, TParams> {
        /**
         * If the data source supports skip/take, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param queryView The QueryView instance that should be navigated.
         * @param query Query parameters to be used.
         * @param skip The number of records to skip.
         * @param take The number of records to take.
         * @param filter Any filtering value entered by the user.
         * @return A promise representing the operation.
         */
        loadBySkipTake?(queryView: QueryView<TEntity, TParams>, query: TParams, skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        /**
         * If the data source supports continuation tokens, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param queryView The QueryView instance that should be navigated.
         * @param query Query parameters to be used.
         * @param reset If true, indicates that the first page of data should be loaded. Otherwise, the continuation token in metadata should be used to fetch
         * the next range of data.
         * @param filter Any filtering value entered by the user.
         * @return A promise representing the operation.
         */
        loadByContinuationToken?(queryView: QueryView<TEntity, TParams>, query: TParams, reset: boolean, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
    }
}

// FILE: MsPortalFx\Data\Data.QueryView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of query results from an underlying QueryCache. The
     * 'items' observable array property remains constant but its contents change
     * whenever you change query parameters, or when the results themselves change.
     */
    class QueryView<TEntity, TQueryParams> extends FxImpl.Data.DataView<TEntity, TQueryParams> implements EditScopeInputDataView<KnockoutObservableBase<TEntity[]>, TQueryParams> {
        private _items;
        private _metadata;
        /**
         * Internal constructor. Extensions should not invoke this directly. Instead,
         * create a QueryCache and then use its 'createView' method to obtain a QueryView.
         *
         * @param dataSource Internal. Extensions should not use this QueryView constructor directly.
         * @param lifetime Internal. Extensions should not use this QueryView constructor directly.
         * @param config Internal. Extensions should not use this QueryView constructor directly.
         */
        constructor(dataSource: FxImpl.Data.QueryViewSource<TEntity, TQueryParams>, lifetime: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TQueryParams>);
        /**
         * An observable array whose contents are the current query results retrieved from the underlying cache.
         * The array is empty until the first query results are obtained.
         *
         * Use the QueryView's 'fetch' method to specify a query that, when completed, will give the data for this array.
         *
         * Use the QueryView's 'refresh' method to cause this array's data to be updated via a new server request.
         */
        get items(): KnockoutObservableArray<TEntity>;
        get metadata(): KnockoutObservableBase<DataNavigationMetadata>;
        get data(): KnockoutObservableBase<TEntity[]>;
    }
}

// FILE: MsPortalFx\Data\Data.UriFormatter.d.ts
declare module MsPortalFx.Data {
    /**
     * Returns a URI formatting function that uses the specified format string. This can be
     * suppled as the 'sourceUri' parameter on a DataCacheConfig instance.
     *
     * If the parameter value you will later supply is a simple primitive (string or number),
     * then your format string should refer only to a single token, '{id}'.
     * Example: '/products/{id}.json'
     *
     * If the parameter value you will later supply is an object with subproperties,
     * then your format string should instead reference those subproperties by name, for example:
     * Example: '/products/{department}/{category}/all'.
     *
     * @param uriFormat A formatting string.
     * @param encodeTokens If true, tokens will be URI component encoded. If false, tokens will be inserted without encoding, so you must ensure you have already encoded the tokens appropriately.
     * @return A URI formatting function.
     */
    function uriFormatter(uriFormat: string, encodeTokens: boolean): (params: any) => string;
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.AtomizationContext.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxLifetimeManager = FxBase.LifetimeManager;
    /**
     * Atomization serves two main goals:
     * 1) Enables several data views to be bound to one data entity, thus giving smooth, consistent
     *    experience to user, where 2 views representing the same asset are always in sync.
     * 2) Minimizes memory trace.
     */
    interface AtomizationContext {
        /**
         * Add a new entity to atomization context.
         * @param type Entity type.
         * @param id Entity id.
         * @param entity Entity itself.
         * @param referrer Lifetime manager of the requesting data set.
         */
        addEntity(type: string, id: string, entity: Object, referrer: FxLifetimeManager): void;
        /**
         * Retrieves an appropriate entity from atomization context. Null if entity is not present.
         * @param type Entity type.
         * @param id Entity id.
         * @param referrer Lifetime manager of the requesting data set.
         * @return Entity itself.
         */
        getEntity(type: string, id: string, referrer: FxLifetimeManager): Object;
        /**
         * Update references to elements removed from an array in atomization context.
         * @param type Entity type.
         * @param removedItemsArray Removed items.
         * @param referrer Lifetime manager of the requesting data set.
         */
        releaseEntities(type: string, removedItemsArray: any[], referrer: FxLifetimeManager): void;
    }
    /**
     * Implementation of a atomization context with garbage collection.
     */
    class RefCountingAtomizationContext implements AtomizationContext {
        private _atomizationCache;
        constructor();
        getEntity(type: string, id: string, referrer: FxLifetimeManager): Object;
        addEntity(type: string, id: string, entity: Object, referrer: FxLifetimeManager): void;
        releaseEntities(type: string, removedItemsArray: any[], referrer: FxLifetimeManager): void;
    }
    module AtomizationContext {
        let atomizationContextCollection: StringMap<FxImpl.Data.AtomizationContext>;
        /**
         * Retrieves a atomization context. Creates one if hasn't been created yet, using
         */
        function get(id?: string): FxImpl.Data.AtomizationContext;
        /**
         * Retrieves information whether a given type can be atomized.
         * @param type Type in question.
         * @return Whether a given type can be atomized.
         */
        function canAtomizeType(type: string): boolean;
        /**
         * Factory of atomization contexts.
         * @return Atomization context.
         */
        function createInstance(): FxImpl.Data.AtomizationContext;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.CloneVisitor.d.ts
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An interface through which a CloneVisitor is to be used.
     */
    interface CloneVisitorContract {
        /**
         * Deeply clones the supplied data.
         *
         * @param data The data to be cloned.
         * @param typeMetadata Type metadata covering the data.
         *
         * @return A clone of the data.
         */
        clone(data: any, typeMetadata: Metadata.Metadata): any;
    }
    /**
     * Options supplied when constructing a CloneVisitor.
     */
    interface CloneVisitorOptions extends VisitorOptions {
    }
    /**
     * This interface is used to customize a CloneVisitor by supplying mix-in style callbacks.
     */
    interface CloneVisitorCallbacks extends VisitorCallbacks<void, any> {
    }
    /**
     * A visitor that deeply clones supplied data.
     */
    class CloneVisitor extends Visitor<void, any> implements CloneVisitorContract {
        /**
         * Constructs an CloneVisitor instance.
         *
         * @param options Options used in the construction of the CloneVisitor.
         * @param callbacks Optional, mix-in style callbacks that override default CloneVisitor behavior.
         */
        constructor(options: CloneVisitorOptions, callbacks: CloneVisitorCallbacks);
        clone(data: any, typeMetadata: Metadata.Metadata): any;
        visitArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata): ArrayOrObservableArray;
        visitObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata): StringMap<any>;
        visitEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata): any;
        visitObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata): any;
        visitDate(date: Date): Date;
        visitScalar(value: number | string): any;
        visitFunction(fn: Function): any;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.DataCache.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxData = MsPortalFx.Data;
    /**
     * Provides a specialised API on top of ObjectCache intended for loading DataSet
     * objects via FxData.Loader. This is not intended to be used directly - developers
     * should use one of the two subclasses, EntityCache or QueryCache, depending on whether
     * they want to retrieve single entities by ID, or multiple entities by query.
     */
    abstract class DataCache<TEntity, TParams> implements DataViewSource<TEntity, TParams> {
        private _loader;
        private _cacheByParams;
        private _cacheName;
        /**
         * Constructs an instance of DataCache<TEntity, TParams>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: FxData.DataCacheConfig<TEntity, TParams>);
        /**
         * Retrieves a DataSetPromise from the cache. If it is not already present in the cache,
         * it will be created (e.g. via the configured loader).
         *
         * @param params Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed. If you pass 'null', then this call will not force the cache entry to stay in memory.
         * @return A promise that will complete with the retrieved DataSet.
         */
        fetch(params: TParams, referrer: FxBase.LifetimeManager): FxData.DataSetPromise;
        /**
         * Instructs the underlying data loader to refresh data in the DataSet corresponding to the
         * supplied parameters.
         *
         * @param params Parameters defining what data the cache entry should refresh (or load, if not already cached).
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed. If you pass 'null', then this call will not force the cache entry to stay in memory.
         * @return A promise that will complete when the data has finished being refreshed.
         */
        refresh(params: TParams, referrer: FxBase.LifetimeManager): FxBase.Promise;
        /**
         * Instructs the underlying data loader to refresh data in the DataSet corresponding to the
         * specified cache entries.
         *
         * @param predicate A predicate that determines which cache entries should be refreshed. If not specified, all in-memory cache entries will be refreshed.
         */
        refreshAll(predicate?: (params: TParams) => boolean): void;
        /**
         * Immediately removes the specified cache entry, regardless of whether it has active referrers,
         * and without waiting for any eviction delay. This also stops any polling configured for this entry.
         *
         * If there was no cache entry matching the specified parameters, this method does nothing.
         *
         * @param params Parameters defining the entry to be removed.
         */
        forceRemove(params: TParams): void;
        /**
         * Passes each current cache entry to a callback, so that you may mutate it in place (for
         * example, to reflect the result of a create/update/delete operation without waiting for
         * polling to complete).
         *
         * Any in-flight poll/refresh requests for updated cache entries will be discarded and
         * restarted. This ensures the old requests don't overwrite your changes with stale data.
         *
         * @param callback A callback invoked for each cache entry.
         * @param predicate An optional predicate that determines which cache entries are to be updated. If not specified, all cache entries are to be updated.
         */
        applyChanges(callback: (params: TParams, dataSet: FxData.DataSet) => void, predicate?: (params: TParams) => boolean): void;
        /**
         * Disposes the DataCache, which in turn disposes all DataSets it was holding.
         */
        dispose(): void;
        /**
         * See FxData.DataCache interface.
         */
        _doesPoll(): boolean;
        _findEntity<TEntity, TId, TData>(findCallback: (cacheEntryParams: TParams, cacheEntryData: TData, id: TId) => TEntity, id: TId): TEntity;
        /**
         * Dumps the data currently in the data cache
         *
         * @param dumpAsObjects If not set this function will print all the data in the cache to the console and return nothing. If set to true the function will return the objects in the cache.
         * @return If dumpAsObjects is not set there is no return value. If it is set the data in the cache will be returned.
         */
        dump(dumpAsObjects?: boolean): any;
        protected _tryFindDataInRelatedCache(params: TParams, entryLifetime: FxBase.LifetimeManager): any;
        protected _forEachEntry(callback: (params: TParams, dataSetPromise: FxData.DataSetPromise, dataSet: FxData.DataSet) => void, predicate?: (params: TParams) => boolean): void;
        protected abstract _getDataFromDataSet(dataSet: FxData.DataSet): any;
        private _supplyValue;
        private _establishDataSet;
        private _createUniqueDataSetName;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.EditScopeCache.d.ts
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxData = Fx.Data;
    import Rpc = FxImpl.Rpc;
    import FxImplData = FxImpl.Data;
    let saveSerializedEditScopeEndPoint: Rpc.ActionEndPointDefinition<FxImplData.SaveSerializedEditScopeParameters>;
    let loadSerializedEditScopeEndPoint: Rpc.FuncEndPointDefinition<string, FxImplData.EditScopeEdits>;
    let onEditScopeDiscardedEndPoint: Rpc.ActionEndPointDefinition<string>;
    let updateEditScopeIsSavingStateEndPoint: Rpc.ActionEndPointDefinition<FxImplData.UpdateEditScopeIsSavingStateParameters>;
    interface SaveSerializedEditScopeParameters {
        editScopeId: string;
        edits: EditScopeEdits;
    }
    interface UpdateEditScopeIsSavingStateParameters {
        editScopeId: string;
        isSaving: boolean;
    }
    enum FetchEditScopeError {
        /**
         * The ajax call to loading original data failed.
         */
        LoadOriginalDataFailed = 0,
        /**
         * The ajax call to load serialized, previously authored edits failed.
         */
        LoadEditsFailed = 1,
        /**
         * Deserialized, previously authored edits are no longer consistent with the current server data.
         */
        ApplyEditsFailed = 2
    }
    /**
     * Load and save EditScope edits callback interface.
     */
    interface EditScopeCacheEditsCallbacks {
        /**
         * Function called to load EditScope edits.
         */
        loadEdits?: (editScopeId: string) => FxBase.PromiseV<FxImplData.EditScopeEdits>;
        /**
         * Function called to save EditScope edits.
         */
        saveEdits?: (editScopeId: string, editScope: FxImplData.EditScope<any>) => void;
        /**
         * Function called to bracket an async EditScope 'save' operation.
         */
        updateEditScopeIsSavingState?: (editScopeId: string, isSaving: boolean) => void;
    }
    /**
     * Receives editScopeDiscarded events for dirty editScopes from Shell and routes them to the EditScopeCaches.
     */
    class EditScopeDiscardedReceiver {
        private _caches;
        constructor(rpcClient?: Rpc.Client);
        register(editScopeCache: EditScopeCacheBase): void;
        deregister(editScopeCache: EditScopeCacheBase): void;
    }
    let editScopeDiscardedReceiver: FxImplData.EditScopeDiscardedReceiver;
    interface EditScopeCacheBase {
        onEditScopeDiscarded(editScopeId: string): FxBase.Promise;
    }
    /**
     * A cache of EditScopes.
     */
    class EditScopeCache<TData, TParams> implements FxData.EditScopeCache<TData, TParams>, EditScopeCacheBase, FxImplData.ViewSource<EditScopeKey<TParams>> {
        static allLifetimes: TriggerableLifetimeManager;
        private _options;
        private _cacheByParams;
        private _loadEdits;
        private _saveEdits;
        private _updateEditScopeIsSavingState;
        private readonly _ltm;
        private _editScopeEditsChangedSubs;
        /**
         * Initializes a new instance of EditScopeCache.
         */
        constructor(options: FxData.EditScopeCacheOptions<TData, TParams>, callbacks?: EditScopeCacheEditsCallbacks);
        /**
         * Creates a EditScopeView that provides a convenient way to retrieve an EditScope from the cache.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EditScopeView. A typical example is a PartContainer
         * instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed from the UI.
         * @param config Additional options for configuring the EditScopeView.
         * @return An EditScopeView instance.
         */
        createView(lifespan: FxBase.LifetimeManager, config?: FxData.EditScopeViewConfig<TData, TParams>): FxData.EditScopeView<TData, TParams>;
        /**
         * Retrieves a FxBase.PromiseV<Data.EditScope> from the cache. If it is not already present in the cache,
         * it will be created (either via a configured supplyExistingData, or supplyNewData).
         *
         * @param key Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed.
         * @return A promise that will complete with the retrieved EditScope.
         */
        fetch(key: EditScopeKey<TParams>, referrer: FxBase.LifetimeManager): FxBase.PromiseV<EditScope<TData>>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<TData>) => void): FxBase.Promise;
        /**
         * Disposes the EditScopeCache, which in turn disposes all EditScopes it was holding.
         */
        dispose(): void;
        disposeAndDiscardEdits(editScopeId: string, editScopeView: FxData.EditScopeView<TData, TParams>): void;
        onEditScopeDiscarded(editScopeId: string): FxBase.Promise;
        private static _remoteSaveEditScope;
        private static _remoteSaveEdits;
        private static _remoteLoadEdits;
        private static _remoteUpdateEditScopeIsSavingState;
        private get _isDisposed();
        private _serializeKey;
        private _getEditScopeForKey;
        private _acquireEditScope;
        private _loadAndApplyEdits;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.EditScopeCacheOld.d.ts
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import FxData = Fx.Data;
    /**
     * A cache of key results for a specific type of EditScope and key parameters.
     */
    class EditScopeCacheOld<T, TParams> implements FxData.EditScopeCache<T, TParams>, FxImpl.Data.EditScopeCacheBase, FxImpl.Data.ViewSource<EditScopeKey<TParams>> {
        private static _rpcClient;
        private _options;
        private _cacheByParams;
        private _loadEdits;
        private _saveEdits;
        private readonly _ltm;
        private _editScopeEditsChangedSubs;
        /**
         * Initializes a new instance of EditScopeCache.
         */
        constructor(options: FxData.EditScopeCacheOptions<T, TParams>, callbacks?: EditScopeCacheEditsCallbacks);
        /**
         * Creates a EditScopeView that provides a convenient way to retrieve an EditScope from the cache.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EditScopeView. A typical example is a PartContainer
         * instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed from the UI.
         * @param config Additional options for configuring the EditScopeView.
         * @return An EditScopeView instance.
         */
        createView(lifespan: FxBase.LifetimeManager, config?: FxData.EditScopeViewConfig<T, TParams>): FxData.EditScopeView<T, TParams>;
        /**
         * Retrieves a FxPromiseV<Data.EditScope> from the cache. If it is not already present in the cache,
         * it will be created (either via a configured supplyExistingData, or supplyNewData).
         *
         * @param key Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed.
         * @return A promise that will complete with the retrieved EditScope.
         */
        fetch(key: EditScopeKey<TParams>, referrer: FxBase.LifetimeManager): FxPromiseV<EditScope<any>>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<any>) => void): FxPromise;
        /**
         * Disposes the EditScopeCache, which in turn disposes all EditScopes it was holding.
         */
        dispose(): void;
        disposeAndDiscardEdits(editScopeId: string, editScopeView: FxData.EditScopeView<T, TParams>): void;
        onEditScopeDiscarded(editScopeId: string): FxPromise;
        private static _remoteSaveEditScope;
        private static _remoteSaveEdits;
        private static _remoteLoadEdits;
        private get _isDisposed();
        private _revertEditScope;
        private _serializeKey;
        private _getEditScopeForKey;
        private _acquireEditScope;
        private _loadAndApplyEdits;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.EditScopeKey.d.ts
declare module FxImpl.Data {
    /**
     * Internal EditScope key value for specific T type held in cache.
     */
    interface EditScopeKey<TParams> {
        /**
         * EditScope id.
         */
        editScopeId: string;
        /**
         * Value identifying the data loaded into the EditScope held in the cache.
         * If the data is object-typed, this value is an id identifying that entity.
         * If the data is array-typed, this value is the query processed to return the array items.
         *
         * There are two sentinel values:
         * undefined - implies, that EditScopeView.fetchForNewData was called.
         * null - implies, that EditScopeView.fetchForExistingData was called and no 'params' was passed.
         *        This happens e.g. in scenario, when there's only one array on the server, that user
         *        wants to retrieve.
         */
        params: TParams;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.MergeVisitor.d.ts
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An interface through which a MergeVisitor is to be used.
     */
    interface MergeVisitorContract<TData> {
        /**
         * Merges supplied source data onto a supplied target.
         *
         * @param source The source data (from which values will be copied).
         * @param target The target (onto which source values will be applied).
         * @param typeMetadata Type metadata covering the source/target data.
         */
        merge(source: TData, target: TData, typeMetadata: Metadata.Metadata): void;
    }
    /**
     * Options supplied when constructing a MergeVisitor.
     */
    interface MergeVisitorOptions extends VisitorOptions {
        /**
         * A callback called when data is detached from the target data.
         *
         * @param data The data.
         * @param typeMetadata Type metadata covering the data.
         */
        onDetach: (data: any, typeMetadata: Metadata.Metadata) => void;
        /**
         * A callback called to clone supplied source data, in the event that the data is new to the target data.
         *
         * @param data The data to be cloned.
         * @param typeMetadata Type metadata covering the data.
         *
         * @return A clone of the data.
         */
        clone: (data: any, typeMetadata: Metadata.Metadata) => any;
    }
    /**
     * This interface is used to customize a MergeVisitor by supplying mix-in style callbacks.
     */
    interface MergeVisitorCallbacks extends VisitorCallbacks<any, boolean> {
    }
    /**
     * A Visitor that observably merges source data onto target data.
     */
    class MergeVisitor<TData> extends Visitor<any, boolean> implements MergeVisitorContract<TData> {
        _clone: (data: any, typeMetadata: Metadata.Metadata) => any;
        _onDetach: (data: any, typeMetadata: Metadata.Metadata) => void;
        /**
         * Constructs an MergeEntityOnlyVisitor instance.
         *
         * @param options Options used in the construction of the MergeEntityOnlyVisitor.
         */
        constructor(options: MergeVisitorOptions, callbacks: MergeVisitorCallbacks);
        merge(source: TData, target: TData, typeMetadata: Metadata.Metadata): void;
        visitObject(sourceObject: StringMap<any>, typeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        /**
         * See base class.
         */
        visitObjectPropertyValueDispatch(property: string, sourceObject: StringMap<any>, typeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitEntityTypedObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitNonEntityTypedObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitArray(sourceArray: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, targetArray: ArrayOrObservableArray): boolean;
        _mergeArray(sourceArray: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, targetArray: ArrayOrObservableArray, workerFunctions?: {
            getEdits?: (unwrappedSourceArray: any[], unwrappedTargetArray: any[]) => KnockoutArrayEdit<any>[];
            getSourceItem?: (targetItem: any, unwrappedSourceArray: any[]) => any;
            handleAdd?: (itemToAdd: any, index: number) => void;
            handleDelete?: (itemToDelete: any, index: number) => void;
        }): boolean;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.RefCountCache.d.ts
declare module FxImpl.Data {
    /**
     * For testing only. This API does not exist in production code.
     */
    function internalSetDefaultEvictionDelay(newValue: number): number;
    /**
     * Configures a RefCountCache instance.
     */
    interface RefCountCacheConfig<T> {
        /**
         * Optional. Invoked to notify that the given entry is being ejected from the cache.
         *
         * @param entry The entry being ejected.
         * @param key The entry key.
         */
        onEntryDisposed?(entry: T, key: string): void;
        /**
         * Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         *
         * Do not use this in conjunction with the 'extendEntryLifetimes' setting.
         */
        evictionDelay?: number;
        /**
         * Causes cache entries to remain in memory for a framework-controlled period after
         * their last referrer is removed.
         *
         * Do not use this in conjunction with the 'evictionDelay' setting.
         */
        extendEntryLifetimes?: boolean;
    }
    /**
     * A cache of objects of type T, uniquely identifiable via string keys, in which all
     * accesses to the cache are tracked by referrerId (another string key). The cache tracks
     * which referrers have references to which entries, and automatically ejects cache entries
     * when no referrers have references to them.
     */
    class RefCountCache<T> {
        private _onDisposeEntryCallback;
        private _isDisposed;
        private _evictionDelayMilliseconds;
        private _evictionTimeoutHandlesByKey;
        private _entriesByKey;
        private _entriesByReferrerThenKey;
        /**
         * Constructs an instance of RefCountCache.
         *
         * @param config Configuration for the RefCountCache instance.
         */
        constructor(config?: RefCountCacheConfig<T>);
        /**
         * Gets or creates a cache entry for the given key.
         *
         * @param key The entry key.
         * @param referrerId An arbitrary unique string. The entry will be held in memory until this referrerId disposes its reference. If you pass
         * null/undefined, no referrer will be associated with the entry.
         * @param createCallback A function that supplies a value for the entry. This is called only when creating new entries.
         * @return A new or existing cache entry.
         */
        getEntry(key: string, referrerId: string, createCallback: () => T): T;
        /**
         * Reveals whether or not the RefCountCache currently holds an entry for the given key.
         *
         * @param key The entry key.
         * @return True if the entry exists; false otherwise.
         */
        hasEntry(key: string): boolean;
        /**
         * Disassociates the given entry from the given referrer. If the entry is no longer
         * associated with any referrers, it will be ejected from the cache.
         *
         * @param key The entry key.
         * @param referrerId The ID of the referrer.
         */
        dissociateEntry(key: string, referrerId: string): void;
        /**
         * Dissociates all referrers from the entry and evicts the entry from the cache. Does not wait
         * for any eviction delay.
         *
         * @param key The entry to be evicted.
         */
        immediatelyEvictEntry(key: string): void;
        /**
         * Removes all associations with the given referrer. Any entries that no longer
         * have associations will be ejected from the cache.
         *
         * @param referrerId The ID of the referrer.
         */
        disposeReferrer(referrerId: string): void;
        /**
         * Invokes a callback for each entry currently in the cache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEntry(callback: (key: string, value: T) => void): void;
        /**
         * Disposes the RefCountCache so that onDisposeEntryCallback runs for every entry.
         * Once disposed, the RefCountCache may no longer be used to retrieve entries.
         */
        dispose(): void;
        private _ensureReferenceExists;
        private _cancelAnyDelayedEviction;
        private _delayedEvictEntryIfNoReferences;
        private _immediateEvictEntryIfNoReferences;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.Shared.d.ts
declare module FxImpl.Data.Shared {
    /**
     * A JavaScript array instance wrapped in an observable wrapper.  Only in some cases will this be a
     * KnockoutObservableArray.
     */
    type ObservableArray = KnockoutObservableBase<any[]>;
    /**
     * A JavaScript array which may or may not be wrapped in an observable wrapper.
     */
    type ArrayOrObservableArray = any[] | ObservableArray;
    /**
     * Unwraps a property value on a given object.
     * Here, we follow a conventional usage of Knockout observables where observability is considered to be an aspect of
     * the (object,key)-pair.  The 'property value' here is the result of unwrapping.
     * The exception here are observable arrays, which are treated themselves as self-standing containers and, hence,
     * not unwrapped by this function.
     *
     * @param obj An object.
     * @param property A property name.
     * @return The unwrapped object property value.
     */
    function unwrapObjectPropertyValue(obj: StringMap<any>, property: string): any;
    /**
     * Returns a boolean reflecting whether a property on a supplied object is observable.
     * Here, we follow a conventional usage of Knockout observables where observability is considered to be an aspect of
     * the (object,key)-pair.  The 'property value' here is the result of unwrapping.
     * The exception here are observable arrays, which are treated themselves as self-standing containers and, hence,
     * not unwrapped by this function.
     *
     * @param obj An object.
     * @param property A property name.
     * @return A boolean reflecting whether the object property value is observable.
     */
    function isObservableObjectPropertyValue(obj: StringMap<any>, property: string): boolean;
    /**
     * Unwraps a value that is assumed/asserted to be of type T[] or of type KnockoutObservableBase<T[]> and its
     * subclasses.
     *
     * @param data The array or observable-wrapped array.
     * @return A JavaScript array.
     */
    function unwrapArrayOrObservableArray(data: ArrayOrObservableArray): any[];
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.ViewSource.d.ts
declare module FxImpl.Data {
    interface QueryViewSource<T, TParams> extends DataViewSource<T, TParams> {
        /**
         * Any navigation options configured for this QueryCache.
         */
        navigationOptions: MsPortalFx.Data.QueryCacheNavigationOptions<T, TParams>;
    }
    interface DataViewSource<T, TParams> extends RefreshableViewSource<T, TParams> {
        /**
         * Retrieves data matching the specified parameters.
         *
         * @param params Parameters describing the data to be fetched.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @return A promise that completes with the requested data.
         */
        fetch(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): MsPortalFx.Data.DataSetPromise;
    }
    interface RefreshableViewSource<T, TParams> extends ViewSource<TParams> {
        "--noUnusedLocals"?: T | any;
        /**
         * Instructs the data source to update the contents of whatever T corresponds to the
         * specified parameters.
         *
         * @param params Parameters describing the data to be updated.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @return A promise that completes when the refresh has completed.
         */
        refresh(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): MsPortalFx.Base.Promise;
    }
    interface ViewSource<TParams> {
        /**
         * Retrieves data matching the specified parameters.
         *
         * @param params Parameters describing the data to be fetched.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @return A promise that completes with the requested data.
         */
        fetch(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): MsPortalFx.Base.Promise;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.Views.d.ts
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxData = Fx.Data;
    import FxPromise = FxBase.Promise;
    import ErrorNotificationTarget = FxData.ErrorNotificationTarget;
    interface CancelableRequestInfo<T extends FxPromise> {
        cancelationToken: FxBase.Promises.CancelationToken;
        cancelablePromise: T;
        externalPromise: FxPromise;
    }
    /**
     * Represents a callback that will be invoked when an a fetch operation
     * reports a 'not found' error.
     */
    interface InterceptNotFoundCallback<TParams> {
        (params: TParams): void;
    }
    /**
     * Options for configuring an ObjectView.
     */
    interface ObjectViewConfig<TObject, TParams> {
        "--noUnusedLocals"?: TObject | any;
        /**
         * Indicates whether the ObjectView should intercept any 'not found' (404) errors, and if so,
         * how they should be handled. Defaults to 'true'.
         *
         *  - 'false' means that the ObjectView will not intercept 'not found' errors, which means that
         *    such errors will cause parts/blades to go into generic failure states
         *  - 'true' means that the ObjectView will intercept 'not found' errors, and handle them by
         *    displaying a generic 'not found' message
         *  - callback functions mean that custom 'not found' handling applies, so 404s will trigger
         *    your callback. This is useful for displaying custom 'not found' messages.
         *
         * Regardless of this option, all onInputsSet promise rejections other than 'not found' (404) will
         * continue to trigger generic part/blade failures.
         */
        interceptNotFound?: boolean | InterceptNotFoundCallback<TParams>;
    }
    /**
     * Provides a convenient way to access results from an underlying ViewSource. Whenever you modify
     * the query parameters associated with the ObjectView, it will fetch a corresponding TObject from
     * the underlying ViewSource.
     *
     * This class should not be instantiated directly.  Rather, acquire an instance of a subclass by
     * calling 'createView' on a Cache instance.
     */
    class ObjectView<TObject, TParams> {
        _loadedCacheEntry: KnockoutObservable<TObject>;
        _interceptNotFound: boolean | InterceptNotFoundCallback<TParams>;
        _isDisposed: boolean;
        _dataSource: ViewSource<TParams>;
        _errorNotificationTarget: ErrorNotificationTarget;
        _currentParams: TParams;
        _currentCacheEntryDisposer: FxBase.DisposableLifetimeManager;
        _requestInProgress: KnockoutObservable<CancelableRequestInfo<FxBase.PromiseV<TObject>>>;
        _isLoading: KnockoutComputed<boolean>;
        _lifetime: FxBase.LifetimeManager;
        /**
         * Constructs an instance of ObjectView<TEntity, TParams>.
         *
         * @param dataSource A provider of data for the ObjectView, for example a DataCache instance.
         * @param lifetime The current cache entry referenced by this ObjectView will remain in memory at least until this object notifies that it is disposed.
         * @param errorNotificationTarget An object that represents the minimum lifetime of the current cache entry, and can optionally receive notifications about any errors encountered.
         * @param config Options for configuring the instance.
         */
        constructor(dataSource: ViewSource<TParams>, errorNotificationTarget: ErrorNotificationTarget, config: ObjectViewConfig<TObject, TParams>);
        /**
         * An observable value that indicates whether this ObjectView currently refers to a request that has not yet completed.
         */
        get loading(): KnockoutComputed<boolean>;
        /**
         * Sets the ObjectView's current query parameters, changing what data it exposes.
         * The data will be fetched from the underlying cache, which may or may not already have it in memory.
         *
         * If you call 'fetch' while an earlier load is still in progress, the older load will be superseded,
         * meaning that its promise will never complete. This is so you do not need manual code to stop
         * superseded promise handlers from performing actions that are now irrelevant.
         *
         * @param params Query parameters describing the data to be fetched. If you supply null/undefined, then the preceding query will be superseded,
         * but no new query will be begun - the ObjectView will therefore become empty.
         * @return A promise that completes when the load has completed.
         */
        fetch(params: TParams): FxPromise;
        private _cancelInProgressRequest;
        private _releaseCurrentContents;
        private _handleFetchRejections;
    }
    /**
     * Provides a convenient way to access results from an underlying ViewSource. Whenever you modify
     * the query parameters associated with the ObjectView, it will fetch a corresponding TObject from
     * the underlying ViewSource.
     *
     * Extension developers are not intended to use this directly, and should instead use one of the
     * specialized subclasses, e.g. EntityView, QueryView, that can be obtained by calling
     * .createView() on an EntityCache or QueryCache instance.
     */
    class DataView<TEntity, TParams> extends ObjectView<FxData.DataSet, TParams> {
        private _partialErrors;
        private get _refreshableDataSource();
        /**
         * Internal constructor. Extension developers are not intended to use this directly, and should
         * instead use one of the specialized subclasses, e.g. EntityView, QueryView, that can be obtained
         * by calling .createView() on an EntityCache or QueryCache instance.
         */
        constructor(dataSource: FxImpl.Data.DataViewSource<TEntity, TParams>, lifetime: FxBase.LifetimeManager, config: ObjectViewConfig<TEntity, TParams>);
        get partialErrors(): KnockoutReadOnlyObservableArray<FxData.PartialError>;
        /**
         * Instructs the underlying data loader to re-fetch and update whatever data is
         * currently being exposed by this instance.
         *
         * If a request is currently in progress, this does not trigger a further request.
         * So, it is safe to invoke 'refresh' immediately after a 'fetch' if you want to
         * be sure to fetch fresh data and not accept existing cached data.
         *
         * @return A promise that completes when the refresh is done. Or, if a request was already in progress, a promise that completes when the existing request completes.
         */
        refresh(): FxBase.Promise;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.Visitor.d.ts
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import Metadata = Fx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An entity is an object whose associated type metadata describes an entity type (with a primary key /
     * unique id).
     */
    type Entity = StringMap<any>;
    /**
     * An array of entity objects.  An entity is an object whose associated type metadata describes an entity type (with
     * a primary key / unique id).
     */
    type EntityArray = ArrayOrObservableArray;
    /**
     * This interface is used to customize a Visitor by supplying mix-in style callbacks.
     */
    interface VisitorCallbacks<TArgs, TResult> {
        /**
         * Visits an entity-typed array (observable or native).
         *
         * @param array An entity-typed array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntityArray?: (array: EntityArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed array (observable or native).
         *
         * @param array An non-entity-typed array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityArray?: (array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an array (observable or native).
         *
         * @param array An array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitArray?: (array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an array item.
         *
         * @param item An item contained in an array.
         * @param index The index for the item in the containing array.
         * @param typeMetadata Type metadata covering item.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitArrayItem?: (item: any, index: number, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an entity-typed object.
         *
         * @param entity An entity-typed object.
         * @param typeMetadata Type metadata covering the entity.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntity?: (entity: Entity, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed object.
         *
         * @param obj A non-entity-typed object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityObject?: (obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a object.
         *
         * @param obj An object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObject?: (obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Determines whether a given object property should be visited.
         *
         * @param property The property name.
         * @param obj The object.
         * @param typeMetadata Type metadata for the object.
         *
         * @return A boolean reflecting whether the property should be visited.
         */
        shouldVisitObjectProperty?: (property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata) => boolean;
        /**
         * Visits an entity-typed property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntityTypedObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityTypedObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a date value.
         *
         * @param date The date value.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitDate?: (data: Date, args?: TArgs) => TResult;
        /**
         * Visits a scalar (non-Date) value.
         *
         * @param value The scalar value.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitScalar?: (value: number | string, args?: TArgs) => TResult;
        /**
         * Visits a function.
         *
         * @param fn The function.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitFunction?: (fn: Function, args?: TArgs) => TResult;
    }
    /**
     * An interface through which a Visitor is to be used.
     */
    interface VisitorContract<TResult> {
        /**
         * Performs the visitation.
         *
         * @param data The data to be visited.
         * @param typeMetadata Type metadata covering the data.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visit(data: any, typeMetadata: Metadata.Metadata): TResult;
    }
    /**
     * An interface through which a Visitor is to be used.
     */
    interface VisitorWithArgsContract<TArgs, TResult> {
        /**
         * Performs the visitation.
         *
         * @param data The data to be visited.
         * @param typeMetadata Type metadata covering the data.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visit(data: any, typeMetadata: Metadata.Metadata, args: TArgs): TResult;
    }
    /**
     * Options supplied when constructing a Visitor.
     */
    interface VisitorOptions {
    }
    /**
     * A Visitor that can be extended/specialized via inheritance and via mix-in style callbacks.
     */
    class Visitor<TArgs, TResult> implements VisitorWithArgsContract<TArgs, TResult>, VisitorContract<TResult>, VisitorCallbacks<TArgs, TResult> {
        _callbacks: VisitorCallbacks<TArgs, TResult>;
        /**
         * Constructs a Visitor instance.
         *
         * @param options Options used in the construction of the Visitor.
         * @param callbacks Optional, mix-in style callbacks that override default Visitor behavior.
         */
        constructor(options: VisitorOptions, callbacks: VisitorCallbacks<TArgs, TResult>);
        visit(data: any, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitEntityArray(array: EntityArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitNonEntityArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitArrayItem(item: any, index: number, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitEntity(entity: Entity, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitNonEntityObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        shouldVisitObjectProperty(property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata): boolean;
        visitEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitNonEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitDate(date: Date, args?: TArgs): TResult;
        visitScalar(value: number | string, args?: TArgs): TResult;
        visitFunction(fn: Function, args?: TArgs): TResult;
        /**
         * Returns the object properties that should be visited.
         *
         * @param obj An object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return An array of string that are the names of the properties that should be visited.
         */
        getObjectPropertiesToVisit(obj: StringMap<any>, typeMetadata: Metadata.Metadata): string[];
        /**
         * Visits a property on an object, delegating to 'visitEntityTypedObjectPropertyValue' or
         * 'visitNonEntityTypedObjectPropertyValue' based on type metadata.
         *
         * @param property The property name.
         * @param obj The object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObjectPropertyValueDispatch(property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visit(data: any, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visitArrayDispatch(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visitObjectDispatch(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.DataNavigationMetadata.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes the state of navigable data, for example specifying the
     * total number of items or the token needed to fetch further data.
     *
     * This information is typically extracted from a server response.
     */
    interface DataNavigationMetadata {
        /**
         * If available, provides the total number of items that may be navigated through.
         * Not all data sources make this information available, so this property may be null/undefined.
         */
        totalItemCount?: number;
        /**
         * If applicable, specifies the server-generated continuation token value that may
         * be used to fetch the next range of items. This value may be in any format - for
         * example, it may be an entire URI.
         */
        continuationToken?: string;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.DataNavigator.d.ts
declare module MsPortalFx.Data {
    enum SortOrder {
        /**
         * Column is unsorted.
         */
        Unsorted = 0,
        /**
         * Column is sorted ascending.
         */
        Ascending = 1,
        /**
         * Column is sorted descending.
         */
        Descending = 2
    }
    interface SortBy {
        /**
         * The item key to sort by.
         */
        itemKey: string;
        /**
         * The direction of the sort either ascending or descending.
         */
        sortOrder: SortOrder;
    }
    /**
     * Represents a source of data that supports one or more standard navigation mechanisms,
     * such as skip/take or continuation tokens.
     */
    interface DataNavigator<T> {
        /**
         * The current range of items.
         */
        items: KnockoutObservableBase<T[]>;
        /**
         * Provides metadata about navigation state, such as current page index
         * or the total number of items.
         */
        metadata: KnockoutObservableBase<DataNavigationMetadata>;
        /**
         * Describes errors associated with the current items in the data navigator.
         */
        partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>;
        /**
         * If this data navigator supports loading via skip/take, loads data by that method.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        loadBySkipTake?(skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        /**
         * If the data navigator supports loading via continuation tokens, resets its state so that
         * the next load will fetch the first page of data.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        resetLoadByContinuationToken?(filter: string, sort?: SortBy[]): void;
        /**
         * If the data navigator supports loading via continuation tokens, loads data by that method.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        loadByContinuationToken?(): MsPortalFx.Base.Promise;
        /**
         * Instructs all consumers of this navigator to reset their navigation state
         * and begin at the first page.
         *
         * @return A promise that completes when all consumers of the navigator have finished resetting their navigation state.
         */
        resetNavigation(): MsPortalFx.Base.Promise;
        /**
         * Used by controls that are consuming the navigator to receive notification
         * when the navigation state should be reset. Not intended for use from
         * portal extension code.
         *
         * @param callback Callback to invoke when navigation state should be reset.
         */
        addResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
        /**
         * Removes a callback previously registered using addResetListener. Not intended
         * for use from portal extension code.
         *
         * @param callback Callback to be removed. Must be the same function instance that was previously registered.
         */
        removeResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.DataNavigatorBase.d.ts
declare module MsPortalFx.Data {
    /**
     * An abstract base class for data navigators.
     */
    class DataNavigatorBase<TEntity> implements DataNavigator<TEntity> {
        items: KnockoutObservableBase<TEntity[]>;
        metadata: KnockoutObservableBase<DataNavigationMetadata>;
        private _resetListeners;
        private _partialErrors;
        constructor(partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        get partialErrors(): KnockoutReadOnlyObservableArray<PartialError>;
        resetNavigation(): MsPortalFx.Base.Promise;
        addResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
        removeResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.LocalDataNavigator.d.ts
declare module MsPortalFx.Data {
    /**
     * A DataNavigator that supports skip/take over in-memory data.
     */
    class LocalDataNavigator<T> extends DataNavigatorBase<T> {
        private _allItems;
        private _currentSkipTakeParams;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, allItems: KnockoutObservableBase<T[]>, partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        loadBySkipTake(skip: number, take: number, filter: string): MsPortalFx.Base.Promise;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.RemoteDataNavigator.d.ts
declare module MsPortalFx.Data {
    /**
     * Options that describe how a RemoteDataNavigator should perform navigation.
     */
    interface RemoteDataNavigatorOptions<TEntity, TQueryParams> {
        "--noUnusedLocals"?: TEntity | any;
        /**
         * If the data source supports skip/take, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         */
        loadBySkipTake?(metadata: DataNavigationMetadata, query: TQueryParams, skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        /**
         * If the data source supports continuation tokens, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param metadata The most recent metadata, if any, fetched previously by this data source.
         * @param query Query parameters to be used.
         * @param reset If true, indicates that the first page of data should be loaded. Otherwise, the continuation token in metadata should be used to
         * fetch the next range of data.
         * @param filter Specifies any filtering value entered by the user.
         * @param sort An array of objects to sort by.
         * @return A promise representing the operation.
         */
        loadByContinuationToken?(metadata: DataNavigationMetadata, query: TQueryParams, reset: boolean, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
    }
    /**
     * A DataNavigator that uses callbacks to read arbitrary external
     * data, such as data loaded on demand from a remote server.
     */
    class RemoteDataNavigator<TEntity, TQueryParams> extends DataNavigatorBase<TEntity> {
        private _options;
        private _continuationTokenFilter;
        private _continuationTokenSort;
        private _continuationTokenResetRequested;
        private _queryParams;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableBase<TEntity[]>, metadata: KnockoutObservableBase<DataNavigationMetadata>, options: RemoteDataNavigatorOptions<TEntity, TQueryParams>, partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        loadBySkipTake(skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        loadByContinuationToken(): MsPortalFx.Base.Promise;
        resetLoadByContinuationToken(filter: string, sort?: SortBy[]): void;
        /**
         * Sets query parameters on the navigator, and resets navigation state so that
         * consumers will load the first page of results for the new query. Typically,
         * parts should call this from their onInputsSet methods.
         *
         * Controls that use navigators will not request any data until the first time
         * that navigation state is reset, so you must call this from onInputsSet even
         * if your navigator has no particular query (in this case, just pass 'null' to
         * signal that you are ready for the control to load data).
         *
         * @param query The new query parameters that will be passed to your loadBy... callbacks.
         * @return A promise that completes when all consumers of the navigator have finished resetting their navigation state. Typically, you should return
         * this from your onInputsSet method.
         */
        setQuery(query: TQueryParams): MsPortalFx.Base.Promise;
        private _getClonedQuery;
    }
}

// FILE: MsPortalFx\Decorators.d.ts
declare module MsPortalFx.Composition {
    import FxBase = MsPortalFx.Base;
    /**
     * This decorator should only apply to properties.
     *
     * It marks the property ignored by Po. Properties that are marked NotProxied are excluded from
     * observable / view model proxying.  Marking properties with this decorator enables a significant performance
     * optimization for observable / view model proxying.
     *
     * @param target The target object
     * @param key The property key
     * @param descriptor The property descriptor
     */
    function NotProxied(target: any, key: string, descriptor: PropertyDescriptor): void;
    /**
     * This decorator should only apply to class which contains properties.
     *
     * It makes all properties in this class ignored by Po. All properties in this class are excluded from
     * observable / view model proxying. Marking this decorator enables a significant performance
     * optimization for observable / view model proxying.
     *
     * @param target The target object
     * @param key The property key
     * @param descriptor The property descriptor
     */
    let ProxyCompatibilityMode: Action1<any>;
    let exportForDevMode: {
        log: FxBase.Diagnostics.Log;
    };
}

// FILE: MsPortalFx\Environment.d.ts
declare module FxImpl {
    interface QueryObject {
        readonly clientoptimizations?: string;
        readonly l?: string;
        readonly sessionid?: string;
        readonly [key: string]: string;
    }
    interface ShellFeatures {
        readonly flights: ReadonlyStringMap<boolean>;
        readonly fromConfig: ReadonlyStringMap<string>;
        readonly fromQuery: QueryObject;
    }
    class Features {
        readonly value: FeatureConfig;
        readonly shellFeatures: ShellFeatures;
        readonly isEnabled: (feature: string, defaultValue?: boolean) => boolean;
        readonly getValue: (feature: string) => string;
        constructor(shellFeatures?: ShellFeatures, extensionName?: string, extensionFeatures?: ReadonlyArray<ReadonlyStringMap<string | boolean>>);
    }
    let features: Features;
}

// FILE: MsPortalFx\EnvironmentInit.d.ts
declare module FxImpl {
    const origin: string;
    const protocol: string;
    const href: string;
    function onEnvironmentSet(callback: Action1<typeof MsPortalFx.getEnvironmentValue>): void;
    function throwBeforeEnvironment(): void;
    function setEnvironment(): void;
    /**
     * Returns uri that includes the scheme. Assumes that uris that do not begin with a scheme or a slash are in
     * application relative form.
     *
     * @param uri A uri.
     * @return The absolute uri.
     */
    function ensureAbsoluteUri(uri: string, replacementOrigin?: string, appPath?: string): string;
}
declare module MsPortalFx {
    const isIFrame: boolean;
    /**
     * Gets the value of the specified feature.
     * NOTE: The feature must be specified without the <Extension>_ prefix.
     *
     * @param feature The name of the feature.
     * @returns The value of the feature.
     */
    function getFeatureValue(feature: string): string;
    /**
     * Gets a value indicating whether or not the specified feature is enabled.
     * NOTE: The feature must be specified without the <Extension>_ prefix.
     *
     * @param feature The name of the feature.
     * @returns True if the feature is enabled; else false.
     */
    function isFeatureEnabled(feature: string): boolean;
    /**
     * Gets the value of an environment variable, preserving the typing.
     *
     * @param key The name of the value to get
     * @param defaultValue The value to return if the value is not there
     * @returns The value from the enviroment or the defaultValue
     */
    function getEnvironmentValue<T extends keyof FxEnvironment>(key: T, defaultValue?: FxEnvironment[T]): FxEnvironment[T];
    const isDevelopmentMode: boolean;
    const isTestMode: boolean;
    const isInWebWorker: boolean;
    const sessionId: string;
    const trace: TraceConfig;
    const portalUri: string;
    /**
     * The original Object.defineProperty() method. This method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.
     * NOTE: 1. The Object.defineProperty() might be overridden to only defines non enumeration property. So, the MsPortalFx.defineProperty is the recommended way to define enumeration property.
     *       2. Set "MsPortalFx.defineProperty" to "MsPortalFx.defineProperty || Object.defineProperty" to avoid potential recursive loop.
     *
     * @param obj The object on which to define the property.
     * @param property name The property name.
     * @param descriptor The descriptor for the property.
     */
    let defineProperty: Action3<any, string, PropertyDescriptor>;
}

// FILE: MsPortalFx\Errors\Errors.d.ts
declare module FxImpl {
    /**
     * Alias for native Error type.
     */
    type NativeError = Error;
    /**
     * Alias for native Error object.
     */
    const NativeError: ErrorConstructor;
}
declare module MsPortalFx.Errors {
    import NativeError = FxImpl.NativeError;
    /**
     * Defines the contract of an error within the Framework.
     */
    interface ErrorContract {
        /**
         * Gets the proxyable name of the error.
         */
        type: string;
        /**
         * The error message.
         */
        message?: string;
        /**
         * The error name.
         */
        name?: string;
        /**
         * The error code.
         */
        code?: number;
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel?: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel?: ErrorLevel;
        /**
         * Error source information.
         */
        source?: string;
        /**
         * Inner errors that caused this error.
         */
        innerErrors?: NativeError[];
        /**
         * Indicates if the error has been handled.
         */
        handled?: boolean;
        /**
         * Time error occured.
         */
        timestamp?: number;
        /**
         * Call stack.
         */
        stack?: string;
        /**
         * Information associated with the error that is never proxied.
         */
        errorData?: any;
        /**
         * Information associated with the error that may be proxied.
         */
        data?: any;
    }
    const enum ErrorLevel {
        /**
         * Do not log if unhandled.
         */
        None = 0,
        /**
         * Log as warning if unhandled.
         */
        Warning = 1,
        /**
         * Log as error if unhandled.
         */
        Error = 2
    }
    interface ErrorType<E extends Error> {
        /**
         * Constructor.
         */
        new (...args: any[]): E;
        /**
         * Provides the unique type name for this error.
         */
        TypeName: string;
    }
    interface ErrorOptions {
        /**
         * The error message.
         */
        message?: string;
        /**
         * The error code.
         */
        code?: number;
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel?: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel?: ErrorLevel;
        /**
         * Error source information.
         */
        source?: string;
        /**
         * Inner errors that caused this error.
         */
        innerErrors?: NativeError | NativeError[];
        /**
         * Indicates if the error has been handled.
         */
        handled?: boolean;
        /**
         * Time error occured.
         */
        timestamp?: number;
        /**
         * Call stack.
         */
        stack?: string;
        /**
         * The error name.
         */
        name?: string;
        /**
         * Information associated with the error.
         * (This error data is shielded from being proxied by a get accessor.)
         */
        errorData?: any;
        /**
         * Information associated with the error.
         * (This error data may be proxied.)
         */
        data?: any;
    }
    /**
     * Checks if the error is an instance of the specified error type.
     * Works across the proxied obserable layer for MsPortalFx.Errors.Error derived errors.
     *
     * @param error The error instance to check.
     * @param errorType The type of error to check for.
     * @return Indicates if the error is an instance of the type.
     */
    function isInstanceOfErrorType<E extends Error>(error: any, errorType: ErrorType<E>): error is E;
    /**
     * Helper to convert various param types to an options object.
     */
    function getErrorOptions<T extends ErrorOptions>(message: string, defaultOptions?: T): T;
    function getErrorOptions<T extends ErrorOptions>(options: T, defaultOptions?: T): T;
    /**
     * Framework Error object that can be thrown or
     * or derived from to make more specific errors.
     */
    class Error extends NativeError implements ErrorContract {
        /**
         * Stores the error type name.
         * Preferably derived errors should specify this to uniquely identify themselves.
         * However, if not provided the contructor name is used to set this at run-time.
         */
        static TypeName: string;
        /**
         * Checks that this error type is a base of the error.
         *
         * @error The error to check.
         * @return True if the error is of this error type.
         */
        static isBaseOf(error: any): error is Error;
        /**
         * The error code.
         */
        code: number;
        /**
         * The error source information.
         */
        source: string;
        /**
         * The name of the extension that created the error.
         */
        extension: string;
        /**
         * The error type name.
         */
        type: string;
        /**
         * The error type names in the prototype chain.
         */
        baseTypes: string[];
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel: ErrorLevel;
        /**
         * Inner error that caused this error.
         */
        innerErrors: NativeError[];
        /**
         * If true, indicates that no further handling is required.
         */
        handled: boolean;
        /**
         * Time error occured.
         */
        timestamp: number;
        /**
         * The error message.
         */
        message: string;
        /**
         * The error name.
         */
        name: string;
        /**
         * The error call stack.
         */
        stack: string;
        /**
         * Information associated with the error that is never proxied.
         */
        private _errorData;
        /**
         * Information associated with the error that can be proxied.
         */
        data: any;
        /**
         * Constructs a generic Error.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a generic Error.
         *
         * @param options The error options.
         */
        constructor(options?: ErrorOptions);
        /**
         * Error specific data.
         */
        get errorData(): any;
    }
    /**
     * Defines the contract of an error related to Data within the Framework.
     */
    interface DataErrorContract extends ErrorContract {
        /**
         * The name of the data set that was the source of the error.
         */
        dataSetName: string;
        /**
         * Information associated with the error.
         */
        errorData: any;
    }
    /**
     * Represents a generic data error.
     */
    class DataError extends Error implements DataErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The name of the data set that was the source of the error.
         */
        dataSetName: string;
        /**
         * Constructs a DataError.
         *
         * @param options The data error options.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents a fetch data error.
     */
    class FetchDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a FetchDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents an unauthorized data error.
     */
    class UnauthorizedDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a UnauthorizedDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents a "not found" data error.
     */
    class NotFoundDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a NotFoundDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents and cancelation error.
     */
    class CanceledError extends Error {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a CanceledError.
         * Thrown to cancel operations.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a CanceledError.
         * Thrown to cancel operations.
         *
         * @param options The error options.
         */
        constructor(options?: ErrorOptions);
    }
    /**
     * common DisposedCanceledError that share with all dispose pattern.
     */
    class DisposedCanceledError extends CanceledError {
        constructor();
    }
    interface DisposedErrorContract extends ErrorContract {
        /**
         * The name of the object being disposed.
         */
        source?: string;
    }
    interface DisposedErrorOptions extends ErrorOptions {
        /**
         * The name of the object being disposed.
         */
        source?: string;
    }
    /**
     * Represents a disposed error.
     */
    class DisposedError extends Error implements DisposedErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The name of the object being disposed.
         */
        source: string;
        /**
         * Construct a DisposedError.
         * Thrown when a instance is accessed after being disposed.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a DisposedError.
         * Thrown when a instance is accessed after being disposed.
         *
         * @param options The error options.
         */
        constructor(options?: DisposedErrorOptions);
    }
    interface AjaxErrorContract extends ErrorContract {
        /**
         * The XHR of the response.
         */
        jqXHR: JQueryXHR<any>;
        /**
         * The text status.
         */
        textStatus: string;
        /**
         * The XHR Error string
         */
        errorThrown: string;
    }
    interface AjaxErrorOptions extends ErrorOptions {
        /**
         * The XHR of the response.
         */
        jqXHR: JQueryXHR<any>;
        /**
         * The text status.
         */
        textStatus: string;
        /**
         * The XHR Error string
         */
        errorThrown: string;
    }
    /**
     * Represents a Ajax error.
     */
    class AjaxError extends Error implements AjaxErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The XHR of the response.
         */
        jqXHR: JQueryXHR<any>;
        /**
         * The text status.
         */
        textStatus: string;
        /**
         * The XHR Error string
         */
        errorThrown: string;
        /**
         * Construct a AjaxError.
         * Thrown when a instance is accessed after being Ajax.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a AjaxError.
         * Thrown when a instance is accessed after being Ajax.
         *
         * @param options The error options.
         */
        constructor(options?: AjaxErrorOptions);
    }
}

// FILE: MsPortalFx\Extension\ActionBarKind.d.ts
declare module MsPortalFx.Extension {
    const enum ActionBarKind {
        /**
         * Indicates that no action bar is to be used.
         */
        None = 0,
        /**
         * The type of action bar to use in a form blade.
         */
        Create = 1,
        /**
         * The type of action bar to use in a picker blade.
         */
        Picker = 2,
        /**
         * The type of action bar to use in a form blade.
         */
        Form = 3,
        /**
         * The type of action bar to use in a filter blade.
         */
        Filter = 4,
        /**
         * The type of action bar to use in a delete confirmation blade.
         */
        Delete = 5,
        /**
         * The type of action bar to use in a generic blade.
         */
        Generic = 6
    }
}

// FILE: MsPortalFx\Extension\AssetIdSourceType.d.ts
declare module MsPortalFx.Extension {
    const enum AssetIdSourceType {
        /**
         * Asset ID from a property on the inputs.
         */
        FromInput = 0,
        /**
         * Asset ID from a property on the property provider service on the scope asset type.
         */
        FromProvider = 1,
        /**
         * Asset ID from a property on the property provider service on the permission asset type.
         */
        FromSourceProvider = 2
    }
}

// FILE: MsPortalFx\Extension\AssetTypeOptions.d.ts
declare module MsPortalFx.Extension {
    const enum AssetTypeOptions {
        /**
         * The asset type does not provide any options.
         */
        NoOptions = 0,
        /**
         * The asset type is hidden from the browse menu, search and the resource filter types.
         */
        HideAssetType = 1,
        /**
         * The asset type's instances (actual resources) are by default hidden from the browse resource list and search results.
         */
        HideInstances = 2
    }
}

// FILE: MsPortalFx\Extension\BrowseType.d.ts
declare module MsPortalFx.Extension {
    const enum BrowseType {
        /**
         * Use the service view model (browse V1).
         *
         * @deprecated Browse V1 is no longer supported and at this point is not used by any teams
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        ServiceViewModel = 0,
        /**
         * Use the resource type for browse.
         */
        ResourceType = 1,
        /**
         * Use the asset type blade for browse.
         */
        AssetTypeBlade = 2,
        /**
         * Service link into the classic portal for a service.
         */
        ServiceLink = 3,
        /**
         * Instance link into the classic portal for an instance of a service.
         *
         * @deprecated Instance link browse is no longer supported and at this point is not used by any teams
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        InstanceLink = 4,
        /**
         * AzEtensions yield metadata that describes the Blade to open for browse.
         */
        _Internal_AzExtension = 999,
        /**
         * The asset type does not support browse (used only in typescript).
         */
        NoBrowse = -1
    }
}

// FILE: MsPortalFx\Extension\ColumnFormat.d.ts
declare module MsPortalFx.Extension {
    const enum ColumnFormat {
        /**
         * The column has no format (used only in typescript).
         */
        NoFormat = 0,
        /**
         * Simple string column direct from ARG results.
         */
        String = 1,
        /**
         * Resource column which is an ARM ID from ARG results.
         */
        Resource = 2,
        /**
         * Simple date column direct from ARG results.
         */
        Date = 3,
        /**
         * The result from ARG will be mapped as a number based on the user's current locale.
         */
        Number = 4,
        /**
         * The result from ARG will be mapped to a location display name.
         */
        Location = 5,
        /**
         * Simple string column direct from ARG results that will launch a blade using the Blade property of the column.
         */
        BladeLink = 6
    }
}

// FILE: MsPortalFx\Extension\CommandKind.d.ts
declare module MsPortalFx.Extension {
    const enum CommandKind {
        /**
         * A standard command invokes execute on the command view model
         */
        Standard = 0,
        /**
         * A Url command opens a new Url in new browser session
         */
        Url = 1,
        /**
         * A blade command kind opens a blade
         */
        Blade = 2,
        /**
         * A FileDownload command kind to download file content.
         */
        FileDownload = 3,
        /**
         * A ListCommand opens a list of items
         */
        List = 4,
        /**
         * A Dynamic command initializes and executes another command.
         */
        Dynamic = 5
    }
}

// FILE: MsPortalFx\Extension\Extension.d.ts
declare module FxImpl.Extension {
    import Rpc = FxImpl.Rpc;
    const extensionStatusEndPoint: Rpc.ActionEndPointDefinition<ExtensionStatus>;
    /**
     * The descriptor for an extension window.
     */
    interface ExtensionDescriptor {
        /**
         * The name of the extension.
         */
        name: string;
    }
    /**
     * Types of events an extension can notify the shell about.
     */
    const enum ExtensionStatusCode {
        /**
         * The extension is operating normally.
         */
        Normal = 0,
        /**
         * The extension has detected that it's server version has changed.
         */
        VersionChanged = 1,
        /**
         * The extension has detected that it is no longer authorized for its server.
         */
        AuthorizationExpired = 2,
        /**
         * When ajax calls return a status code 0,
         * Usually happens when unable to connect to the network, firewall issues or browser extensions.
         */
        UnknownNetworkError = 4,
        /**
         * Disconnected from Relex.
         */
        RelexDisconnected = 5,
        /**
         * Too many requests. User has exceeded the rate limit.
         */
        TooManyRequests = 6,
        /**
         * Session expired
         */
        SessionExpired = 7,
        /**
         * MFA error
         */
        MfaError = 8,
        /**
         * Claims error
         */
        ClaimsError = 9
    }
    interface ExtensionStatus {
        code: ExtensionStatusCode;
        message?: string;
        data?: {
            clientRequestId?: string;
            correlationId?: string;
            missingClaims?: string;
            resourceName?: string;
            retryAfter?: string;
            type?: string;
            uri?: string;
            version?: string;
        };
    }
    function setRuntime(runtime: RuntimeImpl): void;
    function getRuntime(): Runtime;
    const enum LocatorType {
        /**
         * Locator for an extension definition.
         */
        Extension = 0,
        /**
         * Locator for a blade definition.
         */
        Blade = 1,
        /**
         * Locator for a lens definition.
         */
        Lens = 2,
        /**
         * Locator for an asset type definition.
         */
        AssetType = 3,
        /**
         * Locator for a command group.
         */
        CommandGroup = 4,
        /**
         * Locator for a part instance definition.
         */
        PartInstance = 5,
        /**
         * Locator for a part type definition.
         */
        PartType = 6,
        /**
         * Locator for a startboard part instance definition.
         */
        StartboardPartInstance = 7,
        /**
         * Locator for an action bar definition.
         */
        BladeActionBar = 8,
        /**
         * Locator for a command.
         */
        Command = 9,
        /**
         * Removed type
         */
        UnusedPlaceholder = 10,
        /**
         * Locator for a hub instance manifest.
         */
        Hub = 11,
        /**
         * Locator for a custom lens.
         */
        CustomLens = 12,
        /**
         * Locator for a command type defined in the commands catalog.
         */
        CommandType = 13,
        /**
         * Locator for a blade redirect.
         */
        BladeRedirect = 14,
        /**
         * Locator for a part instance redirect.
         */
        PartInstanceRedirect = 15,
        /**
         * Locator for a part type redirect.
         */
        PartTypeRedirect = 16,
        /**
         * Browse configuration for a asset type
         */
        AssetTypeForBrowse = 17,
        /**
         * Html template for parts and blades
         */
        HtmlTemplate = 18
    }
}

// FILE: MsPortalFx\Extension\Extension.Definition.d.ts
declare module MsPortalFx.Extension {
    /**
     * Definition for an extension.
     */
    interface Definition {
        /**
         * Name of the extension.
         */
        name: string;
        /**
         * Version of the extension.
         */
        version?: string;
        /**
         * Definition schema version.
         */
        schemaVersion?: string;
        /**
         * For diagnostics only.
         * This property is to assistant in identfying which build of the extension this is
         * i.e. debug vs retail
         */
        buildDescription?: string;
        /**
         * If this flag is true visual artifacts are displayed in the assets, parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * Parts to show on startboard on startup.
         */
        startBoardParts?: PartInstanceDefinition[];
        /**
         * List of templates defined by the template
         */
        htmlTemplates?: StringMap<HtmlTemplateDefinition>;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: string[];
    }
    interface CommandsDefinition {
        /**
         * Reusable command types defined within this extension.
         */
        commandsCatalog?: CommandDefinition[];
        /**
         * A list of groups of commands.
         */
        commandGroups?: CommandGroupDefinition[];
    }
    /**
     * Definition for an item that can host commands.
     */
    interface CommandContainerDefinition {
        /**
         * Command group associated with this blade.
         */
        commandGroup?: string;
        /**
         * Reference to command group that is associated with this blade.
         * Also included binding overrides for command view model inputs.
         */
        commandGroupReference?: CommandGroupReference;
    }
    const enum BladeAttributes {
        /**
         * Blade has no attributes and will take all defaults
         */
        None = 0,
        /**
         * The blade explicitly does not support rebind
         */
        SuppressRebind = 1,
        /**
         * The blade explicitly supports provisioning
         * It accepts as an optional input "_provisioningContext"
         */
        DoesProvisioning = 2
    }
    interface ViewModelLocator {
        /**
         * The name of the view model.
         */
        name: string;
        /**
         * The module that contains the entry point.
         */
        module?: string;
        /**
         * The export in the module that contains the entry point.
         */
        export?: string;
    }
    /**
     * Definition for a blade.
     */
    interface BladeDefinition extends AssetInstanceDefinition, CommandContainerDefinition {
        /**
         * Name of the blade.
         */
        name: string;
        /**
         * Lenses contained on the blade.
         */
        lenses: LensDefinition[];
        /**
         * The view model factory of the blade.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * Action bar contained on the blade.
         */
        actionBar?: ActionBarDefinition;
        /**
         * Names of inputs that will be supplied by master parts when this blade is invoked.
         */
        inputs?: string[];
        /**
         * Names of  optional inputs that will be supplied by master parts when this blade is invoked.
         */
        optionalInputs?: string[];
        /**
         * Name of inputs that will be used to identify the template of this blade.
         */
        templateKeyInputs?: string[];
        /**
         * Names of outputs that the blade can supply to the master part that invoked it.
         */
        outputs?: string[];
        /**
         * View Model providing a display Title & Icon URI.
         */
        viewModelName?: string;
        /**
         * Internal. Not for use by extensions.
         */
        _internal_viewModelExtensionName?: string;
        /**
         *  Inputs from blade to above View Model providing a display Title & Icon URI.
         */
        viewModelInputs?: InputBinding[];
        /**
         * Bindings between the inner parts and the blade.
         */
        bindings?: InputBinding[];
        /**
         * Width of this blade when displayed.
         */
        width?: MsPortalFx.Blades.BladeWidth;
        /**
         * Width of this blade when used as contextPane.
         */
        contextPaneWidth?: MsPortalFx.Blades.BladeWidth;
        /**
         * Flag to indicate if this blade should be rendered in a fully responsive container.
         */
        reflowReady?: boolean;
        /**
         * Initial display state of this blade on first composition.
         * DisplayState.Minimized is ignored.
         */
        initialDisplayState?: MsPortalFx.Blades.DisplayState;
        /**
         * A value indicating whether or not the blade is locked.
         */
        locked?: boolean;
        /**
         * A value indicating whether or not the blade can be pinned to the startboard.
         */
        pinnable?: boolean;
        /**
         * The name of the part defined to represent the pinned blade.
         */
        pinnedPart?: string;
        /**
         * The extension of the part defined to represent the pinned blade.
         */
        pinnedPartExtension?: string;
        /**
         * The type of edit scope to created for the when the blade is opened. The id of the created
         * edit scope will be passed to the blade as an input parameter named 'editScopeId'.
         */
        editScopeType?: string;
        /**
         * The style of the blade.
         */
        style?: Blades.BladeStyle;
        /**
         * If true, disposes the edit scope when blade would be implicitly closed by shell due to a selection change; else prompts for confirmation.
         */
        discardEditsOnSelectionChange?: boolean;
        /**
         * The permissions for the blade.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * The toolbar for the blade.
         */
        toolbar?: ToolbarDefinition;
        /**
         * If this is a menu blade, describes its configuration options. If this is not a menu blade, this property is not set.
         */
        menuBlade?: MenuBladeConfig;
        /**
         * If this is a template blade, describes its configuration options. If this is not a template blade, this property is not set.
         */
        templateBlade?: TemplateBladeConfig;
        /**
         * If this is a frame blade, describes its configuration options. If this is not a frame blade, this property is not set.
         */
        frameBlade?: FrameBladeConfig;
        /**
         * Delays composing blade content till inputs are set.
         */
        waitForInputsSet?: boolean;
        /**
         * Gets or sets the activation style.
         */
        activationStyle?: ActivationStyle;
        /**
         * blade attributes, a collection of bitwise flags
         * Eventually the other boolean properties should be migrated to this member
         */
        attributes?: BladeAttributes;
        /**
         * Indicates whether this Blade has an 'onPin' method.
         */
        hasOnPinMethod?: boolean;
        /**
         * Configuration options for an AzBlade.
         */
        azBlade?: AzBladeConfig;
        /**
         * List of external domains that are whitelisted for usage in links without redirecting to a confirmation page.
         */
        trustedLinkedDomains?: string[];
        /**
         * Blade view model bundle loading measurements.
         */
        viewModelBundleLoading?: {
            /**
             * The time at which bundle-loading completes.
             */
            end: number;
            /**
             * The time spent on bundle-loading.
             */
            duration: number;
        };
    }
    /**
     * Configuration options for an AzBlade.
     */
    interface AzBladeConfig {
    }
    /**
     * Describes configuration options for a menu blade.
     */
    interface MenuBladeConfig {
        /**
         * Indicates whether this is a no-PDL MenuBlade.
         */
        isV2?: boolean;
    }
    /**
     * Describes configuration options for a template blade.
     */
    interface TemplateBladeConfig extends ItemWithTemplate {
        /**
         * Specifies whether the blade is a parameter provider.
         */
        parameterProvider?: boolean;
        /**
         * Defines the detail blade(s) that will be created based on this part.
         */
        details?: DetailsDefinition[];
        /**
         * The size of the part.  Only FullWidthFitHeight and FitToContainer are valid.
         */
        partSize?: MsPortalFx.Parts.PartSize;
        /**
         * Part settings to be applied to the virtual part
         */
        partState?: PartStateDefinition;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: StyleSheetDefinition[];
        /**
         * Indicates whether this is a no-PDL TemplateBlade.
         */
        isV2?: boolean;
    }
    /**
     * Describes configuration options for a frame blade.
     */
    interface FrameBladeConfig {
        /**
         * Part settings to be applied to the virtual part
         */
        partState?: PartStateDefinition;
    }
    /**
     * Defines the attributes for a toolbar.
     */
    interface ToolbarDefinition {
        /**
         * The source for the toolbar view model.
         */
        source: InputBinding;
    }
    /**
     * Definition of a action bar instance.
     */
    interface ActionBarDefinition {
        /**
         * Name of this action bar instance.
         */
        name?: string;
        /**
         * The view model locator of the action bar instance.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The kind of action bar.
         */
        actionBarKind?: MsPortalFx.Extension.ActionBarKind;
        /**
         * If given, specifies the view model associated with the action bar.
         * This is used when referencing the view model as a property on some other view model.
         */
        source?: InputBinding;
        /**
         * If given, specifies the view model associated with the action bar.
         * This is used when referencing the view model as a standalone item (not a property on some other view model).
         */
        viewModel?: string;
        /**
         * Input bindings for the view model of the action bar.
         */
        bindings?: InputBinding[];
    }
    /**
     * Definition for a lens.
     */
    interface LensDefinition {
        /**
         * Name of the lens.
         */
        name?: string;
        /**
         * Optional title to be displayed in the lens.
         */
        title?: string;
        /**
         * Part instances contained on the lens.
         */
        partInstances?: PartInstanceDefinition[];
        /**
         * Checks if it is a summary lens.
         */
        isSummary?: boolean;
    }
    /**
     * The mode of the redirect part.
     */
    const enum RedirectMode {
        /**
         * It is not a redirect part.
         */
        None = 0,
        /**
         * The redirect part preserves the pinning.
         */
        Preserve = 1,
        /**
         * The part is completed deprecated.
         */
        Deprecate = 2
    }
    /**
     * Definition of a part instance.
     */
    interface PartInstanceDefinition {
        /**
         * Name of this part instance.
         */
        name?: string;
        /**
         * Reference to part type to instantiate. Either reference or inline must be declared.
         */
        reference?: PartReferenceDefinition;
        /**
         * Part definition to instantiate. Either reference or inline must be declared.
         */
        inline?: PartDefinition;
        /**
         * Specifies whether or not the part acts as a parameter provider. This information is provided here
         * so that we know whether references to external parts are parameter providers.
         */
        parameterProvider?: boolean;
        /**
         * Indicates if the part is retired.
         */
        redirectMode?: RedirectMode;
        /**
         * Some configuration options that are part type sepecific
         * This is for parts which have better perf when they can be initialized early.
         */
        options?: StringMap<any>;
    }
    /**
     * Definition of a part reference instance.
     */
    interface PartReferenceDefinition {
        /**
         * Name of the part type.
         */
        partTypeName: string;
        /**
         * Extension where part type is defined. Defaults to same extension where reference is used.
         */
        extension?: string;
        /**
         * Version of the extension.
         */
        version?: string;
        /**
         * Input bindings for the view model of the part.
         */
        bindings?: InputBinding[];
        /**
         * Initial size of this part newly instantiated. Defaults to 'defaultInitialSize' defined on part type.
         */
        initialSize?: Parts.PartSize;
        /**
         * The part initial width in grid steps if the initialSize is PartSize.Custom.
         */
        initialWidth?: number;
        /**
         * The part initial height in grid steps if the initialSize is PartSize.Custom.
         */
        initialHeight?: number;
        /**
         * Optional. Initial size of this part when rendered in a larger context.
         * This size is applied when the larger context is first rendered. If no large size is provided, then conserve the initial size.
         */
        largeInitialSize?: Parts.PartSize;
        /**
         * Type of asset that this instance is bound to.
         * This is used as an override for the assetType that is used in the referenced part type.
         * The assetPropertyId cannot be overridden because that is a part implementation
         * detail.
         */
        assetType?: string;
        /**
         * The view model locator to inject as a property of the referenced part view model in order to extend it.
         */
        extenderViewModelLocator?: MsPortalFx.Extension.ViewModelLocator;
        /**
         * Name of view model to inject as a property of the referenced part view model in order to extend it.
         */
        extenderViewModel?: string;
    }
    /**
     * The definition of the part gallery info
     */
    interface PartGalleryInfoDefinition {
        /**
         * The text of the part on the part gallery.
         */
        title: string;
        /**
         * The category that the part belongs to.
         */
        category?: string;
        /**
         * Part description
         */
        description?: string;
        /**
         * The thumbnail for the part on the part gallery.
         */
        thumbnail?: Base.Image;
        /**
         * Gets the selectable path to trigger auto configuration.
         */
        autoConfigSelectablePath?: string;
        /**
         * The feature values used to conditionally show the part in the gallery.
         */
        feature?: string;
    }
    /**
     * The definition of the part input.
     */
    interface InputDefinition {
        /**
         * The name of the input.
         */
        name: string;
        /**
         * The type of the input.
         */
        type?: string;
        /**
         * Indicates if the input is optional.
         */
        optional?: boolean;
        /**
         * Indicates if the input is the asset id.
         */
        isAssetId?: boolean;
    }
    /**
     * Definition of a part type.
     */
    interface PartTypeDefinition extends PartDefinition {
        /**
         * Name of the part type.
         */
        name?: string;
        /**
         * The view model locator of the Part.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The info of the part shown in the part gallery.
         */
        partGalleryInfo?: PartGalleryInfoDefinition;
        /**
         * The definitions of the inputs to the part.
         */
        inputDefinitions?: InputDefinition[];
        /**
         * Reference to part type to instantiate.
         */
        reference?: PartReferenceDefinition;
        /**
         * Specifies whether or not the part acts as a parameter provider.
         */
        parameterProvider?: boolean;
        /**
         * If the Part uses the @Filterable decorator, these are the filters supported statically by the Part.
         */
        filters?: DashboardFilter[];
        /**
         * Indicates whether this Part supports filtering.
         */
        supportsFiltering?: boolean;
        /**
         * Informs the shell to always invoke onClick and ignore the associated deepLink
         * for parts pinned to a dashboard
         */
        ignorePinnedDeepLink?: boolean;
    }
    /**
     * If a Part uses the @Filterable decorator, this is a representation of a filter supported statically by the Part.
     */
    interface DashboardFilter {
        /**
         * The kind of the filter.
         */
        filterKind: MsPortalFx.Extension.FilterKind;
        /**
         * If the filter is extension-defined, this is an id that identifies the filter.
         */
        filterId?: string;
    }
    interface ItemWithTemplate {
        /**
         * Key to the HTML template used by the item.
         */
        htmlTemplate?: string;
        /**
         * The HTML template used by the item. This is preferred. If not specified,
         * the htmlTemplate key is used to get it from the global list of templates.
         */
        htmlTemplateInline?: HtmlTemplateDefinition;
    }
    /**
     * Definition for a part.
     */
    interface PartDefinition extends AssetInstanceDefinition, CommandContainerDefinition, ItemWithTemplate {
        /**
         * Name of the viewmodel to use.
         */
        viewModel?: string;
        /**
         * The view model locator of the view model.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * Default template for this part.
         */
        partKind?: Parts.PartKind;
        /**
         * View model properties that part can declare input bindings for.
         */
        inputs?: string[];
        /**
         * Input bindings for the view model of the part.
         */
        bindings?: InputBinding[];
        /**
         * Defines the detail blade(s) that will be created based on this part.
         */
        details?: DetailsDefinition[];
        /**
         * Default initial size of this part when instantiated. Defaults to PartSize.Normal.
         */
        initialSize?: Parts.PartSize;
        /**
         * The part initial width in grid steps if the initialSize is PartSize.Custom.
         */
        initialWidth?: number;
        /**
         * The part initial height in grid steps if the initialSize is PartSize.Custom.
         */
        initialHeight?: number;
        /**
         * Optional. Initial size of this part when rendered in a larger context.
         * This size is applied when the larger context is first rendered. If no large size is provided, then conserve the initial size.
         */
        largeInitialSize?: Parts.PartSize;
        /**
         * Sizes supported by a custom part.  Ignored for parts that are not PartKind.Custom.
         */
        supportedSizes?: Parts.PartSize[];
        /**
         * The resize mode for this this part. Ignored for parts that are not PartKind.Custom.
         */
        resizeMode?: Parts.ResizeMode;
        /**
         * Properties in viewmodel to save in viewstate.
         */
        viewStateProperties?: string[];
        /**
         * The type of edit scope to created for the when the tile is put on the start board. The id of the created
         * edit scope will be passed to the part as a property named 'editScopeId'.
         */
        editScopeType?: string;
        /**
         * Strategies to save view model properties in user settings.
         */
        partState?: PartStateDefinition;
        /**
         * Optional. Whether the part can use old versions of inputs. Default is false.
         *
         * Old versions of inputs might be present if the part was pinned/cloned and the input properties changed in PDL.
         */
        canUseOldInputVersions?: boolean;
        /**
         * The permissions for the part.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * Specifies whether this part and its parent blade share the same view model.
         */
        shareVmWithParentBlade?: boolean;
        /**
         * Optional part options.
         */
        options?: StringMap<any>;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: StyleSheetDefinition[];
        /**
         * Indicates whether the FX is to apply default padding to the content area of the Part.
         */
        noFxContentPadding?: boolean;
        /**
         * List of external domains that are whitelisted for usage in links without redirecting to a confirmation page.
         */
        trustedLinkedDomains?: string[];
    }
    /**
     * Definition for strategies to save view model properties in user settings.
     */
    interface PartStateDefinition {
        /**
         * Property names whose values are saved for each inputs identity.
         */
        inputIdentityProperties?: string[];
        /**
         * Properties whose values are saved to a user defined key.
         */
        sharedProperties?: PartSharedStateDefinition[];
    }
    /**
     * Definition for part properties that get saved to settings with a user defined key.
     */
    interface PartSharedStateDefinition {
        /**
         * Property name to save.
         */
        property: string;
        /**
         * User setting key to use when saving value.
         */
        key: string;
    }
    /**
     * The definition of the default blade action.
     */
    interface DefaultBladeAction {
        /**
         * The name of the part that owns default blade action.
         */
        partName: string;
        /**
         * The name of the default action
         */
        actionName: string;
    }
    /**
     * Definition for how detail blades should be open.
     */
    interface DetailsDefinition {
        /**
         * The name of the details definition.
         */
        name?: string;
        /**
         * Name of details blade to open. Undefined if selection implements DynamicSelection.
         */
        blade?: string;
        /**
         * Name of extension of the details blade to open. Undefined if selection implements DynamicSelection.
         */
        bladeExtension?: string;
        /**
         * Whether multiple blades should be open.
         */
        isMultiple?: boolean;
        /**
         * Input bindings that trigger the opening of detail blade.
         */
        invocationInputArguments?: InputBinding[];
        /**
         * location of selectable or selectable set in the view model that will trigger
         * opening the blade.   If this is omitted then container.selectable is used.
         */
        selectablePath?: string;
        /**
         * Bindings to populate the selection value that is passed to the blade.
         * This is only applicable to the invocationInputArguments generated by the shell.
         * This feature is used when explicit invocation input arguments are not provided.
         */
        selectableBindings?: InputBinding[];
        /**
         * Additional input bindings for the view model of the details blade.
         */
        additionalInputArguments?: InputBinding[];
        /**
         * Output bindings between the detail blade and the part's view model.
         */
        outputArguments?: InputBinding[];
        /**
         * The parameter collector model associated with the blade action, if any.
         */
        parameterCollector?: string;
        /**
         * Flag indicating if this blade action starts a sub journey.
         */
        asSubJourney?: boolean;
        /**
         * Gets or sets if the blade will be opened in the context pane.
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    interface ActivationStyle {
        /**
         * The width of the curent blade when it activates a detail blade.
         */
        width?: MsPortalFx.Blades.BladeWidth;
    }
    /**
     * Definition for an input of a part/blade/command.
     */
    interface InputBinding {
        /**
         * Name of part's view model property.
         */
        property?: string;
        /**
         * Specifies from where to acquire individual values for the array-typed input property on the part's view
         * model.
         */
        valuesFrom: Reference[];
        /**
         * In binding scenarios that distinguish between required and optional parameters,
         * such as part binding, indicates whether this binding parameter is optional. In
         * other scenarios it should not be true.
         */
        optional?: boolean;
        /**
         * Whether this input is part of a set that uniquely identifies the values.
         */
        isIdentityInput?: boolean;
    }
    /**
     * Describes a reference to property on a part or a blade's model.
     */
    interface Reference {
        /**
         * Specifies the type of the reference.
         */
        referenceType: ReferenceType;
        /**
         * Refers to the property on the source's model.
         */
        property: string;
        /**
         * When "referenceType" is "Part", names the part that is being referenced.  If not supplied, the part is
         * determined implicitly from part context in which the reference is used.
         */
        part?: string;
        /**
         * When "referenceType" is "Command", names the blade command that is being referenced.
         */
        bladeCommand?: string;
        /**
         * When "referenceType" is "Command", names the part command that is being referenced.
         */
        partCommand?: string;
        /**
         * When "referenceType" is "Constant", the value to use as the source value of binding.
         */
        constantValue?: any;
    }
    interface CommandExternalReference {
        /**
         * Command type defined in the commands catalog.
         */
        commandType: string;
        /**
         * Name of the extension that defines the commands catalog.
         *   Undefined to assume the same extension.
         */
        extension?: string;
    }
    interface CommandDefinition extends AssetInstanceDefinition {
        /**
         * Identifier for the command.
         */
        name?: string;
        /**
         * The view model locator of the blade.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The command text.
         */
        text?: string;
        /**
         * View model for the command.
         */
        viewModel?: string;
        /**
         * Input bindings for the view model of the command.
         */
        bindings?: InputBinding[];
        /**
         * Defines the detail blade that can be opened by this command
         */
        details?: DetailsDefinition;
        /**
         * The permissions for the command.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * The kind of the command.
         */
        commandKind?: CommandKind;
        /**
         * Reference to a command defined in the commands catalog of an extension.
         */
        reference?: CommandExternalReference;
    }
    /**
     * The server event that maps to this notification.
     */
    interface ServerEvent {
        /**
         * The event source.
         */
        source: string;
        /**
         * The event operation.
         */
        operation: string;
    }
    /**
     * The notification message.
     */
    interface NotificationMessage {
        /**
         * The message type.
         */
        type: NotificationMessageType;
        /**
         * The notification status.
         */
        status: string;
        /**
         * The notification substatus.
         */
        subStatus?: string;
        /**
         * The title to show for the notification.
         */
        title: string;
        /**
         * The descriptive message to show for the notification.
         */
        message: string;
        /**
         * The optional asset type associated with the notification message.
         */
        assetType?: string;
    }
    /**
     * Definition for the instance of an asset.
     */
    interface AssetInstanceDefinition {
        /**
         * Type of asset that this instance is bound to.
         */
        assetType?: string;
        /**
         * Name of the input property that maps to the identifier of this asset.
         * Required if 'assetType' is defined.
         */
        assetIdInputProperty?: string;
    }
    interface CommandGroupDefinition {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Commands in the command group.
         */
        commands: CommandDefinition[];
    }
    interface CommandReference {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Input bindings for the view model of the command.
         */
        bindings?: InputBinding[];
    }
    interface CommandGroupReference {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Commands in the command group.
         * These references exist to override command bindings.
         */
        commands: CommandReference[];
    }
    /**
     * Definition of a gallery service.
     */
    interface MarketplaceDefinition {
        /**
         * Service view model factory.
         */
        serviceViewModelLocator: ViewModelLocator;
        /**
         * Service view model name.
         */
        serviceViewModel: string;
    }
    /**
     * The permission base for the permission and permission set classes.
     */
    interface PermissionBase {
        /**
         * The type of the permission.
         */
        permissionType: PermissionType;
    }
    /**
     * Defines the permission type used by the permission base to describe the type of permission.
     */
    const enum PermissionType {
        /**
         * The permission is a permission object.
         */
        Permission = 0,
        /**
         * The permission is a permission set (collection of permissions).
         */
        PermissionSet = 1
    }
    /**
     * Permission used on part, command and blade.
     */
    interface Permission extends PermissionBase {
        /**
         * The optional extension name for the asset type for the action.
         */
        extensionName?: string;
        /**
         * The the asset type for the action.
         */
        assetType: string;
        /**
         * The reference for the asset id for the action.
         */
        assetId: AssetIdSource;
        /**
         * The action required for the permission.
         */
        action: string;
    }
    /**
     * Permission set used on part, command and blade.
     */
    interface PermissionSet extends PermissionBase {
        /**
         * The set requirement for the set.
         */
        requirement: SetRequirement;
        /**
         * The permissions for the set.
         */
        permissions: Array<Permission | PermissionSet>;
    }
    /**
     * Describes a asset ID source reference for a permission.
     */
    interface AssetIdSource {
        /**
         * Specifies the type of the reference.
         */
        sourceType: AssetIdSourceType;
        /**
         * The name of the property for the asset ID.
         */
        property: string;
        /**
         * When the source type is "FromProvider" or "FromSourceProvider", this is the key to pass to the property
         * provider along with the inputs.
         */
        providerKey?: string;
    }
    /**
     * Points to a knockout HTML fragment which functions as a extension html template.
     */
    interface HtmlTemplateDefinition {
        /**
         * The file path/name which this template was defined in
         */
        file: string;
        /**
         * The template content
         */
        content: string;
    }
    /**
     * Points to a set of CSS styles.
     */
    interface StyleSheetDefinition {
        /**
         * The file path/name which this style sheet was defined in.
         */
        file: string;
        /**
         * The style sheet content.
         */
        content: string;
    }
}

// FILE: MsPortalFx\Extension\Extension.Manifest.d.ts
declare module FxImpl {
    /**
     * The environment information for an asset type or kind (base).
     */
    interface ConfigAssetTypeOrKindOverride {
        /**
         * The options for the asset type of kind (overrides PDL options).
         */
        options?: string | number;
    }
    /**
     * The environment information for an asset type.
     */
    interface ConfigAssetTypeOverride extends ConfigAssetTypeOrKindOverride {
        /**
         * The environment information for any kinds attached to the asset type.
         */
        kinds?: ReadonlyStringMap<ConfigAssetTypeOrKindOverride>;
    }
    /**
     * The environment configuration for an asset manifest.
     */
    interface EnvironmentConfigurationForAssetManifest {
        /**
         * The list of asset types that are to be hidden for the environment.
         *
         * @deprecated EnvironmentConfigurationForAssetManifest.hideAssetTypes - This has been superseded by the assetTypeOptions but we need to handle older builds of extension config.
         */
        hideAssetTypes?: ReadonlyArray<string>;
        /**
         * The list of asset types where instances are to be hidden for the environment.
         */
        assetTypeOptions?: ReadonlyStringMap<ConfigAssetTypeOverride>;
        /**
         * The map of the api versions to use for the resource types for the environment.
         */
        resourceTypeApiVersions?: ReadonlyStringMap<string>;
        /**
         * The map of asset type to ARG browse options for the environment.
         */
        argBrowseOptions?: ReadonlyStringMap<string>;
        /**
         * The map of the asset type to the list of commands to hide.
         */
        hideAssetTypeCommands?: ReadonlyStringMap<ReadonlyArray<string>>;
    }
    const enum ExtensionManifestFlags {
        /**
         * Whether the extension supports FastExtensionLoad
         */
        FastExtensionLoad = 1,
        /**
         *  Whether the extension supports Prewarming
         */
        Prewarming = 2,
        /**
         *  Whether the extension supports TestPrewarming
         */
        TestPrewarming = 4,
        /**
         *  Whether the extension uses no-code blade definition types
         */
        BladeDefinitionCodelessGen = 8,
        /**
         *  Whether the extension uses no-code part definition types
         */
        PartDefinitionCodelessGen = 16,
        /**
         *   Whether the extension uses view definition for the asset
         */
        UiDefExtension = 32
    }
    /**
     * Defines the manifests providing asset types.
     */
    interface ManifestForAssetTypes {
        /**
         * List of asset types supported by this extension.
         */
        assetTypes?: MsPortalFx.Extension.AssetTypeManifest[];
        /**
         * Metadata describing AzBlades and AzParts.
         */
        azMetadata?: {
            /**
             * Metadata covering AzBlades.
             */
            blades?: ReadonlyStringMap<AzBladeMetadata>;
        };
        /**
         * Determines that this extension opted into Experimentation using the ExP platform
         */
        enableExperimentation?: boolean;
        /**
         * The environment configuration for the manifest.
         */
        environmentConfiguration?: StringMap<EnvironmentConfigurationForAssetManifest>;
        /**
         * Feedback email address
         */
        feedbackEmail?: string;
        /**
         * List of flags associated with an extension
         */
        flags?: ExtensionManifestFlags;
        /**
         * If this flag is true visual artifacts are displayed in the assets, parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * List of notifications supported by this extension
         */
        notifications?: MsPortalFx.Extension.NotificationDefinition[];
        /**
         * List of notifications in the new schema supported by this extension
         */
        notifications2?: MsPortalFx.Extension.Notification[];
        /**
         * Page version of the extension.
         */
        pageVersion?: string;
        /**
         * The list of redirects.
         */
        redirects?: MsPortalFx.Extension.RedirectDefinition[];
        /**
         * The map of weave blades.
         */
        weaveBladesMap?: ReadonlyStringMap<number>;
    }
    /**
     * Defines the manifests providing asset type browse definitions.
     */
    interface ManifestForAssetTypesBrowse {
        assetTypesBrowse?: MsPortalFx.Extension.AssetTypeBrowseManifest[];
    }
    /**
     * Defines the manifests providing asset type menu definitions.
     */
    interface ManifestForAssetTypesMenu {
        assetTypesMenu?: MsPortalFx.Extension.AssetTypeMenuManifest[];
    }
    /**
     * Defines the manifests providing gallery parts.
     */
    interface ManifestForGalleryParts {
        /**
         * The list of gallery parts.
         */
        galleryParts?: MsPortalFx.Extension.GalleryPartManifest[];
    }
    interface ManifestForCreateUiDefinition {
        /**
         * The map of assets to create ui definition uris.
         */
        createUiDefinition?: ReadonlyStringMap<string>;
    }
    interface ManifestForViewDefinition {
        /**
         * The map of assets to view definition uris.
         */
        viewDefinition?: ReadonlyStringMap<string>;
    }
    interface ManifestForDeclarativeDefinitions {
        /**
         * The map of assets to declarative definition uris.
         */
        declarativeDefinitions?: ReadonlyStringMap<string>;
    }
    /**
     * Metadata for an AzBlade.
     */
    interface AzBladeMetadata {
        /**
         * Indicates whether the Blade should use 'BladeSize.XLarge' as its minimum width.
         */
        useXLargeMinWidth?: boolean;
    }
}
declare module MsPortalFx.Extension {
    const enum ArgBrowseOptions {
        DoNotUse = 0,
        /**
         * Allows users to opt in/out of the new experience but will default to the old experience.
         * This will show a 'Try preview' button on the old browse blade
         * and an 'Opt out of preview' button on the ARG browse blade
         */
        AllowOptIn = 1,
        /**
         * Allows users to opt in/out of the new experience but will default to the new experience.
         * This will show a 'Try preview' button on the old browse blade
         * and an 'Opt out of preview' button on the ARG browse blade
         */
        ForceOptIn = 2,
        /**
         * This will force users to the new experience.
         * There wil be no 'Opt out of preview' button on the ARG browse blade
         */
        Force = 3,
        /**
         * This will force users to the old experience. This is the default experience if not flags are set.
         * There wil be no 'Try preview' button on the ARG browse blade
         */
        Disable = 4
    }
    /**
     * String map that maps the value specified in the feature flag to the enum.
     */
    const ArgBrowseFeatureValueToEnumMap: StringMap<ArgBrowseOptions>;
    const enum NotificationMessageType {
        /**
         * Indicates an error message.
         */
        Error = 0,
        /**
         * Indicates a warning message.
         */
        Warning = 1,
        /**
         * Indicates a success message.
         */
        Success = 2,
        /**
         * Indicates a progress message.
         */
        Progress = 3,
        /**
         * Indicates an info message.
         */
        Info = 4
    }
    /**
     * Manifest for an extension.
     */
    interface Manifest extends FxImpl.ManifestForAssetTypes, FxImpl.ManifestForAssetTypesBrowse, FxImpl.ManifestForAssetTypesMenu, FxImpl.ManifestForCreateUiDefinition, FxImpl.ManifestForGalleryParts, FxImpl.ManifestForViewDefinition, FxImpl.ManifestForDeclarativeDefinitions {
    }
    interface RedirectDefinition {
        /**
         * The type of redirect.
         */
        type: RedirectType;
        /**
         * The extension of the blade/part to redirect to.
         */
        toExtension?: string;
        /**
         * The extension of the blade/part to redirect from.
         */
        fromExtension?: string;
    }
    interface BladeRedirectDefinition extends RedirectDefinition {
        /**
         * Can can only be MenuBlade or ResourceMenuBlade for blade redirects
         */
        type: RedirectType.ResourceMenuBlade | RedirectType.Blade;
        /**
         * The name of the blade to redirect.
         */
        fromBlade: string;
        /**
         * The name of the blade to redirect to.
         */
        toBlade?: string;
    }
    interface PartRedirectDefinition extends RedirectDefinition {
        /**
         * Can can only be PartType or PartInstance for part redirects
         */
        type: RedirectType.PartType | RedirectType.PartInstance;
        /**
         * The part name which is being redirected from
         */
        fromPart: string;
        /**
         * Blade name if the part is a instance in a blade
         */
        fromBlade?: string;
        /**
         * Lens name if the part is a instance in a blade
         */
        fromLens?: string;
        /**
         * The part name which is being redirected to
         */
        toPart: string;
        /**
         * Optional bindings used to replace the previous part bindings
         */
        bindings?: MsPortalFx.Extension.InputBinding[];
    }
    interface AssetRedirectDefinition extends RedirectDefinition {
        /**
         * Redirect type can only be Asset
         */
        type: RedirectType.Asset;
        /**
         * Name of the asset we are redirecting from
         */
        fromAsset: string;
        /**
         * Optional, the name of the kind we are redirecting from
         */
        fromKind?: string;
        /**
         * Name of the asset we are redirecting to
         */
        toAsset: string;
        /**
         * Optional, the name of the we are redirecting too
         */
        toKind?: string;
    }
    /**
     * Asset type manifest for an extension.
     */
    interface AssetTypeManifest {
        /**
         * The name of the asset type.
         */
        name?: string;
        /**
         * The entry point of the view model.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The name of the extension that contains the view model.
         */
        viewModelExtensionName?: string;
        /**
         * The singular display name of the asset type.
         */
        singularDisplayName?: string;
        /**
         * The plural display name of the asset type.
         */
        pluralDisplayName?: string;
        /**
         * The lowercase singular display name of the asset type.
         */
        lowerSingularDisplayName?: string;
        /**
         * The lowercase plural display name of the asset type.
         */
        lowerPluralDisplayName?: string;
        /**
         * The service display name of the asset type.
         */
        serviceDisplayName?: string;
        /**
         * The contracts flag for which contracts the asset view model supports.
         */
        contracts?: number;
        /**
         * The name of the asset type view model associated with this asset type.
         */
        viewModel?: string;
        /**
         * The icon of the asset type.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The part associated with this asset.
         */
        partName?: string;
        /**
         * The extension where the external part is located
         */
        partExtensionName?: string;
        /**
         * If this flag is true visual artifacts are displayed in the asset's parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * The blade associated with the asset.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the asset.
         */
        bladeExtensionName?: string;
        /**
         * Optional browse type which indicates the type of browse for the asset type.
         */
        options?: MsPortalFx.Extension.AssetTypeOptions;
        /**
         * Optional browse type which indicates the type of browse for the asset type.
         */
        browseType?: BrowseType;
        /**
         * Optional 'private' browse flag which indicates to exclude this asset from the browse UX.
         *
         * @deprecated 04/30/2020 - This has been superseded by options. Please use the 'options' property and the
         * AssetTypeOptions flags.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        privateBrowse?: boolean;
        /**
         * Optional link URI for browse associated with the asset using a link to an external source.
         */
        browseLinkUri?: string;
        /**
         * Optional browse flag which indicates that if RDFE access is not available to not show this asset from the browse UX.
         */
        browseRequiresRdfe?: boolean;
        /**
         * Optional browse flag which are the browse requirements.
         */
        browseRequirements?: number;
        /**
         * Optional resource type definition associated with the asset.
         */
        resourceType?: ResourceTypeDefinition;
        /**
         * The service name for the property provider service associated with the asset.
         */
        propertyProviderServiceViewModelLocator?: MsPortalFx.Extension.ViewModelLocator;
        /**
         * The service name for the property provider service associated with the asset.
         */
        propertyProviderServiceViewModel?: string;
        /**
         * The type of the asset id.
         */
        assetIdType?: string;
        /**
         * The create blade name.
         */
        noPdlCreateBlade?: string;
        /**
         * The name of the extension with the create blade.
         */
        noPdlCreateExtension?: string;
        /**
         * The market place item.
         */
        marketplaceItemId?: string;
        /**
         * The market place category.
         */
        marketplaceMenuItemId?: string;
        /**
         * The static overview menu item for the asset type.
         */
        staticOverview?: StaticOverviewDefinition;
        /**
         * The list of keywords.
         * NOTE: comma separated list.
         */
        keywords?: string;
        /**
         * The service menu blade reference.
         */
        serviceMenuBlade?: string;
        /**
         * The service menu blade reference extension.
         */
        serviceMenuBladeExtension?: string;
        /**
         * The service menu ID.
         */
        serviceMenuItemId?: string;
        /**
         * A brief description of the asset type. Max length is 350 characters.
         */
        description?: string;
        /**
         * A link which points to learn more content of the asset type.
         */
        links?: LinkDefinition[];
        /**
         * Optional ARG browse option on which experience should be shown for the asset type.
         */
        argBrowseOption?: ArgBrowseOptions;
        /**
         * Optional list of commands to be hidden for the asset type.
         */
        hiddenCommands?: ReadonlyArray<string>;
    }
    /**
     * The resource type definition defines the resource type information for an asset type.
     */
    interface ResourceTypeDefinition {
        /**
         * The name of the resource type.
         */
        resourceTypeName: string;
        /**
         * The top level tenant alias used to communicate to ARM.  This is valid only for tenant-routing resources.
         *
         * The resource type name is the "full" resource type.  This is the full hierarchical type that is returned in
         * the ResourceType property of the results and provides a match between a resource type (and resource ID) to
         * the asset type. For a nested resource this would be:
         *      {resourceProviderNamespace}/{parentType}/{nestedType}/.../{nestedType}.
         * E.g. Microsoft.Type/Parent/Child
         *
         * The top level tenant alias is the "flat" resource type.  This is a non-hierarchical type used to enumerate
         * instances using ARM's Providers API. Your RP manifest must enable nested resources to be enumerated at the
         * top level for it to be used with the Portal FX Browse support. For more info contact your ARM partner.
         *
         * For root resource types, this would be the same as the resource type name.  For nested resource types, this
         * would be:
         *      {resourceProviderNamespace}/{nestedType}.
         * E.g. Microsoft.Type/Child
         */
        topLevelTenantAlias?: string;
        /**
         * The top level resource type alias used to communicate to ARM.  This is valid only for end-point-routing
         * resources.  See the notes for the topLevelTenantAlias for more information (same value).
         */
        topLevelResourceTypeAlias?: string;
        /**
         * The ARM API version to use for this resource type.
         * If this is not specified, the latest API version will be used from the ARM manifest file.
         */
        apiVersion?: string;
        /**
         * The routing type for the resource type.
         * If this is not specified, the 'Default' routing type will be used.
         */
        routingType?: ResourceRoutingType;
        /**
         * The optional array of kinds for this resource type.
         */
        kinds?: ResourceKindDefinition[];
        /**
         * The optional array of proxy routing filters for this resource type.
         */
        proxyRoutingFilters?: ProxyRoutingFilter[];
    }
    /**
     * The resource kind definition defines the resource kind information for a resource type.
     */
    interface ResourceKindDefinition {
        /**
         * The name of the resource type kind.
         */
        name: string;
        /**
         * The is default flag of the resource type kind.
         */
        isDefault?: boolean;
        /**
         * Optional browse type which indicates the type of browse for the asset type.
         */
        options?: MsPortalFx.Extension.AssetTypeOptions;
        /**
         * The visibility of the resource type kind.
         *
         * @deprecated 04/30/2020 - This has been superseded by options. Please use the 'options' property and the
         * AssetTypeOptions flags.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        visibility?: Obsolete;
        /**
         * The singular display name of the resource type kind.
         */
        singularDisplayName?: string;
        /**
         * The plural display name of the resource type kind.
         */
        pluralDisplayName?: string;
        /**
         * The lowercase singular display name of the resource type kind.
         */
        lowerSingularDisplayName?: string;
        /**
         * The lowercase plural display name of the resource type kind.
         */
        lowerPluralDisplayName?: string;
        /**
         * The service display name of the resource type kind.
         */
        serviceDisplayName?: string;
        /**
         * The blade associated with the resource type kind.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the resource type kind.
         */
        bladeExtensionName?: string;
        /**
         * Name of part to use for pinning
         */
        partName?: string;
        /**
         * Name of the extension that contains the part
         */
        partExtensionName?: string;
        /**
         * The icon of the resource type kind.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * If this flag is true visual artifacts are displayed in the asset's parts and blades to indicate the functionality is preview.
         */
        isPreview?: boolean;
        /**
         * The is use resource menu flag of the resource type kind.
         */
        useResourceMenu?: boolean;
        /**
         * The static overview menu item of the resource type kind.
         */
        staticOverview?: StaticOverviewDefinition;
        /**
         * The name of the extension with the create blade.
         */
        noPdlCreateExtension?: string;
        /**
         * The create blade name.
         */
        noPdlCreateBlade?: string;
        /**
         * The market place item.
         */
        marketplaceItemId?: string;
        /**
         * The market place category.
         */
        marketplaceMenuItemId?: string;
        /**
         * The list of keywords.
         * NOTE: comma separated list.
         */
        keywords?: string;
        /**
         * The service menu asset type reference.
         */
        serviceMenuBlade?: string;
        /**
         * The service menu asset type reference extension.
         */
        serviceMenuBladeExtension?: string;
        /**
         * The service menu ID.
         */
        serviceMenuItemId?: string;
        /**
         * The kinds (for filtering) for the kind.
         */
        kinds?: string[];
        /**
         * The filter map for the kind.
         */
        filterMap?: StringMap<boolean>;
    }
    /**
     * The Link definition defines title and url for the asset type documentation.
     */
    interface LinkDefinition {
        /**
         * The title for link.
         */
        title: string;
        /**
         * The uri for the link.
         */
        uri: string;
    }
    /**
     * The static overview definition defines the static overview menu item for an asset type or resource type kind.
     */
    interface StaticOverviewDefinition {
        /**
         * The optional ID for the static overview menu item.
         */
        id?: string;
        /**
         * The optional display name of the static overview menu item.
         */
        displayName?: string;
        /**
         * The optional icon of the static overview menu item.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The optional keywords.
         */
        keywords?: string;
    }
    interface AssetTypeMenuManifest {
        /**
         * Name of the asset type of the menu definition.
         */
        name: string;
        /**
         * The overview menu item.
         */
        overview: MenuItem;
        /**
         * The menu groups.
         */
        groups: Array<MenuGroup>;
        /**
         * The menu options.
         */
        options: AssetMenuOptions | MsPortalFx.Assets.ResourceMenuOptions;
    }
    interface MenuItemBase {
        /**
         * The id of the item.
         */
        id: string;
        /**
         * Localized display name of the item.
         */
        displayName: string;
        /**
         * Localized keywords for the item.
         */
        keywords?: string;
    }
    interface MenuItem extends MenuItemBase {
        /**
         * The icon of the menu item.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * Localized tooltip for the item.
         */
        tooltip?: string;
        /**
         * Blade name for the item.
         */
        bladeName: string;
        /**
         * Optional blade extension name for the item.
         */
        bladeExtensionName?: string;
        /**
         * Optional blade parameters for the item.
         */
        bladeParameters?: StringMap<any>;
    }
    interface MenuGroup extends MenuItemBase {
        /**
         * The items in the menu group.
         */
        items: Array<MenuItem>;
        /**
         *  The ID for the built-in group.
         */
        referenceId?: string;
        /**
         * The elevated state of the menu group.
         */
        elevated?: boolean;
    }
    interface AssetMenuOptions {
        /**
         * Enable search for the menu.
         */
        showSearch?: boolean;
    }
    /**
     * Manifest for a notification that will be used to format notifications.
     */
    interface NotificationDefinition {
        /**
         * The notification event source for this notification.
         */
        eventSource: string;
        /**
         * The notification event type of this notification.
         */
        eventType: string;
        /**
         * The notification label for this notification.
         */
        label: string;
        /**
         * The notification message for this notification.
         * Note that this message can support format items. The notification arguments received by the server will be plugged into these items
         * Example: This is a {0} message written by {1}.
         */
        message: string;
        /**
         * The notification asset type of this notification.
         */
        assetType?: string;
    }
    /**
     * Manifest for a notification in the new schema.
     */
    interface Notification {
        /**
         * The notification name.
         */
        name: string;
        /**
         * The notification asset type of this notification.
         */
        assetType?: string;
        /**
         * The server event that this notification maps to.
         */
        serverEvent?: ServerEvent;
        /**
         * The messages for this notification.
         */
        messages: NotificationMessage[];
    }
    /**
     * Manifest for a part instance.
     */
    interface PartInstanceManifest {
        /**
         * The name of the part instance.
         */
        name: string;
        /**
         * Default initial size of this part when instantiated. Defaults to PartSize.Normal.
         */
        initialSize?: Parts.PartSize;
    }
    /**
     * Manifest for a blade.
     */
    interface BladeManifest {
        /**
         * Name of the blade.
         */
        name: string;
        /**
         * Width of this blade when displayed.
         */
        width?: MsPortalFx.Blades.BladeWidth;
        /**
         * A list of extension name hints that are likely to be required by the blade.
         */
        extensionHints?: string[];
    }
    interface GalleryPartManifest {
        /**
         * Name of the part type.
         */
        name?: string;
        /**
         * Initial size for the part.
         */
        initialSize?: Parts.PartSize;
        /**
         * Initial width for the custom size part.
         */
        initialWidth?: number;
        /**
         * Initial height for the custom size part.
         */
        initialHeight?: number;
        /**
         * The info of the part shown in the part gallery.
         */
        partGalleryInfo?: PartGalleryInfoDefinition;
        /**
         * Type of asset that this instance is bound to.
         */
        assetType?: string;
        /**
         * The definitions of the inputs to the part.
         */
        inputDefinitions?: InputDefinition[];
    }
    /**
     * Interface for resource selection in browse commands.
     */
    interface BrowseResourceSelection {
        /**
         * The max number of selected resources supported by the command operation.
         */
        readonly maxSelectedItems?: number;
        /**
         * The message shown when user tries to select more than supported items by the command operation.
         */
        readonly disabledMessage?: string;
    }
    /**
     * Interface for ARM command options.
     */
    interface ArmCommandOptionsManifest {
        /**
         * The ARM bulk command definitions.
         */
        readonly definitions?: StringMap<ArmCommandDefinition>;
        /**
         * The flag indicating whether to launch Fx bulk delete confirmation blade for bulk delete operations.
         *
         * NOTE: All ARM bulk delete commands should set this flag to true for consistent bulk delete confirmation experience.
         */
        readonly isDelete?: boolean;
    }
    /**
     * Command definition for ARM operation.
     */
    interface ArmCommandDefinition {
        /**
         * Http method POST/DELETE/PATCH etc. By default POST will be used.
         */
        readonly httpMethodType?: string;
        /**
         * ARM uri for the command operation. Currently only ARM operations are supported.
         * Uri should be a relative uri with the fixed format - {resourceid}/placeholder.
         * Eg. "{resourceid}/start?api-version=2016-03-30"
         */
        readonly uri: string;
        /**
         * ARM command operation can be long running operation. asyncOperation property specifies how to poll the status for completion of long running operation.
         */
        readonly asyncOperation?: AsyncOperationOptions;
        /**
         * The list of resource-specific ARM error codes that should be retried.
         */
        readonly retryableArmCodes?: ReadonlyArray<string>;
        /**
         * The list of resource-specific ARM error codes that shouldn't be retried.
         * This helps optimize network calls and improve bulk operation performance.
         */
        readonly nonRetryableArmCodes?: ReadonlyArray<string>;
    }
    /**
     * Various opt-in configs to describe how long running ARM operations needs to be polled and results processed for Bulk commanding.
     */
    interface AsyncOperationOptions {
        /**
         * By default when http Accepted (202) status code is received, the Location header will be looked up for polling uri to get the status of long running operation.
         * A different response header can be specified with the pollingHeaderOverride value.
         */
        readonly pollingHeaderOverride?: string;
        /**
         * A property path to look for status in the response body.
         * By default 'status' property will be looked up to see if it has "Succeeded", "Failed", "InProgress" or "Canceled".
         */
        readonly statusPath?: string;
    }
    /**
     * The interface for command execution confirmation options.
     */
    interface ConfirmationOptionsManifest {
        /**
         * The confirmation title.
         */
        readonly title?: string;
        /**
         * The confirmation message.
         */
        readonly message: string;
        /**
         * The confirmation text input.
         * User needs to enter this text in order to confirm command execution.
         */
        readonly explicitConfirmationText?: string;
    }
    /**
     * The interface for ARM bulk commands.
     */
    interface ArmStaticCommand extends AssetTypeCommandManifest {
        /**
         * The ARM bulk command definitions.
         */
        readonly armCommandDefinitions?: StringMap<ArmCommandDefinition>;
        /**
         * The flag indicating whether to launch Fx bulk delete confirmation blade for bulk delete operations.
         *
         * NOTE: All ARM bulk delete commands should set this flag to true for consistent bulk delete confirmation experience.
         */
        readonly isBulkDeleteOperation?: boolean;
    }
    /**
     * The blade reference options for open blade command.
     */
    interface BladeReferenceOptions {
        /**
         * The blade name.
         */
        readonly blade: string;
        /**
         * The extension name for the blade
         */
        readonly extension?: string;
        /**
         * The flag indicating whether blade needs to be opened as a context pane.
         * Defaults to false.
         */
        readonly inContextPane?: boolean;
        /**
         * The blade parameters.
         */
        readonly parameters?: StringMap<any>;
    }
    /**
     * Interface for asset type command manifest.
     */
    interface AssetTypeCommandManifest {
        /**
         * Specify a unique identifier or friendly command name (non localized string). This will be used for telemetry.
         */
        readonly id: string;
        /**
         * Command label shown in the toolbar.
         */
        readonly label: string;
        /**
         * Command icon shown in the toolbar.
         */
        readonly icon: MsPortalFx.Base.Image;
        /**
         * Command aria label.
         */
        readonly ariaLabel?: string;
        /**
         * Command tooltip shown on hover.
         */
        readonly tooltip?: string;
        /**
         * The blade reference.
         */
        readonly bladeReference?: BladeReferenceOptions;
        /**
         * The marketplaceItemId to open create flows.
         */
        readonly marketplaceItemId?: string;
        /**
         * The browse grid selection model.
         */
        readonly selection?: BrowseResourceSelection;
        /**
         * The command execution confirmation options.
         */
        readonly confirmation?: ConfirmationOptionsManifest;
        /**
         * The ARM bulk command definition options.
         */
        readonly armCommandDefinitionOptions?: ArmCommandOptionsManifest;
        /**
         * The list of commands.
         */
        readonly commands?: ReadonlyArray<AssetTypeCommandManifest>;
    }
    /**
     * Asset type command definitions including Browse bulk commanding.
     */
    interface AssetTypeCommandSet {
        /**
         * Command definitions generic operations.
         */
        readonly commands?: ReadonlyArray<AssetTypeCommandManifest>;
        /**
         * Command definitions for resource selection based operations.
         */
        readonly selectionCommands?: ReadonlyArray<AssetTypeCommandManifest>;
    }
    interface AssetTypeBrowseManifest {
        /**
         * Name of the asset type of the browse definition.
         */
        name: string;
        /**
         * Browse query for ARG browse.
         */
        browseQuery: string;
        /**
         * Array of default columns for the browse (either a column name or a built-in column).
         */
        defaultColumns: (string | MsPortalFx.Assets.ResourceColumnIds)[];
        /**
         * Array of column definitions.
         */
        columns: AssetTypeBrowseColumnManifest[];
        /**
         * Optional column which contains the resource status to display in the resource part.
         */
        statusColumn?: string;
        /**
         * Array of merged resource type definitions.
         */
        mergedResourceTypes?: AssetTypeMergedResourceTypeManifest[];
        /**
         * Optional flag which indicates whether to honor the selected flag on the merged resource types.
         */
        honorSelectedMergedResourceTypes?: boolean;
        /**
         * Array of asset type command definitions.
         */
        commands?: AssetTypeCommandSet;
        /**
         * Optional parent resource type for browse.
         *
         * The parent resource type if defined will determine the display name of the browse blade as well as the
         * resource type used for browse blade view management.
         */
        browseParentResourceType?: string;
    }
    interface AssetTypeBrowseColumnManifest {
        /**
         * Name of the column.
         */
        name: string;
        /**
         * Optional name of the column used for sorting the column.
         */
        sortColumn?: string | MsPortalFx.Assets.ResourceColumnIds;
        /**
         * Localized display name of the column.
         */
        displayName: string;
        /**
         * Optional description localized string of the column.
         */
        description?: string;
        /**
         * Columns format of the column.
         */
        format: MsPortalFx.Extension.ColumnFormat;
        /**
         * Optional width of the column (in pixels).
         *
         * @deprecated 04/30/2020 - Use the 'width' property with grid units. PDL compiler was updated, this should not
         * be emitted any longer.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        widthInPixels?: Obsolete;
        /**
         * Optional width of the column (in grid units).
         */
        width?: string;
        /**
         * Optional blade name for BladeLink columns.
         */
        bladeName?: string;
        /**
         * Optional blade extension name for BladeLink columns.
         */
        bladeExtensionName?: string;
        /**
         * Optional name of the column for the blade parameters for BladeLink columns.
         */
        bladeParameterColumn?: string | MsPortalFx.Assets.ResourceColumnIds;
        /**
         * Optional flag to launch the blade in a context pane for BladeLink columns.
         */
        openBladeAsContextPane?: boolean;
    }
    interface AssetTypeMergedResourceTypeManifest {
        /**
         * Name of the resource type.
         */
        resourceTypeName: string;
        /**
         * Optional flag indicating whether the merged resource type is selected by default.
         */
        selected?: boolean;
    }
}

// FILE: MsPortalFx\Extension\FilterKind.d.ts
declare module MsPortalFx.Extension {
    const enum FilterKind {
        /**
         * The TimeRange filter.
         */
        TimeRange = 0,
        /**
         * The Equality filter.
         */
        Equality = 1,
        /**
         * The Subscription filter.
         */
        Subscription = 2,
        /**
         * The Location filter.
         */
        Location = 3,
        /**
         * The ResourceType filter.
         */
        ResourceType = 4,
        /**
         * The ResourceGroup filter.
         */
        ResourceGroup = 5
    }
}

// FILE: MsPortalFx\Extension\KindVisibility.d.ts
declare module MsPortalFx.Extension {
    const enum KindVisibility {
        /**
         * Normal visibility.
         */
        Normal = 0,
        /**
         * Hidden visibility.
         */
        Hidden = 1
    }
}

// FILE: MsPortalFx\Extension\ProxyRoutingFilter.d.ts
declare module MsPortalFx.Extension {
    const enum ProxyRoutingFilter {
        /**
         * Text proxy routing filter.
         */
        TextFilter = 1,
        /**
         * Resource group proxy routing filter.
         */
        ResourceGroupFilter = 2,
        /**
         * Location proxy routing filter.
         */
        LocationFilter = 3
    }
}

// FILE: MsPortalFx\Extension\RedirectType.d.ts
declare module MsPortalFx.Extension {
    const enum RedirectType {
        /**
         * No redirect.
         */
        None = 0,
        /**
         * Defines a redirect to a blade.
         */
        Blade = 2,
        /**
         * Defines a redirect to the resource menu blade.
         */
        ResourceMenuBlade = 3,
        /**
         * Defines a redirect from a part type to another part type
         */
        PartType = 4,
        /**
         * Defines a redirect from a part instance on a blade to a part type
         */
        PartInstance = 5,
        /**
         * Defines a redirect to a asset
         */
        Asset = 6
    }
}

// FILE: MsPortalFx\Extension\ReferenceType.d.ts
declare module MsPortalFx.Extension {
    const enum ReferenceType {
        /**
         * The reference is to a view model property on a part.
         */
        Part = 0,
        /**
         * The reference is to an input belonging to the enclosing blade.
         */
        BladeInput = 1,
        /**
         * The reference is to a view model property on a blade's action bar.
         */
        BladeActionBar = 2,
        /**
         * The reference is to a property on a blade's extension view model.
         */
        BladeProperty = 3,
        /**
         * The reference is to a view model property on a command.
         */
        Command = 4,
        /**
         * The reference is a constant value.
         */
        Constant = 5,
        /**
         * The reference is to a property on a a item that is currently selected
         */
        SelectedItem = 6,
        /**
         * The reference is to a view model property on the part adapter.
         */
        Adapter = 7,
        /**
         * The reference is to a property on the containing Dashboard.
         */
        Dashboard = 8,
        /**
         * The reference is to an input of the part adapter.
         */
        AdapterInput = 9,
        /**
         * The reference is to the parameters passed to an AzBlade, made available to the AzBlade's virtual Part.
         */
        _Internal_AzBladeParameters = 999
    }
}

// FILE: MsPortalFx\Extension\ResourceRoutingType.d.ts
declare module MsPortalFx.Extension {
    enum ResourceRoutingType {
        /**
         * Default routing type, resource-group level resources.
         */
        Default = 0,
        /**
         * Tenant (provider) based resources.
         */
        Tenant = 1,
        /**
         * Extension based resources.
         */
        Extension = 2,
        /**
         * Provider proxy based resources.
         */
        ProviderProxy = 3
    }
}

// FILE: MsPortalFx\Extension\Runtime.d.ts
declare module FxImpl {
    import Fx = MsPortalFx;
    function toAbsoluteUrisRequire(resultConfig: RequireConfig): void;
    function setupRequire(requireBundle: RequireConfig, fxRequireBundle?: RequireConfig): void;
    module Extension {
        import FxBase = Fx.Base;
        import Rpc = FxImpl.Rpc;
        import FxAssets = Fx.Assets;
        import FxExtension = Fx.Extension;
        import FxViewModels = Fx.ViewModels;
        import Context = FxImpl.TelemetryContext;
        import Security = FxBase.Security;
        import InternalSecurity = FxImpl.Security;
        import Settings = Fx.Settings;
        import HubsAzure = HubsExtension.Azure;
        export const getExtensionGalleryService: Rpc.ProxiedObjectTypeDefinition<void, any>;
        export const getBladeDefinitionEndPoint: Rpc.FuncEndPointDefinition<string, FxExtension.BladeDefinition>;
        export const getPartDefinitionEndPoint: Rpc.FuncEndPointDefinition<string, FxExtension.PartTypeDefinition>;
        /**
         * Parameters needed to load a ReactView's model
         */
        interface ReactModelParams {
            /**
             * ReactView's model name
             */
            modelName: string;
            /**
             * Id of the port used to communicate with ReactView iframe
             */
            portId: string;
        }
        /**
         * Parameters needed to dispose a ReactView's model
         */
        interface DisposeReactModelParams {
            /**
             * ReactView's model name
             */
            modelName: string;
            /**
             * Id of the port used to communicate with ReactView iframe
             */
            portId: string;
            /**
             * If model's module should be unloaded
             */
            unrequire: boolean;
        }
        export interface GetManifestParams {
            extensionName: ExtensionNames;
            propertyName: keyof MsPortalFx.Extension.Manifest;
        }
        export interface ExtensionRegistration {
            baseUri: string;
        }
        export interface CatalogApiCacheContent {
            createMenu: string;
            portal: ReadonlyStringMap<string>;
            curationData: string;
        }
        export const getReactModelEndPoint: Rpc.ActionEndPointDefinition<ReactModelParams>;
        export const disposeReactModelEndPoint: Rpc.ActionEndPointDefinition<DisposeReactModelParams>;
        export const getCommandsDefinitionEndPoint: Rpc.FuncEndPointDefinition<void, FxExtension.CommandsDefinition>;
        export const pingEndPoint: Rpc.FuncEndPointDefinition<void, void>;
        export const getLastResourceIdInJourneyEndPoint: Rpc.FuncEndPointDefinition<void, string>;
        export interface SetExtensionFlightsOptions {
            readonly flights: ReadonlyArray<string>;
            readonly impressionId: string;
        }
        export const setExtensionFlightsEndPoint: Rpc.FuncEndPointDefinition<SetExtensionFlightsOptions, readonly string[]>;
        export interface GetAuthorizationTokenOptions {
            readonly resourceName?: string;
        }
        export interface GetAuthorizationTokenOptionsExtended extends GetAuthorizationTokenOptions {
            readonly isBackground: boolean;
            readonly skipCache?: boolean;
        }
        export let getCatalogApiCacheContentEndPoint: Rpc.FuncEndPointDefinition<void, CatalogApiCacheContent>;
        export let getExtensionRegistrationEndPoint: Rpc.FuncEndPointDefinition<ExtensionNames, ExtensionRegistration>;
        export let getManifestEndPoint: Rpc.FuncEndPointDefinition<GetManifestParams, any>;
        export let getAuthorizationTokenEndPoint: Rpc.FuncEndPointDefinition<GetAuthorizationTokenOptionsExtended, Security.GetAuthorizationTokenResponse>;
        export let setAllTokensForExtensionEndPoint: Rpc.FuncEndPointDefinition<InternalSecurity.ExtensionTokens, void>;
        export let getUserInfoEndPoint: Rpc.FuncEndPointDefinition<any, Security.UserInfo>;
        export let getSharedSettingsEndPoint: Rpc.FuncEndPointDefinition<any, Settings.SharedSettings>;
        export let getLocalGalleryPackagesEndpointsDefinition: Rpc.FuncEndPointDefinition<void, string[]>;
        export let getLocalGalleryPackagesEndpointDefinition: Rpc.FuncEndPointDefinition<void, string>;
        export interface HasPermissionsToShellArgs {
            entityId: string;
            requestedActions: string[];
        }
        export let hasPermissionsToShell: Rpc.FuncEndPointDefinition<HasPermissionsToShellArgs, string | boolean>;
        /**
         * @deprecated 2020/04/30 - All asset ID's should be resource ID's and this should no longer be used.
         * This was exposed by the mapAssetIdToResourceId in Assets.ts which is also deprecated. Since all
         * asset ID's are now resource ID's, just use the resource ID directly.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        export let mapAssetIdToResourceIdEndPoint: Rpc.FuncEndPointDefinition<FxAssets.AssetTriplet, string>;
        export let mapResourceIdToAssetIdEndPoint: Rpc.FuncEndPointDefinition<string, FxAssets.AssetTriplet>;
        export interface MapAssetIdToDynamicSelectionArgs {
            assetId: FxAssets.AssetTriplet;
            forceBladeSelection: boolean;
        }
        export let mapAssetIdToDynamicSelectionAndIconEndPoint: Rpc.FuncEndPointDefinition<MapAssetIdToDynamicSelectionArgs, FxAssets.DynamicSelectionAndIcon>;
        export interface MapResourceIdToDynamicSelectionArgs {
            resourceId: string;
            forceBladeSelection: boolean;
        }
        export let mapResourceIdToDynamicSelectionAndIconEndPoint: Rpc.FuncEndPointDefinition<MapResourceIdToDynamicSelectionArgs, FxAssets.DynamicSelectionAndIcon>;
        export interface GetAssetTypeInformationEndPointArgs {
            extensionName: string;
            assetType: string;
        }
        export let getAssetTypeInformationEndPoint: Rpc.FuncEndPointDefinition<GetAssetTypeInformationEndPointArgs, FxAssets.AssetTypeInformation>;
        export let getResourceTypeAssetTypeInformationEndPoint: Rpc.FuncEndPointDefinition<string[], FxAssets.ResourceTypeAssetTypeInformation[]>;
        export let getResourceAssetInformationEndPoint: Rpc.FuncEndPointDefinition<string[], FxAssets.ResourceAssetInformation[]>;
        export interface GetResourceEndPointArgs {
            resourceId: string;
            skipCache: boolean;
            invoker: string;
        }
        /**
         * @deprecated 2020/04/30 - This should no longer be used, it is no longer supported.  Use batch() call to ARM endpoint
         * directly to retrieve a resource.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        export let getResourceEndPoint: Rpc.FuncEndPointDefinition<GetResourceEndPointArgs, HubsAzure.ResourceWithStrings>;
        /**
         * @deprecated Do not use, no longer supported. This API has for a long time not executed any code in FX, it is
         * safe to remove this call.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        export let signalResourcesChangedEndPoint: Rpc.FuncEndPointDefinition<string[], void>;
        export interface SdkSuppliedEnvironment {
            readonly eventHandlers?: ReadonlyStringMap<ReadonlyArray<keyof EventHandlerContracts>>;
            readonly extensionRoot?: string;
            readonly marketplaceViewModelLocator?: MsPortalFx.Extension.ViewModelLocator;
            readonly weaveBladesMap?: ReadonlyStringMap<string>;
        }
        /**
         * Enumeration of the types of view models the shell supports.  These types have different feature sets and containers.
         */
        export const enum ViewModelType {
            /**
             * This is flagged as being a kind of a part view model
             */
            IsPartFlag = 128,
            /**
             * This is flagged as being a blade view model
             */
            IsBladeFlag = 64,
            /**
             * This is a PDL V1 view model that requires FxImpl.Composition.BladeContainer
             */
            UseV1BladeContainerFlag = 256,
            /**
             * Run of the mill generic part
             */
            GenericPart = 129,
            /**
             * LEGACY Inferred pinned part for a blade.
             * Its a part that represents a pinned blade on a dashboard.
             */
            InferredBladePinPart = 2,
            ClassicBlade = 68,
            VirtualTemplateBladeV1Part = 453,
            VirtualMenuBladeV1Part = 454,
            VirtualMenuBladeV2Part = 204,
            Command = 7,
            BladeActionBar = 8,
            /**
             * LEGACY - A part extender view model provides additional inputs to a part in another extension
             */
            PartExtenderViewModel = 9,
            /**
             * LEGACY - A adapter part modifies the inputs to a part
             */
            AdapterPart = 10,
            /**
             * A service view model is a view model that exposes little or no features
             * in the container API.  Also, not always but frequently they do not directly drive the chrome
             * i.e... no title, no icon.. etc.. no physical screen dimensions.
             *
             * Examples of service viewmodels include
             * DynamicBladeService
             * ResourceProvider
             * BrowseService
             * GridColumnsService
             * PropertyProviderService
             */
            ServiceViewModel = 11
        }
        export interface Definition extends FxExtension.Definition {
            requireConfig?: RequireConfig;
        }
        /**
         * Options passed to getViewModel and getPartViewModel from the shell such that before it return the content of the viewModel, it will execute the task.
         */
        export interface EarlyExecuteTask {
            /**
             * options to keep the task output promise in the "_msPortalFx_earlyExec" + keepReturns
             */
            readonly keepReturnsIn?: string;
            /**
             * The name of the method to call.
             */
            readonly method: string;
            /**
             * Arguments to pass to the method.
             */
            readonly args?: ReadonlyArray<unknown>;
            /**
             * Whether to ignore missing methods.
             */
            readonly ignoreMissingMethod?: true;
        }
        /**
         * Options passed to getViewModel and getPartViewModel from the shell
         */
        export interface GetViewModelOptions {
            /**
             * The type of the view model.
             */
            type: ViewModelType;
            /**
             * The view model locator.
             */
            locator: MsPortalFx.Extension.ViewModelLocator;
            /**
             * If true the selectable container should be initialized
             */
            createSelectable?: boolean;
            /**
             * Creation context of the view model
             */
            telemetryContext?: Context.State;
            /**
             * A Part's size, if requesting a Part's view model.
             */
            partSize?: Fx.Parts.PartSize;
            /**
             * A Part's expected content size, if requesting a Part's view model.
             */
            contentSize?: {
                height: number;
                width: number;
            };
            /**
             * A Part's location, if requesting a Part's view model.
             */
            partLocation?: FxViewModels.PartLocation;
            /**
             * onInputsSet parameters
             */
            onInputsSetParameters?: OnInputsSetParameters;
            /**
             * Part collapsed state
             */
            collapsed?: boolean;
            /**
             * If set, initiate execution of this task on the view model before the view model is returned
             */
            earlyExecTask?: EarlyExecuteTask;
            /**
             * various view model flags used to configure SDK options
             */
            flags?: Fx.ViewModels.Internal.ViewModelFlags;
            /**
             * If this is the virtual Part for a MenuBlade, 'menuId' will be set to the id any initially-selected menu entry for the MenuBlade.
             */
            menuId?: string;
        }
        /**
         * Parameters to onInputsSet
         */
        export interface OnInputsSetParameters {
            /**
             * Actual inputs.
             */
            inputs: any;
            /**
             * Settings.
             */
            settings: any;
            /**
             * Trace options.
             */
            traceOptions: FxImpl.ViewModels.CompositionViewModelTraceOptions;
            /**
             * An identifier for the composition item that can be used in diagnostic traces.
             */
            viewModelName: string;
            /**
             * Inputs metadata (currently only for Parts).
             */
            inputsMetadata: InputsMetadata;
            /**
             * If true, indicates that the Part's/Blade's 'onInputsSet' should _not_ be called.
             * When the extension calls 'configuration.updateValues(...)', FX shouldn't notify the view model via 'onInputsSet'/'onRebind'.
             */
            dontCallViewModelOnInputsSet: boolean;
            /**
             * A StringMap from filter id to filter model for the currently applied Dashboard-level filters.
             */
            dashboardFilters: StringMap<any>;
            /**
             * A StringMap from filter id to filter model that specify/override the Dashboard-level filters.
             */
            partFilters: StringMap<any>;
        }
        /**
         * Metadata describing how inputs can be bound to properties on the Part's container (its enclosing Dashboard and, later, enclosing
         * Blade).
         */
        export type InputsMetadata = StringMap<InputMetadata>;
        /**
         * Metadata describing how an input can be bound to a property from its container (its enclosing Dashboard and, later, enclosing Blade).
         */
        export interface InputMetadata {
            /**
             * Those sources available at the container level.  The user will select 0 or 1 of these via configuration UI.
             */
            bindingSources: InputBindingSource[];
            /**
             * The currently selected source or null/undefined if the user has elected to override this input with an explicitly specified
             * value.
             */
            activeBindingSourceName: string;
        }
        /**
         * Metadata describing a container property to which a Part input can be bound.  For a given Part input, the user will select 0 or 1
         * of these via configuration UI.
         */
        export interface InputBindingSource {
            /**
             * The runtime-level name of the property at the container level (the Dashboard or, later, the enclosing Blade).
             */
            name: string;
            /**
             * Indicates whether this Dashboard-level property accepts value updates.
             */
            acceptsValueUpdates: boolean;
        }
        export interface Runtime extends FxBase.Disposable {
            /**
             * Gets the security token an extension uses to make calls against
             * secured back end services.
             * This is the internal implementation of get authorization token.
             *
             * @param options Optional options containing the resource name of the extension wants access to.
             * @param rpcEndpoint The rpc end point that actually gets auth token from server side.
             * @return A security token for the named service or if no such token is available undefined.
             */
            getAuthorizationToken(options?: GetAuthorizationTokenOptions): FxBase.PromiseV<Security.AuthorizationToken>;
            /**
             * Gets the signed in user and directory info.
             *
             * @return The info for the currently signed in user and directory.
             */
            getUserInfo(): FxBase.PromiseV<Security.UserInfo>;
            /**
             * Gets the shared settings for the extensions to use.
             *
             * @return The shared settings properties.
             */
            getSharedSettings(): FxBase.PromiseV<Settings.SharedSettings>;
            /**
             * Checks to see if the current user has permissions to perform a set of actions against an entity.
             * secured back end services.
             *
             * @param entityId The entity to check for permissions. The entity ID MUST be a resource ID, a subscription ID or a resource group ID.
             * @param actions The actions being to checked.
             * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
             */
            hasPermission(entityId: string, actions: string[]): Q.Promise<boolean>;
            /**
             * Checks to see if the current user has permissions to perform a set of actions against an asset.
             * secured back end services.
             *
             * @param assetId The asset to check for permissions. The asset MUST have an associated resource type.
             * @param actions The actions being to checked.
             * @return A promise that resolves to true if the current user can perform all the provided actions against the provided asset.
             */
            assetHasPermission(assetId: FxAssets.AssetTriplet, actions: string[]): FxBase.PromiseV<boolean>;
            /**
             * Maps an asset ID to a resource ID using the asset type system.
             * Note that this will reject if the asset type does not support mapping to resource ID.
             *
             * @deprecated 2020/04/30 - All asset ID's should be resource ID's and this should no longer be used.
             * This was exposed by the mapAssetIdToResourceId in Assets.ts which is also deprecated. Since all
             * asset ID's are now resource ID's, just use the resource ID directly.
             *
             * Please refer to https://aka.ms/portalfx/breaking for more details.
             *
             * @param assetId The fully qualified asset ID.
             * @return A promise that resolves to the resource ID string for the fully qualified asset ID.
             */
            mapAssetIdToResourceId(assetId: FxAssets.AssetTriplet): FxBase.PromiseV<string>;
            /**
             * Maps a resource ID to an asset ID using the asset type system.
             * Note that this will reject if an asset type is not found for the resource type.
             *
             * @param resourceId The resource ID string.
             * @return A promise that resolves to the fully qualified asset ID for the resource ID.
             */
            mapResourceIdToAssetId(resourceId: string): FxBase.PromiseV<FxAssets.AssetTriplet>;
            /**
             * Maps an asset triplet to a dynamic selection and an icon using the asset type system.
             * Note that this will reject if an asset type is not found.
             *
             * @param assetId The fully qualified asset ID.
             * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
             * @return A promise that resolves to the fully qualified dynamic selection and the icon for the asset ID.
             */
            mapAssetIdToDynamicSelectionAndIcon(assetId: FxAssets.AssetTriplet, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
            /**
             * Maps a resource ID to a dynamic selection and an icon using the asset type system.
             * Note that this will reject if an asset type is not found for the resource type.
             *
             * @param resourceId The resource ID string.
             * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
             * @return A promise that resolves to the fully qualified dynamic selection and the icon for the resource ID.
             */
            mapResourceIdToDynamicSelectionAndIcon(resourceId: string, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
            /**
             * Gets an asset type's information for a given asset type using the asset type system.
             * Note that this will reject if the asset type is not found.
             *
             * @param extensionName The name of the extension that owns the asset type.
             * @param assetType The name of the asset type.
             * @return A promise that resolves to the asset type information structure for the asset type.
             */
            getAssetTypeInformation(extensionName: string, assetType: string): FxBase.PromiseV<FxAssets.AssetTypeInformation>;
            /**
             * Gets an asset type information for an array of resource types using the asset type system.
             * Note that this will not reject if an asset type is not found for the resource type, but the
             * assetTypeInformation will be null for that resource type.
             *
             * @param resourceTypes The array of names of the resource types.
             * @return A promise that resolves to the asset type information structure for the resource type.
             */
            getResourceTypeAssetTypeInformation(resourceTypes: string[]): FxBase.PromiseV<FxAssets.ResourceTypeAssetTypeInformation[]>;
            /**
             * Gets the asset information for an array of resource IDs using the asset type system.
             * Note that this will not reject if an asset type is not found for the resource type, but the assetId and
             * assetTypeInformation will be null for that resource ID.
             *
             * @param resourceIds An array of resource IDs.
             * @return A promise that resolves to an array of asset information packets, one for each source resource ID.
             */
            getResourceAssetInformation(resourceIds: string[]): FxBase.PromiseV<FxAssets.ResourceAssetInformation[]>;
            /**
             * Gets the resource identified by a supplied resource ID.
             *
             * @deprecated 2020/04/30 - This should no longer be used, it is no longer supported.  Use batch() call to ARM
             * endpoint directly to retrieve a resource.
             *
             * Please refer to https://aka.ms/portalfx/breaking for more details.
             *
             * @param resourceId A resource ID.
             * @param invoker A string identifying the invoker (for telemetry).
             * @param skipCache An optional flag to refresh the cache.
             * @return A promise that resolves with a resource object.
             */
            getResource(resourceId: string, invoker: string, skipCache?: boolean): FxBase.PromiseV<HubsAzure.ResourceWithStrings>;
            /**
             * Signals that resources of the specified type have changed and cache for these resources should be updated.
             *
             * @deprecated Do not use, no longer supported. This API has for a long time not executed any code in FX, it is
             * safe to remove this call.
             *
             * Please refer to https://aka.ms/portalfx/breaking for more details.
             *
             * @param resourceIds The array of resource IDs.
             * @return The promise that resolves when the operation has completed.
             */
            signalResourcesChanged(resourceIds: string[]): FxBase.Promise;
            /**
             * Gets the URIs of endpoints that can be invoked to return gallery package information.
             *
             * @return A promise that resolves to an array of URI strings.
             */
            getLocalGalleryPackagesEndpoints(): FxBase.PromiseV<string[]>;
        }
        export class RuntimeImpl implements Runtime {
            private readonly _rpcClient;
            private _tokenCache;
            private _permissionsCache;
            private readonly _ltm;
            constructor(_rpcClient: FxImpl.Rpc.Client);
            getAuthorizationToken(options?: GetAuthorizationTokenOptions): Q.Promise<Security.AuthorizationToken>;
            getSharedSettings(): FxBase.PromiseV<Settings.SharedSettings>;
            getUserInfo(): FxBase.PromiseV<Security.UserInfo>;
            getLocalGalleryPackagesEndpoints(): FxBase.PromiseV<string[]>;
            hasPermission(entityId: string, actions: string[]): Q.Promise<boolean>;
            assetHasPermission(assetId: FxAssets.AssetTriplet, actions: string[]): FxBase.PromiseV<boolean>;
            mapAssetIdToResourceId(assetId: FxAssets.AssetTriplet): FxBase.PromiseV<string>;
            mapResourceIdToAssetId(resourceId: string): FxBase.PromiseV<FxAssets.AssetTriplet>;
            mapAssetIdToDynamicSelectionAndIcon(assetId: FxAssets.AssetTriplet, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
            mapResourceIdToDynamicSelectionAndIcon(resourceId: string, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
            getAssetTypeInformation(extensionName: string, assetType: string): FxBase.PromiseV<FxAssets.AssetTypeInformation>;
            getResourceTypeAssetTypeInformation(resourceTypes: string[]): FxBase.PromiseV<FxAssets.ResourceTypeAssetTypeInformation[]>;
            getResourceAssetInformation(resourceIds: string[]): FxBase.PromiseV<FxAssets.ResourceAssetInformation[]>;
            getResource(resourceId: string, invoker: string, skipCache?: boolean): FxBase.PromiseV<HubsAzure.ResourceWithStrings>;
            signalResourcesChanged(resourceIds: string[]): FxBase.Promise;
            dispose(): void;
        }
        /**
         * Determines the 'ViewModelType' value for the Blade based on its BladeDefinition.
         * @param bladeDefinition The Blade's BladeDefinition.
         * @returns The 'ViewModelType' value.
         */
        export function getViewModelType(bladeDefinition: FxExtension.BladeDefinition): ViewModelType;
        /**
         * Returns the friendly name for a Blade/Part locator.
         * @param name The Blade/Part name.
         * @returns The locator friendly name.
         */
        export function getLocatorFriendlyName(name: string, isBlade?: boolean): string;
        export {};
    }
}

// FILE: MsPortalFx\Extension\SetRequirement.d.ts
declare module MsPortalFx.Extension {
    enum SetRequirement {
        /**
         * All items in the set must be satisfied (operator AND).
         */
        All = 0,
        /**
         * Any items in the set must be satisfied (operator OR).
         */
        Any = 1
    }
}

// FILE: MsPortalFx\FxExtension.d.ts
declare module "Fx/Extension" {
    export = MsPortalFxExtension;
    module MsPortalFxExtension {
        /**
         * @deprecated: MsPortalFxExtension.Decorator - The extension decorator is no longer supported due to changes to support faster extension load times.
         * Please add a '<Extension Name="name" />' element in your PDL file and remove this class and decorator usage.
         */
        function Decorator(): (constructor: Function) => void;
    }
}

// FILE: MsPortalFx\Globalization.d.ts
declare module FxImpl {
    import Fx = MsPortalFx;
    const knownCulturesMap: StringMap<Language>;
    interface Format<T> {
        format(value: T): string;
    }
    interface FormatCache<TOptions, TValue> {
        getValue(options?: TOptions): Format<TValue>;
    }
    class IntlContext {
        displayLanguage: string;
        formatCulture: string;
        numbers: FormatCache<Fx.Intl.NumberFormatOptions, number>;
        dateTimes: FormatCache<Fx.Intl.DateTimeFormatOptions, Date>;
        supported: (locales: string[]) => string[];
        constructor(displayLanguage: string, formatCulture: string, intl?: any);
    }
    function createWithBrowserIntl(displayLanguage: string, formatCulture: string): IntlContext;
    module Intl {
        const displayLanguage: string;
        const formatCulture: string;
        const effectiveLocale: string;
        interface NumberFormat {
            /**
             * Returns the format of the number according to the formatting options of this NumberFormat object.
             */
            format(value: number): string;
        }
        /**
         * An object that can provide language sensitive number formatting.
         */
        module NumberFormat {
            /**
             * Creates a new instance of an object that can provide language sensitive number formatting.
             */
            function create(options?: Fx.Intl.NumberFormatOptions): NumberFormat;
            /**
             * Returns the format of the number default formatting options for the current locale.
             */
            function format(value: number): string;
        }
        interface DateTimeFormat {
            /**
             * Returns the format of the number according to the formatting options of this DateTimeObject object.
             */
            format(value: Date): string;
        }
        /**
         * An object that can provide language sensitive date and time formatting.
         */
        module DateTimeFormat {
            /**
             * The format options that returns strings similar to 11/30/2011.
             */
            const shortDatePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to Wednesday, November 30, 2011.
             */
            const longDatePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to Wednesday, November 30, 2011, 5:25:30 AM.
             */
            const fullDateTimePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to November 30.
             */
            const monthDayPattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to 5:25 AM.
             */
            const shortTimePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to 5:25:30 AM.
             */
            const longTimePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to November 2011.
             */
            const yearMonthPattern: Fx.Intl.DateTimeFormatOptions;
            const weekDayPattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * Creates a new instance of an object that can provide language sensitive date and time formatting.
             */
            function create(options?: Fx.Intl.DateTimeFormatOptions): DateTimeFormat;
        }
        module Internal {
            function supportedLocalesOf(locales: string[]): string[];
        }
    }
    function sanitizeFormatCulture(format: string, language: string): string;
    /**
     * Language object which has a corresponding culture information of locale, name, and localized name.
     */
    interface Language {
        /**
         * Language locale identifier.
         */
        locale: string;
        /**
         * Language English name.
         */
        name: string;
        /**
         * Language localized name.
         */
        localizedName: string;
        /**
         * Language neutral culture status.
         */
        neutralCulture: boolean;
        /**
         * Default specific culture.
         */
        specificCulture?: string;
    }
}
declare module "MsPortalFx/Globalization" {
    let Intl: typeof FxImpl.Intl;
    export = Intl;
}

// FILE: MsPortalFx\Hubs\InternalCommands.d.ts
declare module FxImpl {
    /**
     * Interface is in Framework but implementation is in Framework.Client under Internal/ListCommand.
     * Declaring the interface here allows the shell to avoid referencing the Framework.Client module.
     * This is a internal command type that exists only for hubs.
     */
    interface ListCommand2Contract extends MsPortalFx.ViewModels.ListCommandContract {
        /**
         * Shell tests for the existance of this property.
         * Name is short intentionally to keep the size small.
         */
        lc2: boolean;
    }
}

// FILE: MsPortalFx\Hubs\Notifications.d.ts
declare module MsPortalFx.Hubs.Notifications {
    import FxAssets = MsPortalFx.Assets;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * The notification status.
     */
    enum NotificationStatus {
        /**
         * An information notification
         */
        Information = 0,
        /**
         * A warning notification
         */
        Warning = 1,
        /**
         * An error notification
         */
        Error = 2,
        /**
         * An in progress notification
         */
        InProgress = 3,
        /**
         * A success notification
         */
        Success = 4
    }
    /**
     * Interface that represents data required to create a client notification.
     */
    interface ClientNotificationParameters {
        /**
         * The notification status - Information, Warning, Error, InProgress, Success.
         */
        status: NotificationStatus;
        /**
         * The notification title.
         */
        title: string;
        /**
         * The notification description.
         */
        description: string;
        /**
         * Optionally, render the notification description as HTML.
         */
        descriptionAsHtml?: boolean;
        /**
         * The event correlation ids associated with the notification.
         */
        correlationIds?: string[];
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        percentComplete?: number;
        /**
         * The asset associated with the notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        asset?: FxAssets.AssetTriplet;
        /**
         * A URI that the notification links to.
         */
        uri?: string;
        /**
         * The blade linked to this notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        linkedBlade?: FxViewModels.DynamicBladeSelection;
        /**
         * The notification id.
         */
        notificationId?: string;
        /**
         * Any additional properties associated with the notification.
         */
        additionalProperties?: any;
    }
    /**
     * Interface that represents data representing a client notification.
     * This interface cannot be used to create a new notification.
     */
    interface ClientNotificationData extends ClientNotificationParameters {
        /**
         * The notification timestamp.
         */
        timestamp: Date;
        /**
         * Boolean indicating if this is a recommendation notification.
         */
        isRecommendation?: boolean;
    }
    /**
     * Client notification class
     */
    class ClientNotification implements ClientNotificationParameters {
        /**
         * The notification status - Information, Warning, Error, InProgress, Success.
         */
        status: NotificationStatus;
        /**
         * The notification id.
         */
        notificationId: string;
        /**
         * The notification title.
         */
        title: string;
        /**
         * The notification description.
         */
        description: string;
        /**
         * Render the notification description as HTML.
         */
        descriptionAsHtml: boolean;
        /**
         * The event correlation ids associated with the notification.
         */
        correlationIds: string[];
        /**
         * The percentage of operation completed. Used only when notification status is InProgress.
         * If a value is specified, a deterministic progress bar is shown. If not, a non-deterministic progress bar is shown.
         */
        percentComplete: number;
        /**
         * The asset associated with the notification.
         */
        asset: FxAssets.AssetTriplet;
        /**
         * A URI that the notification links to.
         */
        uri: string;
        /**
         * The blade linked to this notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        linkedBlade: FxViewModels.DynamicBladeSelection;
        /**
         * Additional properties on the notification.
         */
        additionalProperties: any;
        /**
         * Constructs a notification object that can be published.
         *
         * @param clientNotificationData The client notification data.
         */
        constructor(params: ClientNotificationParameters);
        validate(): boolean;
        package(): FxImpl.Hubs.Notifications.InternalClientNotificationData;
        /**
         * Generates a randomly unique id to be used for notificationId, correlationId, and others where needed.
         *
         * @returns string id that always starts with clientNotification and ends with a globally unique identifier.
         */
        static generateClientNotificationId(): string;
        /**
         * Publishes this notification to the portal using the properties specified.
         */
        publish(): void;
        /**
         * Publishes a one time notification.
         *
         * @param clientNotificationData The client notification data.
         */
        static publish(params: ClientNotificationParameters): ClientNotification;
    }
}
declare module FxImpl.Hubs.Notifications {
    import Rpc = FxImpl.Rpc;
    import Notifications = MsPortalFx.Hubs.Notifications;
    let addClientNotificationDefinition: Rpc.FuncEndPointDefinition<InternalClientNotificationData, void>;
    let addClientNotificationsDefinition: Rpc.FuncEndPointDefinition<InternalClientNotificationData[], void>;
    /**
     * The action performed when the modal notification buttons are clicked.
     */
    const enum ModalNotificationClickAction {
        /**
         * Execute a click on the notification
         */
        NotificationClick = 1,
        /**
         * Refresh the portal
         */
        RefreshPortal = 2
    }
    /**
     * Action to take for the client notification URI.
     */
    enum ClientNotificationUriAction {
        /**
         * Navigates within the portal (ex: route to deep link).
         */
        NavigatePortal = 0,
        /**
         * Opens the URI in a new browser tab.
         */
        OpenInNewTab = 1,
        /**
         * Opens the URI in the current browser tab (replacing the portal).
         */
        OpenInCurrentTab = 2
    }
    /**
     * Notification field type (for inline forms).
     */
    const enum NotificationFieldType {
        /**
         * TextBox control.
         */
        TextBox = 0,
        /**
         * TextArea control (multiline textbox).
         */
        TextArea = 1,
        /**
         * Email control (textbox with email validation).
         */
        Email = 2,
        /**
         * CheckBox control.
         */
        CheckBox = 3
    }
    /**
     * Notification toast duration.
     */
    const enum ToastDuration {
        /**
         * Toast stays for 5 seconds.
         */
        Short = 0,
        /**
         * Toast stays for 30 seconds.
         */
        Long = 1,
        /**
         * Toast stays till the user manually dismisses it.
         */
        Sticky = 2,
        /**
         * Suppress toast notification.
         */
        Suppress = 3,
        /**
         * Modal toast notification.
         */
        Modal = 4
    }
    /**
     * The parameters for the modal dialog.
     */
    interface ModalNotificationParams {
        /**
         * The notification that is shown in the menu and in the dialog.
         * The asset specified in the notification will be launched on the primary click.
         */
        notification: InternalClientNotificationData;
        /**
         * The primary button text. Optional, if not specified will default to OK.
         */
        primaryButtonText?: string;
        /**
         * The secondary button text. Optional, if not specified will default to Cancel.
         */
        secondaryButtonText?: string;
        /**
         * The action performed when the primary button is clicked. Defaults to no action.
         */
        primaryButtonClickAction?: ModalNotificationClickAction;
        /**
         * The action performed when the secondary button is clicked. Defaults to no action.
         */
        secondaryButtonClickAction?: ModalNotificationClickAction;
    }
    /**
     * Metadata defining a notification form field.
     */
    interface NotificationField {
        /**
         * Field name.
         */
        name: string;
        /**
         * Field label (should be localized).
         */
        label: string;
        /**
         * Field type (defines the generated control).
         */
        fieldType: NotificationFieldType;
        /**
         * Default value for the field. Default is empty.
         */
        defaultValue?: string;
        /**
         * Defines whether the field is optional. Default is required.
         */
        optional?: boolean;
    }
    /**
     * Defines the arguments for making an AJAX call to a specified endpoint from an actionable
     * notification.
     */
    interface EndpointArgs {
        /**
         * The endpoint URI. This can be formatted with the field values using the field names. This
         * format ${fieldName} will be replaced with the field value.
         */
        uri: string;
        /**
         * The AJAX call method/type (http verb).
         */
        method: string;
        /**
         * The body (data). This can be formatted with the field values using the field names. This
         * format ${fieldName} will be replaced with the field value.
         */
        body: string;
        /**
         * Message to replace the notification content if the AJAX call succeeds.
         */
        successMessage: string;
        /**
         * Message to replace the notification content if the AJAX call fails.
         */
        failureMessage: string;
        /**
         * Defines whether we shuold supply the ARM tokens in the authentication header or not.
         */
        useArmToken?: boolean;
    }
    /**
     * Defines the arguments for opening a blade from an actionable notification.
     */
    interface OpenBladeArgs {
        /**
         * The blade name.
         */
        blade: string;
        /**
         * The extension name.
         */
        extension: string;
        /**
         * The inputs to the blade. Defaults to an empty object.
         */
        parameters?: any;
        /**
         * Defines whether the blade should be launched in a context pane. Defaults to false.
         */
        openInContextPane?: boolean;
    }
    /**
     * Defines the arguments for launching an external link from an actionable notification.
     */
    interface ExternalLinkArgs {
        /**
         * The URI to launch.
         */
        uri: string;
    }
    /**
     * Defines the arguments for launching a deep link from an actionable notification.
     */
    interface DeepLinkArgs extends ExternalLinkArgs {
    }
    /**
     * Defines the arguments for pinning a dashboard part from an actionable notification.
     */
    interface PinToDashboardArgs {
        /**
         * The name of the pinned part.
         */
        name: string;
        /**
         * The name of the extension for the pinned part.
         */
        extension: string;
        /**
         * The parameters for the pinned part.
         */
        parameters: Object;
    }
    /**
     * Defines an actionable notification action. If more than one action is defined, the first in
     * the following order will be executed and the rest will be ignored: openBlade, deepLink,
     * externalLink.
     */
    interface NotificationAction {
        /**
         * Arguments for an "openBlade" action (opens a portal blade).
         */
        openBlade?: OpenBladeArgs;
        /**
         * Arguments for an "externalLink" action (launches an external link).
         */
        externalLink?: ExternalLinkArgs;
        /**
         * Arguments for an "deepLink" action (launches a deep link).
         */
        deepLink?: DeepLinkArgs;
    }
    /**
     * Defines an actionable notification button action. If more than one action is defined, the first in
     * the following order will be executed and the rest will be ignored: openBlade, deepLink,
     * externalLink, pinToDashboard, endpoint.
     */
    interface NotificationButton extends NotificationAction {
        /**
         * Button label (should be localized).
         */
        label: string;
        /**
         * Optional button id  which will be logged in telemetry (non localized string).
         */
        id?: string;
        /**
         * Arguments for an "endpoint" action (making an AJAX call to a specified endpoint).
         */
        endpoint?: EndpointArgs;
        /**
         * Arguments for an "pinToDashboard" action.
         */
        pinToDashboard?: PinToDashboardArgs;
        /**
         * Styles the button as a secondary button. Also secondary buttons do not trigger form
         * validation. Defaults to false.
         */
        secondary?: boolean;
    }
    /**
     * Defines an inline form for actionable notifications.
     */
    interface NotificationInlineForm extends NotificationAction {
        /**
         * List of notification form fields.
         */
        fields?: NotificationField[];
        /**
         * List of notification action buttons.
         */
        buttons?: NotificationButton[];
    }
    /**
     * The RPC method that hubs calls to add a modal notification.
     */
    let showModalNotification: Rpc.FuncEndPointDefinition<ModalNotificationParams, MsPortalFx.ViewModels.Dialogs.DialogResult>;
    /**
     * Interface that represents additional data about Iris notifications..
     */
    interface IrisNotificationDetails {
        /**
         * The campaign id.
         */
        campaignId: string;
        /**
         * The message id.
         */
        messageId: string;
        /**
         * The transaction id.
         */
        transactionId: string;
        /**
         * The telemetry callback URI
         */
        telemetryUri: string;
    }
    /**
     * Interface that represents data representing a client notification.
     */
    interface InternalClientNotificationData extends Notifications.ClientNotificationData {
        /**
         * Flag indicating if this is a server event.
         */
        isServerEvent?: boolean;
        /**
         * Action to take for the notification URI.
         */
        uriAction?: ClientNotificationUriAction;
        /**
         * Toast duration for the notification.
         */
        toastDuration?: ToastDuration;
        /**
         * Inline form metadata for actionable notifications.
         */
        inlineForm?: NotificationInlineForm;
        /**
         * Details about the Iris notification.
         */
        irisNotificationDetails?: IrisNotificationDetails;
        /**
         * The email id of the user.
         */
        caller?: string;
    }
    /**
     * Client notification class
     */
    class InternalClientNotification extends Notifications.ClientNotification {
        /**
         * Toast duration for the notification.
         */
        toastDuration?: ToastDuration;
        /**
         * Inline form metadata for actionable notifications.
         */
        inlineForm?: NotificationInlineForm;
        /**
         * Iris notification details.
         */
        irisNotificationDetails?: IrisNotificationDetails;
        /**
         * Action to take for the notification URI.
         */
        uriAction?: ClientNotificationUriAction;
        /**
         * The email id of user.
         */
        caller: string;
        /**
         * Constructs a notification object that can be published.
         *
         * @param The client notification data.
         */
        constructor(params: InternalClientNotificationData);
        /**
         * Publishes this notification to the portal using the properties specified.
         *
         * @returns The timestamp at which the notification was published.
         */
        publish(): Date;
        /**
         * Publishes a one time notification.
         *
         * @param clientNotificationData The client notification data.
         */
        static internalPublish(params: InternalClientNotificationData): InternalClientNotification;
    }
}

// FILE: MsPortalFx\Internal\Internal.Constants.d.ts
declare module FxImpl.Constants {
    module RpcMethods {
        const addClientNotification: string;
        const addClientNotifications: string;
        const brokerExtensionService: string;
        const canShowNps: string;
        const entryPointGetBladeDefinition: string;
        const entryPointGetReactModel: string;
        const entryPointDisposeReactModel: string;
        const entryPointGetCommandsDefinition: string;
        const entryPointGetControlDefinition: string;
        const entryPointGetPartDefinition: string;
        const forwardEvent: string;
        const getArmEndpoint: string;
        const getAllAssetTypes: string;
        const getAssetTypeInformation: string;
        const getAuthToken: string;
        const setAllTokensForExtension: string;
        const getCatalogApiCacheContent: string;
        const getClientNotifications: string;
        const getExtensionRegistration: string;
        const getLastResourceIdInJourney: string;
        const getLocationDisplayNames: string;
        const getManifest: string;
        const getRegisteredResourceProviderInfo: string;
        const getResource: string;
        const getResourceAssetInformation: string;
        const getResourceGroup: string;
        const getResourceTypeAssetTypeInformation: string;
        const getSelectedSubscriptions: string;
        const getSettings: string;
        const getSharedSettings: string;
        const getUserInfo: string;
        const hasPermission: string;
        const logFeatureAdoptionTelemetry: string;
        const mapAssetIdToDynamicSelectionAndIcon: string;
        const mapAssetIdToResourceId: string;
        const mapResourceIdToAssetId: string;
        const mapResourceIdToDynamicSelectionAndIcon: string;
        const navigateToDashboard: string;
        const networkTelemetry: string;
        const notifyDeployment: string;
        const pollDeployment: string;
        const internalDeploymentHelper: string;
        const experimentationHelper: string;
        const notifyExtensionStatus: string;
        const ping: string;
        const pinParts: string;
        const registration: string;
        const setExtensionFlights: string;
        const shellReadUserSettings: string;
        const shellWriteLastUsedUserSettings: string;
        const shellWriteUserSettings: string;
        const showNps: string;
        const signalResourcesChanged: string;
        const updateSubscriptionInfo: string;
        const updateTenantInfo: string;
        const viewModels: string;
        const tryEarlyGetViewModel: string;
        const hubsGetResourceGroupsFromSubscription: string;
        const getLockValidation: string;
        const getSasUriForQueue: string;
        const getClientIp: string;
        const getHmacSha256: string;
        const getExtensionGalleryServiceViewModel: string;
        const getLocalGalleryPackagesEndpoints: string;
        const getLocationsForCreate: string;
        const getLocations: string;
        const getProvisioningOperation: string;
        const getProvisioningRequest: string;
        const initiateProvisioningRequest: string;
        const registerLocalGalleryPackagesEndpoint: string;
        const submitProvisionerTelemetry: string;
    }
}

// FILE: MsPortalFx\Knockout\knockout.d.ts
/*!
 * Knockout JavaScript library v3.4.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
interface KnockoutDisposable {
    dispose(): void;
}
interface KnockoutSubscription<T> extends KnockoutDisposable {
    _target: KnockoutObservableBase<T>;
    callback(value: T): void;
    disposeCallback(this: KnockoutSubscription<T>): void;
    isDisposed?: boolean;
}
interface KnockoutReadOnlyObservableBase<T> extends KnockoutSubscribable<T> {
    peek(): T;
}
interface KnockoutObservableBase<T> extends KnockoutReadOnlyObservableBase<T> {
    (value: T): void;
}
interface KnockoutComputedOptions<T> {
    read?: () => T;
    write?: (value: T) => void;
    owner?: any;
    disposeWhen?(): boolean;
    deferEvaluation?: boolean;
}
interface KnockoutComputed<T> extends KnockoutObservableBase<T>, KnockoutDisposable {
    getDependenciesCount(): number;
    hasWriteFunction(): boolean;
    isActive(): boolean;
}
interface KnockoutComputedStatic {
    fn: KnockoutComputed<any>;
}
interface KnockoutPureComputedStatic {
    fn: KnockoutComputed<any>;
    <T>(func: () => T, context?: any): KnockoutComputed<T>;
    <T>(options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
}
interface KnockoutReadOnlyObservable<T> extends KnockoutReadOnlyObservableBase<T> {
    equalityComparer(a: T, b: T): boolean;
    valueHasMutated(): void;
    valueWillMutate(): void;
}
interface KnockoutObservable<T> extends KnockoutReadOnlyObservable<T>, KnockoutObservableBase<T> {
}
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    indexOf(searchElement: T, fromIndex?: number): number;
    slice(start: number, end?: number): T[];
}
interface KnockoutObservableArray<T> extends KnockoutReadOnlyObservableArray<T>, KnockoutObservable<T[]> {
    splice(start: number, deleteCount?: number, ...items: T[]): T[];
    pop(): T;
    push(...items: T[]): number;
    shift(): T;
    unshift(...items: T[]): number;
    reverse(): T[];
    sort(compareFunction?: (a: T, b: T) => number): void;
    replace(oldItem: T, newItem: T): void;
    remove(item: T): T[];
    remove(predicate: (item: T) => boolean): T[];
    removeAll(items?: T[]): T[];
    destroy(item: T): void;
    destroyAll(items?: T[]): void;
}
interface KnockoutObservableArrayStatic {
    fn: KnockoutObservableArray<any>;
    <T>(value?: T[]): KnockoutObservableArray<T>;
}
interface KnockoutSubscribable<T> {
    (): T;
    extend(source: any): KnockoutObservableBase<T>;
    getSubscriptionsCount(): number;
    notifySubscribers(this: this, valueToWrite: T, topic?: string): void;
}
interface KnockoutObservableStatic {
    fn: KnockoutObservable<any>;
    <T>(value?: T): KnockoutObservable<T>;
}
interface KnockoutArrayEdit<T> {
    status: string;
    index?: number;
    moved?: number;
    value: T;
}
interface KnockoutCompareArrayOptions {
    sparse?: boolean;
    dontLimitMoves?: boolean;
}
interface KnockoutSubscribableStatic {
    fn: KnockoutSubscribable<any>;
    <T>(): KnockoutSubscribable<T>;
}
declare namespace ko {
    let observable: KnockoutObservableStatic;
    let computed: KnockoutComputedStatic;
    let pureComputed: KnockoutPureComputedStatic;
    let observableArray: KnockoutObservableArrayStatic;
    let subscribable: KnockoutSubscribableStatic;
    function isComputed<TV, TO extends KnockoutComputed<TV> = KnockoutComputed<TV>>(instance: TV | TO): instance is TO;
    function isPureComputed<TV, TO extends KnockoutReadOnlyObservableBase<TV> = KnockoutReadOnlyObservableBase<TV>>(instance: TV | TO): instance is TO;
    function isWritableObservable<TV, TO extends KnockoutObservable<TV> = KnockoutObservable<TV>>(instance: TV | TO): instance is TO;
}
declare namespace ko {
    function isObservable<TV, TO extends KnockoutObservableBase<TV> = KnockoutObservableBase<TV>>(instance: TV | TO): instance is TO;
    function isSubscribable<TV, TO extends KnockoutSubscribable<TV> = KnockoutSubscribable<TV>>(instance: TV | TO): instance is TO;
    namespace utils {
        function extend(target: any, source: any): any;
        function arrayForEach<T>(array: ArrayLike<T>, action: Action2<T, number>): void;
        function arrayIndexOf<T>(array: ArrayLike<T>, item: T): number;
        function arrayFirst<T, TOwner = void>(array: ArrayLike<T>, predicate: (this: TOwner, item: T, index: number) => boolean, predicateOwner?: TOwner): T;
        function arrayRemoveItem<T>(array: T[], itemToRemove: T): void;
        function arrayGetDistinctValues<T>(array: ArrayLike<T>): T[];
        function arrayMap<T, U>(array: ArrayLike<T>, mapping: Func2<T, number, U>): U[];
        function arrayFilter<T>(array: ArrayLike<T>, predicate: Func2<T, number, boolean>): T[];
        function arrayPushAll<T>(array: T[] | KnockoutObservableArray<T>, valuesToPush: ArrayLike<T>): KnockoutObservableArray<T> | T[];
        function unwrapObservable<T>(value: T | KnockoutObservableBase<T>): T;
        function peekObservable<T>(value: T | KnockoutObservableBase<T>): T;
    }
    namespace utils {
        function compareArrays<T>(oldArray: T[], newArray: T[], options?: boolean | KnockoutCompareArrayOptions): KnockoutArrayEdit<T>[];
    }
    export import unwrap = ko.utils.unwrapObservable;
    function toJS(rootObject: any): any;
    function toJSON(rootObject: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;
    const ignoreDependencies: <T>(callback: () => T, callbackTarget?: any, callbackArgs?: any[]) => T;
}

// FILE: MsPortalFx\MsPortalFxBegin.d.ts
declare let executeInDevelopmentModeOnly: Action1<Action>;
declare module FxImpl {
}
declare module MsPortalFx.Base {
    /**
     * An object that is disposable.
     */
    interface Disposable {
        /**
         * A function called on the object when it is disposed.
         */
        dispose(): void;
    }
    type ActionOrDisposable = Action | Disposable;
    interface RegisterForDisposeFunction {
        (disposables: ActionOrDisposable[]): LifetimeManagerBase;
        (disposable: ActionOrDisposable): LifetimeManagerBase;
    }
    /**
     * An object that can limit the lifetime of other objects. When a LifetimeManager object
     * is disposed, it will dispose all other objects that were registered for disposal.
     */
    interface LifetimeManagerBase {
        /**
         * Registers an object to be disposed.  It will throw if the object doesn't have dispose method.
         *
         * @param disposable An object to be disposed once the LifetimeManager object itself is disposed.
         */
        registerForDispose: RegisterForDisposeFunction;
    }
    interface LifetimeManager extends LifetimeManagerBase {
        /**
         * Create a createChildLifetime to localize the LifetimeManager.
         * It will provide the function on tracking who create it and when it dispose, it will remove itself from Container's lifetimeManager
         *
         */
        createChildLifetime(): DisposableLifetimeManager;
    }
    interface DisposableLifetimeManager extends Disposable, LifetimeManager {
        /**
         * A value indicating whether or not the lifetime is disposed.
         */
        isDisposed(): boolean;
    }
}

// FILE: MsPortalFx\MsPortalFxEnd.d.ts
declare module FxImpl {
    /**
     * Promise resolved when require config has been called and init scripts have been injected
     */
    const requireReady: Q.Promise<void>;
    function injectShellScripts(requireConfig: RequireConfig, shellRequireConfig: RequireConfig): void;
    function requireExtension(): void;
}

// FILE: AzureDataContracts.d.ts
declare module HubsExtension.AzureContracts {
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBase {
        /**
         * The resource entity id of the resource entity.
         */
        readonly id: string;
        /**
         * The name of the resource entity.
         */
        readonly name: string;
        /**
         * The location of the resource entity.
         */
        readonly location: string;
        /**
         * The tags of the resource entity.
         */
        readonly tags: ReadonlyStringMap<string>;
        /**
         * The properties of the resource entity.
         */
        readonly properties: ReadonlyStringMap<any>;
        /**
         * Is this resource group managed by another resource.
         */
        readonly managedBy?: string;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseWithStrings extends ResourceBase {
        /**
         * The location string for the resource group's location.
         */
        readonly locationString: string;
    }
    /**
     * The locked states enumeration provides named constants for the resource group.
         * DEPRECRATED 11/14/2018
     */
    type ResourceLockState = Obsolete;
    /**
     * Data model for a single resource group.
     */
    interface ResourceGroup extends ResourceBase {
        /**
         * The lock state of the resource group.
         * DEPRECRATED 11/14/2018
         */
        readonly lockState?: Obsolete;
        /**
         * The provisioning state of the resource group.
         */
        readonly provisioningState: string;
    }
    /**
     * Data model for a single resource group with the display strings.
     */
    interface ResourceGroupWithStrings extends ResourceGroup, ResourceBaseWithStrings {
    }
    /**
     * Data model for a single resource.
     */
    interface Resource extends ResourceBase {
        /**
         * The resource group ID of the resource.
         */
        readonly resourceGroup: string;
        /**
         * The type of the resource.
         */
        readonly type: string;
        /**
         * The resource type kind of the resource.
         */
        readonly kind?: string;
        /**
         * The self link URI of the resource.
         * DEPRECRATED 11/14/2018
         */
        readonly selfLinkUri?: Obsolete;
        /**
         * The zones of the resource entity.
         */
        readonly zones?: ReadonlyArray<string>;
        /**
         * The plan of the resource entity.
         */
        readonly plan?: ReadonlyStringMap<any>;
        /**
         * The sku of the resource entity.
         */
        readonly sku?: ReadonlyStringMap<any>;
        /**
         * The identity of the resource entity.
         */
        readonly identity?: ReadonlyStringMap<any>;
    }
    /**
     * Data model for a single resource with the display strings.
     */
    interface ResourceWithStrings extends Resource, ResourceBaseWithStrings {
        /**
         * The resource name without the parent resource if it's a nested resource.
         */
        readonly trimmedName: string;
    }
}

// FILE: MsPortalFx\Observables\AzureObservables.d.ts
declare module HubsExtension.Internal.Azure {
    import ResourceBase = HubsExtension.Azure.ResourceBase;
    import ActionEndPointDefinition = FxImpl.Rpc.ActionEndPointDefinition;
    /**
     * Endpoint for the hubs extension to communicate subscription changes to the shell.
     */
    let updateSubscriptionInfoEndPoint: ActionEndPointDefinition<readonly MsPortalFx.Azure.Subscription[]>;
    /**
     * Endpoint for the hubs extension to send resource provider information to the shell.
     */
    let getRegisteredResourceProviderInfoEndPoint: ActionEndPointDefinition<string[]>;
    /**
     * The interfaces of part gallery.
     */
    module PartGallery {
        /**
         * The data provider for the part gallery.
         */
        interface DataProvider {
            /**
             * Loads a resource group.
             */
            loadResourceGroup(subscriptionId: string, resourceGroupName: string, ignore404?: boolean): Q.Promise<ResourceBase>;
            /**
             * Creates a resource group.
             */
            createResourceGroup(subscriptionId: string, resourceGroupName: string, resourceGroupLocation: string): Q.Promise<ResourceBase>;
        }
    }
}
declare module HubsExtension.Azure {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxImage = FxBase.Image;
    /**
     * Data model for a single resource entity.
     */
    export import ResourceBase = HubsExtension.AzureContracts.ResourceBase;
    /**
     * Data model for a single resource entity.
     */
    export import ResourceBaseWithStrings = HubsExtension.AzureContracts.ResourceBaseWithStrings;
    /**
     * Data model for a single resource group.
     */
    export import ResourceGroup = HubsExtension.AzureContracts.ResourceGroup;
    /**
     * Data model for a single resource group with the display strings.
     */
    export import ResourceGroupWithStrings = HubsExtension.AzureContracts.ResourceGroupWithStrings;
    /**
     * Data model for a single resource.
     */
    export import Resource = HubsExtension.AzureContracts.Resource;
    /**
     * Data model for a single resource with the display strings.
     */
    export import ResourceWithStrings = HubsExtension.AzureContracts.ResourceWithStrings;
    /**
     * Data contract for a list of Azure values.
     */
    interface CollectionResponse<T> {
        /**
         * The list of objects of type T.
         */
        value: T[];
    }
    /**
     * Data contract for a list of Azure values with a continuation token.
     */
    interface ContinuationCollectionResponse<T> {
        /**
         * The list of objects of type T.
         */
        value: T[];
        /**
         * The optional continuation token.
         */
        token?: string;
    }
    /**
     * Data contract for Azure subscription policies.
     */
    class SubscriptionPolicies {
        /**
         * The subscription location placement id.
         */
        locationPlacementId: string;
        /**
         * The subscription quota id.
         */
        quotaId: string;
    }
    /**
     * Data model for tenant info.
     */
    class TenantInfo {
        /**
         * List of all tenants for the user.
         */
        tenants: Tenant[];
        /**
         * Whether the call to get tenants for the user failed.
         */
        failure: boolean;
    }
    /**
     * Data model for a tenant.
     */
    class Tenant {
        /**
         * Tenant id.
         */
        id: string;
        /**
         * The tenant domain name.
         */
        domainName: string;
        /**
         * The tenant display name.
         */
        displayName: string;
        /**
         * The tenant category.
         */
        tenantCategory: string;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseObservable {
        /**
         * The resource entity id of the resource entity.
         */
        readonly id: KnockoutObservableBase<string>;
        /**
         * The name of the resource entity.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The location of the resource entity.
         */
        readonly location: KnockoutObservableBase<string>;
        /**
         * The tags of the resource entity.
         */
        readonly tags: KnockoutObservableBase<ReadonlyStringMap<string>>;
        /**
         * The properties of the resource entity.
         */
        readonly properties: KnockoutObservableBase<ReadonlyStringMap<any>>;
        /**
         * Is this resource group managed by another resource.
         */
        readonly managedBy?: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseObservableWithStrings extends ResourceBaseObservable {
        /**
         * The location string for the resource group's location.
         */
        readonly locationString: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource group.
     */
    interface ResourceGroupObservable extends ResourceBaseObservable {
        /**
         * The provisioning state of the resource group.
         */
        readonly provisioningState: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource group with the display strings.
     */
    interface ResourceGroupObservableWithStrings extends ResourceGroupObservable, ResourceBaseObservableWithStrings {
    }
    /**
     * Data contract for a list of Azure resource groups.
     */
    interface ResourceGroupList {
        /**
         * The list of resource groups.
         */
        readonly resourceGroups: ReadonlyArray<ResourceGroup>;
    }
    /**
     * Data model for a single resource.
     */
    interface ResourceObservable extends ResourceBaseObservable {
        /**
         * The resource group ID of the resource.
         */
        readonly resourceGroup: KnockoutObservableBase<string>;
        /**
         * The type of the resource.
         */
        readonly type: KnockoutObservableBase<string>;
        /**
         * The resource type kind of the resource.
         */
        readonly kind?: KnockoutObservableBase<string>;
        /**
         * The zones of the resource entity.
         */
        readonly zones?: KnockoutObservableBase<ReadonlyArray<string>>;
        /**
         * The plan of the resource entity.
         */
        readonly plan?: KnockoutObservableBase<ReadonlyStringMap<any>>;
        /**
         * The plan of the resource entity.
         */
        readonly sku?: KnockoutObservableBase<ReadonlyStringMap<any>>;
        /**
         * The identity of the resource entity.
         */
        readonly identity?: KnockoutObservableBase<ReadonlyStringMap<any>>;
    }
    /**
     * Data model for a single resource with the display strings.
     */
    interface ResourceObservableWithStrings extends ResourceObservable, ResourceBaseObservableWithStrings {
        /**
         * The resource name without the parent resource if it's a nested resource.
         */
        readonly trimmedName: KnockoutObservableBase<string>;
    }
    /**
     * Data contract for a list of Azure resources.
     */
    interface ResourceList {
        /**
         * The list of resources.
         */
        readonly resources: ReadonlyArray<Resource>;
    }
    /**
     * The data model used by the region picker.
     */
    class RegionPickerDataModel {
        /**
         * The default parameter set.
         */
        regionPicker: {
            /**
             * The region id.
             */
            regionId: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the subscription picker.
     */
    class SubscriptionPickerDataModel {
        /**
         * The default parameter set.
         */
        subscriptionPicker: {
            /**
             * The subscription id.
             */
            subscriptionId: KnockoutObservable<string>;
            /**
             * The subscription name.
             */
            subscriptionName: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the create new resource group.
     */
    class ResourceGroupDataModel {
        /**
         * The default parameter set.
         */
        resourceGroup: {
            /**
             * The new resource group name.
             */
            resourceGroupName: KnockoutObservable<string>;
            /**
             * The subscription Id for the new resource group.
             */
            subscriptionId: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the resource group picker.
     */
    class ResourceGroupPickerDataModel {
        /**
         * The default parameter set.
         */
        resourceGroupPicker: {
            /**
             * The resource group name.
             */
            resourceGroupName: KnockoutObservable<string>;
            /**
             * The resource group location.
             */
            resourceGroupLocation: KnockoutObservable<string>;
            /**
             * The subscription Id for the resource group.
             */
            subscriptionId: KnockoutObservable<string>;
            /**
             * Flag to indicate new resource group or existing one.
             */
            isNewResourceGroup: KnockoutObservable<string>;
        };
    }
    module SpecPicker {
        import Forms = FxViewModels.Forms;
        import SpecPicker = HubsExtension.Azure.SpecPicker;
        const enum OriginControl {
            Unknown = 0,
            DropDown = 1,
            Selector = 2,
            InfoBox = 3
        }
        /**
         * Spec picker selection modes.
         */
        const enum SelectionMode {
            /**
             * Single selection.
             */
            Single = 0,
            /**
             * Multiple selection.
             */
            Multiple = 1
        }
        type ColorScheme = "" | "mediumBlue" | "darkOrchid" | "yellowGreen" | "orange";
        /**
         * Data contract for a spec.
         */
        interface Spec extends FxImpl.Composition.Selectable.Selectable2Options<FxImpl.Composition.Selectable.BladeReference<any>> {
            /**
             * The id.
             */
            id: string;
            /**
             * The spec code.
             */
            specCode: string;
            /**
             * The color scheme.
             */
            colorScheme: ColorScheme;
            /**
             * The title.
             */
            title: string;
            /**
             * The sub title.
             * This value will be displayed if there is not enough space for title in some container. e.g spec title in recommendation blade
             */
            shortTitle?: string;
            /**
             * The features.
             */
            features: Array<SpecPicker.Feature>;
            /**
             * The promoted features.
             */
            promotedFeatures: Array<SpecPicker.PromotedFeature>;
            /**
             * The spec cost.
             */
            cost: SpecPicker.SpecCost;
        }
        /**
         * Data contract for a Feature.
         */
        interface Feature {
            /**
             * The id.
             */
            id: string;
            /**
             * The display name.
             */
            displayName?: string;
            /**
             * The display value.
             */
            displayValue?: string | number;
            /**
             * The icon name.
             */
            iconName?: string;
            /**
             * The icon Svg Data.
             */
            iconSvgData?: string;
            /**
             * The icon image.
             */
            iconImage?: FxImage;
        }
        /**
         * Data contract for a Promoted Feature.
         */
        interface PromotedFeature {
            /**
             * The id.
             *
             * It can be set to lookup the promoted feature in partner extensions.
             * This id is optional. Since it isn't required by spec picker control.
             */
            id?: string;
            /**
             * The value.
             */
            value: string;
            /**
             * The unit description.
             */
            unitDescription: string;
        }
        /**
         * Data contract for a spec data.
         */
        interface SpecData {
            /**
             * The features.
             */
            features: SpecPicker.Feature[];
            /**
             * The specs.
             */
            specs: Array<SpecPicker.Spec>;
            /**
             * The resource map used for spec cost computation.
             * It's a mapping from regionId to array of resource quota set.
             */
            resourceMap?: StringMap<Pricing.SpecResourceSet[]>;
            /**
             * The list spec ids to allow zero cost.
             * This is a pre-defined list of specs that are allowed zero cost, to avoid displaying misleading billing information in UI. Make it required is to
             * enforce awareness of this parameter.
             *
             * 1) Sometimes a zero cost is computed by the billing backend for various reasons, either legitimate or not, for any spec card.
             * 2) There is a very strong design requirement that the spec picker should never show a zero unexpected.
             */
            specsToAllowZeroCost: string[];
            /**
             * The spec type. e.g. "Website", "VirtualMachine"
             * this value will be log to telemetry log
             */
            specType: string;
            /**
             * The common properties of reservation, should only be used by reservations.
             */
            reservationProperties?: Pricing.ReservationPropertiesDefinition;
            /**
             * The message will be displayed on the top of specPickerPart.
             */
            message?: string;
            /**
             * The message will be displayed on top of specPickerPart for Direct EA user.
             * If this message is not set, the default message is "Prices presented below are estimated retail prices and do not reflect applicable discounts
             * for your subscription. If you have purchased Azure services through a reseller, contact your reseller for applicable pricing."
             */
            messageForEA?: string;
            /**
             * The message will be displayed on top of specPickerPart for Indirect EA user.
             * If this message is not set, no message will be shown by default on top of specPickerPart.
             */
            messageForIndirectEA?: string;
            /**
             * The message will be displayed on the top of specPickerPart for Reseller user.
             * If this message is not set, no message will be shown by default on top of specPickerPart.
             */
            messageForReseller?: string;
        }
        /**
         * Data contract for spec picker blade parameter.
         * This contract defined all required properties to open spec picker blade.
         */
        interface SpecPickerBladeParameter {
            /**
             * The blade to open.
             */
            detailBlade: string;
            /**
             * The extension to open.
             */
            extension: string;
            /**
             * The selected spec id.
             * This parameter will be set to ProviderInputs.inputParameters.
             */
            selectedSpecId?: string;
            /**
             * The selected specs ids.
             * This parameter will be set to ProviderInputs.inputParameters.
             */
            selectedSpecIds?: string[];
            /**
             * If this property is set to true, it will show the recommended view by default.
             * If don't set this property, the default view is "View All spec"
             */
            selectRecommendedView?: boolean;
            /**
             * The subscription id.
             * This parameter will be set to ProviderInputs.options.
             */
            subscriptionId: string;
            /**
             * The region id.
             * This parameter will be set to ProviderInputs.options.
             */
            regionId: string;
            /**
             * The disabled specs. Will be used by spec picker part.
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "disabledSpecs" from extender view model.
             * If you don't provide a value and there is no "disabledSpecs" in extender view model, spec picker won't show disabled spec.
             */
            disabledSpecs?: DisabledSpec[];
            /**
             * The recommended spec ids.
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "recommendedSpecIds" from extender view model.
             * If you don't provide a value and there is no "recommendedSpecIds" in extender view model, spec picker won't show recommended specs.
             */
            recommendedSpecIds?: string[];
            /**
             * The recent spec ids. (future api)
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "recentSpecIds" from extender view model.
             * If you don't provide a value and there is no "recentSpecIds" in extender view model, spec picker won't show recent specs.
             * Currently not used for the spec picker, but used for the dropdown
             */
            recentSpecIds?: string[];
            /**
             * The options.
             * This parameter will be merge to ProviderInputs.options and this value will be passed to extender.
             */
            options?: any;
            /**
             * Whether to hide the cost or not.
             */
            hideCost?: boolean;
        }
        /**
         * Data contract for disabled spec.
         */
        interface DisabledSpec {
            /**
             * The disabled spec id.
             */
            specId: string;
            /**
             * The disabled message.
             * If you don't provide a value, the default message is "Not available".
             */
            message?: string;
            /**
             * The blade reference for disabled specs
             */
            supplyBladeReferenceAsync?: Func<FxBase.PromiseV<FxImpl.Composition.Selectable.BladeReference<any>>>;
            /**
             * The help balloon message.
             * If you don't provide a value, the help balloon won't display.
             */
            helpBalloonMessage?: string;
            /**
             * The help balloon link text.
             */
            helpBalloonLinkText?: string;
            /**
             * The help balloon link URI.
             */
            helpBalloonLinkUri?: string;
        }
        /**
         * Data contract for pricing tier display.
         */
        interface PricingTierDisplay extends PricingTierSpecDisplay {
            /**
             * The asset name.
             */
            assetName: string;
            /**
             * The part title.
             * If you don't provide a value, the default value is "Pricing tier".
             */
            partTitle?: string;
            /**
             * The feature icons.
             */
            featureIcons?: KnockoutObservableBase<any[]>;
            /**
             * The multi specs display object
             */
            specs?: KnockoutObservableBase<PricingTierSpecsDisplay[]>;
        }
        interface PricingTierSpecDisplay {
            /**
             * The spec code.
             * If you don't provide a value, the default value will get from spec card.
             */
            specCode?: string;
            /**
             * The first number.
             */
            firstNumber?: KnockoutObservableBase<any>;
            /**
             * The first text.
             */
            firstText?: KnockoutObservableBase<string>;
            /**
             * The second number.
             */
            secondNumber?: KnockoutObservableBase<any>;
            /**
             * The second text.
             */
            secondText?: KnockoutObservableBase<string>;
        }
        interface PricingTierSpecsDisplay extends PricingTierSpecDisplay {
            /**
             * The corresponding spec id
             * Must be provided to correlate spec display info
             */
            specId: string;
        }
        /**
         * Data contract for pricing tier launcher extender input.
         */
        interface PricingTierLauncherExtenderInput {
            /**
             * The entity id.
             */
            entityId?: any;
        }
        /**
         * Data contract for pricing tier launcher spec data.
         */
        interface PricingTierLauncherSpecData {
            /**
             * The features.
             */
            features: SpecPicker.Feature[];
            /**
             * The spec.
             */
            spec?: SpecPicker.Spec;
            /**
             * The specs.
             */
            specs?: SpecPicker.Spec[];
        }
        /**
         * Data contract for pricing tier launcher extender output.
         */
        interface PricingTierLauncherExtenderOutput {
            /**
             * The pricing tier display data
             */
            pricingTierDisplay: PricingTierDisplay;
            /**
             * The spec picker blade parameter.
             */
            specPickerBladeParameter: SpecPickerBladeParameter;
            /**
             * The spec data.
             */
            specData: SpecPicker.PricingTierLauncherSpecData;
            /**
             * The error message displayed by the Part when it has failed.
             */
            failureMessage?: string;
        }
        /**
         * Data contract or a pricing tier launcher extender.
         */
        interface PricingTierLauncherExtender {
            /**
             * The input from part view model to extender.
             */
            input: KnockoutObservableBase<PricingTierLauncherExtenderInput>;
            /**
             * The output from extender to part view model.
             */
            output: KnockoutObservableBase<PricingTierLauncherExtenderOutput>;
            /**
             * Save selected spec async.
             *
             * @param selected spec id.
             * @return A promise representing the completion of the operation.
             */
            saveSelectedSpecAsync?(selectedSpecId: string): FxBase.Promise;
            /**
             * Save selected specs async.
             *
             * @param selected specs ids.
             * @return A promise representing the completion of the operation.
             */
            saveSelectedSpecsAsync?(selectedSpecsIds: string[]): FxBase.Promise;
            /**
             * Checks to see if the current user has read permission to access pricing tier launcher part.
             *
             * @param entityId The entity to check for permissions. It will be null during creation.
             * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
             */
            hasReadPermision?(entityId: any): FxPromiseV<boolean>;
        }
        /**
         * Data contract for spec picker extender input.
         */
        interface SpecPickerExtenderInput {
            /**
             * The selected spec id.
             */
            selectedSpecId?: string;
            /**
             * The selected spec id.
             */
            selectedSpecIds?: string[];
            /**
             * Whether to hide the cost column or not
             */
            hideCost?: boolean;
            /**
             * The options.
             * This value will be passed from collector to provider part. And passed from provider part to extender.
             */
            options: any;
            /**
             * The specs made available to the spec picker extender
             */
            availableSpecData: KnockoutObservableBase<Spec[]>;
        }
        /**
         * Data contract for pricing tier launcher extender output.
         */
        interface SpecPickerExtenderOutput {
            /**
             * The spec data.
             */
            specData?: SpecPicker.SpecData;
            /**
             * The disabled specs.
             * If you don't provide a value, spec picker will try to get "disabledSpecs" from provider parameter.
             */
            disabledSpecs?: DisabledSpec[];
            /**
             * The recommended spec ids.
             */
            recommendedSpecIds?: string[];
            /**
             * The recent spec ids.
             */
            recentSpecIds?: string[];
            /**
             * The error message displayed by the Part when it has failed.
             */
            failureMessage?: string;
            /**
             * The specs passed through a filter
             */
            filteredSpecIds?: KnockoutComputed<string[]>;
        }
        /**
         * Data contract for spec picker extender.
         */
        interface SpecPickerExtender {
            /**
             * The input from part view model to extender.
             */
            input: KnockoutObservableBase<SpecPickerExtenderInput>;
            /**
             * The output from extender to part view model.
             */
            output: KnockoutObservableBase<SpecPickerExtenderOutput>;
            /**
             * Checks to see if the current user has permissions to access pricing tier launcher part.
             *
             * @param entityId The entity to check for permissions. It will be null during creation.
             * @param options The options from provider.
             * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
             */
            hasEditPermision?(entityId: any, options: any): FxPromiseV<boolean>;
            /**
             * The controls to be placed on the filter form
             */
            filterControls?: KnockoutObservableArray<FilterControl>;
            /**
             * The selection mode for the specPicker
             */
            selectionMode?: SelectionMode;
            /**
             * The message shown when there are no specs.
             */
            noSpecsMsg?: KnockoutObservableBase<string>;
        }
        /**
         * Controls allowed in the spec picker filter section
         */
        type FilterControl = Forms.Base.Slider.ViewModel<any> | Forms.TextBox.ViewModel | Forms.NumericTextBox.ViewModel | Forms.CheckBox.ViewModel | Forms.Base.EditableComboBox.ViewModel<any>;
        /**
         * Data contract for spec picker launcher part view model.
         */
        interface SpecPickerLauncherPartViewModel {
            /**
             * Get provider input.
             *
             * @param providerId The provider id.
             * @return A spec picker blade parameter.
             */
            getProviderInput(providerId: string): SpecPickerBladeParameter;
            /**
             * Update selected spec async.
             *
             * @param selectedSpecId The selected spec id.
             * @param selectedRecommendedView Shows if the recommended view was selected or not.
             * @return A promise representing the update selected spec request which will complete asynchronously.
             */
            updateSelectedSpecAsync?(selectedSpecId: string, selectedRecommendedView?: boolean): FxBase.Promise;
            /**
             * Update selected spec async.
             *
             * @param selectedSpecIds The selected specs ids.
             * @param selectedRecommendedView Shows if the recommended view was selected or not.
             * @return A promise representing the update selected spec request which will complete asynchronously.
             */
            updateSelectedSpecsAsync?(selectedSpecIds: string[], selectedRecommendedView?: boolean): FxBase.Promise;
        }
        /**
         * Data contract for a spec cost.
         * This cost is hard coded in spec data. Doesn't return from Billing API
         */
        interface SpecCost {
            /**
             * The amount.
             */
            amount?: number;
            /**
             * The currency code.
             */
            currencyCode?: string;
            /**
             * The caption.
             */
            caption: string;
            /**
             * The decimal precision of the price. Defaults to 2.
             */
            decimalPrecision?: number;
        }
        /**
         * Spec picker V3 data used in ParameterCollection flow
         */
        module ParameterCollectionV3 {
            /**
             * Spec picker V3 data sent from Collector to Provider and back from Provider to Collector.
             */
            interface SpecPickerProviderCollectorParameter {
                fromProviderToCollector: SpecPickerProviderCollectorParameterFromProvider;
                fromCollectorToProvider: SpecPickerProviderCollectorParameterFromCollector;
            }
            interface SpecPickerProviderCollectorParameterFromProvider {
                /**
                 * The selected spec id.
                 */
                selectedSpecId?: string;
                /**
                 * The selected specs ids.
                 */
                selectedSpecIds?: string[];
                /**
                 * Check if the recommended view should be shown by default.
                 */
                selectedRecommendedView: boolean;
            }
            interface SpecPickerProviderCollectorParameterFromCollector {
                /**
                 * The entity id.
                 */
                entityId: any;
                /**
                 * The selected spec id.
                 */
                selectedSpecId?: string;
                /**
                 * The selected specs ids.
                 */
                selectedSpecIds?: string[];
                /**
                 * The subscription id.
                 */
                subscriptionId: string;
                /**
                 * The region id.
                 */
                regionId: string;
                disabledSpecs: SpecPicker.DisabledSpec[];
                recommendedSpecIds: string[];
                recentSpecIds?: string[];
                /**
                 * Whether to hide the cost or not
                 */
                hideCost?: boolean;
                selectRecommendedView: boolean;
                options: StringMapPrimitive;
                /**
                 * A telemetry flag to determine which control or part was responsible for launching the spec picker.
                 */
                originControl?: SpecPicker.OriginControl;
            }
        }
    }
    module Lock {
        /**
         * The data contract for all information needed to check a lock on a resource
         */
        interface LockCheck {
            /**
             * The resource id to check
             */
            resourceId: string;
            /**
             * The level of the lock
             */
            lockLevel: LockType;
        }
        type LockType = "ReadOnly" | "CanNotDelete" | "";
    }
    module Pricing {
        import ResourceManager = MsPortalFx.Azure.ResourceManager;
        /**
         * Data contract for spec cost query input.
         */
        interface SpecCostQueryInput {
            /**
             * The subscription Id.
             */
            subscriptionId: string;
            /**
             * The list of spec resource sets.
             */
            specResourceSets: SpecResourceSet[];
            /**
             * The list spec ids to allow zero cost.
             * This is a pre-defined list of specs that are allowed zero cost, to avoid displaying misleading billing information in UI. Make it required is to
             * enforce awareness of this parameter.
             *
             * 1) Sometimes a zero cost is computed by the billing backend for various reasons, either legitimate or not, for any spec card.
             * 2) There is a very strong design requirement that the spec picker should never show a zero unexpected.
             */
            specsToAllowZeroCost: string[];
            /**
             * The spec type. e.g. "Website", "VirtualMachine"
             */
            specType?: string;
            /**
             * The common properties of reservation, should only be used by reservations.
             */
            reservationProperties?: ReservationPropertiesDefinition;
        }
        /**
         * Data contract for reservation properties
         */
        interface ReservationPropertiesDefinition {
            /**
             * The version of reservation. e.g. "1.0".
             */
            version: string;
        }
        /**
         * Data contract for a first party resource quota.
         */
        interface FirstPartyResource {
            /**
             * The round-tripped Id.
             */
            id?: string;
            /**
             * The MINT Resource Id (referred to as Resource GUID in some documentation).
             */
            resourceId: string;
            /**
             * The quantity of the resource.
             */
            quantity: number;
        }
        /**
         * Data contract for a resource quota set.
         */
        interface SpecResourceSet {
            /**
             * The spec id.
             */
            id: string;
            /**
             * This property is obsolete. Please use firstParty.
             */
            quotas?: FirstPartyResource[];
            /**
             * The first party quotas.
             */
            firstParty?: FirstPartyResource[];
            /**
             * The third party quotas.
             */
            thirdParty?: ThirdPartyResource[];
            /**
             * The reservation spec properties.
             */
            reservationSpecProperties?: ReservationSpecPropertiesDefinition;
        }
        /**
         * Data contract for reservation spec properties.
         */
        interface ReservationSpecPropertiesDefinition {
            /**
             * The reservation term.
             */
            term: string;
        }
        /**
         * Data contract for a third party resource.
         */
        interface ThirdPartyResource {
            /**
             * The round-tripped Id.
             */
            id?: string;
            /**
             * The resource publisher Id.
             */
            publisherId: string;
            /**
             * The resource offer Id.
             */
            offerId: string;
            /**
             * The resource plan Id.
             */
            planId: string;
            /**
             * The promotion code.
             */
            promotionCode: string;
            /**
             * The third party meters.
             */
            meters: ThirdPartyMeter[];
        }
        /**
         * Data contract for a third party meter.
         */
        interface ThirdPartyMeter {
            /**
             * The meter ID
             */
            meterId: string;
            /**
             * The meter quantity
             */
            quantity: number;
        }
        /**
         * Data contract for a third party resource and the quantity of that resource
         */
        interface CostEstimate {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The total monetary amount for this estimate
             * FirstParty + ThirdParty, but single currency
             */
            amount: number;
            /**
             * The billing currency code (e.g. USD)
             */
            currencyCode: string;
            /**
             * The status code for the individual spec cost
             */
            statusCode: SpecCostQueryResultSpecStatusCode;
            /**
             * The cost the first party resources
             */
            firstParty: CostEstimateResource[];
            /**
             * The cost the third party resources
             */
            thirdParty: CostEstimateResource[];
            /**
             * The availability id
             */
            availabilityId?: string;
        }
        /**
         * Data contract for a cost estimate resource.
         */
        interface CostEstimateResource {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The line level cost breakdown for the resource.
             */
            meters: CostEstimateMeter[];
            /**
             * Additional info about the third party plan / SKU. Null for 1st party resources and comes from the Ratings API
             * for 3rd party resources. Marked optional to avoid breaking older unit tests.
             */
            features?: ProductFeatures;
            /**
             * The per-term cost of purchasing this resource. Null for 1st party resources, and comes from the Ratings API
             * for 3rd party resources. Marked optional to avoid breaking older unit tests.
             */
            costPerTerm?: number;
            /**
             * A string indicating the length of the subscription period for this 3rd party resource.
             * An empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             * This value is not localized (it is set from a list of constant values hard coded in the data-market feed).
             * Marked optional to avoid breaking older unit tests.
             */
            term?: string;
        }
        /**
         * Describes whether the third party product has a free trial or is a bring-your-own-license offer.
         */
        interface ProductFeatures {
            /**
             * Indicates whether a 3rd party plan/SKU includes a free trial period.
             */
            hasFreeTrial: boolean;
            /**
             * Indicates whether a third party plan / SKU requires the user to buy a license externally.
             */
            bringYourOwnLicense: boolean;
        }
        /**
         * Data contract for a cost estimate meter.
         */
        interface CostEstimateMeter {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The monetary amount for this estimate
             * This is in the billing currency code, which is specified in the parent object.
             */
            amount: number;
            /**
             * The monetary amount per unit
             * This value is prorated for 1st party resources, and comes from the Ratings API for 3rd party resources
             */
            perUnitAmount: number;
            /**
             * The Per Unit currency code (e.g. USD)
             * This is the same as the billing currency code for 1st party resources, and comes from the Ratings API for 3rd party resources
             */
            perUnitCurrencyCode: string;
            /**
             * The localized unit. It's empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             */
            unit: string;
            /**
             * The name of the meter. Empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             * Marked optional to avoid breaking older unit tests.
             */
            name?: string;
            /**
             * Price rules describing the progressive pricing scheme for this meter. Meters which have one flat rate will have a single rule
             * with no upper/lower bound. Marked optional to avoid breaking older unit tests.
             */
            priceRules?: PriceRule[];
        }
        /**
         * An interval in a progressing pricing scheme.
         */
        interface PriceRule {
            /**
             * The lower bound for this interval. If this value is null, then there is no lower bound.
             */
            from: number;
            /**
             * The upper bound for this interval. If this value is null, then there is no upper bound.
             */
            to: number;
            /**
             * The cost for each unit of usage between from and to.
             * This is expressed in the PerUnitCurrencyCode currency code given by the parent CostEstimateMeter.
             */
            amount: number;
        }
        /**
         * Data contract for the spec cost query result.
         */
        interface SpecCostQueryResult {
            /**
             * Gets or sets a flag that indicates whether the costs were successfully returned.
             * Otherwise, a failure statusCode is returned.
             */
            isSuccess: boolean;
            /**
             * @deprecated SpecCostQueryResult.isEASubscription - Please use "channel" property instead of this. For backwards compatibility,
             * this will be set to true for channel === DirectEA and false for all other channels.
             *
             * Gets or sets a flag that indicates whether the cost is of enterprise agreement type.
             */
            isEASubscription: boolean;
            /**
             * Gets or sets the channel.
             */
            channel: string;
            /**
             * Gets or sets the list of the list of cost estimates.
             */
            costs: CostEstimate[];
            /**
             * Gets or sets the status code.
             */
            statusCode: Pricing.SpecCostQueryResultStatusCode;
            /**
             * Gets or sets the SpecCostQueryResult version.
             */
            version: string;
        }
        /**
         * Constants for gallery pricing.
         */
        module Constants {
            /**
             * Constants for the gallery pricing summary blade.
             */
            let PricingSummaryBlade: {
                displayText: string;
                bladeName: string;
                bladeExtension: string;
            };
            /**
             * Constants for the gallery legal terms blade.
             */
            let LegalTermsBlade: {
                bladeName: string;
                bladeExtension: string;
            };
            /**
             * Constants for the channel type.
             */
            let ChannelType: {
                directEA: string;
                indirectEA: string;
                unknownEA: string;
                direct: string;
                csp: string;
            };
        }
        /**
         * Gallery create pricing information model.
         */
        interface PricingInfo {
            /**
             * The subscription id.
             */
            subscriptionId: string;
            /**
             * The pricing tier selections made by the user.
             */
            pricingTierSelections: PricingTierSelection[];
            /**
             * The usage-based resources selected by the user.
             */
            usageBasedResources: UsageBasedResource[];
            /**
             * Gallery item products with pricing information.
             */
            products?: ResourceManager.GalleryItemProduct[];
            /**
             * Gallery item products with no pricing information.
             */
            productsWithNoPricing?: ResourceManager.GalleryItemProduct[];
            /**
             * Optional. Shows the "Pin to Startboard" checkbox on the legal terms blade.
             */
            showPinToStartboardCheckbox?: boolean;
        }
        /**
         * Pricing tier selection model.
         */
        interface PricingTierSelection {
            /**
             * The pricing tier id.
             */
            pricingTierId: string;
            /**
             * The pricing tier display name.
             */
            pricingTierDisplayName: string;
            /**
             * The number of instances.
             */
            instanceCount: number;
            /**
             * The calculated unit display name.
             */
            unitDisplayName: string;
            /**
             * The spec resource set.
             */
            specResourceSet: SpecResourceSet;
            /**
             * The specs allowed to have zero as a possible cost amount.
             */
            specsToAllowZeroCost: string[];
        }
        /**
         * Usage-based resource model.
         */
        interface UsageBasedResource {
            /**
             * The resource display name.
             */
            resourceDisplayName: string;
            /**
             * The resource type display name.
             */
            resourceTypeDisplayName: string;
            /**
             * The number of instances.
             */
            instanceCount: number;
        }
        /**
         * Status code for the GetSpecsCosts result
         * The corresponding C# enum is CostEstimateOverallStatusCode
         */
        const enum SpecCostQueryResultStatusCode {
            /**
             * Costing data was successfully returned.
             */
            Success = 0,
            /**
             * Costing data is not available.
             */
            CostDataNotAvailable = 1,
            /**
             * Batch mode request error-ed for some items.
             */
            Partial = 2,
            /**
             * Batch mode request error-ed for all items.
             */
            BatchFailed = 3,
            /**
             * Auth failure.
             */
            AuthFailure = 4,
            /**
             * An unexpected exception was thrown by the subscription provider component. Check logs for details.
             */
            SubscriptionException = 5,
            /**
             * User&apos; subscription was not found.
             */
            SubscriptionNotFound = 6,
            /**
             * User&apos; subscription is not active.
             */
            SubscriptionNotActive = 7,
            /**
             * Subscription data is invalid.
             */
            SubscriptionIsInvalid = 8,
            /**
             * Not supported in billing region.
             */
            NotSupportedInBillingRegion = 9,
            /**
             * Pricing is not available for this subscription.
             */
            SubscriptionPricingUnavailable = 10,
            /**
             * Pricing is available as retail when EA is requested
             */
            SuccessAsRetailForEa = 12,
            /**
             * Spec is not supported in the current environment, e.g. Mooncake, Blackforest
             */
            NotSupportedInCurrentEnvironment = 13,
            /**
             * Pricing is available as retail when new EA is requested
             */
            SuccessAsRetailForNewEa = 14
        }
        /**
         * Status code for the GetSpecsCosts result
         * The corresponding C# enum is CostEstimateOverallStatusCode
         */
        const enum SpecCostQueryResultSpecStatusCode {
            /**
             * Costing data was successfully returned.
             */
            Success = 0,
            /**
             * Error retrieving price
             */
            PricingException = 1,
            /**
             * Spec not supported in region
             */
            NotSupportedInBillingRegion = 2,
            /**
             * Spec not available for subscription
             */
            NotAvailableForSubscription = 3,
            /**
             * Spec returns for retail but not ea
             */
            SuccessAsRetailForEa = 4,
            /**
             * Meter doesn't exist, do not display
             */
            MeterNotFound = 5,
            /**
             * Spec returns for retail but not ea. (New ea subscription case)
             */
            SuccessAsRetailForNewEa = 6
        }
    }
    /**
     * The resource type cache type.
     */
    type ResourceTypeCache = StringMap<ResourceTypeMetadata>;
    /**
     * The resource type metadata from the server.
     */
    interface ResourceTypeMetadata {
        /**
         * The name of the resource type.
         */
        resourceType: string;
        /**
         * The list of capabilities supported by the type.
         * Note: This is a comma separated list of capabilities
         * Example: "CrossResourceGroupResourceMove, CrossSubscriptionResourceMove"
         */
        capabilities: string;
    }
}

// FILE: MsPortalFx\Parts\PartColor.d.ts
declare module MsPortalFx.Parts {
    enum PartColor {
        /**
         * The default theme color.
         */
        Theme = 0,
        /**
         * Blue.
         */
        Blue = 1,
        /**
         * Green.
         */
        Green = 2,
        /**
         * Orange.
         */
        Orange = 3,
        /**
         * Pink.
         */
        Pink = 4,
        /**
         * Purple.
         */
        Purple = 5,
        /**
         * Azure.
         */
        Azure = 6,
        /**
         * Dark.
         */
        Dark = 7,
        /**
         * Red.
         */
        Red = 8
    }
}

// FILE: MsPortalFx\Parts\PartKind.d.ts
declare module MsPortalFx.Parts {
    enum PartKind {
        /**
         * Custom part that requires a provided template
         */
        Custom = 0,
        /**
         * Part to show the summary of a collection.
         */
        CollectionSummary = 1,
        /**
         * Part to show the summary of an item.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        ItemSummary = 4,
        /**
         * Part to display a Settings control.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        Settings = 7,
        /**
         * Part to display a SingleSetting control.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        SingleSetting = 8,
        /**
         * Part to display a LogStream control.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        LogStream = 11,
        /**
         * Part to display a Grid control.
         */
        Grid = 14,
        /**
         * Part to display a document Editor.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        Editor = 15,
        /**
         * Part to display a document DiffEditor.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        DiffEditor = 16,
        /**
         * Part used for provisioning an asset.
         */
        Provisioning = 17,
        /**
         * Built-in part that displays unavailable UI.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        Unavailable = 18,
        /**
         * Part to show the summary of a collection.
         */
        Button = 20,
        /**
         * Part used to launch a quick start blade.
         */
        QuickStart = 21,
        /**
         * Part used to represent an asset.
         */
        Asset = 22,
        /**
         * Part used to show documentation or getting started information.
         */
        InfoList = 23,
        /**
         * Part used to show a list of properties.
         */
        Properties = 24,
        /**
         * Part used to display a collection of records with an optional rollup.
         */
        Collection = 25,
        /**
         * Part used to display a Chart control.
         */
        Chart = 26,
        /**
         * Part used to display a single value gauge with optional metrics.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        SingleValueGauge = 27,
        /**
         * Part used to display a Donut control.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        Donut = 28,
        /**
         * Part used to display a quota gauge with optional metrics.
         *
         * @deprecated This part is no longer supported. Use a custom part instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        QuotaGauge = 29,
        /**
         * Part used to show the resource summary.
         *
         * @deprecated This part is no longer supported. Use Essentials control instead.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        ResourceSummary = 30,
        /**
         * Part used to render a web page inside an iframe.
         */
        Frame = 31,
        /**
         * Part that displays an extension error.
         */
        _Internal_Error = 997,
        /**
         * Part used to render an AppBlade.
         */
        _Internal_App = 998,
        /**
         * Part that hosts an AzBlade/AzPart (a web page inside a visible iframe) without loading an extension.
         */
        _Internal_Az = 999,
        /**
         * Part that hosts a ReactView/ReactPart (a react view inside a visible iframe).
         */
        _Internal_React = 1000
    }
}

// FILE: MsPortalFx\Parts\PartSize.d.ts
declare module MsPortalFx.Parts {
    const enum PartSize {
        /**
         * A tile that is 1 column x 1 row.
         */
        Mini = 0,
        /**
         * A tile that is 2 columns x 1 row.
         */
        Small = 1,
        /**
         * A tile that is 2 columns x 2 rows.
         */
        Normal = 2,
        /**
         * A tile that is 4 columns x 2 rows.
         */
        Wide = 3,
        /**
         * A tile that is 2 columns x 4 rows.
         */
        Tall = 4,
        /**
         * A tile that is 6 columns x 4 rows.
         */
        HeroWide = 5,
        /**
         * A tile that is 4 columns x 6 rows.
         */
        HeroTall = 6,
        /**
         * A tile that is 6 columns by unbounded rows that fits the content.
         */
        HeroWideFitHeight = 7,
        /**
         * A tile that expands all the available columns by unbounded rows that fits the content.
         */
        FullWidthFitHeight = 8,
        /**
         * A tile that fits all the available space of the content area it occupies.
         */
        FitToContainer = 9,
        /**
         * A tile that is 4 columns x 4 rows.
         */
        Large = 10,
        /**
         * A tile that is 6 columns x 6 rows.
         */
        Hero = 11,
        /**
         * A tile with a custom size.
         */
        Custom = 99
    }
}

// FILE: MsPortalFx\Parts\PartSizeHelper.d.ts
declare module MsPortalFx.Parts {
    enum InternalPartSize {
        Mini = 0,
        Small = 1,
        Normal = 2,
        Wide = 3,
        Tall = 4,
        HeroWide = 5,
        HeroTall = 6,
        HeroWideFitHeight = 7,
        FullWidthFitHeight = 8,
        FitToContainer = 9,
        Large = 10,
        Hero = 11,
        Custom = 99
    }
}

// FILE: MsPortalFx\Parts\PartState.d.ts
declare module MsPortalFx.Parts {
    /**
     * Reflects the overall state of a Part, which determines whether or not it can be bound and displayed on the screen.
     */
    enum PartState {
        /**
         * The Part ready to be bound and displayed.
         */
        Ready = 0,
        /**
         * The Part is in a failed state where it cannot be bound and displayed. Instead, the user will see an error.
         */
        Failed = 1
    }
}

// FILE: MsPortalFx\Parts\ResizeMode.d.ts
declare module MsPortalFx.Parts {
    const enum ResizeMode {
        /**
         * Default mode. Resizes based on an optional set of fixed sizes.
         */
        Fixed = 0,
        /**
         * Resizes programmatically based on extension requesting size change.
         */
        Programmatic = 1,
        /**
         * Resizes based on user interaction.
         */
        User = 2
    }
}

// FILE: MsPortalFx\Polyfills\array.d.ts
interface ReadOnlyArrayPolyfills<T> {
    /**
     * @deprecated ReadOnlyArrayPolyfills.concatUnique Please use MsPortalFx.union instead.
     */
    concatUnique(this: ReadonlyArray<T>, other: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * @deprecated ReadOnlyArrayPolyfills.first Please use MsPortalFx.find instead.
     */
    first(this: ReadonlyArray<T>, predicate?: (value: T) => boolean, startIndex?: number): T;
    /**
     * @deprecated ReadOnlyArrayPolyfills.firstIndex Please use MsPortalFx.findIndex instead.
     */
    firstIndex(this: ReadonlyArray<T>, predicate?: (value: T) => boolean, startIndex?: number): number;
    /**
     * Determines whether an array includes a specific element.
     *
     * @param searchElement The element to search for.
     * @param startIndex The starting index. If negative, the search will start at array.length - startIndex.
     *
     * @return True if the element is in the array, false otherwise.
     */
    includes(this: ReadonlyArray<T>, searchElement: T, startIndex?: number): boolean;
    /**
     * @deprecated ReadOnlyArrayPolyfills.last Please use MsPortalFx.last instead.
     */
    last(this: ReadonlyArray<T>): T;
    /**
     * @deprecated ReadOnlyArrayPolyfills.mapMany Please use MsPortalFx.mapMany instead.
     */
    mapMany<U>(this: ReadonlyArray<T>, selector: (source: T) => ReadonlyArray<U>): U[];
    /**
     * @deprecated ReadOnlyArrayPolyfills.stableSort Please use MsPortalFx.stableSort instead.
     */
    stableSort(this: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[];
    /**
     * @deprecated ReadOnlyArrayPolyfills.unique Please use MsPortalFx.unique instead.
     */
    unique(this: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
}
interface ReadonlyArray<T> extends ReadOnlyArrayPolyfills<T> {
}
interface ArrayPolyfills<T> extends ReadOnlyArrayPolyfills<T> {
    /**
     * @deprecated ArrayPolyfills.concatUnique Please use MsPortalFx.union instead.
     */
    concatUnique(this: T[], other: T[], predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * @deprecated ArrayPolyfills.remove Please use MsPortalFx.remove instead.
     */
    remove(this: T[], item: T): T[];
}
interface Array<T> extends ArrayPolyfills<T> {
}
/**
 * Returns a negative, zero or a positive number if its first
 * parameter is smaller, equal or greater than its second parameter
 * respectively.
 */
interface Comparator<T> {
    (a: T, b: T): number;
}
declare module MsPortalFx {
    /**
     * Detect a value is undefined.
     *
     *  @param unchangePropertyName : this.unchangePropertyName be unchange after invoke this call back function
     *  @param functionsMap : The functionsMap to look up for this method to be invokec.  Typically is a prototype object.  Array.prototype.
     *  @param functionName : The functionName to look up in functionName.
     *
     *  @return the new function: typeof functionsMap[functionName].  This is good for monkey patch for this method.
     */
    let getAssertSameInCallFunc: (unchangePropertyName: string, functionsMap: StringMap<(...args: any[]) => any>, fucntionName: string) => ((...args: any[]) => any);
}

// FILE: MsPortalFx\Polyfills\date.d.ts
interface Date {
    toString(value: MsPortalFx.Intl.DateTimeFormatOptions): string;
    /**
     * Calculates date for first day of the week for the date.
     *
     * @param firstDayOfWeek 0 - Sunday, 1 - Monday, ..., 6 - Saturday.
     *
     * @return date object representing the first day of the week for the date
     */
    getFirstDayOfWeek(firstDayOfWeek?: number): Date;
}
declare interface DateConstructor {
    getLocaleValues: () => any;
    setLocaleValues: (def?: any) => void;
}
declare module MsPortalFx {
    function getLocaleValues(): {
        days: string[];
        daysAbbr: string[];
        months: string[];
        monthsAbbr: string[];
        ampm: string[];
        ampmAbbr: string[];
        dateSeparator: string;
        timeSeparator: string;
        standard: {
            d: string;
            D: string;
            f: string;
            F: string;
            g: string;
            G: string;
            m: string;
            M: string;
            r: string;
            R: string;
            s: string;
            t: string;
            T: string;
            u: string;
            y: string;
            Y: string;
        };
        firstDayOfWeek: number;
    };
    function setLocaleValues(def?: any): void;
    function getDateToStringFunc(): (format?: string | MsPortalFx.Intl.DateTimeFormatOptions) => string;
    function dateParse(value: string): number;
}

// FILE: MsPortalFx\Polyfills\string.d.ts
interface StringPolyfills {
    /**
     * Formats a string based on its key value pair object.
     *
     * @param args The list of arguments format arguments. For example: "String with params {0} and {1}".format("val1", "val2");.
     * @return Formatted string.
     */
    format(this: string, ...restArgs: any[]): string;
    /**
     * Formats a string based on its key value pair object.
     *
     * @param formatSpecifierMap An object that contains that format mappings. For example: "String with parameters {one} and {two}".format({one: "val1", two: "val2"});.
     * @param tokenEncoder If specified, this callback will be used to produce a string representation of the tokens being injected into the string.
     * @return Formatted string.
     */
    format(this: string, formatSpecifierMap: Object, tokenFormatter?: (tokenValue: any) => string): string;
    /**
     * Determines whether a string is contained completely within another string, case sensitively.
     *
     * @param searchString The string to search for within the given string.
     * @param startIndex The starting index. If negative, the search starts at index 0. If greater than str.lenth,
     *      the search starts at str.length.
     *
     * @return True if the search string is found within the given string, false otherwise.
     */
    includes(this: string, searchString: string, startIndex?: number): boolean;
    /**
     * @deprecated StringPolyfillsPlease.localeCompareIgnoreCase use MsPortalFx.localeCompareIgnoreCase instead.
     */
    localeCompareIgnoreCase(this: string, value: string, locales?: string[], options?: any): number;
    /**
     * @deprecated StringPolyfillsPlease.replaceAll use MsPortalFx.replaceAll instead.
     */
    replaceAll(this: string, searchValue: string, replaceValue: string): string;
    /**
     * @deprecated StringPolyfillsPlease.replaceMany use MsPortalFx.replaceMany instead.
     */
    replaceMany(this: string, replacementMap: StringMap<string>): string;
    /**
     * @deprecated StringPolyfillsPlease.repeat use MsPortalFx.repeat instead.
     */
    repeat(this: string, count: number): string;
    /**
     * @deprecated StringPolyfillsPlease.startsWith use MsPortalFx.startsWith instead.
     */
    startsWith(this: string, searchString: string, position?: number): boolean;
    /**
     * @deprecated StringPolyfillsPlease.endsWith use MsPortalFx.endsWith instead.
     */
    endsWith(this: string, searchString: string, position?: number): boolean;
}
interface String extends StringPolyfills {
}
declare module MsPortalFx {
}

// FILE: MsPortalFx\Q\Q.d.ts
/**
 * If value is a Q promise, returns the promise.
 * If value is a promise from another library it is coerced into a Q promise (where possible).
 */
declare function Q<T>(promise: Q.IPromise<T>): Q.Promise<T>;
/**
 * If value is a Q promise, returns the promise.
 * If value is a promise from another library it is coerced into a Q promise (where possible).
 */
declare function Q<T>(promise: JQueryPromise): Q.Promise<T>;
/**
 * If value is not a promise, returns a promise that is fulfilled with value.
 */
declare function Q<T = void>(value?: T | Q.IPromise<T>): Q.Promise<T>;
declare module Q {
    interface QPromiseLike<T> {
        then<U>(onFulfill: (value: T) => U | QPromiseLike<U>, onReject?: (reason: any) => any): QPromiseLike<U>;
    }
    type IPromise<T> = QPromiseLike<T> | PromiseLike<T>;
    type QPromiseState = "fulfilled" | "rejected" | "pending";
    interface PromiseState<T> {
        /**
         * "fulfilled", "rejected", "pending"
         */
        state: QPromiseState;
        value?: T;
        reason?: any;
    }
    interface Promise<T = void> {
        /**
         * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
         * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed until the promise returned from callback is finished.
         */
        fin(finallyCallback: () => any): Promise<T>;
        /**
         * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
         * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed until the promise returned from callback is finished.
         */
        finally(finallyCallback: () => any): Promise<T>;
        /**
         * The then method from the Promises/A+ specification, with an additional progress handler.
         */
        then<TResult>(onFulfill: (value: T) => TResult | IPromise<TResult> | Promise<never>, onReject?: (reason: any) => TResult | IPromise<TResult>, onProgress?: Function): Promise<TResult>;
        then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value?: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null, onProgress?: Function): Promise<TResult1 | TResult2>;
        /**
         * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
         *
         * This is especially useful in conjunction with all
         */
        spread<U>(onFulfilled: Function, onRejected?: Function): Promise<U>;
        fail<U>(onRejected: (reason: any) => U | IPromise<U>): Promise<U>;
        /**
         * A sugar method, equivalent to promise.then(undefined, onRejected).
         */
        catch(onRejected: (reason: any) => T | Promise<T> | never | Promise<never>): Promise<T>;
        catch(onRejected: (reason: any) => void): Promise<T>;
        catch<TResult>(onRejected: (reason: any) => TResult | IPromise<TResult> | Promise<never>): Promise<T | TResult>;
        catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
        /**
         * A sugar method, equivalent to promise.then(undefined, undefined, onProgress).
         */
        progress(onProgress: (progress: any) => any): Promise<T>;
        /**
         * Much like then, but with different behavior around unhandled rejection. If there is an unhandled rejection, either because promise is rejected and no onRejected callback was provided, or because onFulfilled or onRejected threw an error or returned a rejected promise, the resulting rejection reason is thrown as an exception in a future turn of the event loop.
         *
         * This method should be used to terminate chains of promises that will not be passed elsewhere. Since exceptions thrown in then callbacks are consumed and transformed into rejections, exceptions at the end of the chain are easy to accidentally, silently ignore. By arranging for the exception to be thrown in a future turn of the event loop, so that it won't be caught, it causes an onerror event on the browser window, or an uncaughtException event on Node.js's process object.
         *
         * Exceptions thrown by done will have long stack traces, if Q.longStackSupport is set to true. If Q.onerror is set, exceptions will be delivered there instead of thrown in a future turn.
         *
         * The Golden Rule of done vs. then usage is: either return your promise to someone else, or if the chain ends with you, call done to terminate it.
         */
        done<U>(onFulfilled?: (value: T) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>, onProgress?: (progress: any) => any): void;
        /**
         * Returns a promise to get the named property of an object. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     return o[propertyName];
         * });
         */
        get<U>(propertyName: string): Promise<U>;
        set(propertyName: string, value: any): Promise<void>;
        delete(propertyName: string): Promise<void>;
        /**
         * Returns a promise for the result of calling the named method of an object with the given array of arguments. The object itself is this in the function, just like a synchronous method call. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     return o[methodName].apply(o, args);
         * });
         */
        post<U>(methodName: string, args: any[]): Promise<U>;
        /**
         * Returns a promise for the result of calling the named method of an object with the given variadic arguments. The object itself is this in the function, just like a synchronous method call.
         */
        invoke<U>(methodName: string, ...args: any[]): Promise<U>;
        /**
         * Returns a promise for an array of the property names of an object. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     return Object.keys(o);
         * });
         */
        keys(): Promise<string[]>;
        /**
         * A sugar method, equivalent to promise.then(function () { return value; }).
         */
        thenResolve<U>(value: U): Promise<U>;
        /**
         * A sugar method, equivalent to promise.then(function () { throw reason; }).
         */
        thenReject(reason: any): Promise<T>;
        timeout(ms: number, message?: string | Error): Promise<T>;
        /**
         * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
         */
        delay(ms: number): Promise<T>;
        /**
         * Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always true.
         */
        isFulfilled(): boolean;
        /**
         * Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always false.
         */
        isRejected(): boolean;
        /**
         * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
         */
        isPending(): boolean;
        valueOf(): any;
        /**
         * Returns a "state snapshot" object, which will be in one of three forms:
         *
         * - { state: "pending" }
         * - { state: "fulfilled", value: <fulfllment value> }
         * - { state: "rejected", reason: <rejection reason> }
         */
        inspect(): PromiseState<T>;
    }
    interface PromiseArray2<T1, T2> extends Promise<[T1, T2]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2) => U | IPromise<U>, onRejected?: Function): Promise<U>;
    }
    interface PromiseArray3<T1, T2, T3> extends Promise<[T1, T2, T3]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2, t3: T3) => U | IPromise<U>, onRejected?: Function): Promise<U>;
    }
    interface PromiseArray4<T1, T2, T3, T4> extends Promise<[T1, T2, T3, T4]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4) => U | IPromise<U>, onRejected?: Function): Promise<U>;
    }
    interface PromiseArray5<T1, T2, T3, T4, T5> extends Promise<[T1, T2, T3, T4, T5]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => U | IPromise<U>, onRejected?: Function): Promise<U>;
    }
    interface Deferred<T> {
        promise: Promise<T>;
        resolve(value?: T | Q.Promise<T>): void;
        reject(reason?: any): void;
        notify(value?: any): void;
    }
    /**
     * Promisify a value and apply onFulfilled, onRejected and onProgress callbacks
     */
    function when<T>(value: IPromise<T>): Promise<T>;
    function when<T>(value: T): Promise<T>;
    function when<T, U>(value: IPromise<T>, onFulfilled: (val: T) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>, onProgress?: (progress: any) => any): Promise<U>;
    function when<T, U>(value: T, onFulfilled: (val: T) => U | IPromise<U>): Promise<U>;
    /**
     * Function call
     */
    function fcall<T>(method: (...args: any[]) => T | IPromise<T>, ...args: any[]): Promise<T>;
    /**
     * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
     */
    function any<T>(promises: IPromise<T>[]): Promise<T>;
    /**
     * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
     */
    function any<T>(promises: any[]): Promise<T>;
    /**
     * A sugar method, equivalent to promise.then(undefined, undefined, onProgress).
     */
    function progress<T>(promise: Promise<T>, onProgress: Function): Promise<unknown>;
    /**
     * Calls a method on a promise object
     */
    function post(promise: any, methodName: String, args: any[]): any;
    /**
     * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
     */
    function all<T1, T2>(promises: [IPromise<T1>, IPromise<T2>]): PromiseArray2<T1, T2>;
    function all<T1, T2, T3>(promises: [IPromise<T1>, IPromise<T2>, IPromise<T3>]): PromiseArray3<T1, T2, T3>;
    function all<T1, T2, T3, T4>(promises: [IPromise<T1>, IPromise<T2>, IPromise<T3>, IPromise<T4>]): PromiseArray4<T1, T2, T3, T4>;
    function all<T1, T2, T3, T4, T5>(promises: [IPromise<T1>, IPromise<T2>, IPromise<T3>, IPromise<T4>, IPromise<T5>]): PromiseArray5<T1, T2, T3, T4, T5>;
    function all<T>(promises: IPromise<T>[]): Promise<T[]>;
    /**
     * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
     */
    function all<T = void>(promises: any[]): Promise<T[]>;
    /**
     * Returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected.
     */
    function allSettled<T>(promises: IPromise<T>[]): Promise<PromiseState<T>[]>;
    /**
     * Returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected.
     */
    function allSettled<T>(promises: any[]): Promise<PromiseState<T>[]>;
    /**
     * Returns a promise that is fulfilled with the original array of promises, but only after all the original promises have settled, i.e. become either fulfilled or rejected.
     */
    function allResolved<T>(promises: IPromise<T>[]): Promise<Promise<T>[]>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, U>(promises: [T1 | IPromise<T1>, T2 | IPromise<T2>], onFulfilled: (t1: T1, t2: T2) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>): Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, U>(promises: [T1 | IPromise<T1>, T2 | IPromise<T2>, T3 | IPromise<T3>], onFulfilled: (t1: T1, t2: T2, t3: T3) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>): Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, U>(promises: [T1 | IPromise<T1>, T2 | IPromise<T2>, T3 | IPromise<T3>, T4 | IPromise<T4>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>): Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, T5, U>(promises: [T1 | IPromise<T1>, T2 | IPromise<T2>, T3 | IPromise<T3>, T4 | IPromise<T4>, T5 | IPromise<T5>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>): Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, T5, T6, U>(promises: [T1 | IPromise<T1>, T2 | IPromise<T2>, T3 | IPromise<T3>, T4 | IPromise<T4>, T5 | IPromise<T5>, T6 | IPromise<T6>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>): Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, T5, T6, T7, U>(promises: [T1 | IPromise<T1>, T2 | IPromise<T2>, T3 | IPromise<T3>, T4 | IPromise<T4>, T5 | IPromise<T5>, T6 | IPromise<T6>, T7 | IPromise<T7>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>): Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T, U>(promises: (T | IPromise<T>)[], onFulfilled: (...args: T[]) => U | IPromise<U>, onRejected?: (reason: any) => U | IPromise<U>): Promise<U>;
    /**
     * Returns a promise that will have the same result as promise, except that if promise is not fulfilled or rejected before ms milliseconds, the returned promise will be rejected with an Error with the given message. If message is not supplied, the message will be "Timed out after " + ms + " ms".
     */
    function timeout<T>(promise: Promise<T>, ms: number, message?: string | Error): Promise<T>;
    /**
     * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
     */
    function delay<T>(promise: Promise<T> | number, ms?: number): Promise<T>;
    /**
     * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
     */
    function delay<T>(value: T | number, ms?: number): Promise<T>;
    /**
     * Returns a promise that will be fulfilled with undefined after at least ms milliseconds have passed.
     */
    function delay(ms: number): Promise<void>;
    /**
     * Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always true.
     */
    function isFulfilled(promise: any): boolean;
    /**
     * Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always false.
     */
    function isRejected(promise: Promise<any>): boolean;
    /**
     * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
     */
    function isPending(promise: Promise<any>): boolean;
    /**
     * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
     */
    function isPending(obj: any): boolean;
    /**
     * Returns a "deferred" object with a:
     * promise property
     * resolve(value) method
     * reject(reason) method
     * notify(value) method
     */
    function defer<T = void>(): Deferred<T>;
    /**
     * Returns a promise that is rejected with reason.
     */
    function reject<T = never>(reason?: any): Promise<T>;
    /**
     * Apply callbacks to a new Q promise
     */
    function promise<T>(resolver: (resolve: (val: T | IPromise<T>) => void, reject: (reason: any) => void, notify: (progress: any) => void) => void): Promise<T>;
    /**
     * Apply callbacks to a new Q promise
     */
    function Promise<T>(resolver: (resolve: (val: T | IPromise<T>) => void, reject: (reason: any) => void, notify: (progress: any) => void) => void): Promise<T>;
    /**
     * Returns whether the given value is a Q promise.
     */
    function isPromise(obj: any): boolean;
    /**
     * Returns whether the given value is a promise (i.e. it's an object with a then function).
     */
    function isPromiseAlike(obj: any): boolean;
    /**
     * This is an experimental tool for converting a generator function into a deferred function. This has the potential of reducing nested callbacks in engines that support yield.
     */
    function nextTick(callback: Function): void;
    /**
     * A settable property that will intercept any uncaught errors that would otherwise be thrown in the next tick of the event loop, usually as a result of done. Can be useful for getting the full stack trace of an error in browsers, which is not usually possible with window.onerror.
     */
    let onerror: (reason: any) => void;
    /**
     * A settable property that lets you turn on long stack trace support. If turned on, "stack jumps" will be tracked across asynchronous promise operations, so that if an uncaught error is thrown by done or a rejection reason's stack property is inspected in a rejection callback, a long stack trace is produced.
     */
    let longStackSupport: boolean;
    /**
     * Returns the list of errors that were not handled.
     */
    function getUnhandledReasons(): string[];
    /**
     * Clears the list of errors that were not handled.
     * NOTE: Q.d.ts said it returns something, but the implementation never did.
     */
    function resetUnhandledRejections(): void;
    /**
     * Calling resolve with a pending promise causes promise to wait on the passed promise, becoming fulfilled with its fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).
     * Calling resolve with a rejected promise causes promise to be rejected with the passed promise's rejection reason.
     * Calling resolve with a fulfilled promise causes promise to be fulfilled with the passed promise's fulfillment value.
     * Calling resolve with a non-promise value causes promise to be fulfilled with that value.
     */
    function resolve<T>(obj: IPromise<T> | T): Promise<T>;
}

// FILE: MsPortalFx\RequireMetadata.d.ts
declare module FxImpl {
    const RequireMetadata: {
        [moduleId: string]: string[];
    };
}

// FILE: Strings.d.ts
declare namespace MsPortalFx.Resources {
    const Strings: {
        readonly Azure: {
            readonly BaseResourceDropDown: {
                readonly creatingResourcedDisabledValidationMessage: string;
                readonly searchingValidationMessage: string;
            };
            readonly Legal: {
                readonly LegalTermsSelector: {
                    readonly legalTermsAcceptedMessage: string;
                    readonly legalTermsLabel: string;
                    readonly legalTermsMessage: string;
                };
            };
            readonly Locations: {
                readonly DropDown: {
                    readonly defaultLabel: string;
                    readonly emptyMessage: string;
                    readonly group: string;
                    readonly groupBubble: string;
                    readonly groupOther: string;
                    readonly groupOtherBubble: string;
                    readonly groupRecommended: string;
                    readonly groupRecommendedBubble: string;
                    readonly groupServiceProvided: string;
                    readonly groupServiceProvidedBubble: string;
                };
            };
            readonly ResourceGroups: {
                readonly DropDown: {
                    readonly ProvisioningStateValidation: {
                        readonly baseMessage: string;
                        readonly deleted: string;
                        readonly deleting: string;
                        readonly movingresources: string;
                    };
                    readonly createNewAriaLabel: string;
                    readonly defaultAriaLabel: string;
                    readonly defaultLabel: string;
                    readonly description: string;
                    readonly lockedValidationMessage: string;
                    readonly name: string;
                    readonly noOptions: string;
                    readonly requiredPermissionsValidationMessage: string;
                    readonly useExistingAriaLabel: string;
                };
                readonly InfoBalloon: {
                    readonly linkText: string;
                    readonly text: string;
                };
            };
            readonly ResourceManager: {
                readonly Provisioner: {
                    readonly ArmValidation: {
                        readonly networkFailure: string;
                        readonly validationFailed: string;
                    };
                    readonly pricingSummaryLinkLabel: string;
                    readonly seeTemplateLink: string;
                };
            };
            readonly Subscriptions: {
                readonly DropDown: {
                    readonly defaultLabel: string;
                    readonly disabledSubscriptionValidationMessage: string;
                    readonly globalSubscriptionFilter: string;
                    readonly onlyShowingSelectedSubsMessage: string;
                    readonly requiredPermissionsValidationMessage: string;
                    readonly showingSelectedSubsMessagePrefix: string;
                    readonly showingSelectedSubsMessageSuffix: string;
                    readonly subCantRegisterWithRP: string;
                    readonly subDisallowedRP: string;
                    readonly subscriptionNotAllowedForGalleryItemValidationMessage: string;
                    readonly tooManyToDisplay: string;
                    readonly unknownTenant: string;
                };
            };
            readonly Validators: {
                readonly RequiredPermission: {
                    readonly message: string;
                };
                readonly ReservedResourceName: {
                    readonly message: string;
                };
            };
            readonly errorMessageWithCode: string;
            readonly errorMessageWithTarget: string;
            readonly unknownErrorOccured: string;
        };
        readonly Chart: {
            readonly noDataMessage: string;
        };
        readonly CoreGrid: {
            readonly loading: string;
            readonly noData: string;
        };
        readonly DatePolyfill: {
            readonly AgoStrings: {
                readonly aDay: string;
                readonly aMinute: string;
                readonly aMonth: string;
                readonly aWeek: string;
                readonly aYear: string;
                readonly anHour: string;
                readonly days: string;
                readonly hours: string;
                readonly lessThanAMinute: string;
                readonly minutes: string;
                readonly months: string;
                readonly weeks: string;
                readonly years: string;
            };
            readonly Days: {
                readonly friday: string;
                readonly monday: string;
                readonly saturday: string;
                readonly sunday: string;
                readonly thursday: string;
                readonly tuesday: string;
                readonly wednesday: string;
            };
            readonly DaysAbbr: {
                readonly friday: string;
                readonly monday: string;
                readonly saturday: string;
                readonly sunday: string;
                readonly thursday: string;
                readonly tuesday: string;
                readonly wednesday: string;
            };
            readonly Months: {
                readonly april: string;
                readonly august: string;
                readonly december: string;
                readonly february: string;
                readonly january: string;
                readonly july: string;
                readonly june: string;
                readonly march: string;
                readonly may: string;
                readonly november: string;
                readonly october: string;
                readonly september: string;
            };
            readonly MonthsAbbr: {
                readonly april: string;
                readonly august: string;
                readonly december: string;
                readonly february: string;
                readonly january: string;
                readonly july: string;
                readonly june: string;
                readonly march: string;
                readonly may: string;
                readonly november: string;
                readonly october: string;
                readonly september: string;
            };
        };
        readonly DeleteAssetConfirmation: {
            readonly affectedItemsLabel: string;
            readonly assetNameValidationFailureMessage: string;
            readonly bladeTitle: string;
            readonly confirmationLabel: string;
            readonly warningText: string;
        };
        readonly DeleteCommand: {
            readonly Confirmation: {
                readonly message: string;
                readonly title: string;
            };
            readonly Failure: {
                readonly message: string;
                readonly title: string;
            };
        };
        readonly EditableGrid: {
            readonly deleteCommandText: string;
            readonly insertCommandText: string;
            readonly moveBottomCommandText: string;
            readonly moveDownCommandText: string;
            readonly moveTopCommandText: string;
            readonly moveUpCommandText: string;
        };
        readonly FileDownload: {
            readonly unauthorizedText: string;
        };
        readonly FileDownloadCommand: {
            readonly authTokenNotAvailable: string;
            readonly fileDownloadErrorStatus: string;
        };
        readonly FileUpload: {
            readonly dragAndDropFiles: string;
            readonly notReady: string;
            readonly notSupported: string;
        };
        readonly HeatMap: {
            readonly noUnitsMessage: string;
        };
        readonly NumericTextBox: {
            readonly invalidText: string;
        };
        readonly Part: {
            readonly Chart: {
                readonly editButtonText: string;
            };
            readonly PropertiesPart: {
                readonly changeLabel: string;
                readonly changeResourceGroupLabel: string;
                readonly changeSubscriptionLabel: string;
            };
            readonly Provisioning: {
                readonly description: string;
            };
            readonly Quickstart: {
                readonly title: string;
            };
            readonly ResourceSummary: {
                readonly locationPropertyLabel: string;
                readonly notAvailable: string;
                readonly resourceGroupPropertyLabel: string;
                readonly statusPropertyLabel: string;
                readonly subscriptionIdPropertyLabel: string;
                readonly subscriptionNamePropertyLabel: string;
            };
            readonly SettingList: {
                readonly Group: {
                    readonly general: string;
                    readonly monitoring: string;
                    readonly resourceManagement: string;
                    readonly settings: string;
                    readonly support: string;
                };
                readonly Keyword: {
                    readonly events: string;
                    readonly insights: string;
                    readonly logs: string;
                };
                readonly Keywords: {
                    readonly eventLogs: string;
                    readonly exportTemplate: string;
                    readonly helpRequest: string;
                    readonly quotas: string;
                    readonly resourceAdvisor: string;
                    readonly resourceHealth: string;
                    readonly troubleshoot: string;
                };
                readonly access: string;
                readonly accessControl: string;
                readonly accessDetails: string;
                readonly eventLogs: string;
                readonly exportTemplate: string;
                readonly helpRequest: string;
                readonly locks: string;
                readonly locksForSubscriptions: string;
                readonly properties: string;
                readonly quotas: string;
                readonly resourceAdvisor: string;
                readonly resourceGroups: string;
                readonly resourceHealth: string;
                readonly resourceProviders: string;
                readonly resources: string;
                readonly roles: string;
                readonly searchBoxPlaceholder: string;
                readonly subCerts: string;
                readonly tags: string;
                readonly troubleshoot: string;
                readonly users: string;
            };
        };
        readonly Pickers: {
            readonly AccessDenied: {
                readonly reasonMessage: string;
            };
            readonly Specs: {
                readonly DropDown: {
                    readonly available: string;
                    readonly labelFormatter: string;
                    readonly labelLinkText: string;
                    readonly recent: string;
                    readonly recommended: string;
                    readonly title: string;
                };
                readonly pricingTier: string;
            };
        };
        readonly ResourceGroup: {
            readonly Validation: {
                readonly alreadyExistsMessage: string;
                readonly invalidMessage: string;
                readonly lengthValidationMessage: string;
                readonly subscriptionHasNoPermissionsMessage: string;
            };
        };
        readonly Services: {
            readonly AssetHandler: {
                readonly assetTypeGridColumn: string;
                readonly titleGridColumn: string;
            };
            readonly Gallery: {
                readonly viewPricingSummaryLabel: string;
            };
        };
        readonly Toolbar: {
            readonly FeedbackButton: {
                readonly title: string;
            };
            readonly MoveButton: {
                readonly resourcegroup: string;
                readonly subscription: string;
                readonly title: string;
            };
        };
        readonly UnitConversion: {
            readonly billion: string;
            readonly billionPerSecond: string;
            readonly bytes: string;
            readonly bytesPerDay: string;
            readonly bytesPerHour: string;
            readonly bytesPerMinute: string;
            readonly bytesPerSecond: string;
            readonly countPerDay: string;
            readonly countPerHour: string;
            readonly countPerMinute: string;
            readonly countPerSecond: string;
            readonly days: string;
            readonly gigabytes: string;
            readonly gigabytesPerSecond: string;
            readonly gigabytesPerSecondSI: string;
            readonly gigabytesSI: string;
            readonly hours: string;
            readonly kilobytes: string;
            readonly kilobytesPerSecond: string;
            readonly kilobytesPerSecondSI: string;
            readonly kilobytesSI: string;
            readonly megabytes: string;
            readonly megabytesPerSecond: string;
            readonly megabytesPerSecondSI: string;
            readonly megabytesSI: string;
            readonly microSeconds: string;
            readonly milliSeconds: string;
            readonly million: string;
            readonly millionPerSecond: string;
            readonly minutes: string;
            readonly percentage: string;
            readonly petabytes: string;
            readonly petabytesPerSecond: string;
            readonly petabytesPerSecondSI: string;
            readonly petabytesSI: string;
            readonly seconds: string;
            readonly terabytes: string;
            readonly terabytesPerSecond: string;
            readonly terabytesPerSecondSI: string;
            readonly terabytesSI: string;
            readonly thousand: string;
            readonly thousandPerSecond: string;
            readonly trillion: string;
            readonly trillionPerSecond: string;
        };
        readonly ViewModels: {
            readonly Container: {
                readonly networkError: string;
                readonly networkErrorDetails: string;
                readonly notFound: string;
                readonly unauthorizedText: string;
                readonly unexpectedError: string;
            };
            readonly Controls: {
                readonly CreatorAndComboBox: {
                    readonly createNew: string;
                    readonly newItemText: string;
                    readonly selectExisting: string;
                    readonly useExisting: string;
                };
                readonly CreatorAndSelector: {
                    readonly createNew: string;
                    readonly selectExisting: string;
                    readonly useExisting: string;
                };
                readonly ResourceGroups: {
                    readonly createNew: string;
                    readonly selectExisting: string;
                };
                readonly button: string;
                readonly calendar: string;
                readonly fileUpload: string;
                readonly noRowsMessage: string;
                readonly search: string;
                readonly selector: string;
            };
            readonly Toolbar: {
                readonly noAccess: string;
            };
        };
    };
}

// FILE: MsPortalFx\Services\Services.AssetHandler.d.ts
declare module MsPortalFx.Services {
    /**
     * The asset expansion class provides several helpers for asset expanding regular value to asset values.
     *
     * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
     * no code in FX will use this.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module AssetExpansion {
        /**
         * Gets the prefix of all the asset expansion properties.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetDetailsPropertyPrefix: Obsolete;
        /**
         * Gets the name of the asset details expanded property.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetDetailsPropertyName: Obsolete;
        /**
         * Gets the name of the asset title expanded property.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const titlePropertyName: Obsolete;
        /**
         * Gets the name of the asset description expanded property.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const descriptionPropertyName: Obsolete;
        /**
         * Gets the name of the asset icon expanded property.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const iconPropertyName: Obsolete;
        /**
         * Gets the name of the asset type string expanded property.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetTypeStringPropertyName: Obsolete;
        /**
         * Gets the name of the asset ID expanded property.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetIdPropertyName: Obsolete;
        /**
         * Checks if the given value has been asset expanded.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param value The value to check.
         * @return true if the value has been asset expanded, else null.
         */
        function isAssetExpanded(value: any): Obsolete;
        /**
         * Gets the asset expansion from the given value.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param value The value to use.
         * @return The asset expansion if the value was asset expanded, otherwise returns null.
         */
        function getAssetExpansion(value: any): Obsolete;
        /**
         * Adds an asset expansion to the given value.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param value The value to expand.
         * @param assetDetails The asset expansion.
         * @return The value that was expanded.
         */
        function addAssetExpansion(value: any, assetDetails: AssetDetails): Obsolete;
        /**
         * Removes the asset expansion from the give value.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param value The value to unexpand.
         */
        function removeAssetExpansion(value: any): Obsolete;
    }
    /**
     * The asset details provides information about the asset.
     *
     * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type AssetDetails = Obsolete;
    /**
     * Asset expands an item.
     *
     * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * @param item The item to be cloned and asset expanded.
     * @param mapFunc The mapping function to asset expand the items in the source data set.
     * @param context An opaque context object which is passed to the mapping function as the second parameter.
     * @return The cloned and asset expanded item.
     */
    function assetExpandItem<T>(item: T, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): Obsolete;
    /**
     * Asset expands an item and adds the result to the observable result set.
     *
     * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * @param item The item to be cloned, asset expanded and added to the result set.
     * @param results The observable result set.
     * @param mapFunc The mapping function to asset expand the items in the source data set.
     * @param context An opaque context object which is passed to the mapping function as the second parameter.
     * @return The cloned and asset expanded item.
     */
    function assetExpandItemAndAddToResultSet<T>(item: T, results: KnockoutObservableArray<any>, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): Obsolete;
    /**
     * The data set asset expansion mapper is used to watch a data set (typed observable array) and push asset expanded
     * values to a result set (untyped observable array).
     */
    module DataSetAssetExpansionMapper {
        /**
         * Connects a dataset to a set of results with a mapper and a cancellation flag.
         *
         * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param lifetime The LifetimeManager for this observable to react to data set.
         * @param dataSet The source data set (typed observable array).
         * @param results The result set (untyped observable array).
         * @param mapFunc The mapping function to asset expand the items in the source data set.
         * @param context An opaque context object which is passed to the mapping function as the second parameter.
         * @return The knockout subscription for the connection (used to dispose on cancel).
         */
        function connectDataSet<T>(lifetimeManager: MsPortalFx.Base.LifetimeManager, dataSet: KnockoutObservableArray<T>, results: KnockoutObservableArray<any>, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): Obsolete;
    }
}

// FILE: MsPortalFx\Services\Services.Data.d.ts
declare module MsPortalFx.Services {
    /**
     * The data set subscription is used to watch a data set (typed observable array) and call callback functions for
     * insert/remove as values change.  The insert/remove callbacks include the include (handles 'sort' issues) and
     * helps maintain value order if copying the data set into another data set.
     */
    class DataSetSubscription {
        /**
         * Subscribes to a dataset to a set of results with callbacks for insert/remove.
         *
         * @param lifetimeManager  the lifetime of the subscription
         * @param sourceDataSet The source data set (typed observable array).
         * @param insertFunc The insert function.
         * @param removeFun The remove function.
         * @param context An opaque context object which is passed to the callback functions as the context parameter.
         * @return a disposable lifetime Manager on the source data set must be disposed when complete.
         */
        static subscribeDataSet<T>(lifetimeManager: MsPortalFx.Base.LifetimeManager, sourceDataSet: KnockoutObservableArray<T>, insertFunc?: (value: T, index: number, context?: any) => void, removeFunc?: (value: T, index: number, context?: any) => void, context?: any): MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Inserts an item into the destination data set at the given index.
         *
         * @param destinationDataSet The destination data set.
         * @param value The value to insert.
         * @param index The index in the data set where to insert the value.
         */
        static insertItem<T>(destinationDataSet: KnockoutObservableArray<T>, value: T, index: number): void;
        /**
         * Removes an item from the destination data set at the given index.
         *
         * @param destinationDataSet The destination data set.
         * @param value The value to remove.
         * @param index The index in the data set where to remove the value.
         */
        static removeItem<T>(destinationDataSet: KnockoutObservableArray<T>, value: T, index: number): void;
    }
}

// FILE: MsPortalFx\Services\Services.GalleryService.d.ts
declare module MsPortalFx.Services.Gallery {
    import FxGalleryService = MsPortalFx.Services.Gallery;
    import AzureResourceManager = MsPortalFx.Azure.ResourceManager;
    let noSubCreateCategoryId: string;
    /**
     * Constants for the gallery.
     */
    module Constants {
        /**
         * Constants for the gallery create parameters.
         */
        let GalleryParametersKey: string;
        /**
         * Constants for the gallery create options.
         */
        let GalleryOptionsKey: string;
    }
    /**
     * The interface for the gallery service view model.
     */
    interface GalleryServiceContract {
        /**
         * Runs a gallery create pre-check before launching the create flow. This enables extensions
         * to run a pre-check on the create flow and launch an alternative blade instead.
         *
         * @param galleryItem The gallery item that the create flow belongs to.
         * @return A Jquery promise that is always resolved, either with the dynamic blade selection
         *      object or null.
         */
        galleryCreatePreCheck(galleryItem: GalleryItem): MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicBladeSelection>;
    }
    /**
     * The base gallery service view model.
     */
    class BaseGalleryServiceViewModel implements FxGalleryService.GalleryServiceContract {
        /**
         * Runs a gallery create pre-check before launching the create flow. This enables extensions
         * to run a pre-check on the create flow and launch an alternative blade instead.
         *
         * @param galleryItem The gallery item that the create flow belongs to.
         * @return A Jquery promise that is always resolved, either with the dynamic blade selection
         *      object or null.
         */
        galleryCreatePreCheck(galleryItem: FxGalleryService.GalleryItem): MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicBladeSelection>;
    }
    /**
     * Gallery item model.
     */
    interface GalleryItem extends StringMap<any> {
        /**
         * The Identity of the gallery item.
         */
        identity: string;
        /**
         * The Publisher name.
         */
        publisher: string;
        /**
         * Gets or sets Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * Gets or sets item name.
         */
        itemName: string;
        /**
         * Gets or sets item type.
         */
        itemType?: string;
        /**
         * The item display name.
         */
        itemDisplayName: string;
        /**
         * The item version.
         */
        version: string;
        /**
         * The item summary.
         */
        summary: string;
        /**
         * The item long summary.
         */
        longSummary?: string;
        /**
         * The item description.
         */
        description: string;
        /**
         * The resource group name the gallery item belongs to.
         */
        resourceGroupName: string;
        /**
         * The uri to the ui definition file.
         */
        uiDefinitionUri: string;
        /**
         * The item artifacts, includes the CSM templates.
         */
        artifacts: Artifact[];
        /**
         * The list of category IDs the gallery item belongs to.
         */
        categoryIds: string[];
        /**
         * The list of screenshot image Uris provided for the item.
         */
        screenshotUris: string[];
        /**
         * The list of Links provided for the item.
         */
        links: LinkProperties[];
        /**
         * The dictionary of icon image Uris by icon type.
         */
        iconFileUris: StringMap<string>;
        /**
         * The dictionary of additional properties to be displayed.
         */
        properties?: StringMap<string>;
        /**
         * Gallery item products.
         */
        products?: AzureResourceManager.GalleryItemProduct[];
        /**
         * The marketing material used to link to other marketing portals.
         */
        marketingMaterial?: MarketingMaterial;
        /**
         * The dictionary of metadata properties to be used by the extension.
         */
        metadata?: StringMap<string>;
        /**
         * Indicates if the package is currently in preview.
         */
        isPreview?: boolean;
    }
    /**
     * The artifact type.
     */
    enum ArtifactType {
        /**
         * Template artifact type, used by CSM.
         */
        template = 0,
        /**
         * Fragment artifact type, used by CSM.
         */
        fragment = 1,
        /**
         * Custom artifact, consumed by the extension ownner.
         */
        custom = 3,
        /**
         * Metadata artifact, consumed by the extension ownner.
         */
        metadata = 4
    }
    /**
     * Gallery artifact model.
     */
    interface Artifact {
        /**
         * The artifact name.
         */
        name: string;
        /**
         * The URI to the artifact file.
         */
        uri: string;
        /**
         * The artifact type.
         */
        type: string;
    }
    /**
     * The artifact type.
     */
    interface MarketingMaterial {
        /**
         * The path to the marketing material.
         */
        path: string;
    }
    /**
     * Link properties model.
     */
    interface LinkProperties {
        /**
         * The id of the link.
         */
        id: string;
        /**
         * The display name of the link.
         */
        displayName: string;
        /**
         * The URI of the link.
         */
        uri: string;
    }
    /**
     * Gallery product (offer) model.
     * @deprecated GalleryItemProduct - Use MsPortalFx.Azure.ResourceManager.GalleryItemProduct instead.
     */
    interface GalleryItemProduct extends AzureResourceManager.GalleryItemProduct {
    }
    /**
     * Gallery offer pricing details model.
     * Used to retrieve the pricing information for a gallery offer.
     * @deprecated GalleryItemOfferPricingDetails - Use MsPortalFx.Azure.ResourceManager.GalleryItemOfferPricingDetails instead.
     */
    interface GalleryItemOfferPricingDetails extends AzureResourceManager.GalleryItemOfferPricingDetails {
    }
    /**
     * Gallery offer plan.
     * @deprecated GalleryItemOfferPlan - Use MsPortalFx.Azure.ResourceManager.GalleryItemOfferPlan instead.
     */
    interface GalleryItemOfferPlan extends AzureResourceManager.GalleryItemOfferPlan {
    }
    /**
     * The model for gallery parameters. All values must be strings.
     */
    interface GalleryParameters {
        /**
         * The selected CSM template id.
         */
        selectedTemplateId: string;
        /**
         * The inline deployment template JSON.
         */
        templateJson: string;
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * An array of the resource types being created.
         * Use JSON.stringify() to convert the string[] into a string.
         */
        resourceProviders: string;
        /**
         * The resource id for the primary resource to be created.
         */
        primaryResourceId?: string;
        /**
         * The deployment name.
         */
        deploymentName?: string;
    }
    /**
     * The base gallery data model. The parameter collection data model on the UI
     * elements (forms, wizards, etc.) used for gallery create should extend this.
     */
    class GalleryDataModel {
        /**
         * The gallery deployment parameters.
         */
        galleryParameters: {
            /**
             * The selected CSM template id.
             */
            selectedTemplateId: KnockoutObservable<string>;
            /**
             * The inline deployment template JSON.
             */
            templateJson: KnockoutObservable<string>;
            /**
             * The subscription id.
             */
            subscriptionId: KnockoutObservable<string>;
            /**
             * The resource group name.
             */
            resourceGroupName: KnockoutObservable<string>;
            /**
             * The location/region.
             */
            resourceGroupLocation: KnockoutObservable<string>;
            /**
             * An array of the resource types being created.
             * Use JSON.stringify() to convert the string[] into a string.
             */
            resourceProviders: KnockoutObservable<string>;
            /**
             * The resource id for the primary resource to be created.
             */
            primaryResourceId: KnockoutObservable<string>;
            /**
             * The deployment name.
             */
            deploymentName: KnockoutObservable<string>;
        };
    }
    /**
     * The context from which a gallery create is kicked off.
     * @deprecated LaunchingContext - Use MsPortalFx.Azure.ResourceManager.LaunchingContext instead.
     */
    interface LaunchingContext extends AzureResourceManager.LaunchingContext {
    }
    /**
     * Gallery item information extracted from the gallery item and passed over to the extension.
     * @deprecated GalleryItemExtract - Use MsPortalFx.Azure.ResourceManager.GalleryItemExtract instead.
     */
    interface GalleryItemExtract extends AzureResourceManager.GalleryItemExtract {
    }
}

// FILE: MsPortalFx\Services\Services.GeneralSettings.d.ts
declare module MsPortalFx.Services {
    import FxBase = MsPortalFx.Base;
    interface IGeneralSettings extends StringMap<KnockoutObservableBase<any>> {
        /**
         * Current theme.
         */
        "fxs-theme": KnockoutReadOnlyObservableBase<FxBase.Themes.Theme>;
    }
    /**
     * Get general settings from Shell
     */
    function getSettings(): Base.PromiseV<IGeneralSettings>;
}

// FILE: MsPortalFx\Services\Services.Images.d.ts
declare module MsPortalFx.Services.Image {
    /**
     *  Datatype used for rendering SVGs.
     */
    function newImageData(kind: SvgType, options?: any): MsPortalFx.Base.Image;
    /**
     * List of available SVG's.
     */
    const enum SvgType {
        Blank = 0,
        Custom = 1,
        ImageUri = 2,
        ActiveDirectory = 3,
        Add = 4,
        BadgeError = 6,
        BadgeNone = 7,
        BadgeSuccess = 8,
        BadgeWarning = 9,
        Book = 10,
        Bug = 11,
        Check = 12,
        CloudService = 13,
        Controls = 14,
        Cubes = 15,
        Database = 16,
        Delete = 17,
        Discard = 19,
        Download = 20,
        Filter = 22,
        FolderBlank = 23,
        FolderCube = 24,
        FolderWebsite = 25,
        Ftp = 26,
        Gear = 27,
        Grid = 28,
        Guide = 29,
        Heart = 30,
        Hyperlink = 31,
        Info = 32,
        JourneyHub = 33,
        Key = 34,
        Link = 35,
        Location = 36,
        Lock = 37,
        Media = 38,
        MediaFile = 39,
        Mobile = 40,
        Monitoring = 41,
        Notification = 42,
        Pending = 43,
        Person = 44,
        PersonWithFriend = 45,
        Pin = 46,
        Powershell = 47,
        Properties = 48,
        Question = 49,
        Refresh = 51,
        Save = 52,
        Search = 53,
        SearchGrid = 54,
        ShellClose = 55,
        ShellCollapse = 56,
        ShellDefaultBlade = 57,
        ShellMaximize = 58,
        ShellRestore = 59,
        SslCustomDomains = 60,
        Start = 61,
        Stop = 62,
        Storage = 63,
        Store = 64,
        Subtract = 65,
        Swap = 66,
        TeamProject = 67,
        Toolbox = 68,
        Unlock = 69,
        Unpin = 70,
        VirtualMachine = 71,
        Website = 72,
        WebsitePower = 73,
        Canceled = 74,
        Clock = 75,
        Error = 77,
        InfoAlert = 78,
        Paused = 79,
        Queued = 80,
        AddTeamMember = 82,
        Attachment = 83,
        AvatarDefault = 84,
        AvatarUnknown = 85,
        Backlog = 86,
        BacklogPoly = 87,
        BadgePending = 88,
        BadgeCanceled = 89,
        BadgeDisabled = 90,
        BadgeUnknown = 91,
        BillingHub = 92,
        Builds = 93,
        Code = 94,
        CodePoly = 95,
        Commit = 96,
        CommitPoly = 97,
        Disable = 98,
        Edit = 99,
        Favorite = 101,
        File = 102,
        GearFlat = 103,
        GetMoreLicense = 104,
        GetStarted = 105,
        Go = 108,
        History = 109,
        Inactive = 110,
        Log = 112,
        Pause = 113,
        Postpone = 114,
        Release = 115,
        Request = 116,
        Retain = 117,
        Scale = 118,
        Tasks = 119,
        Triangle = 120,
        Upload = 121,
        UnknownBadge = 122,
        CreateHub = 125,
        BrowseHub = 126,
        HomeHub = 127,
        JourneysHub = 128,
        AlertsHub = 129,
        Help = 130,
        BadgeStopped = 131,
        Connect = 132,
        Disconnect = 133,
        PolyAppInsights = 135,
        PolyAvailabilitySet = 136,
        PolyBackup = 137,
        PolyBrowser = 138,
        PolyCustomDomain = 139,
        PolyGlobe = 140,
        PolyIpAddress = 141,
        PolyLaunchPortal = 142,
        PolyLoadBalancer = 143,
        PolyLoadTest = 144,
        PolyLog = 145,
        PolyLogDiagnostics = 146,
        PolyLogStreaming = 147,
        PolyNetworkInterfaceCard = 148,
        PolyResourceDefault = 149,
        PolyResourceLinked = 150,
        PolyServerFarm = 151,
        PolySqlDataBaseServer = 152,
        PolyTfsVcRepository = 153,
        PolyWebHosting = 154,
        PolyWebsiteStaging = 155,
        PolyWebTest = 156,
        Redo = 157,
        ShellChevron = 158,
        Tools = 159,
        Wrench = 160,
        AzureQuickstart = 161,
        Publish = 162,
        PolyAutomation = 164,
        PolySqlDatabase = 165,
        PolyTrafficManager = 166,
        PolyWebEnvironment = 167,
        PolyWebJobs = 168,
        ShellDots = 169,
        BadgeErrorOutline = 170,
        BadgeInfoOutline = 171,
        BadgeSuccessOutline = 172,
        BadgeWarningOutline = 173,
        DownloadFlat = 174,
        BadgeStoppedOutline = 175,
        Ellipsis = 176,
        PolyClearDBDatabase = 178,
        PolyResourceGroup = 179,
        PolyWorkflow = 180,
        LogoBitbucket = 181,
        LogoDropbox = 185,
        LogoGit = 187,
        LogoGitHub = 189,
        LogoVisualStudio = 191,
        MonitoringFlat = 193,
        PolyCertificate = 194,
        PolyClock = 195,
        PolyControlsHorizontal = 196,
        PolyInputOutput = 197,
        PolyModule = 198,
        PolyPowerUp = 199,
        PolySupport = 200,
        PolyTrafficManagerDisabled = 201,
        PolyTrafficManagerEnabled = 202,
        PolyVersions = 203,
        TrendDown = 204,
        TrendUp = 205,
        Variables = 206,
        PolyResourceGroupList = 208,
        BadgeUnknownOutline = 209,
        HeartPulse = 211,
        LogoExternalRepositoryBox = 212,
        PolyDevConsole = 213,
        PolyProductionReadyDb = 214,
        PolyWebSlots = 215,
        PowerUp = 216,
        GuideFlat = 218,
        Support = 219,
        ShellCornerCheck = 221,
        PolyGlobeError = 222,
        PolyGlobeSuccess = 223,
        PolyGlobeWarning = 224,
        InfoFlat = 225,
        Signout = 226,
        LaunchCurrent = 227,
        Feedback = 228,
        LogoRedis = 229,
        PolyCache = 230,
        PolyBlobBlock = 231,
        PolyBlobPage = 232,
        PolyStorageContainer = 233,
        PolyStorageQueue = 234,
        PolyTable = 235,
        WebHostingPlan = 236,
        PolyExtensions = 237,
        BadgeUpdateOutline = 238,
        PolyBranch = 240,
        PolyChart = 241,
        PolyDiscs = 244,
        PolyVirtualNetwork = 245,
        Tags = 246,
        ShellGear = 247,
        SearchFlat = 248,
        PolyCounter = 250,
        PolyProcessExplorer = 251,
        BadgeFailed = 252,
        BadgeFailedOutline = 253,
        PolyFile = 254,
        PolyFiles = 255,
        PolyImage = 256,
        TripleArrow = 257,
        LogoMicrosoftSquares = 258,
        ArrowDown = 260,
        ArrowLeft = 261,
        ArrowRight = 262,
        ArrowUp = 263,
        Columns = 264,
        FolderAlternate = 265,
        FlatKey = 266,
        Mail = 267,
        Message = 268,
        Query = 270,
        SaveAll = 271,
        Undo = 272,
        ShellHeaderDots = 273,
        ErrorIcon = 274,
        PolyManagementPortal = 276,
        LogoChannel9 = 277,
        LogoStackOverflow = 278,
        Diagnostics = 279,
        PolySSD = 280,
        Star = 283,
        Trash = 284,
        Globe = 285,
        CaretDown = 286,
        CaretUp = 287,
        ResourceRole = 288,
        ShellMinimize = 289,
        PolyStorageAzureFiles = 290,
        PolyPower = 291,
        BadgeCritical = 292,
        BadgeCriticalOutline = 293,
        Preview = 294,
        LoadingEllipsisSquare = 295,
        Customize = 296,
        Collapse = 298,
        Expand = 299,
        PolyApiManagement = 301,
        PolyBizTalk = 302,
        PolyCdn = 303,
        PolyEventHub = 304,
        PolyMobileEngagement = 305,
        PolyOperationalInsights = 306,
        PolyRemoteApp = 307,
        PolyScheduler = 308,
        PolyServiceBus = 309,
        PolySiteRecovery = 310,
        PolyStorSimple = 311,
        PolyStreamAnalytics = 312,
        Hamburger = 313,
        ShellCustomize = 314,
        BadgeErrorSolid = 315,
        BadgeInfoSolid = 316,
        BadgeWarningSolid = 317,
        AddTile = 318,
        SmileyHappy = 319,
        SmileyNeutral = 320,
        SmileySad = 321,
        ShellMiniSize = 322,
        ShellFullscreen = 323,
        ShellShare = 324,
        ShellTrashOutline = 327,
        LoadingSpinner = 328,
        PolyOwl = 332,
        Console = 333,
        AzurePortal = 334,
        Home = 335,
        PolyAdvisor = 336,
        Functions = 337,
        Copy = 338,
        Insert = 339,
        PolyEventGrid = 340,
        Notifications = 342,
        StatusUpsell = 343,
        AllServices = 344,
        DoubleChevron = 345,
        ShellPeekMode = 346,
        ShellExitPeekMode = 347,
        Line = 348,
        FilterRemove = 349,
        PolyDashboard = 350,
        ResourceFlat = 351,
        PolyWorkbooks = 352,
        PolyLogAnalytics = 353,
        Reimage = 354,
        Capture = 355,
        Move = 356,
        PolyCostAlerts = 357,
        PolyCostAnalysis = 358,
        PolyCostBudgets = 359,
        HideItems = 360,
        ShowItems = 361,
        PolyInsights = 362,
        NotificationBell = 363,
        BadgeUnknownSolid = 366,
        CloudUpload = 367,
        ShellContentErrorGeneric = 368,
        ShellContentErrorNotFound = 369,
        ShellContentErrorUnauthorized = 370,
        PolyLearn = 371,
        BadgeUpsell = 372,
        BadgeUpdate = 373,
        BadgeCanceledOutline = 374,
        BadgeDisabledOutline = 375,
        BadgeNoneOutline = 376,
        BadgePendingOutline = 377,
        BadgeUpsellOutline = 378,
        ThemeAzure = 379,
        ThemeBlue = 380,
        ThemeDark = 381,
        ThemeLight = 382,
        Alert = 383,
        QuickStartPoly = 384,
        AllServicesPoly = 385,
        TagsPoly = 386,
        View = 387,
        AddSubscription = 388,
        ManageAccess = 389,
        StudentTools = 390,
        NumberSvgMarker = 899,
        RasterizedSvgMarker = 999
    }
}

// FILE: MsPortalFx\Services\Services.Rpc.d.ts
interface EventHandlerContracts {
    "rpc"?: {
        registerEndPoints(): void;
    };
}
declare module MsPortalFx.Services.Rpc {
    interface EndPointRegistrationOptions {
        /**
         * A list of extension names that can be allowed to invoke this RPC callback.
         * If a falsy value is specified then all extensions are allowed to invoke this callback.
         */
        allowedOrigins: string[];
    }
    /**
     * Registers the given callback with the given callback name. The callback will now be callable over RPC using this name.
     *
     * @param callbackName The callback name.
     * @param callback The callback function.
     */
    function registerCallback(callbackName: string, callback: Function, options?: EndPointRegistrationOptions): void;
    /**
     * Invokes the RPC endpoint with the given callback name in the given extension.
     *
     * @param extensionName The extension name.
     * @param callbackName The callback name.
     * @param args The args of the callback.
     */
    function invokeCallback<T>(extensionName: string, callbackName: string, ...args: any[]): Q.Promise<T>;
    module EventHandler {
        /**
         * A decorator that is used to specify that the annotated class should be used to handle
         * RPC related events originating from the framework.
         *
         * @param contractName The name of the contract to be handled.
         */
        function Decorator<TContractName extends "rpc">(contractName: TContractName): (_: new (...args: any[]) => EventHandlerContracts[TContractName]) => void;
    }
}

// FILE: MsPortalFx\Services\Services.Telemetry.d.ts
/**
 * Telemetry logging facilities.
 */
declare module MsPortalFx.Services {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import TelemetryEventProcessor = FxBase.Diagnostics.Telemetry.TelemetryEventProcessor;
    function getTelemetryEventProcessor(uri?: string, extensionName?: string): TelemetryEventProcessor;
    function getConsoleTelemetryEventProcessor(): TelemetryEventProcessor;
}

// FILE: MsPortalFx\SharedSettings.d.ts
declare module MsPortalFx.Settings {
    /**
     * Interface for shared settings that can be used by other extensions.
     */
    interface SharedSettings {
        links: SharedLinks;
    }
    /**
     * Interface for blade deep links or external links.
     */
    interface SharedLinks {
        /**
         * Link to the account portal.
         */
        accountPortal: string;
        /**
         * Link to the classic portal.
         */
        classicPortal: string;
        /**
         * Link to create support request.
         */
        createSupportRequest: string;
        /**
         * Link to open help and support.
         */
        helpAndSupport: string;
        /**
         * Link to manage support requests.
         */
        manageSupportRequests: string;
        /**
         * Link to submit an idea.
         */
        submitAnIdea: string;
        /**
         * Link to privacy and terms.
         */
        privacyAndTerms: string;
        /**
         * Link to privacy statement.
         */
        privacyStatement: string;
        /**
         * Link to promotional communications manager.
         */
        promotionalCommunicationsManager: string;
        /**
         * Link to learn related resources.
         */
        learnRelatedResources: string;
        /**
         * Link to resource groups overview
         */
        resourceGroupOverview: string;
        /**
         * Link to azure roadmap
         */
        roadmap: string;
        /**
         * Link to time range filter granularity.
         */
        filteringGranularity: string;
    }
    /**
     * Gets the shared settings that are used by other extensions as well
     *
     * @return The info for the currently signed in user and directory.
     */
    function getSharedSettings(): MsPortalFx.Base.PromiseV<MsPortalFx.Settings.SharedSettings>;
}

// FILE: TypeReferences.d.ts

// FILE: MsPortalFx\UI\UI.AssetManager.d.ts
declare module MsPortalFx.UI.AssetManager {
    /**
     * Notifies the shell that an asset has been deleted.
     *
     * @param assetType Type of the asset that was deleted.
     * @param assetId Identifier of the asset that was deleted.
     * @param extensionName Optional extension name of the asset that was deleted.
     */
    function notifyAssetDeleted(assetType: string, assetId: any, extensionName?: string): void;
    /**
     * Notifies the shell that one or more assets has been deleted.
     *
     * @param asset An array of asset triplets.
     */
    function notifyAssetDeletedBulk(assets: MsPortalFx.Assets.AssetTriplet[]): void;
    /**
     * Notifies the shell that one or more resources has been deleted.
     *
     * @param resourceId A single or an array of resource IDs.
     */
    function notifyResourceDeleted(resourceId: string | string[]): void;
}

// FILE: MsPortalFx\UI\UI.Feedback.d.ts
declare module FxImpl {
    interface OpenFeedbackPaneOptions {
        feedbackType: FeedbackType;
        resourceId?: string;
        data?: any;
    }
    const enum FeedbackType {
        Default = 0,
        ResourceDeleted = 1
    }
    /**
     * The RPC endpoint for requesting  feedback by opening the context pane.
     */
    const feedbackEndPoint: Rpc.ActionEndPointDefinition<OpenFeedbackPaneOptions>;
}

// FILE: MsPortalFx\UI\UI.NotificationManager.d.ts
declare module FxImpl.NotificationManager {
    import Rpc = FxImpl.Rpc;
    /**
     * Interface for the parameters to be used with the addNotificationEndPoint.
     */
    interface AddNotificationParameters {
        notifications: MsPortalFx.UI.NotificationManager.Notification[];
    }
    /**
     * Interface for the parameters to be used with the addNotification2EndPoint.
     */
    interface AddNotification2Parameters {
        id: string;
        name: string;
        status: string;
        subStatus: string;
        assetId: any;
        properties: StringMap<string>;
    }
    /**
     * Interface for the parameters to be used with the addNotification2EndPoint.
     */
    interface UpdateNotificationParameters {
        id: string;
        propertyName: string;
        propertyValue: any;
    }
    /**
     * Interface for server event.
     */
    interface ServerEvent {
        operationName: string;
        source: string;
        status: string;
        subStatus: string;
        correlationId: string;
        assetId: string;
        timestamp: Date;
        properties: StringMap<string>;
    }
    /**
     * Interface for the parameters to be used with the addServerEventsEndPoint.
     */
    interface AddServerEventsParameters {
        serverEvents: ServerEvent[];
    }
    /**
     * The RPC endpoint that lets extensions send notifications.
     */
    let addNotificationsEndPoint: Rpc.ActionEndPointDefinition<AddNotificationParameters>;
    /**
     * The RPC endpoint that lets extensions send notifications.
     */
    let addNotification2EndPoint: Rpc.ActionEndPointDefinition<AddNotification2Parameters>;
    /**
     * The RPC endpoint that lets extensions update a notification.
     */
    let updateNotificationEndPoint: Rpc.ActionEndPointDefinition<UpdateNotificationParameters>;
    /**
     * The RPC endpoint that lets hubsextension send server events.
     */
    let addServerEventsEndPoint: Rpc.ActionEndPointDefinition<AddServerEventsParameters>;
    /**
     * Test dispatcher to use when if required when setting up senders.
     */
    let rpcClient: Rpc.Client;
}
declare module MsPortalFx.UI.NotificationManager {
    /**
     * The notification class.
     */
    class Notification2 {
        /**
         * The notification name.
         */
        private _name;
        /**
         * The autogenerated notification id.
         */
        private _id;
        /**
         * Creates a new notification. This should not be called directly, please use the create() method to create a new notification.
         *
         * @param name The name of the notification.
         */
        constructor(name: string);
        /**
         * Creates a new notification. This should not be called directly, please use the create() method to create a new notification.
         *
         * @param state The status and substatus of the notification.
         * @param assetId The asset id associated with the notification. It is only used if an asset type is specified for the notification.
         * @param properties The notification properties. This is used to format the description.
         */
        raise(state: {
            status: string;
            subStatus?: string;
        }, assetId?: any, properties?: StringMap<string>): void;
        /**
         * Updates the correlation id on the notification.
         *
         * @param correlationId The correlation id.
         */
        updateCorrelationId(correlationId: string): void;
        /**
         * Updates the progress of the notification. This is only shown when a progress notification is being shown.
         *
         * @param percentComplete The percent complete.
         */
        reportProgress(percentComplete: number): void;
    }
    /**
     * Creates a new notification with the specified name.
     *
     * @param notificationName The notification name defined in PDL.
     * @return Notification object.
     */
    function create(notificationName: string): MsPortalFx.UI.NotificationManager.Notification2;
    /**
     * The notification state.
     */
    enum NotificationState {
        /**
         * An information notification
         */
        Information = 0,
        /**
         * A warning notification
         */
        Warning = 1,
        /**
         * An error notification
         */
        Error = 2,
        /**
         * An in progress notification
         */
        InProgress = 3,
        /**
         * A success notification
         */
        Success = 4
    }
    /**
     * The notification client details are properties on a notification which are client-local only and not stored
     * on the server. These properties should NOT be set when creating and adding notifications to the system.
     */
    interface NotificationClientDetails {
        /**
         * The asset owner for the notification.
         */
        assetOwner?: string;
        /**
         * The asset type for the notification.
         */
        assetType?: string;
        /**
         * The blade name override for the notification.
         */
        bladeName?: string;
        /**
         * The blade extension override for the notification.
         */
        bladeExtension?: string;
    }
    /**
     * The notification model.
     */
    class Notification {
        /**
         * The notification source which is a globally unique identifier.
         */
        source: string;
        /**
         * The notification event type. The combination of source.eventtype will uniquely identify a notification.
         */
        eventType: string;
        /**
         * The notification state - Information, Warning, Error, InProgress.
         */
        state: NotificationState;
        /**
         * The notification label. This should be localized by the formatter.
         */
        label: string;
        /**
         * The notification timestamp.
         */
        timestamp: Date;
        /**
         * The notification description. This will have a default message but this can be overridden by the
         * message provided by the extension.
         */
        description: string;
        /**
         * A list of arguments used to string.format() the description.
         * When the extension provides a description, these arguments will be used to format the description.
         */
        descriptionArgs: string[];
        /**
         * The subscription Id associated with the notification.
         */
        subscriptionId: string;
        /**
         * The operation Id of the operation associated with the notification. Any new notification that is added
         * with an existing operation id, will be updated instead of creating a new notification.
         */
        operationId: string;
        /**
         * The correlation Id of the operation associated with the notification. Any new notification that is added
         * with an existing operation id, will be updated instead of creating a new notification.
         */
        correlationId: string;
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        percentOperationComplete: number;
        /**
         * The asset id associated with the notification. This will be used to launch the resource blade when the
         * notification is clicked.
         */
        assetId: any;
        /**
         * Flag indicating if the notification is a recommendation.
         */
        isRecommendation: any;
        /**
         * Additional event details.
         */
        eventDetails: any;
        /**
         * Additional properties.
         */
        additionalProperties: any;
        /**
         * The client details are the client-side details for the notification which are not stored. These properties
         * should NOT be set when creating and adding notifications to the system.
         */
        clientDetails: NotificationClientDetails;
        /**
         * Creates a new notification.
         *
         * @param source The notification source. This will be a unique identifier for the source of this notification.
         * @param eventType The notification event type.
         * @param state The notification state. Can be information, warning, error or inprogress.
         * @param descriptionArgs The description arguments used to format this notification.
         * @param subscriptionId The subscription id of the notification.
         * @param operationId The operation id, if the notification is associated with an operation.
         * @param percentOperationComplete The %age of operation completed, used only if this operation state is in progress.
         * @param assetId The ID of the asset associated with this notification.
         */
        constructor(source: string, eventType: string, state: NotificationState, descriptionArgs?: string[], subscriptionId?: string, operationId?: string, percentOperationComplete?: number, assetId?: any);
    }
    /**
     * Adds a single notification to the UI.
     *
     * @param notification The notification to add.
     */
    function addNotification(notification: Notification): void;
    /**
     * Adds notifications to the UI.
     *
     * @param notifications The list of notifications to add.
     */
    function addNotifications(notifications: Notification[]): void;
}

// FILE: MsPortalFx\UniqueIdUtility.d.ts
declare module FxImpl {
    /**
     * The session storage key for the session ID.
     */
    const enum UniqueIdSettingsKeys {
        SessionId = "Redirect_SessionId"
    }
    /**
     * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
     *
     * @param prefix An optional prefix for the GUID.
     * @param omitDashes Do not include dashes between the GUID sections.
     * @return New GUID.
     */
    function createGuid(prefix?: string, omitDashes?: boolean): string;
}

// FILE: MsPortalFx\Util\ColorUtil.d.ts
declare module MsPortalFx.ColorUtil {
    enum AllRawColorCode {
        "Hex_fcd116" = 0,
        "Hex_eb3c00" = 1,
        "Hex_ba141a" = 2,
        "Hex_b4009e" = 3,
        "Hex_442359" = 4,
        "Hex_002050" = 5,
        "Hex_0072c6" = 6,
        "Hex_008272" = 7,
        "Hex_007233" = 8,
        "Hex_7fba00" = 9,
        "Hex_a0a5a8" = 10,
        "Hex_fff100" = 11,
        "Hex_ff8c00" = 12,
        "Hex_e81123" = 13,
        "Hex_ec008c" = 14,
        "Hex_68217a" = 15,
        "Hex_00188f" = 16,
        "Hex_00bcf2" = 17,
        "Hex_00b294" = 18,
        "Hex_009e49" = 19,
        "Hex_bad80a" = 20,
        "Hex_bbc2ca" = 21,
        "Hex_fffc9e" = 22,
        "Hex_ffb900" = 23,
        "Hex_dd5900" = 24,
        "Hex_f472d0" = 25,
        "Hex_9b4f96" = 26,
        "Hex_4668c5" = 27,
        "Hex_6dc2e9" = 28,
        "Hex_00d8cc" = 29,
        "Hex_55d455" = 30,
        "Hex_e2e584" = 31,
        "Hex_d6d7d8" = 32,
        "Hex_807900" = 33,
        "Hex_804600" = 34,
        "Hex_740912" = 35,
        "Hex_760046" = 36,
        "Hex_34113d" = 37,
        "Hex_000c48" = 38,
        "Hex_005e79" = 39,
        "Hex_084c41" = 40,
        "Hex_063d20" = 41,
        "Hex_3d460a" = 42,
        "Hex_32383f" = 43,
        "Hex_bfb500" = 44,
        "Hex_bf6900" = 45,
        "Hex_ae0d1a" = 46,
        "Hex_b10069" = 47,
        "Hex_4e195c" = 48,
        "Hex_00126b" = 49,
        "Hex_008db5" = 50,
        "Hex_00856f" = 51,
        "Hex_0f5b2f" = 52,
        "Hex_8ba208" = 53,
        "Hex_464f59" = 54,
        "Hex_fcf37e" = 55,
        "Hex_ffba66" = 56,
        "Hex_f1707b" = 57,
        "Hex_f466ba" = 58,
        "Hex_a47aaf" = 59,
        "Hex_6674bc" = 60,
        "Hex_66d7f7" = 61,
        "Hex_66d1bf" = 62,
        "Hex_66c592" = 63,
        "Hex_d6e86c" = 64,
        "Hex_8f9ca8" = 65,
        "Hex_fffccc" = 66,
        "Hex_ffe8cc" = 67,
        "Hex_facfd3" = 68,
        "Hex_fbcce8" = 69,
        "Hex_e1d3e4" = 70,
        "Hex_ccd1e9" = 71,
        "Hex_ccf2fc" = 72,
        "Hex_ccf0ea" = 73,
        "Hex_ccecdb" = 74,
        "Hex_f0f7b2" = 75,
        "Hex_63707e" = 76,
        max = 77
    }
    enum ColorCode {
        "a1" = 0,
        "b1" = 1,
        "c1" = 2,
        "d1" = 3,
        "e1" = 4,
        "f1" = 5,
        "g1" = 6,
        "h1" = 7,
        "i1" = 8,
        "j1" = 9,
        "k1" = 10,
        "a0" = 11,
        "b0" = 12,
        "c0" = 13,
        "d0" = 14,
        "e0" = 15,
        "f0" = 16,
        "g0" = 17,
        "h0" = 18,
        "i0" = 19,
        "j0" = 20,
        "k0" = 21,
        "a2" = 22,
        "b2" = 23,
        "c2" = 24,
        "d2" = 25,
        "e2" = 26,
        "f2" = 27,
        "g2" = 28,
        "h2" = 29,
        "i2" = 30,
        "j2" = 31,
        "k2" = 32,
        "a0s2" = 33,
        "b0s2" = 34,
        "c0s2" = 35,
        "d0s2" = 36,
        "e0s2" = 37,
        "f0s2" = 38,
        "g0s2" = 39,
        "h0s2" = 40,
        "i0s2" = 41,
        "j0s2" = 42,
        "k0s2" = 43,
        "a0s1" = 44,
        "b0s1" = 45,
        "c0s1" = 46,
        "d0s1" = 47,
        "e0s1" = 48,
        "f0s1" = 49,
        "g0s1" = 50,
        "h0s1" = 51,
        "i0s1" = 52,
        "j0s1" = 53,
        "k0s1" = 54,
        "a0t1" = 55,
        "b0t1" = 56,
        "c0t1" = 57,
        "d0t1" = 58,
        "e0t1" = 59,
        "f0t1" = 60,
        "g0t1" = 61,
        "h0t1" = 62,
        "i0t1" = 63,
        "j0t1" = 64,
        "k0t1" = 65,
        "a0t2" = 66,
        "b0t2" = 67,
        "c0t2" = 68,
        "d0t2" = 69,
        "e0t2" = 70,
        "f0t2" = 71,
        "g0t2" = 72,
        "h0t2" = 73,
        "i0t2" = 74,
        "j0t2" = 75,
        "k0t2" = 76,
        max = 77
    }
    /**
     * Returns the RawColorString (#0072c6) that can be used in the css or less from the index of the color code.
     * Note: AllRowColorCode["Hex_fcd116"] === 0 and AllRowColorCode[0] === "Hex_fcd116"
     * For example:
     *   getRawColorString(ColorCode.a1) will return "#fcd116".
     * This is same as
     *   getRowColorString(AllRawColorCode.Hex_fcd116) will return "#fcd116".
     * This is because both ColorCode.a1 and AllRawColorCode.Hex_fcd116 both are 0.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number.
     * @return Css style of color hex code string. For example: "#fcd116".
     */
    function getRawColorString(colorIndex: number): string;
    /**
     * Returns the ColorCode string ("a1") base on the index number.
     * Note: ColorCode["a1"] === 0 and ColorCode[0] === "a1"
     * For example:
     *   getColorCodeString(ColorCode.a1) will return "a1".
     * This is same as
     *   getColorCodeString(AllRawColorCode.Hex_fcd116) will return "a1".
     * This is because both ColorCode.a1 and AllRawColorCode.Hex_fcd116 both are 0.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number or numeric number.
     * @return Ux string code. For example: "a1".
     */
    function getColorCodeString(colorIndex: number): string;
    /**
     * Returns the RawColorString (0072c6) that can be use in the data coding.
     * Handles all different possible form of hex color code and format of string.
     * For example:
     *   getRawColorCode("fcd116") will return "fcd116".
     *   getRowColorString("#fcd116") will return "fcd116".
     *   getRowColorString("Hex_fcd116") will return "fcd116".
     *   If not in the above format, it will return null.
     *
     * @param rawColorData String data of any hex string code.
     * @return Css color hex code string. For example: "fcd116".
     */
    function getRawColorCode(rawColorData: string): string;
    /**
     * Returns the RawColorIndex (0 base index) that can be used in for indexing ColorCode or RawColorCode.
     * For example:
     *   getRawColorIndex("fcd116") will return 0.
     *   getRowColorString("#fcd116") will return 0.
     *   getRowColorString("Hex_fcd116") will return 0.
     *   If not in the above format, it will return null.
     *
     * @param rawColorData String data of any hex string code.
     * @return Index for either Enum ColorCode or RawColorCode. For example: 0. This number will be less than 77 (max) if not, returns null.
     */
    function getRawColorIndex(rawColorData: string): number;
    /**
     * Returns the colorIndex (0 base index) that can be used in for indexing ColorCode or RawColorCode.
     * For example:
     *   getColorIndex("fcd116") will return 0.
     *   getColorIndex("#fcd116") will return 0.
     *   getColorIndex("Hex_fcd116") will return 0.
     *   getColorIndex("a1") will return 0.
     *
     *   If invalid data is given, it will return null.
     *
     * @param colorData String data of any hex string code.
     * @return Index for either Enum ColorCode or RawColorCode. For example: 0. This number will be less than 77 (max) if not, returns null.
     */
    function getColorIndex(colorData: string): number;
    /**
     * Returns the Array of the Tint set corresponding to this color code.
     * For example:
     *   getColorCodeTintSet("fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("#fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("Hex_fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("a1") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *
     *   If invalid data is given, it will return null.
     *
     * @param colorData String data of any hex string code. The can be "fcd116", "#fcd116", "Hex_fcd116", or "a1".
     * @param rawColorData Optional boolean indicates that if you want to get the rowColorData. If set, this function returns ["#807900","#bfb500","fff100", "#fcf37e", "#fffccc"] instead of ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     * @return Array of the color code. Typicically. ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     */
    function getColorCodeTintSet(colorData: string, rawColorData?: boolean): string[];
    /**
     * Returns the Array of the Tint set corresponding to this color code.
     * For example:
     *   getColorCodeTintSetIndex(0) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSetIndex(11) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSetIndex(22) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *      ....   (0, 11, 22, 33, 44, 55, 66) all return the same set because they are same color system in MsColorWheel.
     *   If invalid data is given, it will return null.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number.
     * @return Array of the color code index. Typicically. [33, 44, 11, 55, 66]
     */
    function getColorCodeTintSetIndex(colorIndex: number): number[];
    /**
     * Returns the main color wheel color (33) colors. This exclude the set of Tint/Shade.
     *
     * @return Array of the color code index. Typicically. [0, 1, 2, ..., 32]
     */
    function getAllColorCodeIndexes(): number[];
    /**
     * Returns the Array of ms color wheel color set with a start point. This is very useful for color wheel.
     * For example:
     *   getRotatedArray<number>([33,44, 11, 55, 66], 2) will return [11, 55, 66, 33, 44].
     *
     * @param data Array of color number, code, represents a color wheel.
     * @param start Index of start point.
     * @return Array of the color code index. Typicically. [33, 44, 11, 55, 66]
     */
    function getRotatedArray<T>(data: T[], start?: number): T[];
    /**
     * Returns the gradient color wheel color (27) colors index. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code index.
     */
    function getGradientColorCodeIndexes(start?: number): number[];
    /**
     * Returns the rainbow color wheel color (27) colors index. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Line Chart where the colors DO overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code index.
     */
    function getRainbowColorCodeIndexes(start?: number): number[];
    /**
     * Returns the gradient color wheel color (27) colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array [a0,a1,b2,b0,c2,b1,c0,c1,d0,d1,e2,e0,e1,f1,f0,g1,g0,g2,h2,h0,h1,i1,i0,i2,j1,j0,j2,]
     */
    function getGradientColorCode(start?: number): string[];
    /**
     * Returns the gradient color wheel color (27) raw colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array ["#fcd116", .....]
     */
    function getRawGradientColorCode(start?: number): string[];
    /**
     * Returns the gradient color wheel color (27) raw colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array [a0,a1,b2,b0,c2,b1,c0,c1,d0,d1,e2,e0,e1,f1,f0,g1,g0,g2,h2,h0,h1,i1,i0,i2,j1,j0,j2,]
     */
    function getRainbowColorCode(start?: number): string[];
    /**
     * Returns the rainbow color wheel color (27) colors string.  This exclude the set of Tint/Shade.
     * Ux specifies this to used as default for the Donut and barChart where the color doesn't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array ["#fcd116", .....]
     */
    function getRawRainbowColorCode(start?: number): string[];
}

// FILE: MsPortalFx\Util\DateUtil.d.ts
declare module MsPortalFx.DateUtil {
    /**
     * Used to specify date/time range in which user can select date/time.
     */
    class DateTimeRange {
        /**
         * Start date/time in local timezone.
         */
        startDateTime: KnockoutObservable<Date>;
        /**
         * End date/time in local timezone.
         */
        endDateTime: KnockoutObservable<Date>;
        /**
         * Creates a DateTimeRange object
         *
         * @param startDateTime The start date/time in local timezone
         * @param endDateTime The end date/time in local timezone
         */
        constructor(startDateTime?: Date, endDateTime?: Date);
    }
}

// FILE: MsPortalFx\Util\UnitConversion.d.ts
declare module MsPortalFx.UnitConversion {
    import Fx = MsPortalFx;
    import FxUnitConversionUtil = Fx.UnitConversionUtil;
    import FxIntl = Fx.Intl;
    enum Unit {
        None = 0,
        Percentage = 1,
        Bytes = 2,
        Kilobytes = 3,
        Megabytes = 4,
        Gigabytes = 5,
        Terabytes = 6,
        Petabytes = 7,
        BytesPerDay = 8,
        BytesPerHour = 9,
        BytesPerMinute = 10,
        BytesPerSecond = 11,
        KilobytesPerSecond = 12,
        MegabytesPerSecond = 13,
        GigabytesPerSecond = 14,
        TerabytesPerSecond = 15,
        PetabytesPerSecond = 16,
        Count = 17,
        Thousand = 18,
        Million = 19,
        Billion = 20,
        Trillion = 21,
        MicroSeconds = 22,
        MilliSeconds = 23,
        Seconds = 24,
        Minutes = 25,
        Hours = 26,
        Days = 27,
        CountPerDay = 28,
        CountPerHour = 29,
        CountPerMinute = 30,
        CountPerSecond = 31,
        ThousandPerSecond = 32,
        MillionPerSecond = 33,
        BillionPerSecond = 34,
        TrillionPerSecond = 35,
        Bytes_SI = 36,
        Kilobytes_SI = 37,
        Megabytes_SI = 38,
        Gigabytes_SI = 39,
        Terabytes_SI = 40,
        Petabytes_SI = 41,
        BytesPerDay_SI = 42,
        BytesPerHour_SI = 43,
        BytesPerMinute_SI = 44,
        BytesPerSecond_SI = 45,
        KilobytesPerSecond_SI = 46,
        MegabytesPerSecond_SI = 47,
        GigabytesPerSecond_SI = 48,
        TerabytesPerSecond_SI = 49,
        PetabytesPerSecond_SI = 50
    }
    /**
     * Returns the most appropriate unit for formatting the value.
     *
     * @param value The value to find the unit.
     * @param originalUnit The original unit of the value.
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the originalUnit.
     * @return The unit allowing to display the value shortly.
     */
    function getAppropriateUnit(value: number, originalUnit: Unit, defaultZeroUnit?: Unit): Unit;
    /**
     * Return the conversion factor from one unit to another.
     *
     * @param orignalUnit The original unit.
     * @param unit The unit to be converted to.
     * @return The conversion factor used to divide from the originalUnit to the unit.
     */
    function getConversionFactor(originalUnit: Unit, toUnit: Unit): number;
    /**
     * Returns a string representation of the Unit enum.
     *
     * @param unit The unit to be represented with a string.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The string representation.
     */
    function toString(unit: Unit, displaySIUnit?: boolean): string;
    /**
     * This API takes in a value of specified unit and auto converts to appropriate scaled unit and returns a globalized string with converted value and scaled unit.
     *
     * @param value The original value to be converted.
     * @param originalUnit The original unit of the value.
     * @param numberFormat Optional parameter specifying the globalized number format options for min/max precision. By default the API truncates to 2 decimal places.
     * @param displayFormat Optional display format to specify the converted value and scaled unit.
     *                      {0} is converted value
     *                      {1} is the string representation of target unit
     *                      default format is "{0} {1}". Eg. 256 KB
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the originalUnit.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The globalized string representation of auto scaled value and unit.
     */
    function getConvertedValue(value: number, originalUnit: Unit, numberFormat?: FxIntl.NumberFormatOptions, displayFormat?: string, defaultZeroUnit?: Unit, displaySIUnit?: boolean): string;
    /**
     * This API takes in a value of specified unit and converts to the specified target unit and returns a globalized string with converted value and target unit.
     *
     * @param value The original value to be converted.
     * @param originalUnit The original unit of the value.
     * @param toUnit The target unit to which the value should be converted.
     * @param numberFormat Optional parameter specifying the globalized number format options for min/max precision. By default the API truncates to 2 decimal places.
     * @param displayFormat Optional display format to specify the converted value and scaled unit.
     *                      {0} is converted value
     *                      {1} is the string representation of target unit
     *                      default format is "{0} {1}". Eg. 256 KB
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the toUnit.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The globalized string representation of auto scaled value and unit.
     */
    function getConvertedValueForTargetUnit(value: number, originalUnit: Unit, toUnit: Unit, numberFormat?: FxIntl.NumberFormatOptions, displayFormat?: string, defaultZeroUnit?: Unit, displaySIUnit?: boolean): string;
    /**
     * Convert MsPortal Unit to internal Unit which has expanded enumaration values.
     * MsPortal.UnitConversion.Unit have to keep the 0 base enum with no gap due to .d.ts generation which remove the number from the enum.
     * As result, MsPortal.UnitConversion.Unit should not be directly pass into the UnitConversionUtil routines.
     *
     * @param MsPortalFx.UnitConversion.Unit
     * @return MsPortalFx.UnitConversionUtil.Unit
     *
     * Note this odd looking code leverage TypeScript enum speciality.  TypeScript Enum setup 2 map
     *  map 1
     *   MsPortalFx.UnitConversion.Unit.Count === 17
     *   this is equvalient to
     *   MsPortalFx.UnitConversion.Unit["Count"] === 17
     *
     *   The reverse map: NumberMap.
     *   MsPortalFx.UnitConversion.Unit[17] === "Count"
     * This code leverage 2nd map.  In the above example, unitString get "Count", then we use utilUnit["Count"] to get the viva enum.
     */
    function _convertUnitToInternalConversionUnit(unit: Unit): FxUnitConversionUtil.Unit;
    /**
     * Converts the internal ConversionUnitUtil's Unit to public Unit.
     * MsPortal.UnitConversion.Unit have to keep the 0 base enum with no gap due to .d.ts generation which remove the number from the enum.
     * As result, MsPortal.UnitConversion.Unit should not be directly pass into the UnitConversionUtil routines.
     *
     * @param MsPortalFx.UnitConversionUtil.Unit
     * @return MsPortalFx.UnitConversion.Unit
     *
     * Note this odd looking code leverage TypeScript enum speciality.  TypeScript Enum setup 2 map
     *  map 1
     *   MsPortalFx.UnitConversion.Unit.Count === 17
     *   this is equvalient to
     *   MsPortalFx.UnitConversion.Unit["Count"] === 17
     *
     *   The reverse map: NumberMap.
     *   MsPortalFx.UnitConversion.Unit[17] === "Count"
     * This code leverage 2nd map.  In the above example, unitString get "Count", then we use utilUnit["Count"] to get the viva enum.
     */
    function _convertInternalConversionUnitToUnit(unit: FxUnitConversionUtil.Unit): Unit;
}

// FILE: MsPortalFx\Util\UnitConversionUtil.d.ts
declare module MsPortalFx.UnitConversionUtil {
    /**
     * Defines units. This is internal Unit which has expanded/specific assigned enum values. Due to typescript compiler issue, another public Unit enum is exposed with sequential values.
     */
    enum Unit {
        None,
        Percentage,
        Bytes,
        Kilobytes,
        Megabytes,
        Gigabytes,
        Terabytes,
        Petabytes,
        BytesPerDay,
        BytesPerHour,
        BytesPerMinute,
        BytesPerSecond,
        KilobytesPerSecond,
        MegabytesPerSecond,
        GigabytesPerSecond,
        TerabytesPerSecond,
        PetabytesPerSecond,
        Count,
        Thousand,
        Million,
        Billion,
        Trillion,
        MicroSeconds,
        MilliSeconds,
        Seconds,
        Minutes,
        Hours,
        Days,
        CountPerDay,
        CountPerHour,
        CountPerMinute,
        CountPerSecond,
        ThousandPerSecond,
        MillionPerSecond,
        BillionPerSecond,
        TrillionPerSecond,
        Bytes_SI,
        Kilobytes_SI,
        Megabytes_SI,
        Gigabytes_SI,
        Terabytes_SI,
        Petabytes_SI,
        BytesPerDay_SI,
        BytesPerHour_SI,
        BytesPerMinute_SI,
        BytesPerSecond_SI,
        KilobytesPerSecond_SI,
        MegabytesPerSecond_SI,
        GigabytesPerSecond_SI,
        TerabytesPerSecond_SI,
        PetabytesPerSecond_SI
    }
    /**
     * Returns the most appropriate unit for formatting the value. Used internally by various controls.
     *
     * @param value The value to find the unit.
     * @param originalUnit The original unit of the value.
     * @return The unit allowing to display the value shortly.
     */
    function getAppropriateUnit(value: number, originalUnit: Unit, defaultZeroUnit?: Unit): Unit;
    /**
     * Return the conversion factor from one unit to another.  Used internally by various controls.
     *
     * @param orignalUnit The original unit.
     * @param unit The unit to be converted to.
     * @return The conversion factor used to divide from the originalUnit to the unit.
     */
    function getConversionFactor(originalUnit: Unit, toUnit: Unit): number;
    /**
     * Returns a string representation of the Unit enum.  Used internally by various controls.
     *
     * @param unit The unit to be represented with a string.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The string representation.
     */
    function toString(unit: Unit, displaySIUnit?: boolean): string;
}

// FILE: MsPortalFx\Utilities.d.ts
declare module MsPortalFx {
    const uncurryThis: (f: (...args: any[]) => any) => ((...args: any[]) => any);
    const applyCall: (f: (...args: any[]) => any, target: any, args: any[] | IArguments) => any;
    const applyUncurry: (f: (...args: any[]) => any, target: any, args: any[] | IArguments) => any;
    function isEmptyObject(obj: any): obj is Object;
    /**
     * A function that when invoked returns the milliseconds elapsed since startTimer was called.
     */
    type Timer = Func<number>;
    /**
     * Returns a timer function.
     */
    function startTimer(): Timer;
    function isPlainObject(obj: any): boolean;
    const jqueryExtend: (this: any, ...args: any[]) => any;
    /**
     * For testing only. Use Object.keys.
     */
    function _objectKeysPolyfill(o: any): string[];
    function forEachKey<T, U>(obj: StringMap<T>, iterator: (key: string, value: T, context: U) => void, context?: U): U;
    function forEachKey<T, U>(obj: NumberMap<T>, iterator: (key: number, value: T, context: U) => void, context?: U): U;
    /**
     * Shortcut for Object.keys(obj || {}).length.
     * @return number.
     */
    function keysLength(obj: Object): number;
    /**
     * Determines whether an object has properties on it.
     * Will return true for the following inputs: [], {}, "", 0, 1, true, false, new Date(), function() {}.
     * Will return false for the following inputs: [1], {a:1}, "123".
     * @return boolean.
     */
    function isEmpty(obj: Object): boolean;
    /**
     * Detect a value is Disposable.
     *
     * @param value The value to check against value.dispose is a function.
     * @return boolean.
     */
    function isDisposable(value: any): value is {
        dispose: Func<void>;
    };
    /**
     * call value.dispose() if a value is Disposable.
     *
     * @param value The value to call value.dispose()
     * @return boolean;
     */
    const disposeDisposable: (...values: any[]) => void;
    /**
     * Detect a value is null.
     *
     * @param value The value to check against null.
     * @return boolean.
     */
    function isNull(value: any): boolean;
    /**
     * Detect a value is undefined.
     *
     * @param value The value to check against undefined.
     * @return boolean.
     */
    function isUndefined(value: any): boolean;
    /**
     * Indicates whether the specified object is null or undefined.
     *
     * @param value The value to test.
     * @returns True if the value parameter is null or undefined; otherwise, false.
     */
    function isNullOrUndefined(value: any): boolean;
    /**
     * Indicates whether the specified object is not null or undefined.
     *
     * @param value The value to test.
     * @returns True if the value parameter is null or undefined; otherwise, false.
     */
    function notNullOrUndefined(value: any): boolean;
    /**
     * Checks if the string is null, undefined or whitespace.
     *
     * @param  value The target string.
     * @return true if the string is null, undefined or whitespace; otherwise, false.
     */
    function isNullOrWhiteSpace(value: string): boolean;
    /**
     * Checks if the number is valid and not NaN, null or undefined.
     *
     * @param  value The target number.
     * @return true if the number is valid and not NaN, null or undefined; otherwise, false.
     */
    function isNumeric(value: number): value is number;
    interface IMap<K, V> extends Map<K, V> {
        clear(): void;
        delete(key: K): boolean;
        forEach(callbackfn: (value: V, index: K, map: IMap<K, V>) => void, thisArg?: any): void;
        has(key: K): boolean;
        get(key: K): V;
        set(key: K, value: V): this;
        size: number;
    }
    var Map: {
        new <K, V>(): IMap<K, V>;
    };
    interface Memoized<TResult> {
        /**
         * Executes the memoized calback.
         *
         * @returns The memoized result.
         */
        (): TResult;
        /**
         * Disposes the memoized results.
         */
        dispose(): void;
        clear(): void;
    }
    interface MemoizedV<T, TResult> {
        /**
         * Executes the memoized calback.
         *
         * @returns The memoized result.
         */
        (input?: T): TResult;
        /**
         * Dispose/Clear the cache the memoized results.
         */
        dispose(): void;
        clear(): void;
        /**
         * Delete particular Memoized Value.
         */
        delete(input: T): boolean;
        /**
         * access the map
         */
        map(): Map<T, any>;
    }
    interface MemoizeCallback<T, TR> {
        (input?: T): TR;
    }
    interface MemoizeOnError<T, TR> {
        (err: Error, input: T, map: IMap<T, TR>): boolean;
    }
    interface MemoizeCacheFactory<T, TR> {
        (): IMap<T, TR>;
    }
    interface MemoizeOption<T, TResult> {
        checkResult?: (result: TResult, input: T, map: IMap<T, TResult>) => boolean;
        noDebugCheck?: boolean;
        cacheFactory?: MemoizeCacheFactory<T, TResult>;
        onError?: MemoizeOnError<T, TResult>;
    }
    /**
     * Memoize the specified callback.
     *
     * @param callback The function to memoize.
     * @param checkResult Optional return true to keep the result in the map.  If missing, it will remember it
     * @param cacheFactory to provide the call back for create the Map.  Note Map have to support ES6 Map API. and support "undefined" if your input can be "undefined"
     * @param onError provide the onError handler, it will allow you to decide what to do with Error
     * @returns The memoized function call.
     */
    const memoize: <T, TResult>(callback: (input?: T) => TResult, options?: MemoizeOption<T, TResult>) => MemoizedV<T, TResult>;
    /**
     * Converts a promise factory into a memo-ized promise.
     * The factory method will be called until a promise is fulfilled.
     * Once a fulfilled promise is available it will be re-used for subsequent callers.
     * While a promise is pending, it will be returned to all concurrent callers.
     * As an example, if the factory method generates a promise that rejects after 5 seconds on the
     * first call, and a fulfilled promise on the second call, callers might observe rejections for
     * the first 5 seconds and will get the fulfilled promise after that.
     *
     * @param callback The function to memoize that return a Q promise
     * @param checkResult Optional return true to keep the result in the map.  If missing, it will remember it
     * @param cacheFactory to provide the call back for create the Map.  Note Map have to support ES6 Map API. and support "undefined" if your input can be "undefined"
     * @param onError provide the onError handler, it will allow you to decide what to do with Error
     * @returns The memoized function call.
     */
    function memoizeQ<T, TResult extends Q.Promise<any>>(callback: (input?: T) => TResult, options?: {
        cacheFactory?: MemoizeCacheFactory<T, TResult>;
        onError?: MemoizeOnError<T, TResult>;
    }): MemoizedV<T, TResult>;
    /**
     * Retries a promise a given number of times with a given delay between retries from a factory.
     *
     * @param factory The factory for the promise.
     * @param retries The number of retries before the promise is rejected.
     * @param delayBetweenRetries The delay in milliseconds between retries.
     */
    function retryPromise<T>(factory: () => Q.Promise<T>, retries: number, delayBetweenRetries: number): Q.Promise<T>;
    interface QDebouncerCancelDispose {
        /**
         * cancel the scheduled callback, if any.
         */
        cancel(): void;
        /**
         * dispose is  to work with lifetimeManager which will cancel all pending request then mark all following call to dispose cancel rejection.
         */
        dispose(): void;
    }
    interface QDebouncerReturnAny<R> extends QDebouncerCancelDispose {
        /**
         * throttled/debounced function
         *
         * @returns promise when throttle/debounce executed.
         */
        (...args: any[]): Q.Promise<R>;
    }
    interface QDebouncerReturn<R> extends QDebouncerCancelDispose {
        /**
         * throttled/debounced function
         *
         * @returns promise when throttle/debounce executed.
         */
        (): Q.Promise<R>;
    }
    interface QDebouncerReturn1<T, R> extends QDebouncerCancelDispose {
        /**
         * throttled/debounced function
         *
         * @returns promise when throttle/debounce executed.
         */
        (arg1: T): Q.Promise<R>;
    }
    interface QDebouncerReturn2<T1, T2, R> extends QDebouncerCancelDispose {
        /**
         * throttled/debounced function
         *
         * @returns promise when throttle/debounce executed.
         */
        (arg1: T1, arg2: T2): Q.Promise<R>;
    }
    interface QDebouncerReturn3<T1, T2, T3, R> extends QDebouncerCancelDispose {
        /**
         * throttled/debounced function
         */
        (arg1: T1, arg2: T2, arg3: T3): Q.Promise<R>;
    }
    type QDebouncerCallback<R> = (...args: any[]) => (R | Q.Promise<R>);
    function require<TModule extends keyof ModuleMap>(moduleId: TModule): Q.Promise<ModuleMap[TModule]>;
    /**
     * Requests the specified module.
     *
     * @param moduleId The module id.
     * @param localRequire Use local require.
     * @param ignoreErrors Ignore errors for this module.
     * @returns A promise for the module.
     */
    function require<T>(moduleId: string, localRequire?: LocalRequire): Q.Promise<T>;
    /**
     * Requests the specified module.
     *
     * @param moduleId The module id.
     * @param onLoaded Callback that is called when the module is loaded. If already loaded it is called synchronously.
     * @param onError Callback that is called when there is an error loading the module.
     */
    function require<T>(moduleId: string, onLoaded?: (loadedModule: T) => void, onError?: (error: any) => void): void;
    /**
     * Finds the index of the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     *
     * @return The first index that matches the predicate.
     */
    function findIndex<T>(array: ReadonlyArray<T>, predicate?: (value: T, index: number, array: ReadonlyArray<T>) => boolean, startIndex?: number): number;
    /**
     * Finds the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     *
     * @return The first element that matches the predicate.
     */
    function find<T>(array: ReadonlyArray<T>, predicate?: (value: T, index: number, array: T[]) => boolean, startIndex?: number): T;
    /**
     * Returns the first element of the sequence.
     *
     * @return The element
     */
    function first<T>(array: ReadonlyArray<T>): T;
    /**
     * Returns the last element of the sequence.
     *
     * @return The element
     */
    function last<T>(array: ReadonlyArray<T>): T;
    /**
     * Removes all values that equal the given item and returns them as an array
     *
     * @param itemOrPredicate The value or predicate for the item to be removed.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     *
     *
     * @return The removed items.
     */
    function remove<T>(array: T[], itemOrPredicate: T | ((value: T) => boolean), startIndex?: number): T[];
    function pushUnique<T>(uniqueTarget: T[], source: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean, sourceUnique?: boolean): T[];
    /**
     * Returns a unique set from this array based on the predicate.
     *
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @return A new array with the unique values.
     */
    function unique<T>(array: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param arrays The list of arrays to get union of.
     * @return A new array with the unique values.
     */
    function union<T>(...arrays: ReadonlyArray<T>[]): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param other The other array to concatenate with this one.
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @return A new array with the unique values.
     */
    function union<T>(array: ReadonlyArray<T>, other: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Merge multiple T, T[] into a combine T[] exclude null or undefined arguments.
     *
     * @param data, a list fo T, T[]
     * @returns concatenated array.
     */
    const merge: <T>(...data: (T | T[])[]) => T[];
    /**
     * Projects each element of a sequence to a sequence and flattens the resulting sequences into one sequence.
     *
     * @param selector The projection function.
     * @return A flattened array.
     */
    function mapMany<T, TResult>(array: ReadonlyArray<T>, selector: (source: T) => ReadonlyArray<TResult>): TResult[];
    /**
     * Sorts an array using a stable sort algorithm.
     *
     * This method returns a new array, it does not sort in place.
     *
     * @param compare The Compare function.
     * @return Sorted array.
     */
    function stableSort<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[];
    /**
     * Extends from  a source array into an existing string map of key => item.
     *
     * @param objToExtend The target object to be extended.
     * @param sourceArray The source array to convert to a map properties of target object.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the key for the item, otherwise the item itself is used.
     * @param  onlyIfNotExist If true, only Extend the value in array if the existing slot is still undefine. (This behaves like type script argument default value, it only fill in if the value is undefined.)
     *
     * @return The string map of key => item for the source array.
     */
    function extendArrayIntoMap<T, U>(objToExtend: StringMap<U>, sourceItems: ReadonlyArray<T>, getKeyCallback?: (item: T, index?: number) => string, getValueCallback?: (item: T, index?: number, key?: string) => U, onlyIfNotExist?: boolean): StringMap<U>;
    function extendArrayIntoMap<T, U>(objToExtend: NumberMap<U>, sourceItems: ReadonlyArray<T>, getKeyCallback?: (item: T, index?: number) => number, getValueCallback?: (item: T, index?: number, key?: string) => U, onlyIfNotExist?: boolean): NumberMap<U>;
    /**
     * Extends from  a source array into an existing string map of key => item.
     *
     * @param objToExtend The target object to be extended.
     * @param sourceArray The source array to convert to a map properties of target object.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the key for the item, otherwise the item itself is used.
     * @param  onlyIfNotExist If true, only Extend the value in array if the existing slot is still undefine. (This behaves like type script argument default value, it only fill in if the value is undefined.)
     *
     * @return The string map of key => item for the source array.
     */
    function extendStringMapIntoMap<T, U>(objToExtend: StringMap<U>, sourceItems: StringMap<T>, getValueCallback?: (item: T, key?: string) => U, onlyIfNotExist?: boolean): StringMap<U>;
    /**
     * Helpers funciton to create a object lightweight constructor
     *
     * @param keys the ordered argument keys
     *
     * @return The function that will return string map base on the arguments index order of keys
     */
    function getStringMapFunc(...keys: string[]): Func<StringMap<any>>;
    function getStringMapFunc(keys: string[]): Func<StringMap<any>>;
    /**
     * Helpers funciton to create a object lightweight constructor
     *
     * @param keys the ordered argument keys
     *
     * @return The function that will return string map base on the arguments index order of keys
     */
    function applyStringMapFunc(keys: string[]): Func<StringMap<any>>;
    /**
     * Helpers funciton to create a object of type NameValue<N, T>
     *
     * @param name name
     * @param value value
     *
     * @return an object of NameValue<N, T>
     */
    const getNameValue: <N, T>(name: N, value: T) => NameValue<N, T>;
    /**
     * Get a list of typeScript Enum into Array
     *
     * @param tsEnumeration The Type script Enum Array
     * @param sort optional whether to sort by enum's value
     * @return all NameValue<string, number>[] for this typeScriptEnum
     */
    function getEnumArray(tsEnumeration: any, sort?: boolean): NameValue<string, number>[];
    /**
     * Coerce an input into an array if it isn't already one.
     */
    function makeArray<T>(input: T | T[]): T[];
    /**
     * Checks if given dates are equal.
     *
     * @param left Left hand side date.
     * @param left Right hand side date.
     * @return True if left date is equal to right date.
     */
    function areEqualDates(left: any, right: any): boolean;
    /**
     * Round down the date.getTime() to seconds
     *
     * @param date.
     * @return the getTime in seconds
     */
    function toSeconds(date: Date): number;
    /**
     * Returns 'true' if 'data' is an observable array (including KnockoutObservableArray<T> and KnockoutObservableBase<T[]>).
     *
     * @param data The data.
     * @return 'true' if the supplied data is an observable array.
     */
    function isObservableArray<TV, TO extends KnockoutObservableArray<TV> = KnockoutObservableArray<TV>>(data: TO | TV): data is TO;
    type ArrayOrObservableArray<T> = T[] | KnockoutObservableArray<T> | KnockoutObservableBase<T[]>;
    /**
     * Returns 'true' if 'data' is an array or observable array (including T[], KnockoutObservableArray<T> and KnockoutObservableBase<T[]>).
     *
     * @param data The data.
     * @return 'true' if the supplied data is an array or an observable array.
     */
    function isArrayOrObservableArray<TV, TO extends ArrayOrObservableArray<TV> = ArrayOrObservableArray<TV>>(data: TO | TV): data is TO;
    /**
     * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
     *
     * @return New GUID.
     */
    const newGuid: () => string;
    /**
     * Returns a function that can generate globally unique identifiers.
     * Generates a new guid every 4096 calls and concatenates it with an
     * auto incrementing number.  This maintains a complient GUID 4 format
     * if no prefix is added.
     *
     * @return a globally unique string generating function.
     */
    function getUniqueIdGenerator(prefix?: string): () => string;
    /**
     * Returns a function that can generate unique id under the prefix
     * Concatenates prefix with an auto incrementing number.
     *
     * @return a unique string generating function which return a prefix with auto incrementing number
     */
    function getIdGenerator(prefix: string): () => string;
    /**
     * Returns a globally unique identifier string.
     * Lighter-weight than newGuid.
     *
     * @return a globally unique string.
     */
    const getUniqueId: () => string;
    /**
     * Rounds a number to the specified precision.
     *
     * @param numr The number to round.
     * @param precision The precision to round the number to. Defaults to 0.
     * @returns The rounded number.
     */
    function round(num: number, precision?: number): number;
    /**
     * Truncates a number to the integer part.
     *
     * @param value The number to truncate.
     * @return The integer number.
     */
    function truncate(value: number): number;
    /**
     * Returns the result of the boolean exclusive-or operator.
     *
     * @param a First operand.
     * @param b Second operand.
     * @return true if the arguments have different values, false otherwise.
     */
    function xor(a: boolean, b: boolean): boolean;
    /**
     * Generates a random integer between min and max inclusive.
     *
     * @param min The minimum integer result.
     * @param max The maximum integer result.
     * @return A random integer.
     */
    function random(min: number, max: number): number;
    /**
     * Helper function to set a object property as observable if not exists, if is already an observable, set the observableValue.
     * @param obj the object to set property on .
     * @param key A property name.
     * @param value Optional,  of the observable will be. when not provided. this observable will reset to undefeined.
     */
    function setObjPropAsObservable(obj: StringMap<any>, key: string, value?: any): void;
    /**
     * Returns a boolean reflecting whether two scalar values (not object-typed, not array-typed, not function-typed)
     * are equal.  Accounts for the fact that JavaScript Date derives from Object.
     * The caller is responsible for supplying exclusively number-, string- or Date-typed values here.
     *
     * @param left The first scalar value.
     * @param right The second scalar value.
     * @return A boolean reflecting whether the two scalar values are equal.
     */
    function areEqual<T>(left: T, right: T): boolean;
    /**
     * Verifies that two arrays are equal.
     *
     * @param array1 The array to check.
     * @param array2 The array to compare the first array to.
     * @returns A value indicating whether or not the two arrays are equal.
     */
    function arrayEquals<T>(array1: T[], array2: T[]): boolean;
    type GetTypeOfValues = "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "null" | "date" | "array";
    function getTypeOf(x: any): GetTypeOfValues;
    function deepEquals<T>(a: T, b: T, peek?: boolean): boolean;
    /**
     * Checks if a given value is an object or not.
     *
     * @param value Value to test.
     * @return True if value is an object, false otherwise.
     */
    function isObject(value: any): value is Object;
    /**
     * Maps each value of the input object. Values that map to null or undefined are skipped.
     *
     * @param obj Input object whose properties are to be mapped.
     * @param callback Invoked for each property of the object to perform the mapping.
     * @param arg An Optional value that can be passed to callback.
     * @return An array of mapped values.
     */
    function map<T, U>(obj: StringMap<T>, callback: (item: T, key?: string, arg?: any) => U, arg?: any): U[];
    /**
     * Shallow copy from a key/value pairs object.
     *
     * @param dest An un-typed object to be populated.
     * @param src An un-typed object with values to populate.
     * @param scopes Scoped down the list for shallowCopy
     */
    function shallowCopyFromObject(dest: Object, src: Object, scopes?: string[]): void;
    /**
     * Determines if the current string ends with the given string.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
     * http://jsperf.com/string-prototype-endswith/18
     *
     * @param input The input string.
     * @param searchString The characters to be searched for at the end of this string.
     * @param position Optional. Search within this string as if this string were only this long; defaults to this string's actual length, clamped within the range established by this string's length.
     * @return A value indicating whether or not the input string ends with the search string.
     */
    function endsWith(input: string, searchString: string, position?: number): boolean;
    /**
     * Compares the current string to another string and returns a value indicating their relative ordering.
     *
     * @param input The input string to compare.
     * @param other The value to compare the input string to.
     * @param locales The optional array of locale values that will be passed to localeCompare.
     * @param options The options supported by localeCompare.
     * @return 0, if the strings are equal; a negative number if the current string is ordered before value; a positive non-zero number if the current string is orered after value.
     */
    function localeCompareIgnoreCase(input: string, other: string, locales?: string[], options?: CollatorOptions): number;
    /**
     * Repeats the string the specified number of times.
     * @param input The input string.
     * @param count The number of times to repeat the string.
     * @returns The result string.
     *  http://jsperf.com/repeatstring2
     */
    function repeat(input: string, count: number): string;
    /**
     * reverse the string.
     * @param input The input string.
     * @returns The result string.
     */
    function reverse(input: string): string;
    /**
     * Return a function that will perform join with that separator
     *
     * @returns a function that will join the parts together with the character, for example.
     *   joinPaths = getJoinFunc("/");
     *   joinByDash = getJoinFunc("-");
     *
     *  joinPaths("a", "b", "c") will return  "a/b/c";
     *  joinByDash("a", "b", "c") will return  "a-b-c";
     */
    function getJoinFunc(sep: string): (...parts: string[]) => string;
    /**
     * Return a function that will perform quote the input.  (Mimizer helper).
     *
     * @returns a function that will join the parts together with the character(s).
     *   For example.
     *     quote = getQuoteFunc("'");
     *     parenthesis = getQuoteFunc("(", ")");
     *     poMarker = getQuoteFunc("####");
     *
     * quote("abc") will return "'abc'";
     * parenthesis("abc") will reutrn "(abc)";
     * poMarker("abc") will return "####abc####";
     */
    function getQuoteFunc(prefix: string, suffix?: string): (input: string) => string;
    /**
     * Replaces all instances of a value in a string.
     *
     * @param input The input string.
     * @param searchValue The value to replace.
     * @param replaceValue The value to replace with.
     * @return A new string with all instances of searchValue replaced with replaceValue.
     */
    function replaceAll(input: string, searchValue: string, replaceValue: string): string;
    /**
     * Replaces multiple instances of search values and replacement values in a string.
     *
     * @param input The input string.
     * @param replacementMap A string map where each key represents the string to replace, and that key's value represents the value to replace it with.
     * @return A new string with replacementMap values replaced.
     */
    function replaceMany(input: string, replacementMap: StringMap<string>): string;
    /**
     * Splits a string into the specified number of parts.
     * Differs from string.split in that it leaves the last part containing the remaining string (with separators in it).
     * string.split truncates the extra parts.
     * @param input The string to be split.
     * @param separator A string that identifies the character or characters to be used as the separator.
     * @param limit A value used to limit the number of elements returned in the array.
     * @return An array of strings whose length is at most the value of limit.
     */
    function split(input: string, separator: string, limit: number): string[];
    /**
     * Determines if the current string starts with the given string.
     * http://jsperf.com/string-startswith/49
     *
     * @param input The input string.
     * @param searchString The characters to be searched for at the start of this string.
     * @param position Optional. The position in this string at which to begin searching for searchString; defaults to 0.
     * @return A value indicating whether or not the input string begins with the search string.
     */
    function startsWith(input: string, searchString: string, position?: number): boolean;
    /**
     * Trims all occurrences of the given set of strings off the end of the input.
     */
    const trimEnd: (input: string, ...values: string[]) => string;
    /**
     * Trims all occurrences of the given set of strings off the start of the input.
     */
    const trimStart: (input: string, ...values: string[]) => string;
    /**
     * Ensures that the given string ends with the suffix provided.
     * If it already does, it just returns the input string.
     * If it does not, then the suffix is appended and the result is returned.
     */
    function ensureSuffix(input: string, suffix: string): string;
    /**
     * Ensures that the given string starts with the prefix provided.
     * If it already does, it just returns the input string.
     * If it does not, then the prefix is applied and the result is returned.
     */
    function ensurePrefix(input: string, prefix: string): string;
    /**
     * Joins strings in the components array with the specified separator between them.
     * Ignores empty/falsy entries in the components array.
     * If a leading (or trailing) separator is desired, prefix (or suffix)
     * the array of components with an entry that is a separator.
     */
    function pathJoin(pathSeparator: string, ...pathComponents: string[]): string;
    function pathJoin(pathSeparator: string, pathComponents: string[]): string;
    /**
     * Parse an uri and return the Authority of the uri.
     *
     * @param uri The string of uri.
     * @return Authority of the uri.
     */
    function getUriAuthority(uri: string, includePort?: boolean): string;
    /**
     * Verify if one Url is subdomain of another Url.
     *
     * @param domain The string of domain.
     * @param subdomain The string of subdomain
     * @return True if subdomain is subdomain of domain.
     */
    function isSubdomain(domain: string, subdomain: string): boolean;
    /**
     * Returns whether the given URI is an absolute URI.
     *
     * @param uri The URI.
     * @return A boolean value indicating whether the URI is absolute.
     */
    function isUriAbsolute(uri: string): boolean;
    function tryImmediateResolve<T, TR>(promise: Q.Promise<T>, onFulfill: (value: T) => TR | Q.Promise<TR>, onReject?: (reason?: Error) => any): Q.Promise<TR>;
    /**
     * Attempts to execute the callback if the promise is already resolved or rejected,
     * otherwise, waits for the promise resolution or rejection.
     *
     * @param promise The promise to be resolved or rejected.
     * @param onFinally The callback to be executed.
     */
    function tryImmediateFinally<T>(promise: Q.Promise<T>, onFinally: () => any): Q.Promise<T>;
    /**
     * Escapes regular expression special characters -[]/{}()*+?.\^$|
     *
     * @param str The string to escape.
     * @return The escaped string.
     */
    function regexEscape(str: string): string;
    /**
     * No-op function.
     */
    function noop(): void;
    /**
     * Identity function.
     *
     * Note: https://en.wikipedia.org/wiki/Identity_function
     */
    function identity<T>(e: T): T;
    /**
     * Generates a function that returns the provided input.
     */
    function wrap<T>(e: T): Func<T>;
    /**
     * Returns whether the given data is primitive data type.
     * ECMAScript 6 standard defines 6 primitive data types: Boolean, Null, Undefined, Number, String, Symbol(new in ECMAScript 6)
     *
     * @param data The input data.
     * @return A boolean value indicating whether the data is primitive data type.
     */
    function isPrimitive(data: any): data is Primitive;
    /**
     * Applies polyfills as properties to the prototype of the given object.
     * If force is specified the polyfills will overwrite any existing properties.
     */
    function polyfill(kind: {
        prototype: Object;
    }, fills: Object, force?: boolean): void;
    /**
     * Get a readonly map that is a faster alternative to cast a string to small and non-negative integers.
     * - Doesn't support negative integer since the performance is significantly decreased for negative integer.
     * - The JSperf links: http://jsperf.com/int-to-string-map/4, http://jsperf.com/cast-int-to-string-in-loop.
     *
     * The StringToIntMap is mainly used to convert string to const enum. For example:
     * const enum Fruit {
     *   Unknown = 0,
     *   Apple = 1,
     *   Banana = 2,
     *   Max = 3
     * }
     * var stringToIntMap = utilities.getStringToIntMap(Fruit.Max);
     * strictEqual(stringToIntMap["1"], Fruit.Apple);
     * strictEqual(stringToIntMap["2"], Fruit.Banana);
     *
     * @param requiredMaxInteger The required max integer.
     * @returns The object have one to one mapping between the string and the corresponding integer. e.g. {"0":0,"1":1,"2":2,"3":3,"4":4, ... }.
     */
    function getIntToStringMap(requiredMaxInteger: number): string[];
    /**
     * Get a readonly map that is a faster alternative to cast a small and non-negative integer to string.
     * - Doesn't support negative integer since the performance is significantly decreased for negative integer.
     * - The JSperf links: http://jsperf.com/parseint-vs-map-lookup/2, http://jsperf.com/parseint-vs-map-lookup-2
     *
     * The intToStringMap is mainly used to convert const enum to string. For example:
     * const enum Fruit {
     *     Unknown = 0,
     *     Apple = 1,
     *     Banana = 2,
     *     Max = 3
     * }
     *
     * var stringToIntMap = utilities.getStringToIntMap(Fruit.Max);
     * strictEqual(intToStringMap[Fruit.Unknown], "0");
     * strictEqual(intToStringMap[Fruit.Apple], "1");
     *
     * @param requiredMaxInteger The required max integer.
     * @returns The array to have increment integer in string representation. e.g. ["0","1","2","3","4", ...].
     */
    function getStringToIntMap(requiredMaxInteger: number): StringMap<number>;
    /**
     * Makes a shallow clone of the source object with the same prototype and rebinds all functions
     * on the clone to use the source object as 'this'.
     *
     * @param object The source object.
     * @return The cloned object.
     */
    function cloneAndRebindFunctions<T>(object: T): T;
    /**
     * Takes a value and lower cases recursively.
     * For a string, returns the lower case string (non-value remains non-value).
     * For an object, recursively converts all string properties to lower case strings, including arrays of values.
     * For an array, returns an array with all string values converted to lower case.
     *
     * @param source The source value to make lower case.
     * @returns The lower case value.
     */
    function lowerCaseAllStrings(source: any): any;
    /**
     * Returns whether code that could have a performance impact but would assist with development should be enabled.
     */
    let isDiagnosticsEnabled: boolean;
    /**
     * Extends the target object with the properties from source object.
     *
     * @param target The object that is to be extended. This object is modified and returned.
     * @param source The object whose properties are to be copied over.
     * @param deep A flag indicating whether the operation is to be performed recursively.
     * @return The same target object (after extension).
     */
    function extend<T, U>(target: T, source: U, deep?: boolean): T & U;
    /**
     * Clones the source object.
     *
     * @param source The object whose properties are to be copied over.
     * @param deep A flag indicating whether the operation is to be performed recursively.
     * @param noWrapPrimitives If true, top-level primitives such as 'null' will be returned unchanged. If false, top-level primitives will be converted into objects. Defaults to false.
     * @return A new cloned object.
     */
    function clone<T>(source: T): T;
    function clone<T>(source: T, deep: boolean): T;
    function clone<T>(source: T, deep: boolean, noWrapPrimitives: boolean): T;
    /**
     * Similar to extend, except does not modify target.
     * Instead returns a clone of target extended with source.
     */
    function extend2<T, U, V, W>(s1: T, s2: U, s3?: V, s4?: W): T & U & V & W;
    /**
     * Encodes html string.
     *
     * @param value The string to encode.
     * @return The encoded string.
     */
    const encodeHtml: (value?: any) => string;
    /**
     * Encodes the input into a string that is properly escaped.
     *
     * @param value Input to encode.
     * @return Encoded string.
     */
    function encodeAttribute(value?: any): string;
    /**
     * Generates the current JavaScript call stack.
     * On IE9 there is no stack so we get empty string.
     *
     * Note that by default, for slower platform, IE11 etc, which error doesn't come with that stack.
     * We will not get the call stack for those slow platform even if you set to force.
     * Since for common problem, you should have enough information just by morden browser (chrome, edge, firefox.)
     * Use feature.includeslowgetcallstack to enable call stack capture for those slow browser
     *
     * @param force If true, the call stack is returned even if it is expensive to compute.
     * @return The call stack.
     */
    function getCurrentCallStack(force?: boolean): string;
    /**
     * Generates a deterministic string representation for an object.
     *
     * For objects with single properties, the default serialization is used.
     *   For example: {"prop":value}
     * For objects with multiple properties, an array is used to mantain a deterministic order of (sorted) properties.
     *   For example: { b:2, a:1 } => {#:[{a:1},{b:2}]}
     *
     * @param obj Object to serialize.
     * @param properties Optional root properties to include in the
     *
     * @return String representation of object.
     */
    function toSortedString(obj: any, rootProperties?: string[]): string;
    /**
     * Parses a string generated by "toSortedString" method and rehydrates the original object.
     *
     * Similar to JSON.stringify/parse, the rehydrated object will have all the properties
     * from original object, except properties that were set to 'undefined' when serializing.
     *
     * @param sortedString Sorted string.
     * @return Deserialized object.
     */
    function parseSortedString(sortedString: string): any;
    /**
     * Disposes various properties of a view model object.
     *
     * @param viewModel The view model.
     */
    function disposeViewModelProperties(viewModel: any): void;
    /**
     * Generates a property that is not serializable.
     *
     * @param The string to use as part of the property name.
     * @return The non-serializable property name.
     */
    function generateNonSerializableProperty(str: string): string;
    /**
     * Determines whether or not the specified property represents a serializable property.
     *
     * @param propertyName The property name to check.
     * @return True if it's serializable property; false if not.
     */
    function isSerializableProperty(propertyName: string): boolean;
    const getFunctionName: (func: Function) => string;
    function getObjectConstructorName(obj: Object): string;
    /**
     * Helper function to get the objectDescriptor string.
     * Initial design is to help capture when we try to serialized a object which contains cyclic.
     * But doesn't have enough informaiton for the live site issue to pass on to the right team.
     * The data is intend for event log, thus by default doesn't prinit out the data since value might contains
     * user information and security object.
     * In addition, since the object is already cyclic, it only capture the first level property.
     *
     * You should be wary about the performance. This is equavlent to runtime reflection.
     * In addition, In the deepRecursive Mode, it mark the visisted object as "visited", if the object is been ask the second time to serialized the object again.
     * it will mark it as [potential circular].  The reason is that the object can be cached in legit way in two different property and ko.observable. It will break it out to avoid forever loop.
     * Do not use [potential circular] as detection mechanism, this is mainly for the logging purpose.
     *
     * @param obj the object to get the ObjectDescriptor on
     * @param deepRecursive:recursively get into the object to get the string.
     * @return string of object representation.
     *   Here is a dump of StackedAreaChart from the sample.
     *   x = ko.dataFor($0).data
     *   getObjectDescriptor(x)
     *   Here is the return string.
     * {
     *  <ViewModel>: {
     *  disabled: <function>observable,
     *  title: <function>observable,
     *  showTitle: <function>observable,
     *  width: <function>observable,
     *  height: <function>observable,
     *  noDataMessage: <string>,
     *  series: <function>observable,
     *  xAxis: <Axis>,
     *  yAxis: <Axis>,
     *  secondaryXAxes: <function>observable,
     *  secondaryYAxes: <function>observable,
     *  views: <function>observable,
     *  legendPosition: <function>observable,
     *  interactionBehavior: <function>observable,
     *  autogenerateSeriesViews: <function>observable,
     *  events: <Events>,
     *  seriesSelections: <function>observable,
     *  seriesHovers: <function>observable,
     *  hoveredID: <function>observable,
     *  enableTrackXSlider: <function>observable,
     *  disableXSliderMouseout: <function>observable,
     *  xSliderCoordinate: <function>observable,
     *  xSliderFilterHoverThreshold: <function>observable
     *  }
     * }
     * In the dev mode, you can pass in the second argument as deepRecursive
     * getObjectDescriptor(x, enableDebugMode /* true* /);
     * {
     *  <ViewModel>: {
     *    disabled: {
     *      <function>observable: <boolean>
     *    },
     *    title: {
     *      <function>observable: <string>
     *    },
     *    showTitle: {
     *      <function>observable: <boolean>
     *    },
     *    width: {
     *      <function>observable: <number>
     *    },
     *    height: {
     *      <function>observable: <number>
     *    },
     *    noDataMessage: <string>,
     *    series: {
     *      <function>observable: <Array[6]>
     *    },
     *    xAxis: {
     *      <Axis>: {
     *        name: {
     *          <function>observable: <string>
     *        },
     *        scale: {
     *          <function>observable: <number>
     *        },
     *        ticks: {
     *          <function>observable: <number>
     *        },
     *        position: {
     *          <function>observable: <number>
     *        },
     *    .... skip...
     * }
     */
    function getObjectDescriptor(obj: any, deepRecursive?: boolean, includePrivate?: boolean): string;
    /**
     * Converts a source array to a string map of key => item.
     *
     * @param sourceArray The source array to convert to a map.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the value for the item, otherwise the item itself is used.
     * @return The string map of key => item for the source array.
     */
    function convertArrayToMap<T>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => string): StringMap<T>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => string, getValueCallback: (item: T, index?: number, key?: string) => U): StringMap<U>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => string, getValueCallback?: (item: T, index?: number, key?: string) => U): StringMap<U>;
    function convertArrayToMap<T>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => number): NumberMap<T>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => number, getValueCallback: (item: T, index?: number, key?: string) => U): NumberMap<U>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => number, getValueCallback?: (item: T, index?: number, key?: string) => U): NumberMap<U>;
    /**
     * Utility to map a knockout projected array to an observable array.
     * Knockout projection which returns observable of array while many view model exposes KnokoutObservableArray.
     * This utility will help in mapping the projected array to ObservableArray.
     *
     * @param lifetime The LifetimeManager reflecting the lifetime of the array that's computed.
     * @param mappedArray Knockout projected array.
     *
     * @return returns KnockoutObservableArray.
     */
    function thunkArray<T>(lifetime: Base.LifetimeManager, mappedArray: KnockoutObservableBase<T[]>): KnockoutObservableArrayDisposable<T>;
    /**
     * Checks if the given object can be sent through postMessage().
     * E.g., postMessage() does not support functions, Errors, or DOM nodes.
     *
     * @param root The object to check.
     * @return True if the object can be sent through postMessage()
     */
    function canSendThroughPostMessage(root: any): boolean;
    /**
     * Compares two values.
     * Works for primative types string, date, number, and boolean.
     * Works for observables contining the primative types.
     *
     * @param value The value.
     * @param compareTo The compare to value.
     * @return An integer indicating if the value is greater or less than the compareTo.
     */
    function compare(value: any, compareTo: any): number;
    /**
     * Initializes a value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @return The initial value.
     */
    function initValue<T>(value?: T, defaultValue?: T): T;
    /**
     * Initializes an observable value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @return The initial observable value.
     */
    function initObservable<T>(value?: T | KnockoutObservable<T>, defaultValue?: T): KnockoutObservable<T>;
    /**
     * Initializes an observable value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @return The initial observable value.
     */
    function initObservable<T>(value?: T | KnockoutObservableBase<T>, defaultValue?: T): KnockoutObservableBase<T>;
    /**
     * Initializes an observable array of values.
     *
     * @param values The values to use.
     * @param defaultValues The values to use when values is undefined.
     * @return The initial observable values.
     */
    function initObservableArray<T>(values?: T[] | KnockoutObservableArray<T>, defaultValues?: T[]): KnockoutObservableArray<T>;
    /**
     * Initializes an observable array of values.
     *
     * @param values The values to use.
     * @param defaultValues The values to use when values is undefined.
     * @return The initial observable values.
     */
    function initObservableArray<T>(values?: T[] | ReadonlyArray<T> | KnockoutReadOnlyObservableArray<T>, defaultValues?: T[]): KnockoutReadOnlyObservableArray<T>;
    let markIgnoreHighDependenciesCount: (koComputed: KnockoutSubscribable<any>) => void;
}

// FILE: MsPortalFx\Utilities.Internal.d.ts
declare module FxImpl {
    import Fx = MsPortalFx;
    /**
     * Converts an object graph into a form that can be JSON-serialized while retaining
     * information about which properties are observable.
     *
     * Note that information about computed properties is not retained: they will be
     * treated as non-computed observables, since the evaluators cannot be serialized
     * in general.
     *
     * @param root The root of the object graph that may contain observables.
     * @return A serializable object.
     */
    function toSerializableObject(root: any): any;
    /**
     * Returns whether the given object was serialized using the toSerializableObject API.
     *
     * @param object Object to test.
     * @return True if the object was serialized by the Serialization utility.
     */
    function isSerializedObject(object: Object): boolean;
    /**
     * Converts an object previously returned by toSerializableObject into a regular
     * object graph. This recovers the object with the equivalent properties being observable or
     * observable arrays.
     *
     * Note that information about computed properties is not retained: they will be
     * treated as non-computed observables, since the evaluators cannot be serialized
     * in general.
     *
     * @param serializableObject An object previously returned by toSerializableObject (possibly having been passed through JSON serialization).
     * @return An object graph that may include observables.
     */
    function fromSerializableObject(serializableObject: any): any;
    let _setReportCycleError: (func?: (message: string, root: any) => any) => void;
    interface Resettable {
        reset(): void;
    }
    function registerGlobalState(resettable: Resettable): void;
    function resetGlobalState(): void;
    interface ThrowErrorFunction {
        (...formatArguments: any[]): any;
    }
    /**
     * Helper function to return a general error object
     */
    function createError(errorMessage: string, extra?: {
        data?: StringMap<any>;
        innerErrors?: Error | Error[];
    }): Fx.Errors.Error;
    /**
     * Helper funciton to reutrn Q.reject with Error object
     */
    function QReject(errorMessage: string, extra?: {
        data?: StringMap<any>;
        innerErrors?: Error | Error[];
    }): Q.Promise<any>;
    /**
     * Returns a map of functions that throw errors with the provided messages.
     */
    function getErrorMap(obj: Object): Object;
    /**
     * Used in jquery-2.2.4.js
     * removes ability to use eval if nojqueryeval feature flag is set.  Logs an error if jquery uses eval otherwise.
     * @param code code being evaluated
     * @returns if the eval should be skipped
     */
    function skipEval(code: string, logArea: string): boolean;
    function lowerCaseStringMap<T>(): MapBase<string, T>;
    /**
     * Creates an object with the same keys as object and values generated by running each own enumerable property of object through the callback.
     *
     * @param o The object.
     * @param selector The selector.
     * @return The projected object.
     */
    function mapValues<K extends string, T, R>(o: ReadonlyTypedStringMap<K, T>, selector: (value: T, key: K, o: ReadonlyTypedStringMap<K, T>) => R): PartialTypedStringMap<K, R>;
    /**
     * Creates an array of elements split into two groups, the first of which contains elements `predicate` returns truthy for, the second of which contains elements `predicate` returns falsey for. The predicate is invoked with one argument: (value).
     *
     * @param o The object.
     * @param partition The predicate.
     * @return The partitioned array.
     */
    function partition<T>(o: ReadonlyArray<T>, predicate: (o: T) => boolean): [T[], T[]];
    /**
     * Boilerplate implementation of deferred for native promises.
     * Deferred does not exist in the native promise spec but this is a universially accepted
     * and widely used implementation.
     */
    interface Deferred<T> {
        promise: Promise<T>;
        resolve(value?: T | Promise<T>): void;
        reject(reason?: any): void;
    }
    function defer<T>(): Deferred<T>;
    /**
     * Returns a native promise
     * @param obj Native Promise
     * @returns returns never to force a compile error
     */
    function toPromise<T>(obj: Promise<T>): never;
    /**
     * Returns a native promise
     * @param obj Q, JQuery or anything that is promise like
     * @returns A native promise that is a proxy of the promise like object
     */
    function toPromise<T>(obj: PromiseLike<T>): Promise<T>;
}

// FILE: MsPortalFx\ViewModels\ClickableLink.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model that represents a click target that opens a link.
     */
    class ClickableLink {
        /**
         * The URI that will be opened.
         */
        uri: KnockoutObservable<string>;
        /**
         * The link target. Target is _blank if unspecified.
         */
        target: KnockoutObservable<string>;
        /**
         * Window features for the new window.
         * See https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Window_features
         */
        windowFeatures?: KnockoutObservable<string>;
        /**
         * Callback triggered after the link is opened.
         *
         * @param keypress Indicates if the link is opened by keypress.
         */
        onLinkOpened: (keypress: boolean) => void;
        /**
         * Telemetry identifier.
         */
        readonly telemetryName?: string;
        /**
         * Construct an instance of the view model.
         *
         * @param uri The URI that will be opened.
         * @param target The link target.
         * @param windowFeatures Window features for the new window.
         * @param onLinkOpened Callback triggered after the link is opened.
         * @param telemetryName partner provided Telemetry identifier.
         */
        constructor(uri: string | KnockoutObservable<string>, target?: string | KnockoutObservable<string>, windowFeatures?: string | KnockoutObservable<string>, onLinkOpened?: (keypress: boolean) => void, telemetryName?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Composition\CompositionState.d.ts
declare module FxImpl.ViewModels {
    enum CompositionState {
        /**
         * The composition is ready to be bound and displayed.
         */
        Ready = 0,
        /**
         * The composition is in a failed state.
         */
        Failed = 1,
        /**
         * The composition has one or more operations in progress.
         */
        Preparing = 2
    }
}

// FILE: MsPortalFx\ViewModels\Composition\ViewModels.Composition.d.ts
declare module FxImpl.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxImplExtension = FxImpl.Extension;
    import BladeReference = FxImpl.Composition.Selectable.BladeReference;
    /**
     * A description of all applied filters, broken down into active
     * dashboard-level filters and filters applied at the part level.
     */
    interface AllFilterModels {
        /**
         * Indicates al filter models for those filters that are applied to a part.
         */
        part: StringMap<FxImpl.ViewModels.AllFilterModels>;
        /**
         * Indicates all filter models for those filters that are applied to the dashboard.
         */
        dashboard: StringMap<FxImpl.ViewModels.AllFilterModels>;
    }
    /**
     * internal interface used by the shell
     */
    interface FrameworkViewModelContract {
        /**
         * selectables that are managed by the shell
         */
        selectable: KnockoutObservable<any>;
        /**
         * Indicates whether the part's UI may be blocked, e.g., because there are outstanding operations.
         */
        allowUiBlocking: KnockoutObservable<boolean>;
    }
    interface FrameworkBladeVirtualPartViewModelContract {
        /**
         * The time at which the async 'getViewModel' call was received and the process of instantiating/composing the view model began.
         */
        getViewModelStart?: number;
        /**
         * A performance mark name used within the web worker when creating performance measurements relative to "'onInitialize' called".
         */
        onInitializeStartMark?: string;
        /**
         * The time at which 'onInitialize' was called.
         */
        onInitializeStart?: number;
        /**
         * The time taken to load the Blade/Part's view model bundles.
         */
        bundleLoadingTime?: number;
        /**
         * The time from the start of 'onInitialize' to the time when the first ajax call is made.
         */
        prepareFirstAjaxTime: KnockoutObservable<number>;
        /**
         * The time from the start of 'onInitialize' until the returned Promise is resolved.
         */
        onInitializeAsyncTime: KnockoutObservable<number>;
        /**
         * If this is a MenuBlade, this is a Promise that conveys to Shell the BladeReference corresponding to any initially selected menu item.
         */
        initialMenuContentBlade: Q.Promise<BladeReference<unknown>>;
    }
    interface FrameworkPartViewModelContract extends FrameworkBladeVirtualPartViewModelContract, FrameworkViewModelContract {
        /**
         * selectables dynamically registered by the view model.
         * this feature is only used by part view models currently.
         */
        registeredSelectables: KnockoutObservableBase<StringMap<MsPortalFx.ViewModels.Selectable<any> | MsPortalFx.ViewModels.SetSelection<any>>>;
        /**
         * options for registered selectables
         */
        registeredSelectableOptions: KnockoutObservableBase<StringMap<any>>;
        /**
         * Used to communicate Configuration changes back to the Shell.
         */
        updateConfigFn: KnockoutObservable<UpdateConfigurationFunction>;
        /**
         * A mechanism that allows the part viewmodel to determine whether 'revealContent' was invoked
         * from the part's constructor, and to respond to subsequent calls.
         *
         * The name has the underscore prefix purely so it doesn't get proxied. We have no use for it
         * on the Shell side.
         */
        _revealContentCallCount: KnockoutObservable<number>;
        /**
         * A mechanism by which the PartContainer can be aware of 'updatePartInputValues' calls.
         *
         * @param inputs The inputs to the part.
         * @param settings The settings for the part.
         * @param inputsMetadata Metadata describing the current configuration state of the Part's inputs (used by its Configuration API).
         */
        _onInputValuesUpdated: (inputs: any, settings: any, inputsMetadata: FxImplExtension.InputsMetadata) => void;
        /**
         * If a blade was opened from the context menu this member ensures the PO layer has a reference
         * to the command so it is not freed too early.
         */
        activeOpenBladeCommand: KnockoutObservable<any>;
        /**
         * dialog options for a dialog that is currently open
         */
        dialog: KnockoutObservable<MsPortalFx.ViewModels.DialogOptions>;
        /**
         * pinned fxelements instances to ensure they are not GC by the PO layer
         */
        elements: KnockoutObservableArray<MsPortalFx.ViewModels.FxElement>;
    }
    /**
     * Function used to communicate configuration changes to the Shell.
     */
    type UpdateConfigurationFunction = (configuration: UpdatedConfiguration, callOnUpdateWithChanges: boolean) => FxPromise;
    /**
     * Used to communicate Configuration changes back to the Shell.
     */
    interface UpdatedConfiguration {
        /**
         * Part inputs, possibly updated by the user by way of the Part's Configuration API.
         */
        inputs: any;
        /**
         * Part settings, possibly updated by the user by way of the Part's Configuration API.
         */
        settings: any;
        /**
         * Metadata describing the optional binding of Part inputs to properties on the enclosing Dashboard,
         * possibly updated by the user by way of the Part's Configuration API.
         */
        inputsMetadata: StringMap<UpdatedInputMetadata>;
    }
    /**
     * Used to communicate to the Shell changes to the binding of Part inputs to properties on the enclosing Dashboard.
     */
    interface UpdatedInputMetadata {
        /**
         * The name of the new, active binding source for this Part input (a property name on the containing Dashboard).
         */
        activeBindingSourceName?: string;
        /**
         * Directs the Shell to push the associated updated input value to the property on the containing Dashboard.
         */
        applyUpdatedValueToActiveBindingSource?: boolean;
    }
    /**
     * Type of promise from onInputsSet.
     * "Q" | "jQuery" | "unknown"
     */
    const enum OnInputsSetPromiseType {
        Unknown = 0,
        Q = 1,
        JQuery = 2
    }
    /**
     * Type and state of promise from onInputsSet.
     */
    interface OnInputsSetPromiseState {
        /**
         * Type of onInputsSet promise.
         */
        readonly type: OnInputsSetPromiseType;
        /**
         * The state of the Promise when it is first returned.
         * Will be "pending", "rejected", "fullfilled" (for Q Promise), "resolved" (for jQuery Promise)
         * or "unknown" (when no Promise is returned or if the Promise type is unknown).
         */
        readonly state: string;
    }
    /**
     * Tracing options for InputsSet.
     */
    interface CompositionViewModelTraceOptions {
        /**
         * Runtime identifier of the view model.
         */
        debugId: string;
        /**
         * Whether to break before onInputsSet is called.
         */
        breakOnInputsSet: boolean;
    }
    /**
     * Properties that the shell chrome binds too and interacts with
     */
    interface Chrome {
        title?: KnockoutObservable<string>;
        subtitle?: KnockoutObservable<string>;
        icon?: KnockoutObservable<MsPortalFx.Base.Image>;
        statusBar?: KnockoutObservable<MsPortalFx.ViewModels.BladeStatusBar>;
        menuContent?: KnockoutObservable<MsPortalFx.ViewModels.ItemWithTitleAndSubtitle>;
        /**
         * This type is a AMD module so we can't reference it here.  It consists of two types.
         * The typing would be V2PartShellApi | V2BladeShellApi.
         * The part shell API supports filtering and the blade shell api supports pinning
         */
        _msPortalFxV2ShellApi?: KnockoutObservable<any>;
    }
    /**
     * The interface implemented by view models returned to the shell.
     * It is called the composition view model because it is
     * composed of objects provided by the framework and objects provided by the extension author.
     */
    interface CompositionViewModelContract<TContainer, TContent, TFramework extends FrameworkViewModelContract> {
        /**
         * The view model for the container of a composition.
         */
        container: TContainer;
        /**
         * The view model for the content of a composition.
         */
        content: KnockoutObservable<TContent>;
        /**
         * For V2 view models, these are properties that the chrome binds too
         * for example blade title, blade icon.. etc
         */
        chrome?: Chrome;
        /**
         * Private interface used by the shell.
         */
        internal: TFramework;
        /**
         * Triggers a call to the onInputsSet of the content view model if it is defined.
         *
         * @param parameters Inputs and options with which to update the view model.
         * @param settings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * Configuration API).
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, settings?: any, traceOptions?: CompositionViewModelTraceOptions, viewModelName?: string): Q.Promise<any>;
        /**
         * Promise from onInputsSet, if that was called shortly after the view model was created.
         * Undefined otherwise.
         */
        onInputsSetPromise?: Q.Promise<any>;
        /**
         * State and type of promise from onInputsSet when it is firstly returned
         */
        onInputsSetPromiseState: KnockoutObservable<OnInputsSetPromiseState>;
    }
    function createFrameworkPartViewModel(): FrameworkPartViewModelContract;
    /**
     * Implemented by V2 / no-PDL view models.
     */
    interface ViewModelV2 {
        /**
         * Indicates that the view model is a V2 / no-PDL view model.
         * Named with '_msPortalFx' so this is available to the Shell.
         */
        _msPortalFx_viewModelApiV2: boolean;
        /**
         * Indicates if the view model is initialized
         */
        isInitialized(): boolean;
        /**
         * A variant of the PDL 'onInputsSet' that also conveys whether the extension's 'onRebind' is to be called to reflect changes
         * to parameters / settings.  This is to make 'configuration.updateValues(...)' _not_ notify the extension for self-inflicted
         * parameters/settings changes.
         *
         * @param inputs The inputs to the Part.
         * @param settings The settings for the Part.
         * @param dontCallOnRebind If true, indicates that 'onRebind' should not be called (for situations where the extension called
         * 'configuration.updateValues(...)' and reacts locally to the parameters/settings changes.
         * @param filters A StringMap from filter id to filter model for the currently applied Dashboard and part-level filters.
         * @return The promise for the onInputsSet.
         */
        onInputsSet(inputs: any, settings: any, dontCallOnRebind?: boolean, filters?: StringMap<any>): FxPromise;
        /**
         * Method to dispose this view model
         */
        dispose(): void;
    }
    /**
     * The view model base class for all compositions.
     */
    class CompositionViewModelBase<ContainerType, ViewModelType, FrameworkType extends FrameworkViewModelContract> implements CompositionViewModelContract<ContainerType, ViewModelType, FrameworkType> {
        /**
         * If this setting is enabled then when inputs change we invoke the view model factor and create a new inatnce of the view model content
         * This is public and read/write for unit tests
         */
        static alwaysCreateNewViewModels: boolean;
        /**
         * Not to be confused with the type of class, this is the role the view model is used in.
         * i.e. Part, Blade, Command, etc
         */
        readonly role: FxImpl.Extension.ViewModelType;
        /**
         * The view model for the container of a composition.
         */
        readonly container: ContainerType;
        /**
         * The view model for the content of a composition.
         */
        content: KnockoutObservable<ViewModelType>;
        /**
         * For V2 view models, these are properties that the chrome binds too
         * for example blade title, blade icon.. etc
         */
        chrome?: Chrome;
        /**
         * Private interface for shell functionality.
         */
        readonly internal: FrameworkType;
        /**
         * State and type of promise from onInputsSet when it is firstly returned.
         */
        readonly onInputsSetPromiseState: KnockoutObservable<OnInputsSetPromiseState>;
        /**
         * Factory used to create a new view model instance if the view model needs to be swapped
         */
        private _contentFactory;
        constructor(internal: FrameworkType, container: ContainerType, content: ViewModelType, role: FxImpl.Extension.ViewModelType, contentFactory: () => ViewModelType);
        /**
         * Triggers a call to the onInputsSet callbacks on the content and container view models where defined.
         * This is a abstract method and must be implemented by child classes.
         *
         * @param inputs The inputs to the part.
         * @param settings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * @param inputsMetadata For Parts only, metadata describing the current configuration state of the Part's inputs (used by its
         * Configuration API).
         * @param dontCallOnInputsSet If true, indicates that 'onInputsSet' should not be called (for situations where the extension called
         * 'configuration.updateValues(...)' and reacts locally to the parameters/settings changes.
         * @param filters A StringMap from filter id to filter model for the currently applied Dashboard-level filters and part-level filters override if any.
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, settings?: any, traceOptions?: CompositionViewModelTraceOptions, viewModelName?: string, inputsMetadata?: FxImplExtension.InputsMetadata, dontCallOnInputsSet?: boolean, filters?: AllFilterModels): Q.Promise<any>;
    }
    /**
     * The view model base class  for compositions which are not for parts
     */
    class CompositionViewModel extends CompositionViewModelBase<MsPortalFx.ViewModels.ContainerContract, any, FrameworkViewModelContract> {
        /**
         * The state of the composition.
         */
        state: KnockoutObservable<CompositionState>;
        /**
         * Promise from onInputsSet, if that was called shortly after the view model was created.
         * Undefined otherwise.
         */
        onInputsSetPromise?: Q.Promise<any>;
        constructor(container: MsPortalFx.ViewModels.ContainerContract, content: any, role: FxImpl.Extension.ViewModelType, contentFactory: () => any);
        /**
         * Triggers a call to the onInputsSet callbacks on the content and container view models where defined.
         *
         * @param inputs The inputs to the part.
         * @param settings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * @param inputsMetadata For Parts only, metadata describing the current configuration state of the Part's inputs (used by its
         * Configuration API).
         * @param dontCallOnInputsSet If true, indicates that 'onInputsSet' should not be called (for situations where the extension called
         * 'configuration.updateValues(...)' and reacts locally to the parameters/settings changes.
         * @param filters A StringMap from filter id to filter model for the currently applied Dashboard-level filters and part-level filters override if any.
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, settings?: any, traceOptions?: CompositionViewModelTraceOptions, viewModelName?: string, inputsMetadata?: FxImplExtension.InputsMetadata, dontCallOnInputsSet?: boolean, filters?: AllFilterModels): Q.Promise<any>;
    }
}

// FILE: MsPortalFx\ViewModels\Composition\ViewModels.Composition.Part.d.ts
declare module FxImpl.ViewModels.Part {
    import FxViewModels = MsPortalFx.ViewModels;
    interface ComposePartViewModelOptions {
        initialState?: any;
        createSelectable?: boolean;
        location?: FxViewModels.PartLocation;
        logArea?: string;
        flags?: FxViewModels.Internal.ViewModelFlags;
    }
    function composePartViewModel<T>(viewModelFactory: (container: FxViewModels.PartContainerContract) => T, options?: ComposePartViewModelOptions): FxViewModels.PartContract<T>;
}

// FILE: MsPortalFx\ViewModels\Controls\AzureMediaPlayer.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer {
    interface Options {
        /**
         * Start playing the video automatically or not. Default is false.
         */
        autoplay?: boolean;
        /**
         * Should display the media playback controls. Default is true.
         */
        controls?: boolean;
        /**
         * Url of poster image shown before video is played.
         */
        poster?: string;
        /**
         * Azure media services logo display configuration.
         */
        logo?: LogoConfig;
        /**
         * Video source information for playback.
         */
        source: Source;
    }
    /**
     * Interface for the Logo of Azure media player
     */
    interface LogoConfig {
        /**
         * Displays Azure Media Services logo in the player. Default is false.
         */
        enabled?: boolean;
    }
    /**
     * Source object to hold the source information in Options.
     */
    interface Source {
        /**
         * Url of the media source
         */
        url: string;
        /**
         * Streaming media format MIME type
         */
        mimeType: StreamingFormatMimeType;
        /**
         * Protection information for encrypted media content
         */
        protectionInfo?: ProtectionInfo[];
    }
    /**
     * Interface for protection information of the Source.
     */
    interface ProtectionInfo {
        /**
         * Media protection type
         */
        type: ProtectionType;
        /**
         * Authentication token for protected media content
         */
        authenticationToken?: string;
    }
    /**
     * Protection types for Azure media player
     */
    enum ProtectionType {
        PlayReady = 0,
        Widevine = 1,
        AES = 2
    }
    /**
     * Supported streaming MIME types in Azure media player
     */
    enum StreamingFormatMimeType {
        Smooth = 0,
        Dash = 1,
        HLS = 2,
        ProgressiveMP4 = 3
    }
    class ViewModel extends Base.ViewModel implements Options {
        autoplay: boolean;
        controls: boolean;
        poster: string;
        logo: LogoConfig;
        source: Source;
        /**
         * Constructs an AzureMediaPlayer view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the AzureMediaPlayer control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Balloon.d.ts
declare module MsPortalFx.ViewModels.Controls.Balloon {
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Balloon.Contract is deprecated. Use Fx/Controls/InfoBalloon instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Contract extends Loadable.Contract {
        /**
         * Whether the balloon is visible or not.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * The box relative to which the balloon will be rendered.
         */
        box: KnockoutObservable<Box>;
        /**
         * The content to display the balloon. It can be empty if there's existing content in the element.
         */
        content: KnockoutObservable<string>;
        /**
         * The balloon link.
         */
        link: KnockoutObservable<Link>;
        /**
         * jQuery selector string representing the element to append the balloon element to.
         */
        appendTo: string;
        /**
         * Hides all the other balloons that have been previously opened when shown.
         */
        closeOtherBalloons: boolean;
    }
    class Link {
        /**
         * Link text.
         */
        linkText: string;
        /**
         * Link Uri.
         */
        linkUri: string;
        /**
         * Creates a Link class.
         *
         * @param linkText The link text to be displayed.
         * @param linkUri The link uri.
         */
        constructor(linkText?: string, linkUri?: string);
    }
    class Box {
        /**
         * Vertical distance from the top of the document.
         */
        top: number;
        /**
         * Horizontal distance from the left of the document.
         */
        left: number;
        /**
         * Width of the box.
         */
        width: number;
        /**
         * Height of the box.
         */
        height: number;
        /**
         * Creates a Box class.
         *
         * @param top The horizontal offset from the top of the document.
         * @param left The vertical offset from the left of the document.
         * @param width The width of the box.
         * @param height The height of the box.
         */
        constructor(top?: number, left?: number, width?: number, height?: number);
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Balloon.ViewModel is deprecated. Use Fx/Controls/InfoBalloon instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        visible: KnockoutObservable<boolean>;
        box: KnockoutObservable<Box>;
        content: KnockoutObservable<string>;
        /**
         * The link to display in the balloon.
         */
        link: KnockoutObservable<Link>;
        appendTo: string;
        closeOtherBalloons: boolean;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Base.d.ts
declare module MsPortalFx.ViewModels.Controls.Base {
    interface Contract extends MsPortalFx.Control, MsPortalFx.Base.Disposable {
    }
    class ViewModel implements Contract {
        /**
         * Enum that defines the type of the control.
         */
        controlType: ControlType;
        /**
         * Lifetime manager.
         */
        private readonly _ltm;
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        /**
         * Method that can be called to explicitly dispose of view model resources.
         */
        dispose(): void;
        /**
         * Lifetime manager instance that is disposed when the widget is disposed.
         */
        get lifetimeManager(): MsPortalFx.Base.LifetimeManager;
        /**
         * Populates the view model from a key/value pairs object.
         * The keys should map to properties on the view model.
         * The values are applied to the corresponding keys.
         *
         * @param object An untyped object with values to populate on the view model.
         */
        populateFromObject(object: Object): void;
        /**
         * Adds a subscription to be cleaned up in the dispose().
         *
         * @param disposable One KnockoutDisposable to be added to this._disposables.
         */
        _addDisposablesToCleanUp(disposable: MsPortalFx.Base.Disposable): void;
        /**
         * Adds a list of computed to be cleaned up in the dispose().
         *
         * @param disposable Array of KnockoutDisposable to be added to this._disposables.
         */
        _addDisposablesToCleanUp(disposable: MsPortalFx.Base.Disposable[]): void;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Base\Loadable.d.ts
declare module MsPortalFx.ViewModels.Controls.Loadable {
    interface Options {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: KnockoutObservable<boolean>;
    }
    interface Contract extends MsPortalFx.ViewModels.Controls.Base.Contract {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservableBase<boolean>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel implements Contract {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservableBase<boolean>;
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, loading?: boolean);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Command.d.ts
declare module MsPortalFx.ViewModels.Controls.Command {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    /**
     * Command execution status.
     */
    enum Status {
        /**
         * Command has not been executed.
         */
        None = 0,
        /**
         * Command is in the process of executing.
         */
        Pending = 1,
        /**
         * Command execution suceeded.
         */
        Success = 2,
        /**
         * Command execution failed.
         */
        Failure = 3
    }
    /**
     * Command handler interface.
     */
    interface Handler {
        /**
         * Determines if the command is currently executable.
         */
        canExecute: KnockoutComputed<boolean>;
        /**
         * Executes the command.
         */
        execute: () => void | FxPromise;
    }
    /**
     * Command base view model interface.
     */
    interface Contract extends Loadable.Contract {
        /**
         * Indicates if the command should be displayed.
         * This can be changed  to hide/show the command.
         * It is up to UI consumers of the command to determine how to hide/show based on this value.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * The command display text.
         * It is up to UI consumers of the command to determine how to show the text.
         */
        text: KnockoutObservable<string>;
        /**
         * Optional. Sets a label alternative used by accessibility tools.
         */
        ariaLabel?: KnockoutObservable<string>;
        /**
         * The latest command status.
         */
        status: KnockoutObservable<Status>;
        /**
         * The latest command error.
         */
        error: KnockoutObservable<any>;
        /**
         * Handles the command execution.
         */
        handler: KnockoutObservable<Handler>;
        /**
         * Notification that command execution has occured.
         */
        afterExecute: () => void;
        /**
         * Executes the command.
         */
        execute(): FxPromise;
        /**
         * Attaches to the command.
         *
         * @param execute The command execution function.
         * @param canExecute The command availability function.
         */
        attach(execute?: () => void | FxPromise, canExecute?: () => boolean): void;
        /**
         * Detaches from the command.
         */
        detach(): void;
    }
    /**
     * Command base view model.
     */
    class ViewModel extends Loadable.ViewModel {
        /**
         * Indicates if the command should be displayed.
         * This can be changed  to hide/show the command.
         * It is up to UI consumers of the command to determine how to hide/show based on this value.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * The command display text.
         * It is up to UI consumers of the command to determine how to show the text.
         */
        text: KnockoutObservable<string>;
        /**
         * Optional. The aria label for screen reader if your text is not descriptive enough.
         */
        ariaLabel?: KnockoutObservable<string>;
        /**
         * The latest command status.
         */
        status: KnockoutObservable<Status>;
        /**
         * The latest command error.
         */
        error: KnockoutObservable<any>;
        /**
         * Handles the command execution.
         */
        handler: KnockoutObservable<Handler>;
        /**
         * Notification that command execution has occured.
         */
        afterExecute: () => void;
        /**
         * Creates a command view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param text The command text.
         * @param enabled The default enabled state.
         * @param visible The default visiblity.
         */
        constructor(lifetimeManager: FxBase.LifetimeManager, text?: string, execute?: () => void | FxPromise, canExecute?: () => boolean);
        /**
         * Executes the command.
         *
         * @return Callback promise for completion or failure.
         */
        execute(): FxPromise;
        /**
         * Attaches to the command.
         *
         * @param execute The command execution function.
         * @param canExecute The command availability function.
         */
        attach(execute: () => void | FxPromise, canExecute?: () => boolean): void;
        /**
         * Attaches handler to the command.
         *
         * @param handler The command handler to attach.
         */
        attachHandler(handler: Handler): void;
        /**
         * Detaches from the command.
         */
        detach(): void;
    }
    /**
     * Basic command handler implementation.
     */
    class DelegatingHandler implements Handler {
        /**
         * Indicates if the command can be executed.
         */
        canExecute: KnockoutComputed<boolean>;
        /**
         * Executes the command.
         */
        execute: () => void | FxPromise;
        /**
         * Creates a delegating command handler.
         *
         * @param execute The command execution function.
         * @param canExecute The command availability function. Can be left off or null if always true.
         * @param context The this context for the execute and canExecute callbacks.
         */
        constructor(execute: () => void | FxPromise, canExecute?: () => boolean, context?: any);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Control.d.ts
declare module MsPortalFx {
    /**
     * Contract identifying a control as something that can be created via the pcControl binding.
     */
    interface Control {
        /**
         * Enum that defines the type of the control.
         */
        readonly controlType: MsPortalFx.ViewModels.ControlType;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ControlType.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Type of control.
     */
    const enum ControlType {
        /**
         * Value indicates field has not been set to an appropriate control type.
         */
        Invalid = 0,
        /**
         * Control is a section.
         */
        Section = 1,
        /**
         * Control is a text box.
         */
        TextBox = 2,
        /**
         * Control is a drop down field.
         */
        DropDown = 3,
        /**
         * Control is an options group field.
         */
        OptionsGroup = 4,
        /**
         * Control is a password field.
         */
        Password = 5,
        /**
         * Control is a slider.
         */
        Slider = 6,
        /**
         * Control is a check box.
         */
        CheckBox = 7,
        /**
         * Control is a multiselect drop down field.
         */
        MultiselectDropDown = 8,
        /**
         * Control is a range slider.
         */
        RangeSlider = 9,
        /**
         * Control is a numeric text box.
         */
        NumericTextBox = 10,
        /**
         * Control is a selector field.
         */
        Selector = 11,
        /**
         * Control is a filter combo.
         */
        FilterCombo = 12,
        /**
         * Control is multi-line text box.
         */
        MultiLineTextBox = 13,
        /**
         * Control is a dynamic section.
         */
        DynamicSection = 15,
        /**
         * Control is an attachment control.
         */
        Attachment = 16,
        /**
         * Control is a history control.
         */
        History = 19,
        /**
         * Control is an artifact links control (used by VSO).
         */
        ArtifactLinks = 20,
        /**
         * Control is a splitter control.
         */
        Splitter = 21,
        /**
         * Control is a tri state check box.
         */
        TriStateCheckBox = 22,
        /**
         * Control is a custom html.
         */
        CustomHtml = 23,
        /**
         * Control is a time picker.
         */
        TimePicker = 24,
        /**
         * Control is a date picker.
         */
        DatePicker = 25,
        /**
         * Control is a date/time picker.
         */
        DateTimePicker = 26,
        /**
         * Control is a date/time range picker.
         */
        DateTimeRangePicker = 27,
        /**
         * Control is an OAuth button.
         */
        OAuthButton = 29,
        /**
         * QueryBuilder control.
         */
        QueryBuilder = 31,
        /**
         * DockedBalloon control.
         */
        DockedBalloon = 32,
        /**
         * DiffEditor control.
         */
        DiffEditor = 33,
        /**
         * Editor control.
         */
        Editor = 37,
        /**
         * pcCheckBox control.
         */
        pcCheckBox = 39,
        /**
         * CopyableLabel control.
         */
        CopyableLabel = 40,
        /**
         * pcDropDown control.
         */
        pcDropDown = 42,
        /**
         * pcFilterCombo control.
         */
        pcFilterCombo = 43,
        /**
         * pcMultiLineTextBox control.
         */
        pcMultiLineTextBox = 45,
        /**
         * pcMultiselectDropDown control.
         */
        pcMultiselectDropDown = 46,
        /**
         * pcNumericTextBox control.
         */
        pcNumericTextBox = 47,
        /**
         * pcOptionPicker control.
         */
        pcOptionPicker = 48,
        /**
         * pcPassword control.
         */
        pcPassword = 49,
        /**
         * pcRangeSlider control.
         */
        pcRangeSlider = 50,
        /**
         * pcSlider control.
         */
        pcSlider = 52,
        /**
         * pcGrid control.
         */
        pcGrid = 54,
        /**
         * Gallery control.
         */
        Gallery = 55,
        /**
         * pcListView control.
         */
        pcListView = 56,
        /**
         * pcTreeView control.
         */
        pcTreeView = 57,
        /**
         * LogStream control.
         */
        LogStream = 58,
        /**
         * Scrollbar control.
         */
        Scrollbar = 59,
        /**
         * Settings control.
         */
        Settings = 60,
        /**
         * SingleSetting control.
         */
        SingleSetting = 61,
        /**
         * Toolbar control.
         */
        Toolbar = 62,
        /**
         * Chart control.
         */
        Chart = 63,
        /**
         * Donut control.
         */
        Donut = 65,
        /**
         * Graph control.
         */
        Graph = 67,
        /**
         * Map control.
         */
        Map = 68,
        /**
         * Metrics control.
         */
        Metrics = 69,
        /**
         * PairedTimeline control.
         */
        PairedTimeline = 70,
        /**
         * ProgressBar control.
         */
        ProgressBar = 71,
        /**
         * QuotaGauge control.
         */
        QuotaGauge = 72,
        /**
         * SingleValueGauge control.
         */
        SingleValueGauge = 73,
        /**
         * StepGauge control.
         */
        StepGauge = 74,
        /**
         * Console control.
         */
        Console = 75,
        /**
         * DeleteAssetConfirmation control.
         */
        DeleteAssetConfirmation = 76,
        /**
         * HeroBanner control.
         */
        HeroBanner = 77,
        /**
         * InfoBox control.
         */
        InfoBox = 78,
        /**
         * Notice control.
         */
        Notice = 79,
        /**
         * Picker control.
         */
        Picker = 80,
        /**
         * FileDownloadButton control.
         */
        FileDownloadButton = 82,
        /**
         * HotSpot control (pcHotSpot)
         */
        HotSpot = 84,
        /**
         * CreatorAndSelectorV2 control.
         */
        CreatorAndSelectorV2 = 85,
        /**
         * RangeSelection control.
         */
        RangeSelection = 86,
        /**
         * Link InfoBox control.
         */
        LinkInfoBox = 87,
        /**
         * Link HotSpot control.
         */
        LinkHotSpot = 88,
        /**
         * Preview tag control.
         */
        PreviewTag = 89,
        /**
         * CustomValueSlider control.
         */
        CustomValueSlider = 91,
        /**
         * DayPicker control.
         */
        DayPicker = 92,
        /**
         * Search control.
         */
        SearchBox = 93,
        /**
         * Paired timeline badge control
         */
        PairedTimelineBadges = 94,
        /**
         * Spec Comparison Table
         */
        SpecComparisonTable = 95,
        /**
         * MapV2 Control
         */
        MapV2 = 96,
        /**
         * Simple chart
         */
        SimpleChart = 97,
        /**
         * GroupDropDown control.
         */
        GroupDropDown = 98,
        /**
         * DurationPicker control
         */
        DurationPicker = 99,
        /**
         * Simple button
         */
        SimpleButton = 100,
        /**
         * Text Block
         */
        TextBlock = 101,
        /**
         * List 2
         */
        List2 = 104,
        /**
         * Tree 2
         */
        Tree2 = 105,
        /**
         * Async FileUpload
         */
        AsyncFileUpload = 106,
        /**
         * Wizard
         */
        Wizard = 107,
        /**
         * IFrame control.
         */
        IFrame = 108,
        /**
         * Media Player control
         */
        MediaPlayer = 109,
        /**
         * Markdown control.
         */
        Markdown = 110,
        /**
         * Custom Range Slider
         */
        CustomRangeSlider = 111,
        /**
         * PartPinner control.
         */
        PartPinner = 112,
        /**
         * IFrame control.
         */
        IFrameV2 = 113,
        /**
         * Resource filter control.
         */
        ResourceFilter = 114,
        /**
         * Menu control.
         */
        Menu = 115,
        /**
         * Video control.
         */
        Video = 116,
        /**
         * Custom control.
         */
        CustomControl = 117,
        /**
         * Legend control.
         */
        Legend = 118,
        /**
         * Menu control.
         */
        HeatMap = 119,
        /**
         * Essentials control.
         */
        Essentials = 120,
        /**
         * Intune application file control.
         */
        IntuneAppFileUpload = 121,
        /**
         * Monitor Chart control.
         */
        MonitorChart = 122,
        /**
         * Pill (horizontal item) list control.
         */
        PillList = 123,
        /**
         * Resource dropdown control
         */
        ResourceDropDown = 124,
        /**
         * Editable grid control.
         */
        EditableGrid = 125,
        /**
         * MonitorChartV2 control.
         */
        MonitorChartV2 = 126,
        /**
         * Accordion control.
         */
        Accordion = 127,
        /**
         * Pill control.
         */
        Pill = 128,
        /**
         * Pill collection control.
         */
        PillCollection = 129,
        /**
         * ArrayGrid control.
         */
        ArrayGrid = 130,
        /**
         * DataGrid control.
         */
        DataGrid = 131,
        /**
         * PagedDataGrid control.
         */
        PagedDataGrid = 132,
        /**
         * SequentialDataGrid control.
         */
        SequentialDataGrid = 133,
        /**
         * Summary control.
         */
        Summary = 134,
        /**
         * PricingControl control.
         */
        PricingControl = 135,
        /**
         * Tags control.
         */
        TagsByResource = 136,
        /**
         * ArmErrorList control.
         */
        ArmErrorList = 137,
        /**
         * Docs control.
         */
        DocsControl = 138,
        /**
         * Storage File Share dropdown
         */
        FileShareDropDown = 201,
        /**
         * Storage Account dropdown
         */
        StorageAccountDropDown = 202,
        /**
         * Blob Container dropdown
         */
        BlobContainerDropDown = 203,
        /**
         * Metric Grid (Used as part of MonitorChart)
         */
        MetricGrid = 204,
        /**
         * Toggle control
         */
        Toggle = 205,
        /**
         * Recommendations control
         */
        Recommendations = 206
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Data\QueryBuilder.d.ts
declare module MsPortalFx.ViewModels.Controls.Data.QueryBuilder {
    /**
     * An interface for a query update object.
     */
    interface QueryLoading {
        /**
         * The status of the query update.
         */
        status: QueryLoadingStatus;
        /**
         * An optional message corresponding to the update status.
         */
        message?: string;
    }
    enum QueryLoadingStatus {
        /**
         * The query is not loading.
         */
        NotLoading = 0,
        /**
         * The query is done loading.
         */
        Loading = 1,
        /**
         * The query failed to load.
         */
        Failed = 2
    }
    /**
     * The callback method query.
     */
    interface CallbackMethodQuery {
        /**
         * A collection of operator ids.
         */
        operatorIds: string[];
        /**
         * A collection of field ids.
         */
        fieldIds: string[];
        /**
         * The type of the callback.
         */
        type: CallbackMethodType;
        /**
         * The original query object of the predicate invoking the callback.
         */
        originalPredicate: QueryPredicate;
    }
    /**
     * The callback method type.
     */
    enum CallbackMethodType {
        /**
         * A callback requesting operator data.
         */
        Operator = 0,
        /**
         * A callback requesting operand data.
         */
        Operand = 1
    }
    /**
     * The callback method for dynamic schema loading.
     */
    interface CallbackMethod {
        (query: CallbackMethodQuery): MsPortalFx.Base.PromiseV<Schema>;
    }
    /**
     * Query definition.
     */
    interface Query {
        /**
         * The query expression.
         */
        expressions: Array<QueryExpression | QueryGroup | QueryPredicate>;
    }
    /**
     * Query expression type for expression persistence.
     */
    class QueryExpressionType {
        /**
         * Query expression type for expression persistence.
         */
        static get Group(): string;
        /**
         * Query expression type for expression persistence.
         */
        static get Predicate(): string;
    }
    /**
     * Expression definition.
     */
    interface QueryExpression {
        /**
         * The expression type.
         * QueryExpressionType.Group or QueryExpressionType.Predicate.
         */
        type: string;
        /**
         * The expression connector id.
         */
        connector: string;
    }
    /**
     * Group expression definition.
     */
    interface QueryGroup extends QueryExpression {
        /**
         * The expressions in the group.
         */
        expressions: Array<QueryExpression | QueryGroup | QueryPredicate>;
    }
    /**
     * Predicate expression definition.
     */
    interface QueryPredicate extends QueryExpression {
        /**
         * The predicate field id.
         */
        field: string;
        /**
         * The predicate operator id.
         */
        operator: string;
        /**
         * The predicate operands.
         */
        operands: QueryPredicateOperands;
    }
    /**
     * Predicate operands.
     *
     * The operands are not defined on this interface since they can vary by name.
     * They can be accessed directly off this object by operand id.
     * The operand values will be in the following forms:
     *     QueryPredicateOperandValue         // For input and select templates
     *     [QueryPredicateOperandValue, ...]  // For multiple select templates
     */
    interface QueryPredicateOperands {
    }
    /**
     * Predicate operand value.
     */
    interface QueryPredicateOperandValue {
        /**
         * The user selected option id.
         */
        option?: string;
        /**
         * The user selected or supplied value.
         */
        value?: any;
    }
    /**
     * The root interface defining a field schema.
     */
    interface Schema {
        /**
         * Logical connectors for predicates.
         */
        connectors: SchemaConnector[];
        /**
         * Field definitions.
         */
        fields: SchemaField[];
        /**
         * Predicate operator definitions.
         */
        operators?: SchemaOperator[];
    }
    /**
     * The base interface for schame objects.
     */
    interface SchemaObject {
        /**
         * Identifier for the object.
         */
        id: string;
    }
    /**
     * A logical connector for connecting a predicate to a query ("And"/"Or").
     */
    interface SchemaConnector extends SchemaObject {
        /**
         * Text fo label the connector when displayed.
         */
        name?: string;
    }
    /**
     * Schema field definition.
     */
    interface SchemaField extends SchemaObject {
        /**
         * Text to display for the schema field.
         */
        name: string;
        /**
         * Field default operator id.
         */
        defaultOperator?: string;
        /**
         * Field operator and operator group ids.
         */
        operators?: SchemaOperator[];
    }
    /**
     * A predicate operand definition.
     */
    interface SchemaOperand extends SchemaObject {
        /**
         * Text to label the operand in the display.
         */
        name?: string;
        /**
         * The form control used to handle the input for the operand.
         */
        control: MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>;
    }
    /**
     * A predicate operator definition.
     */
    interface SchemaOperator extends SchemaObject {
        /**
         * Text to display for the operator.
         */
        name?: string;
        /**
         * Set of operands for the predicate.
         */
        operands?: SchemaOperand[];
    }
    /**
     * Localizable resource strings for the control.
     */
    interface ResourceStrings {
        /**
         * Column header for predicate connectors.
         */
        connectorColumnHeader: string;
        /**
         * Column header for predicate fields.
         */
        fieldColumnHeader: string;
        /**
         * Column header for predicate operators.
         */
        operatorColumnHeader: string;
        /**
         * Column header for predicate values/operands.
         */
        valueColumnHeader: string;
        /**
         * Add command label.
         */
        addCommandLabel: string;
        /**
         * Insert command label.
         */
        insertCommandLabel: string;
        /**
         * Remove command label.
         */
        removeCommandLabel: string;
        /**
         * Remove command label for multiple items.
         */
        removeCommandLabelMultiple: string;
        /**
         * Group command label.
         */
        groupCommandLabel: string;
        /**
         * Ungroup command label.
         */
        ungroupCommandLabel: string;
    }
    /**
     * Resource item contract.
     */
    interface ResourceItem {
        /**
         * Name of the current resource.
         */
        name: KnockoutObservable<string>;
        /**
         * Unique id of the resource.
         */
        id: KnockoutObservable<string>;
        /**
         * Additional information about the resource.
         */
        description: KnockoutObservable<string>;
        /**
         * Specify the resource type.
         */
        type: KnockoutObservable<string>;
    }
    interface ISchemaObjectBaseViewModel {
        /**
         * Gets the object id.
         *
         * @return The object id.
         */
        id: string;
    }
    interface ISchemaConnectorViewModel {
        /**
         * Gets the connector name.
         *
         * @return The connector name.
         */
        name: string;
    }
    interface IQueryExpressionViewModel {
        /**
         * Gets the expression collection.
         *
         * @return The expression collection.
         */
        collection: KnockoutObservableArray<IQueryExpressionViewModel>;
        /**
         * Gets the expression connector.
         *
         * @return The expression connector.
         */
        connector: KnockoutObservable<ISchemaConnectorViewModel>;
        /**
         * Gets the expression type.
         *
         * @return The expression type.
         */
        type: string;
        /**
         * Gets the selection state of the expression.
         *
         * @return The selection state of the expression.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * Gets the toggle select handler for the selected state.
         *
         * @return The select handler for the selected state.
         */
        select: () => void;
        /**
         * Gets the expression template name for rendering.
         *
         * @return The expression template name for rendering.
         */
        template: string;
        /**
         * Adds the expression to the end of the collection.
         *
         * @param collection The collection to add into.
         */
        add: (collection: KnockoutObservableArray<IQueryExpressionViewModel>) => void;
        /**
         * Groups the expression and its contiguous siblings.
         *
         * @param length The number of siblings after this expression to group.
         * @param group The group to add the expressions to.
         */
        group: (length: number, group: IQueryGroupViewModel) => void;
        /**
         * Inserts the expression after the selected expression.
         *
         * @param selected The selected expression.
         */
        insert: (selected: IQueryExpressionViewModel) => void;
        /**
         * Removes the expression from the current parent collection.
         */
        remove: () => void;
        /**
         * Replaces the specified children of the collection with the expression.
         *
         * @param collection The collection to put the expression in.
         * @param index The start index for the replace.
         * @param count The number of expressions to replace.
         */
        replace: (collection: KnockoutObservableArray<IQueryExpressionViewModel>, index: number, count: number) => void;
    }
    interface ISchemaFieldViewModel {
        /**
         * Gets the field default operator.
         *
         * @return The field default operator.
         */
        defaultOperator: ISchemaOperatorViewModel;
        /**
         * Gets the field name.
         *
         * @return The field name.
         */
        name: string;
        /**
         * Gets the field named operators.
         *
         * @return The field named operators.
         */
        namedOperators: ISchemaOperatorViewModel[];
        /**
         * Gets the field operators.
         *
         * @return The field operators.
         */
        operators: ISchemaOperatorViewModel[];
    }
    interface ISchemaOperatorViewModel {
        /**
         * Gets the operator name.
         *
         * @return The operator name.
         */
        name: string;
        /**
         * Gets the operator operands.
         *
         * @return The operator operands.
         */
        operands: ISchemaOperandViewModel[];
    }
    interface ISchemaOperandViewModel {
        /**
         * Gets the operand name.
         *
         * @return The operand name.
         */
        name: string;
        /**
         * Gets the operand control.
         *
         * @return The operand control.
         */
        control: MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>;
    }
    interface IQueryPredicateOperandViewModel {
        /**
         * Gets the id.
         *
         * @return The operand id.
         */
        id: string;
        /**
         * Gets the name.
         *
         * @return The operand name.
         */
        name: string;
        /**
         * Gets the control.
         *
         * @return The operand control.
         */
        control: MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>;
        /**
         * Gets the current value.
         *
         * @return The current value.
         */
        value: KnockoutObservable<any>;
        /**
         * Gets the selection state of the expression.
         *
         * @return The selection state of the expression.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * Gets the selected option value.
         *
         * @return The selected option value.
         */
        selectedValue: KnockoutComputed<string>;
        /**
         * Saves the query predicate operand view model.
         *
         * @return The query predicate operand value in the format QueryPredicateOperandValue or [QueryPredicateOperandValue] depending on the template.
         */
        serialize: () => any;
    }
    interface IQueryPredicateViewModel {
        /**
         * Gets the current predicate field view model.
         *
         * @return The current predicate field view model.
         */
        field: KnockoutObservable<ISchemaFieldViewModel>;
        /**
         * Gets the available schema fields.
         *
         * @return The schema fields.
         */
        fields: KnockoutObservableArray<ISchemaFieldViewModel>;
        /**
         * Gets the current predicate operator view model.
         *
         * @return The current predicate operator view model.
         */
        operator: KnockoutObservable<ISchemaOperatorViewModel>;
        /**
         * Gets the available operators for the current field.
         *
         * @return The operators.
         */
        operators: KnockoutObservableArray<ISchemaOperatorViewModel>;
        /**
         * Gets the available named operators for the current field.
         *
         * @return The operators.
         */
        namedOperators: KnockoutObservableArray<ISchemaOperatorViewModel>;
        /**
         * Gets the current predicate operand view models.
         *
         * @return The current predicate operand view models.
         */
        operands: KnockoutObservable<IQueryPredicateOperandViewModel[]>;
        /**
         * Gets the current loading state of the query.
         *
         * @return The current loading state of the query.
         */
        queryLoading: KnockoutObservable<QueryLoading>;
        /**
         * Saves the query predicate.
         *
         * @return Persistable predicate object.
         */
        serialize: () => QueryPredicate;
    }
    interface IQueryGroupViewModel {
        /**
         * Gets the expressions in this group.
         *
         * @return The expressions in this group.
         */
        expressions: KnockoutObservableArray<IQueryExpressionViewModel>;
        /**
         * Gets the first nested predicate in this group.
         *
         * @return The first predicate.
         */
        firstPredicate: KnockoutComputed<IQueryPredicateViewModel>;
        /**
         * Saves the query group.
         *
         * @return Persistable group object.
         */
        serialize: () => QueryGroup;
        /**
         * Ungroup this group.
         * Replaces the group with its children.
         */
        ungroup: () => void;
    }
    interface IQueryViewModel {
        /**
         * Gets the query expressions.
         *
         * @return The query expressions.
         */
        expressions: KnockoutObservableArray<IQueryExpressionViewModel>;
        /**
         * Gets the query loading status.
         *
         * @return The query loading status.
         */
        queryLoading: KnockoutObservableBase<QueryLoading>;
        /**
         * Gets the query dirty status.
         *
         * @return The query dirty status.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Gets the query initialized status.
         *
         * @return The query initialized status.
         */
        initialized: KnockoutObservable<boolean>;
        /**
         * Saves the query.
         *
         * @return Persistable query object with only the query interface members.
         */
        serialize: () => Query;
    }
    /**
     * QueryBuilder view model.
     */
    interface Contract extends Loadable.Contract {
        /**
         * Shows the query builder header.
         */
        showHeader: KnockoutObservable<boolean>;
        /**
         * Shows the query builder footer.
         */
        showFooter: KnockoutObservable<boolean>;
        /**
         * Title displayed on query expression builder.
         */
        title: KnockoutObservable<string>;
        /**
         * Schema defining fields and operations allowed in the query expression.
         */
        schema: KnockoutObservable<Schema>;
        /**
         * Query expression to be loaded.
         */
        query: KnockoutObservable<Query>;
        /**
         * Query expression to be saved to.
         */
        queryViewModel: KnockoutObservable<IQueryViewModel>;
        /**
         * Query expression to be saved to.
         */
        savedQuery: KnockoutObservable<Query>;
        /**
         * Adds a new predicate to the end of the query expressions.
         */
        add: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Inserts a new predicate after the currently selected predicate and in the same group.
         */
        insert: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Removes all the selscted expressions and ungroups any groups with less than two expressions.
         */
        remove: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Groups contiguous selected expressions.
         */
        group: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Ungroups the selected group.
         */
        ungroup: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Saves the current query.
         */
        save: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         *  Defines the callback method for extending the schema.
         */
        callback: CallbackMethod;
        /**
         * The loading status of the query and control.
         */
        queryLoading: KnockoutObservableBase<QueryLoading>;
        /**
         * The query expression.
         */
        _msPortalFxOperandControls: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>>;
    }
    interface Options {
        /**
         * The schema used to define the structure of the query builder.
         */
        schema: Schema;
        /**
         * Aria label for the query builder.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * QueryBuilder view model.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Shows the query builder header.
         */
        showHeader: KnockoutObservable<boolean>;
        /**
         * Shows the query builder footer.
         */
        showFooter: KnockoutObservable<boolean>;
        /**
         * Title displayed on query expression builder.
         */
        title: KnockoutObservable<string>;
        /**
         * Schema defining fields and operations allowed in the query expression.
         */
        schema: KnockoutObservable<Schema>;
        /**
         * Query expression to be saved to.
         */
        query: KnockoutObservable<Query>;
        /**
         * Query expression to be saved to.
         */
        queryViewModel: KnockoutObservable<IQueryViewModel>;
        /**
         * Query expression to be loaded or saved.
         */
        savedQuery: KnockoutObservable<Query>;
        /**
         * Adds a new predicate to the end of the query expressions.
         */
        add: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Inserts a new predicate after the currently selected predicate and in the same group.
         */
        insert: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Removes all the selscted expressions and ungroups any groups with less than two expressions.
         */
        remove: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Groups contiguous selected expressions.
         */
        group: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Ungroups the selected group.
         */
        ungroup: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Saves the current query.
         */
        save: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         *  Defines the callback method for extending the schema.
         */
        callback: CallbackMethod;
        /**
         * The loading status of the query and control.
         */
        queryLoading: KnockoutObservableBase<QueryLoading>;
        /**
         * Aria label for the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The query expression.
         */
        _msPortalFxOperandControls: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>>;
        /**
         * Contstructs a query builder view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param schema The schema used to define the structure of the query builder.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, schema: Schema);
        /**
         * Contstructs a query builder view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the qery builder.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: Options);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\DockedBalloon.d.ts
declare module MsPortalFx.ViewModels.Controls.DockedBalloon {
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.DockedBalloon.Type is deprecated. Use Fx/Controls/InfoBalloon instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    enum Type {
        /**
         * Displays a circle with an "i" in it as an anchor.
         */
        Info = 0,
        /**
         * Displays a box with an "!" in it as an anchor.
         */
        Validation = 2
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.DockedBalloon.Contract is deprecated. Use Fx/Controls/InfoBalloon instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Contract extends Loadable.Contract {
        /**
         * The type of balloon anchor to show (Info, Help, or Validation).
         */
        type: Type;
        /**
         * The content to display the balloon. It can be empty if there's existing content in the element.
         */
        content: KnockoutObservable<string | HtmlContent>;
        /**
         * Desired aria-label value. If 'content' member field is too long, please
         * make use of this field; make it a shorter summary of the full content.
         */
        ariaLabel?: KnockoutObservable<string>;
        /**
         * The balloon link.
         */
        link: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        /**
         * Whether the balloon is visible or not.
         */
        balloonVisible: KnockoutObservable<boolean>;
        /**
         * Stop or enable click propagation.
         */
        stopClickPropagation?: KnockoutObservable<boolean>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel is deprecated. Use Fx/Controls/InfoBalloon instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        type: Type;
        content: KnockoutObservable<string | HtmlContent>;
        /**
         * Desired aria-label value. If 'content' member field is too long, please
         * make use of this field; make it a shorter summary of the full content.
         */
        ariaLabel: KnockoutObservable<string>;
        /**
         * The link to display in the balloon.
         */
        link: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        balloonVisible: KnockoutObservable<boolean>;
        stopClickPropagation: KnockoutObservable<boolean>;
        /**
         * @deprecated MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel is deprecated. Use Fx/Controls/InfoBalloon instead.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * Constructs a docked balloon view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Documents\DiffEditor.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.DiffEditor {
    /**
     * This control is no longer supported. Use Fx/Controls/DiffEditor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/DiffEditor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/DiffEditor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Documents\DiscussionThread.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.DiscussionThread {
    /**
     * Represents a result for save command.
     */
    interface DiscussionSaveResult {
        /**
         * Id of the item.
         */
        id?: number;
        /**
         * Published date of the item.
         */
        publishedDate?: Date;
        /**
         * Last updated date of the item.
         */
        lastUpdatedDate?: Date;
    }
    /**
     * Represents a result for comment save command.
     */
    interface DiscussionCommentSaveResult extends DiscussionSaveResult {
    }
    /**
     * Represents a result for thread save command.
     */
    interface DiscussionThreadSaveResult extends DiscussionSaveResult {
        /**
         * Result for the single comment in a newly saved thread.
         */
        commentResult?: DiscussionCommentSaveResult;
    }
    /**
     * Represents an author of a code discussion.
     */
    interface DiscussionAuthor {
        /**
         * Id of the author.
         */
        id: KnockoutObservable<string>;
        /**
         * Display name of the author.
         */
        displayName: KnockoutObservable<string>;
        /**
         * Profile image of the author. It can be base64 data or URL.
         */
        image?: KnockoutObservable<string>;
    }
    /**
     * Base interface for thread and comment.
     */
    interface DiscussionItem {
        /**
         * Id of the discussion item.
         */
        id: KnockoutObservable<number>;
        /**
         * Published date of the discussion item.
         */
        publishedDate: KnockoutObservable<Date>;
        /**
         * Last updated date of the discussion item.
         */
        lastUpdatedDate: KnockoutObservable<Date>;
    }
    /**
     * Represents a comment in a discussion thread.
     */
    interface DiscussionComment extends DiscussionItem {
        /**
         * Id of the parent comment.
         */
        parentId: KnockoutObservable<number>;
        /**
         * Id of the discussion thread.
         */
        threadId: KnockoutObservable<number>;
        /**
         * Author of this comment.
         */
        author: KnockoutObservable<DiscussionAuthor>;
        /**
         * Content of this comment.
         */
        content: KnockoutObservable<string>;
        /**
         * Determines whether this comment can be deleted or not.
         */
        canDelete: KnockoutObservable<boolean>;
        /**
         * Determines whether this comment is editable or not.
         */
        isEditable: KnockoutObservable<boolean>;
        /**
         * Save action for the comment.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionCommentSaveResult>;
    }
    class DiscussionCommentViewModel implements DiscussionComment {
        /**
         * Id of the comment.
         */
        id: KnockoutObservable<number>;
        /**
         * Published date of the comment.
         */
        publishedDate: KnockoutObservable<Date>;
        /**
         * Last updated date of the comment.
         */
        lastUpdatedDate: KnockoutObservable<Date>;
        /**
         * Id of the parent comment.
         */
        parentId: KnockoutObservable<number>;
        /**
         * Id of the discussion thread.
         */
        threadId: KnockoutObservable<number>;
        /**
         * Author of this comment.
         */
        author: KnockoutObservable<DiscussionAuthor>;
        /**
         * Content of this comment.
         */
        content: KnockoutObservable<string>;
        /**
         * Determines whether this comment can be deleted or not.
         */
        canDelete: KnockoutObservable<boolean>;
        /**
         * Determines whether this comment is editable or not.
         */
        isEditable: KnockoutObservable<boolean>;
        /**
         * Save action for the comment.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionCommentSaveResult>;
        /**
         * Creates a discussion comment class.
         *
         * @param id Id of the comment.
         * @param content Content of the comment.
         * @param author Author of the comment.
         */
        constructor(id?: number, content?: string, author?: DiscussionAuthor);
    }
    /**
     * Represents a thread in a code discussion.
     */
    interface DiscussionThread extends DiscussionItem {
        /**
         * Comments added to this discussion thread.
         */
        comments: KnockoutObservableArray<DiscussionComment>;
        /**
         * Save action for the thread.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionThreadSaveResult>;
        /**
         * Action for adding new comment.
         */
        addComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, any>;
        /**
         * Action for deleting the comment.
         */
        deleteComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<number, any>;
    }
    class DiscussionThreadViewModel implements DiscussionThread {
        /**
         * Id of the thread.
         */
        id: KnockoutObservable<number>;
        /**
         * Published date of the thread.
         */
        publishedDate: KnockoutObservable<Date>;
        /**
         * Last updated date of the thread.
         */
        lastUpdatedDate: KnockoutObservable<Date>;
        /**
         * Comments added to this discussion thread.
         */
        comments: KnockoutObservableArray<DiscussionComment>;
        /**
         * Save action for the thread.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionThreadSaveResult>;
        /**
         * Action for adding new comment.
         */
        addComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, any>;
        /**
         * Action for deleting the comment.
         */
        deleteComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<number, any>;
        /**
         * Creates a discussion thread class.
         *
         * @param id Id of the thread.
         * @param comments Comments of the thread.
         */
        constructor(id?: number, comments?: DiscussionComment[]);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Documents\Editor.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.Editor {
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.ContentType is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Type of editor content.
     * Used to enable language specific editor features like colorization.
     */
    const enum ContentType {
        /**
         * Text.
         * 'text/plain'
         */
        Text = 0,
        /**
         * Custom Content Type.
         */
        Custom = 1,
        /**
         * Batch Script.
         * 'text/x-bat'
         */
        Bat = 2,
        /**
         * C.
         * 'text/x-c'
         */
        C = 3,
        /**
         * Coffee Script.
         * 'text/x-coffeescript', 'text/coffeescript'
         */
        CoffeeScript = 4,
        /**
         * C++.
         * 'text/x-cpp'
         */
        Cpp = 5,
        /**
         * C#.
         * 'text/x-csharp'
         */
        CSharp = 6,
        /**
         * C# WebPages.
         * 'text/x-cshtml'
         */
        CSHtml = 7,
        /**
         * Cascading Style Sheet.
         * 'text/css'
         */
        Css = 8,
        /**
         * Dockerfile.
         * 'text/x-dockerfile'
         */
        Dockerfile = 9,
        /**
         * F#.
         * 'text/x-fsharp'
         */
        FSharp = 10,
        /**
         * Go.
         * 'text/x-go'
         */
        Go = 11,
        /**
         * Handlebars template.
         * 'text/x-handlebars-template'
         */
        Handlebars = 12,
        /**
         * Html.
         * 'text/html'
         */
        Html = 13,
        /**
         * Initialization file.
         * 'text/x-ini'
         */
        Ini = 14,
        /**
         * Pug.
         * 'pug'
         */
        Pug = 15,
        /**
         * Java.
         * 'text/x-java-source'
         */
        Java = 16,
        /**
         * JavaScript.
         * 'text/javascript'
         */
        JavaScript = 17,
        /**
         * JSHtm.
         * 'text/x-jshtm'
         */
        JSHtm = 18,
        /**
         * JSON.
         * 'application/json'
         */
        Json = 19,
        /**
         * Less.
         * 'text/x-less', 'text/less'
         */
        Less = 20,
        /**
         * Lua.
         * 'text/x-lua'
         */
        Lua = 21,
        /**
         * Mark Down.
         * 'text/x-markdown'
         */
        MarkDown = 22,
        /**
         * Objective-C
         * 'objective-c'
         */
        ObjectiveC = 23,
        /**
         * PHP.
         * 'application/x-php'
         */
        Php = 24,
        /**
         * Power Shell.
         * 'text/x-powershell'
         */
        PowerShell = 25,
        /**
         * Python.
         * 'text/x-python', 'text/python'
         */
        Python = 26,
        /**
         * R.
         * 'text/x-r'
         */
        R = 27,
        /**
         * Ruby.
         * 'text/x-ruby'
         */
        Ruby = 28,
        /**
         * SQL.
         * 'sql'
         */
        Sql = 29,
        /**
         * Swift.
         * 'swift'
         */
        Swift = 30,
        /**
         * TypeScript.
         * 'text/typescript'
         */
        TypeScript = 31,
        /**
         * Visual Basic.
         * 'text/x-vb'
         */
        VisualBasic = 32,
        /**
         * Xaml.
         * 'application/xaml+xml'
         */
        Xaml = 33,
        /**
         * Xml.
         * 'text/xml', 'application/xml'
         */
        Xml = 34,
        /**
         * MySQL.
         * 'mysql'
         */
        MySQL = 35,
        /**
         * PgSQL.
         * 'pgsql'
         */
        PgSQL = 36
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.Options is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor options.
     */
    interface Options {
        /**
         * Indicates if edits are allowed.
         */
        readOnly?: boolean;
        /**
         * Indicates if line numbers are displayed.
         */
        lineNumbers?: boolean;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        enhancedScrollbar?: boolean;
        /**
         * Controls the size of tabs in the document.
         */
        tabSize?: number;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        insertSpaces?: boolean;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        tabFocusMode?: boolean;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        wrappingColumn?: number;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        minVisibleLines?: number;
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        ariaLabel?: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentType is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Definition of a custom content type.
     * See https://microsoft.github.io/monaco-editor/monarch.html
     */
    interface CustomContentType {
        /**
         * Custom language attributes.
         * These are specific to your language definition.
         *
         * This can be an array of strings:
         *
         * keywords: ["if", "for"],
         *
         * Or this can be a regular expression:
         *
         * symbols: /[=><!~?:&|+-]+/,
         *
         * The attribute can also be a string containing a regular expression.
         */
        [attribute: string]: string | string[] | RegExp | any;
        /**
         * The display name of your language.
         */
        displayName?: string;
        /**
         * Ignore case when compiling regular expressions defined in 'tokenizer'.
         * Default is false.
         */
        ignoreCase?: boolean;
        /**
         * An optional line comment starter.Used in the editor to insert line comments (ctrl + /).
         * Default is two forward slashes.
         */
        lineComment?: string;
        /**
         * A block comment start marker. Used by the editor to insert block comments (shift+alt+A).
         * Default is forward slash asterisk.
         */
        blockCommentStart?: string;
        /**
         * A block comment end marker.
         * Default is asterisk forward slash.
         */
        blockCommentEnd?: string;
        /**
         * The default token returned if nothing matches in the tokenizer.
         * Default is "source".
         * It can be convenient to set this to "invalid" during development of your colorizer to easily spot what is not matched yet.
         */
        defaultToken?: string;
        /**
         * This is used by the tokenizer to easily define matching braces.
         * Each bracket definition is an array of 3 elements, or object, describing the open brace, the close brace, and the token class.
         * The default definition is:
         * [ ['{','}','delimiter.curly'],
         *   ['[',']','delimiter.square'],
         *   ['(',')','delimiter.parenthesis'],
         *   ['<','>','delimiter.angle'] ]
         */
        brackets?: string[][];
        /**
         * A list of auto closing character pairs, used in the editor to automatically insert the closing brace of the pair.
         * The list may end with the single string '@brackets' which automatically includes single-character close brackets defined in the brackets attribute.
         * By default the auto closing pairs are defined as: [['"','"'], ['\'','\''], ['@brackets']]
         */
        autoClosingPairs?: string[][];
        /**
         * Optional postfix attached to all returned tokens.
         * By default this attaches the language name so in the CSS you can refer to your specific language.
         * For example, for the Java language, we could use .identifier.java to target all Java identifiers specifically in CSS.
         */
        tokenPostfix?: string;
        /**
         * The start state of the tokenizer.
         * By default, this is the first entry in the tokenizer attribute.
         */
        start?: string;
        /**
         * Optional list of token classes that are non-word tokens.
         * By default this is defined as: ['delimiter','delimiter.parenthesis','delimiter.curly','delimiter.square','delimiter.angle']
         */
        nonWordTokens?: string[];
        /**
         * Optional string that defines characters that when typed could cause outdentation.
         * This attribute is only used when using advanced brace matching in combination with the bracket attribute.
         * By default it always includes the last characters of the closing brackets in the brackets list.
         * Outdentation happens when the user types a closing bracket word on an line that starts with only white space.
         * If the closing bracket matches a open bracket it is indented to the same amount of that bracket.
         * Usually, this causes the bracket to outdent. For example, in the Ruby language, the end keyword would match with an open declaration like def or class.
         * To make outdentation happen though, we would need to include the d character in the outdentTriggers attribute so it is checked when the users type end:
         *
         * outdentTriggers: 'd',
         */
        outdentTriggers?: string;
        /**
         * This can be used to get autocompletion for certain constructs.
         * For example, in HTML we may want to auto complete a tag with its closing tag when the user types >.
         * A possible way to do this is to define autoComplete:
         *
         * autoComplete: [{
         *     triggers: '>',
         *     match   : '\\s<(\\w+)[^>]*>\\s$',
         *     complete: '</$1>'
         * }],
         *
         * Each matcher specifies three attributes:
         * the triggers attribute gives a string of characters where autocompletion should be checked.
         * On such character, the current input line is tested against match regular expression.
         * If it succeeds, complete is appended to the source with captured groups expanded.
         * To help with matching input, the editor first filters out all whitespace and comment tokens, and then concatenates the remaining tokens where every token is surrounded with a space.
         * The match regular expression is matched against the resulting string.
         */
        autoComplete?: CustomContentTypeAutoCompleteMatcher[];
        /**
         * This can be used to specify custom auto indentation beyond what is already done for brackets and the bracket attributes.
         * Suppose for example we would like to indent for begin/end pairs.
         * The easy way to do this is off course to just specify this pair as part of the brackets attribute.
         * But for the sake of an example, here is how to do it using autoIndent:
         *
         * autoIndent: [{
         *     match     : "\\sbegin\\s(((?!\\send\\s).)*)$",
         *     matchAfter: "\\send\\s"
         * }],
         *
         * On an enter, the current line is matched against the match regular expression.
         * Note that the line is processed as described in autoComplete where each token is surrounded by a space.
         * If the match succeeds, the next line is indented.
         * If also the matchAfter regular expression matches the tokens following the line break, then an extra break is inserted that is outdented (creating a nice block structure).
         * In the example, the match regular expression matches a line where a begin keyword is present.
         * It uses (?!\\send\\s) to ensure there is no closing end after the begin.
         */
        autoIndent?: CustomContentTypeAutoIndentMatcher[];
        /**
         * As described for the bracket attribute, the editor uses auto indentation for any bracket.
         * This attribute suppresses auto indentation for any brackets that match the regular expression.
         * For example, here is how to suppress auto indentation for parenthesis and angled braces:
         *
         * noindentBrackets: /[()<>]/,
         */
        noindentBrackets?: RegExp;
        /**
         * Monarch custom language tokenization rules.
         *
         * The tokenizer attribute describes how lexical analysis takes place, and how the input is divided into tokens.
         * Each token is given a CSS class name which is used to render each token in the editor.
         * Standard CSS token classes include:
         *
         *     identifier         entity           constructor
         *     operators          tag              namespace
         *     keyword            info-token       type
         *     string             warn-token       predefined
         *     string.escape      error-token      invalid
         *     comment            debug-token
         *     comment.doc        regexp
         *     constant           attribute
         *
         *     delimiter .[curly,square,parenthesis,angle,array,bracket]
         *     number    .[hex,octal,binary,float]
         *     variable  .[name,value]
         *     meta      .[content]
         *
         *     A tokenizer consists of an object that defines states.
         *     The initial state of the tokenizer is the first state defined in the tokenizer.
         *     When a tokenizer is in a certain state, only the rules in that state will be applied.
         *     All rules are matched in order and when the first one matches its action is used to determine the token class.
         *     No further rules are tried.
         *     Therefore, it can be important to order the rules in a way that is most efficient, i.e. whitespace and identifiers first.
         *
         *     (Advanced) A state is interpreted as dot (.) separated sub-states.
         *     When looking up the rules for a state, the tokenizer first tries the entire state name, and then looks at its parent until it finds a definition.
         *     For example, in our example, the states "comment.block" and "comment.foo" would both be handled by the comment rules.
         *     Hierarchical state names can be used to maintain complex lexer states, as shown for example in the section on complex embeddings.
         *
         *     Each state is defined as an array of rules which are used to match the input.
         */
        tokenizer: {
            [stateName: string]: CustomContentTypeTokenizationRule[];
        };
        /**
         * Code completion suggestion support for the custom language.
         */
        suggestSupport?: CustomContentTypeSuggestSupport;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeTokenizationRule is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a tokenizer rule.
     * Rules can have the following forms:
     *
     *     {regex: regex, action: action }
     *          CustomContentTypeTokenizationRegexRule
     *
     *     { include: state }
     *         CustomContentTypeTokenizationIncludeRule
     *
     *     [regex, action]
     *         Shorthand for CustomContentTypeTokenizationRegexRule with action: { regex: regex, action: action }
     *
     *     [regex, action, next]
     *         Shorthand for CustomContentTypeTokenizationRegexRule with action having next: { regex: regex, action: action{ next: next } }
     */
    type CustomContentTypeTokenizationRule = CustomContentTypeTokenizationRegexRule | CustomContentTypeTokenizationIncludeRule | (RegExp | string | CustomContentTypeTokenizationRuleAction)[];
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeTokenizationRegexRule is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a regular expression tokenization rule.
     * When regex matches against the current input, then action is applied to set the token class.
     */
    interface CustomContentTypeTokenizationRegexRule {
        /**
         * The regular expression for the rule.
         *
         * The regular expression regex can be either a regular expression (using /regex/), or a string representing a regular expression.
         * If it starts with a ^ character, the expression only matches at the start of a source line.
         * The $ can be used to match against the end of a source line.
         * Note that the tokenizer is not called when the end of the line is already reached, and the empty pattern /$/ will therefore never match (but see '@eos' too).
         * Inside a regular expression, you can reference a string attribute named attr as @attr, which is automatically expanded.
         * This is used in the standard example to share the regular expression for escape sequences using '@escapes' inside the regular expression for characters and strings.
         *
         * Regular expression primer: common regular expression escapes we use are \d for [0-9], \w for [a-zA-Z0-9_], and \s for [ \t\r\n].
         * The notation regex{n} stands for n occurrences of regex.
         * Also, we use (?=regex) for non-consuming `followed by regex', (?!regex) for `not followed by', and (?:regex) for a non-capturing group (i.e. cannot use $n to refer to it).
         */
        regex: RegExp | string;
        /**
         * The action for the rule.
         */
        action: CustomContentTypeTokenizationRuleAction[];
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeTokenizationIncludeRule is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Used for nice organization of your rules and expands to all the rules defined in state.
     * This is pre-expanded and has no influence on performance.
     * Many samples include the '@whitespace' state for example.
     */
    interface CustomContentTypeTokenizationIncludeRule {
        /**
         * The state to include.
         */
        include: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeTokenizationRuleScalarAction is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * The scalar rule actions that are allowed.
     */
    type CustomContentTypeTokenizationRuleScalarAction = CustomContentTypeTokenizationRuleTokenAction | CustomContentTypeTokenizationRuleCasesAction | string;
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeTokenizationRuleAction is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a rule action.
     * An action can have the following forms:
     *
     *     { token: tokenclass }
     *         CustomContentTypeTokenizationRuleTokenAction
     *
     *     { cases: { guard1: action1, ..., guardN: actionN } }
     *         CustomContentTypeTokenizationRuleCasesAction
     *
     *     string
     *         Shorthand for CustomContentTypeTokenizationRuleTokenAction with token only: { token: string }.
     *
     *     [action1,...,actionN]
     *         An array of N actions.
     */
    type CustomContentTypeTokenizationRuleAction = CustomContentTypeTokenizationRuleScalarAction | CustomContentTypeTokenizationRuleScalarAction[];
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeTokenizationRuleTokenAction is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * An object that defines the token class used with CSS rendering.
     */
    interface CustomContentTypeTokenizationRuleTokenAction {
        /**
         * The token class.
         *
         * Common token classes are for example 'keyword', 'comment' or 'identifier'.
         * You can use a dot to use hierarchical CSS names, like 'type.identifier' or 'string.escape'.
         * You can also include $ patterns that are substituted with a captured group from the matched input or the tokenizer state.
         * There are some special token classes:
         *
         * "@brackets"or "@brackets.tokenclass
         *     Signifies that brackets were tokenized.
         *     The token class for CSS is determined by the token class defined in the brackets attribute (together with tokenclass if present).
         *     Moreover, bracket attribute is set such that the editor is matches the braces (and does auto indentation).
         *     For example:
         *         [/[{}()\[\]]/, '@brackets']
         *
         * "@rematch"
         *    (Advanced) Backs up the input and re-invokes the tokenizer.
         *    This of course only works when a state change happens too (or we go into an infinite recursion), so this is usually used in combination with the next attribute.
         *    This can be used for example when you are in a certain tokenizer state and want to get out when seeing certain end markers but don't want to consume them while being in that state.
         *    See also nextEmbedded.
         */
        token: string;
        /**
         * If defined it pushes the current state onto the tokenizer stack and makes state the current state.
         * This can be used for example to start tokenizing a block comment: ['/\\*', 'comment', '@comment' ]
         *
         * Note that this is a shorthand for
         *     { regex: '/\\*', action: { token: 'comment', next: '@comment' } }
         *
         * Here the matched /* is given the "comment" token class, and the tokenizer proceeds with matching the input using the rules in state @comment.
         *
         * There are a few special states that can be used for the next attribute:
         *
         *    "@pop"
         *        Pops the tokenizer stack to return to the previous state.
         *        This is used for example to return from block comment tokenizing after seeing the end marker: ['\\*<forward slash>', 'comment', '@pop']
         *
         *    "@push"
         *        Pushes the current state and continues in the current state.
         *        Nice for doing nested block comments when seeing a comment begin marker, i.e.in the @comment state, we can do: ['/\\*', 'comment', '@push']
         *
         *    "@popall"
         *        Pops everything from tokenizer stack and returns to the top state.
         *        This can be used during recovery to 'jump' back to the initial state from a deep nesting level.
         */
        next?: string;
        /**
         * Switch to state without changing the stack.
         */
        switchTo?: string;
        /**
         * Back up the input by number characters.
         */
        goBack?: number;
        /**
         * Advanced bracket kind.
         * The kind can be either '@open' or '@close'.
         * This signifies that a token is either an open or close brace.
         * This attribute is set automatically if the token class is @brackets.
         * The editor uses the bracket information to show matching braces (where an open bracket matches with a close bracket if their token classes are the same).
         * Moreover, when a user opens a new line the editor will do auto indentation on open braces.
         * Normally, this attribute does not need to be set if you are using the brackets attribute and it is only used for complex brace matching.
         */
        bracket?: string;
        /**
         * Signifies to the editor that this token is followed by code in another language specified by the mimeType, i.e. for example text/javascript.
         * Internally, our syntax highlighter keeps tokenizing the source until it finds an an ending sequence.
         * At that point, you can use nextEmbedded with a '@pop' value to pop out of the embedded mode again.
         * Usually, we need to use a next attribute too to switch to a state where we can tokenize the foreign code.
         * As an example, here is how we could support CSS fragments in our language:
         *     root: [
         *         [/<style\s*>/,   { token: 'keyword', bracket: '@open' , next: '@css_block', nextEmbedded: 'text/css' }],
         *         [/<\/style\s*>/, { token: 'keyword', bracket: '@close' }],
         *         ...
         *     ],
         *
         *     css_block: [
         *         [/[^"<]+/, ''],
         *         [/<\/style\s*>/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],
         *         [/"/, 'string', '@string' ],
         *          [/</, '']
         *     ],
         *
         * Note how we switch to the css_block state for tokenizing the CSS source.
         * Also inside the CSS we use the @string state to tokenize CSS strings such that we do not stop the CSS block when we find </style> inside a string.
         * When we find the closing tag, we also "@pop" the state to get back to normal tokenization.
         * Finally, we need to "@rematch" the token (in the root state) since the editor ignores our token classes until we actually exit the embedded mode.
         */
        nextEmbedded?: string;
        /**
         * Debug logging.
         * Logs message to the console window in the browser (press F12 to see it).
         * This can be useful to see if a certain action is executing.
         * For example: [/\d+/, { token: 'number', log: 'found number $0 in state $S0' } ]
         */
        log?: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeTokenizationRuleCasesAction is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * The final kind of action object is a cases statement.
     * A cases object contains an object where each field functions as a guard.
     * Each guard is applied to the matched input and as soon as one of them matches, the corresponding action is applied.
     * Note that since these are actions themselves, cases can be nested.
     * Cases are used for efficiency: for example, we match for identifiers and then test whether the identifier is possibly a keyword or builtin function:
     *
     *     [/[a-z_\$][a-zA-Z0-9_\$]<asterisk>/,
     *         { cases: { '@typeKeywords': 'keyword.type'
     *                  , '@keywords': 'keyword'
     *                  , '@default': 'identifier' }
     *         }
     *     ]
     *
     * The guards can consist of:
     *
     *     "@keywords"
     *         The attribute keywords must be defined in the language object and consist of an array of strings.
     *         The guard succeeds if the matched input matches any of the strings.
     *         (Note: all cases are pre- compiled and the list is tested using efficient hash maps).
     *         Advanced: if the attribute refers to a single string (instead of an array) it is compiled to a regular expression which is tested against the matched input.
     *
     *     "@default"
     *         (or "@" or "") The default guard that always succeeds.
     *
     *     "@eos"
     *         Succeeds if the matched input has reached the end of the line.
     *
     *     "regex"
     *         If the guard does not start with a @ (or $) character it is interpreted as a regular expression that is tested against the matched input.
     *         Note: the regex is prefixed with ^ and postfixed with $ so it must match the matched input entirely.
     *         This can be used for example to test for specific inputs, here is an example from the Koka language which uses this to enter various tokenizer states based on the declaration:
     *
     *         [/[a-z](\w|\-[a-zA-Z])<asterisk>/,
     *             { cases: { '@keywords': {
     *                         cases: { 'alias': { token: 'keyword', next: '@alias-type' }
     *                                , 'struct': { token: 'keyword', next: '@struct-type' }
     *                                , 'type|cotype|rectype': { token: 'keyword', next: '@type' }
     *                                , 'module|as|import': { token: 'keyword', next: '@module' }
     *                                , '@default': 'keyword' }
     *                        }
     *               , '@builtins': 'predefined'
     *               , '@default': 'identifier' }
     *             }
     *         ]
     *
     *         Note the use of nested cases to improve efficiency.
     *         Also, the library recognizes simple regular expressions like the ones above and compiles them efficiently.
     *         For example, the list of words type| cotype | rectype is tested using a Javascript hashmap/ object.
     *
     *     (Advanced) In general, a guard has the form [pat][op]match, with an optional pattern, and operator (which are $# and ~ by default).
     *     The pattern can be any of:
     *
     *     $#
     *         (default) The matched input (or the group that matched when the action is an array).
     *
     *     $n
     *         The nth group of the matched input, or the entire matched input for $0.
     *
     *     $Sn
     *         The nth part of the state, i.e.$S2 returns foo in a state @tag.foo.
     *         Use $S0 for the full state name.
     *
     *     The above patterns can actually occur in many attributes and are automatically expanded.
     *     Attributes where these patterns expand are token, next, nextEmbedded, switchTo, and log.
     *     Also, these patterns are expanded in the match part of a guard.
     *
     *     The guard operator op and match can be any of:
     *
     *      ~regex or !~regex
     *          (default for op is ~) Tests pat against the regular expression or its negation.
     *
     *      @attribute or !@attribute
     *          Tests whether pat is an element (@), or not an element (!@), of an array of strings defined by attribute.
     *
     *      ==str or != str
     *          Tests if pat is equal or unequal to the given string str.
     *
     *      For example, here is how to check if the second group is not equal to foo or bar: $2!~foo | bar, or if the first captured group equals the name of the current lexer state: $1 == $S0.
     *
     *      If both op and match are empty and there is just a pattern, then the guard succeeds if the pattern is non- empty.
     *      This can be used for example to improve efficiency.
     *      In the Koka language, an upper case identifier followed by a dot is module name, but without the following dot it is a constructor.
     *      This can be matched for in one go using:
     *
     *      [/([A-Z](?:[a-zA-Z0-9_]|\-[a-zA-Z])*)(\.?)/,
     *          { cases: { '$2': ['identifier.namespace', 'keyword.dot']
     *                   , '@default': 'identifier.constructor' }}
     *      ]
     */
    interface CustomContentTypeTokenizationRuleCasesAction {
        /**
         * The cases for the action.
         */
        cases: {
            [caseName: string]: CustomContentTypeTokenizationRuleAction;
        };
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeSuggestSupport is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines suggestions for code completion in a custom language.
     */
    interface CustomContentTypeSuggestSupport {
        /**
         * Indicates if completions should automatically be provided from the current document contents.
         */
        textualCompletions?: boolean;
        /**
         * Array of characters that will trigger suggestions pop-up.
         */
        triggerCharacters?: string[];
        /**
         * Snippet definitions.
         * This is an array containing snippet definitions or simple text suggestions.
         */
        snippets: (string | CustomContentTypeSuggestSupportSnippet)[];
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeSuggestSupportSnippet is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a code suggestion snippet for a custom language.
     */
    interface CustomContentTypeSuggestSupportSnippet {
        /**
         * The type of snippet.
         */
        type: string;
        /**
         * The label displayed in the suggest support pop up.
         */
        label: string;
        /**
         * The snippet to insert.
         */
        codeSnippet: string;
        /**
         * Documentation to display in the suggest support pop-up.
         */
        documentationLabel?: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeAutoCompleteMatcher is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Auto Complete matcher for custom content type.
     */
    interface CustomContentTypeAutoCompleteMatcher {
        /**
         * The string of characters where autocompletion should be checked.
         */
        triggers: string;
        /**
         * Regular expression that is tested against the current input line when triggred.
         */
        match: string;
        /**
         * On match is appended to the source with captured groups expanded.
         */
        complete: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.CustomContentTypeAutoIndentMatcher is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Auto indent matcher for custom content type.
     */
    interface CustomContentTypeAutoIndentMatcher {
        /**
         * Regular expression matched against the current line on an enter to determine indentation.
         */
        match: string;
        /**
         * Regular expression matched against the tokens following the line break to determing block indentation.
         */
        matchAfter: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.JSONSchema is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * JSON schema
     */
    interface JSONSchema {
        /**
         * Incicates format of file name that schema will be applied to.
         */
        fileMatch: string[];
        /**
         * Incicates uri from which schema will be loaded.
         */
        uri?: string;
        /**
         * Indicates to validate schema.
         */
        validate?: boolean;
        /**
         * Inline schema definition.
         */
        schema?: any;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.JSONConfiguration is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * JSON configuration.
     */
    interface JSONConfiguration {
        /**
         * JSON schemas.
         */
        schemas?: JSONSchema[];
        /**
         * If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
         */
        readonly allowComments?: boolean;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.TypeScriptExtraLib is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines an extra library for intellisense in the typescript editor.
     */
    interface TypeScriptExtraLib {
        /**
         * The content of the library.
         * For example the content of a library.d.ts file.
         */
        content: string;
        /**
         * The library name.
         * For instance "library.d.ts".
         */
        path: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.TypeScriptScriptTarget is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * The typescript script target.
     */
    const enum TypeScriptScriptTarget {
        /**
         * ECMAScript 5.
         */
        ES5 = 0,
        /**
         * ECMAScript 6.
         */
        ES6 = 1
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.TypeScriptCompilerOptions is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * TypeScript compiler options.
     */
    interface TypeScriptCompilerOptions {
        /**
         * The target type for compilation.
         * Defaults to ES5.
         */
        target?: TypeScriptScriptTarget;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.TypeScriptConfiguration is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * TypeScript editor configuration.
     */
    interface TypeScriptConfiguration {
        /**
         * Extra libraries to load for TypeScript intellisense.
         */
        extraLibs?: TypeScriptExtraLib[];
        /**
         * Compiler options for compiling the typescript.
         */
        compilerOptions?: TypeScriptCompilerOptions;
        /**
         * The typescript compiler output.
         * Updated on each save.
         * This is the transpiled javascript content.
         */
        output?: KnockoutObservable<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.Configuration is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor configuration.
     */
    interface Configuration {
        /**
         * Contains JSON schema configuration.
         */
        json?: JSONConfiguration;
        /**
         * Contains TypeScript configuration.
         */
        typescript?: TypeScriptConfiguration;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.Contract is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor view model contract.
     */
    interface Contract extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * The type of the file.
         */
        contentType: KnockoutObservable<ContentType>;
        /**
         * Definition for a custom content type.
         * This definition is used only if 'contentType' is set to 'ContentType.Custom'.
         */
        customContentType: KnockoutObservable<CustomContentType>;
        /**
         * The content of the file.
         */
        content: KnockoutObservable<string>;
        /**
         * Content uri, defines file location and type
         */
        contentUri: KnockoutObservable<string>;
        /**
         * The currently selected content of the file.
         */
        selectedContent: KnockoutObservable<string>;
        /**
         * The currently selected Range in the file.
         */
        selectedRange: KnockoutObservable<EditorRange>;
        /**
         *  Definition for markers in the editor.
         */
        markers: KnockoutObservableArray<EditorMarker>;
        /**
         *  Current position of the cursor in the file.
         */
        position: KnockoutObservable<EditorPosition>;
        /**
         * The editor options.
         */
        options: KnockoutObservable<Options>;
        /**
         * Indicates if the contents have been modified but not yet saved.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Saves the editor content.
         */
        save: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Indicates which editor extensions to use.
         */
        extensions?: Extensions;
        /**
         * Indicates options for the specified extensions.
         */
        extensionOptions?: ExtensionOptions;
        /**
         * Configuration options.
         */
        configuration: Configuration;
        /**
         * Indicates if the editor is displayed.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * Refreshes the editor view.
         */
        refresh: MsPortalFx.ViewModels.Controls.Command.Contract;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.EditorPosition is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  A position in the text editor.  Same properties as a Monaco IPosition interface
     */
    interface EditorPosition {
        /**
         * line number (starts at 1)
         */
        lineNumber: number;
        /**
         * column (the first character in a line is between column 1 and column 2)
         */
        column: number;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.MarkerSeverity is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  Editor marker definition
     */
    enum MarkerSeverity {
        /**
         * Ignored marker
         */
        Ignore = 0,
        /**
         * Hint marker
         */
        Hint = 1,
        /**
         * Information marker
         */
        Info = 2,
        /**
         * Warning marker
         */
        Warning = 3,
        /**
         * Error marker
         */
        Error = 4
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.EditorMarker is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  Editor marker definition
     */
    interface EditorMarker {
        /**
         * The message to show in the tool tip
         */
        message: string;
        /**
         * The severity of the marker
         */
        severity: MarkerSeverity;
        /**
         * The text range to apply the marker to
         */
        range: EditorRange;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.EditorRange is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  A Range of text in the text editor. Same properties as a Monaco IRange interface
     */
    interface EditorRange {
        /**
         * Line number on which the range starts (starts at 1).
         */
        startLineNumber: number;
        /**
         * Column on which the range starts in line `startLineNumber` (starts at 1).
         */
        startColumn: number;
        /**
         * Line number on which the range ends.
         */
        endLineNumber: number;
        /**
         * Column on which the range ends in line `endLineNumber`.
         */
        endColumn: number;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Documents.Editor.ViewModel is deprecated. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor view model implementation.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
        /**
         * The contents of the document.
         */
        content: KnockoutObservable<string>;
        /**
         * Selected content of the document.  Will be empty if nothing is selected.
         */
        selectedContent: KnockoutObservable<string>;
        /**
         *  Range of selected text in the editor
         */
        selectedRange: KnockoutObservable<EditorRange>;
        /**
         *  Definition for markers in the editor.
         */
        markers: KnockoutObservableArray<EditorMarker>;
        /**
         *  Position of the cursor in the editor
         */
        position: KnockoutObservable<EditorPosition>;
        /**
         * The type of the document.
         */
        contentType: KnockoutObservable<ContentType>;
        /**
         * Definition for a custom content type.
         */
        customContentType: KnockoutObservable<CustomContentType>;
        /**
         * The editor options.
         */
        options: KnockoutObservable<MsPortalFx.ViewModels.Controls.Documents.Editor.Options>;
        /**
         * Indicates if the content has been modified and has not been saved.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Saves the content of the file.
         */
        save: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Defines an auto save timeout in millisenconds when it expires the editor changes are saved.
         * The timeout is set each time the user changes the text and if there where no changes until the time expires the changes are saved
         * Zero -or- null means auto save is disabled
         */
        autoSaveTimeout: KnockoutObservable<number>;
        /**
         * Content uri, defines document location and type
         */
        contentUri: KnockoutObservable<string>;
        /**
         * Indicates which editor extensions to use.
         */
        extensions: Extensions;
        /**
         * Indicates options for the specified extensions.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Configuration options.
         */
        configuration: Configuration;
        /**
         * Indicates if the editor is displayed
         */
        visible: KnockoutObservable<boolean>;
        /**
         * Refreshes the editor view.
         */
        refresh: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Creates an editor view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param contentType The type of document.
         * @param content The contents of the document.
         * @param options The editor options.
         * @param customContentType The editor options.
         * @param extensions List of extensions to use.
         * @param extensionOptions Options for the specified extensions.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, contentType: ContentType, content: string, options?: MsPortalFx.ViewModels.Controls.Documents.Editor.Options, customContentType?: CustomContentType, extensions?: Editor.Extensions, extensionOptions?: Editor.ExtensionOptions, configuration?: Configuration);
        private _setupExtensions;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Documents\Editor.DiscussionExtension.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.Editor {
    enum Extensions {
        /**
         * Extension used to enable code discussion.
         */
        Discussion = 1
    }
    interface ExtensionOptions {
        /**
         * Options for code discussion. If not specified, code discussion will be disabled.
         */
        discussion?: DiscussionOptions;
    }
    /**
     * Represents the position of the thread in the editor.
     */
    interface EditorThreadPosition {
        /**
         * Determines whether thread should be on modified side or not.
         */
        isModifiedSide: boolean;
        /**
         * Start column of the thread.
         */
        startColumn: number;
        /**
         * End column of the thread.
         */
        endColumn: number;
        /**
         * Start line of the thread.
         */
        startLine: number;
        /**
         * End line of the thread.
         */
        endLine: number;
    }
    interface EditorThread extends MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionThread {
        /**
         * Position of the thread used to locate inside the editor.
         */
        position: KnockoutObservable<EditorThreadPosition>;
    }
    class EditorThreadViewModel extends MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionThreadViewModel {
        /**
         * Position of the thread used to locate inside the editor.
         */
        position: KnockoutObservable<EditorThreadPosition>;
        /**
         * Creates an editor thread class.
         *
         * @param id Id of the thread.
         * @param comment Comments of the thread.
         * @param position Position of the thread.
         */
        constructor(id?: number, comments?: MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionComment[], position?: EditorThreadPosition);
    }
    interface BaseDiscussionOptions<TThread extends DiscussionThread.DiscussionThread> extends BaseExtensionOption {
        /**
         * Author of this discussion.
         */
        author: KnockoutObservable<MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionAuthor>;
        /**
         * Threads of this discussion.
         */
        threads: KnockoutObservableArray<TThread>;
        /**
         * Action for adding new thread.
         */
        addThread?: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<EditorThreadPosition, any>;
        /**
         * Save thread delegate.
         */
        saveThread?: (content: string, thread: EditorThread, containerName?: string) => MsPortalFx.Base.PromiseV<DiscussionThread.DiscussionThreadSaveResult>;
        /**
         * Save comment delegate.
         */
        saveComment?: (content: string, comment: DiscussionThread.DiscussionComment) => MsPortalFx.Base.PromiseV<DiscussionThread.DiscussionCommentSaveResult>;
        /**
         * Delete comment delegate.
         */
        deleteComment?: (threadId: number, commentId: number) => MsPortalFx.Base.Promise;
        /**
         * Name of the container of this discussion thread.
         */
        containerName?: string;
    }
    interface DiscussionOptions extends BaseDiscussionOptions<EditorThread> {
    }
    /**
     * A helper class that eases command handling for discussion thread operations
     * like add thread, add comment, save comment, delete comment.
     */
    class DiscussionCommandHandler implements MsPortalFx.Base.Disposable {
        /**
         * Discussion thread options.
         */
        options: DiscussionOptions;
        /**
         * Lifetime manager with the lifetime of this class.
         */
        private _lifetimeManager;
        /**
         * Creates a DiscussionCommandHandler instance.
         *
         * @param Discussion thread options.
         */
        constructor(options: DiscussionOptions);
        /**
         * Cleans up subscriptions.
         */
        dispose(): void;
        private _attachAddThreadHandler;
        private _addThreadHandlers;
        private _attachSaveThreadHandler;
        private _attachAddCommentHandler;
        private _attachDeleteCommentHandler;
        private _attachSaveCommentHandler;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Documents\Editor.Extension.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.Editor {
    import CommandStatus = MsPortalFx.ViewModels.Controls.Command.Status;
    /**
     * Enum for extension availability.
     * Individual extensions will contribute to this.
     */
    enum Extensions {
        /**
         * No extension.
         */
        None = 0
    }
    /**
     * Detailed options for extensions.
     * Individual extensions will contribute to this.
     */
    interface ExtensionOptions {
    }
    /**
     * Base interface for editor extension options.
     */
    interface BaseExtensionOption {
    }
    /**
     * Handler of the extension command.
     */
    interface ExtensionHandler<TContext, TResult> {
        (context?: TContext): MsPortalFx.Base.PromiseV<TResult>;
    }
    /**
     * Light-weight command used for extension actions.
     */
    class ExtensionCommand<TContext, TResult> {
        /**
         * The latest command status.
         */
        status: KnockoutObservable<CommandStatus>;
        /**
         * The latest command error.
         */
        error: KnockoutObservable<any>;
        /**
         * The latest command error message.
         */
        errorMessage: KnockoutObservable<string>;
        /**
         * Handles the command execution.
         */
        handler: KnockoutObservable<ExtensionHandler<TContext, TResult>>;
        /**
         * Creates an extension command.
         *
         * @handler Handles the command execution.
         */
        constructor(handler?: ExtensionHandler<TContext, TResult>);
        /**
         * Executes the command handler and updates the view model state.
         *
         * @return Callback promise for completion or failure.
         */
        execute(context?: TContext): MsPortalFx.Base.PromiseV<TResult>;
    }
    /**
     * Setup delegate for individual extensions.
     */
    interface ExtensionSetupDelegate {
        (extensions: Extensions, extensionOptions: ExtensionOptions): KnockoutDisposable[];
    }
    /**
     * Enables registering setup delegate for an extension.
     *
     * @param setupDelegate Delegate to run when extensions are initialized.
     */
    function registerExtensionSetup(setupDelegate: ExtensionSetupDelegate): void;
    /**
     * Gets the list of setup delegates for extensions.
     *
     * @return List of setup delegates.
     */
    function getExtensionSetups(): ExtensionSetupDelegate[];
}

// FILE: MsPortalFx\ViewModels\Controls\EditableControl.d.ts
declare module MsPortalFx.ViewModels.Controls.EditableControl {
    interface Contract<TValue> extends Loadable.Contract {
        /**
         * Name attribute of the control to use with form.
         */
        name: string;
        /**
         * Value held by the control. Can be any type.
         */
        value: KnockoutObservable<TValue>;
        /**
         * Original value of the field. Controls edited state.
         */
        dirty: KnockoutObservableBase<boolean>;
    }
    class ViewModel<TValue> extends Loadable.ViewModel implements Contract<TValue> {
        /**
         * Name attribute of the control to use with form.
         */
        name: string;
        /**
         * Value held by the control. Can be any type.
         */
        value: KnockoutObservable<TValue>;
        /**
         * Original value of the field. Controls edited state.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Creates an editable control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\FileDownload\ViewModels.FileDownload.d.ts
declare module MsPortalFx.ViewModels.Controls.FileDownload {
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Type = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Status: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type DownloadProgressDialogOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type UriCallbackConfirmationDialogOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type UriCallbackErrorMessage = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Context: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\FileDownload\ViewModels.FileDownloadButton.d.ts
declare module MsPortalFx.ViewModels.Controls.FileDownloadButton {
    /**
     * MsPortalFx.ViewModels.Controls.FileDownloadButton has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownloadButton has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Forms\CopyableLabel.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.CopyableLabel {
    /**
     * This control is no longer supported. Use Fx/Controls/CopyableLabel instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/CopyableLabel instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/CopyableLabel instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Internal\IFrame.d.ts
declare const enum IframeEnum {
    DefaultTimeOutInMs = 30000
}
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Internal.IFrame {
    enum Scroll {
        /**
         * Only when needed.
         */
        Auto = 1,
        /**
         * Always provide a scroll bar.
         */
        Yes = 2,
        /**
         * Never provide a scoll bar.
         */
        No = 3
    }
    interface Options {
        /**
         * The URL of the page to embed.
         */
        readonly src: string;
        /**
         * Enumerated attribute indicating when the browser should provide a scroll bar.
         */
        readonly scrolling?: Scroll;
        /**
         * Data passed from the shell to the control.
         */
        readonly postMessage?: KnockoutObservable<any>;
        /**
         * Data passed from the control to the shell.
         */
        readonly receiveMessage?: KnockoutObservable<any>;
        /**
         * The timeout period for the source URI to load.
         */
        readonly loadTimeoutInMilliseconds?: number;
    }
    class ViewModel extends Base.ViewModel {
        /**
         * The URL of the page to embed.
         */
        readonly src: string;
        /**
         * Enumerated attribute indicating when the browser should provide a scroll bar.
         */
        readonly scrolling: Scroll;
        /**
         * Data passed from the shell to the control.
         */
        readonly postMessage: KnockoutObservable<any>;
        /**
         * Data passed from the control to the shell.
         */
        readonly receiveMessage: KnockoutObservable<any>;
        /**
         * The timeout period for the source URI to load.
         */
        readonly timeoutInMs: number;
        /**
         * Constructs an IFrame view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the IFrame control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: MsPortalFx.ViewModels.Controls.Internal.IFrame.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Internal\IFrameV2.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Internal.IFrameV2 {
    /**
     * MsPortalFx.ViewModels.Controls.Internal.IFrameV2 has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FrameControl.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Internal.IFrameV2 has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/FrameControl.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Base\ViewModels.ActionHandlerInterfaces.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Base {
    /**
     * A control that can perform actions when directed by an ActionSource control
     */
    interface ActionHandler {
        /**
         *  Internal use only. Signals that this control can perform filtering actions via ActionSource
         */
        _filterActions: boolean;
    }
    /**
     * A control that can invoke actions on another control
     */
    interface ActionSource {
        /**
         * The handler control that will be manipulated by this control.
         */
        actionHandler: KnockoutObservableBase<ActionHandler> | ActionHandler;
        /**
         * When not enabled, this control will not send events to the handler.
         */
        actionsEnabled: KnockoutObservable<boolean>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    import Fx = MsPortalFx;
    class ViewModel<TItem, TSelection> extends Fx.ViewModels.Controls.Loadable.ViewModel implements Contract<TItem, TSelection>, MsPortalFx.Base.Disposable {
        /**
         * Summary of the table.
         */
        summary: KnockoutObservable<string>;
        /**
         * Shows the column header.
         */
        showHeader: boolean;
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * No rows message when no items are displayed.
         */
        noRowsMessage: KnockoutObservable<string>;
        /**
         * The bitmask of plugins to be loaded.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionsOptions: ExtensionsOptions<TItem, TSelection>;
        /**
         * The list of sortBy data.
         */
        sortByList: KnockoutObservableArray<SortBy>;
        /**
         * Row metadata associated to rows in the grid (editState, selected, disabled, groupId).
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         * The extended contract in the control has this as a property on the interface to consume changes.
         */
        private rowMetadata;
        /**
         * The selectable set used for selection and activation.
         */
        selectableData: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>;
        /**
         * The created items for editable grids.
         */
        createdItems: KnockoutObservableArray<TItem>;
        /**
         * Aria label for the grid control
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Callback for getting the aria label for a row
         */
        getRowAriaLabel: (item: TItem) => string;
        /**
         * list of properties that should trigger updating the aria label when changed
         */
        rowAriaLabelDependencies?: string[];
        rowAdd: JQueryEventHandler;
        /**
         * The resetCallback will be populated internally by the Grid control.
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         */
        resetCallback: KnockoutObservableBase<GridResetCallback>;
        /**
         * Observable used to add a new empty row to the grid.
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         * The extended contract in the control has this as a property on the interface to consume changes.
         */
        private addEmptyRow;
        private _addCreatedLocked;
        private _resetHandler;
        private _pendingResetCallbackPromise;
        private _editScope;
        private _msPortalFxActions;
        /**
         * Creates the view model that drives the Grid portal control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items The observable list of items to be displayed in the grid.
         * @param extensions The bitmask of grid plugins to load.
         * @param extensionsOptions Options for extensions.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableArray<TItem>, extensions?: number, extensionsOptions?: ExtensionsOptions<TItem, TSelection>);
        /**
         * Gets the row metadata for an item.
         *
         * @param item The grid item whose metadata is requested.
         * @return Row metadata associated to the item.
         */
        getRowMetadata(item: TItem): RowMetadata<TItem>;
        /**
         * Option to reset the view model state for rebind scenarios.
         * Extension authors can override this method if Grid's default reset action doesn't meet their requirements.
         * This method will be called when DataNavigator's resetNavigation method is called.
         * The reset() method will internally invoke the resetCallback set by the grid control.
         * For pageable extension, calling reset will set empty array to the items, invoke data navigator's resetLoadByContinuationToken method
         * and invoke loadByContinuationToken method to fetch new data.
         */
        reset(): MsPortalFx.Base.Promise;
        /**
         * Disposes the grid view model.
         */
        dispose(): void;
        private _createMetadataForItem;
        private _create;
        private _addCreated;
        private _markForDelete;
        private _addInitialCreatedRow;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Base.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum Extensions {
        /**
         * Plugin to have sortable columns.
         */
        SortableColumn = 1,
        /**
         * Plugin to have selectable rows.
         */
        SelectableRow = 2,
        /**
         * Plugin to have right-clickable row.
         */
        RightClickableRow = 4,
        /**
         * Plugin to group rows by column value.
         */
        Groupable = 8,
        /**
         * Plugin to have editable rows.
         */
        EditableRow = 16,
        /**
         * Plugin to have filterable rows.
         */
        Filterable = 32,
        /**
         * Plugin to have reorder rows.
         */
        ReorderRow = 64,
        /**
         * Plugin to have a shortcut to the item context menu displayed in the row.
         */
        ContextMenuShortcut = 128,
        /**
         * Plugin to handle and display large items in sequential pages.
         */
        Pageable = 256,
        /**
         * Plugin to display hierarchical items.
         */
        Hierarchical = 512,
        /**
         * Plugin to control scrolling behavior.
         * This plugin is always enabled.
         * It is no longer a requirement to specify this plugin explicitly.
         * The options can be used to control vertical and horizontal scrolling behavior.
         */
        Scrollable = 1024,
        /**
         * Plugin to enable hover index communication with other parts.
         */
        Hoverable = 2048,
        /**
         * Plugin to have resizable columns.
         */
        ResizableColumn = 4096
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Gets the aria label for a row
         */
        getRowAriaLabel?: (item: TItem) => string;
        /**
         * list of properties that should trigger updating the aria label when changed
         */
        rowAriaLabelDependencies?: string[];
    }
    interface RowMetadata<T> {
        /**
         * One entry representing the item.
         */
        item: T;
        /**
         * Css class associated with the row.
         */
        cssClass?: KnockoutObservable<string>;
    }
    interface Column {
        /**
         * Name of the column displayed in the header.
         */
        name?: KnockoutObservable<string>;
        /**
         * String mapping to the item key.
         */
        itemKey: string;
        /**
         * Formatter used when displaying one cell.
         */
        format?: Format;
        /**
         * Formatter options associated with the formatters.
         */
        formatOptions?: FormatOptions;
        /**
         * Declare this column is activatable.  The control will automatic apply activatable style through this column.
         */
        activatable?: KnockoutObservableBase<boolean>;
        /**
         * Css class associated with the column.
         */
        cssClass?: string;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Pixel widths are rendered at the specified width.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         * Fractional and percentage widths will use minWidth when horizontal scrolling is enabled.
         */
        width?: KnockoutObservable<string>;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * Indicate this column text need to support ellipse
         */
        enableEllipse?: KnockoutObservableBase<boolean>;
        /**
         * Enable cell content to height 100%
         */
        fullHeight?: KnockoutObservableBase<boolean>;
        /**
         * Forward-compat for Grid2.
         * No use in Grid1.
         */
        id?: string;
        /**
         * Hides the column in collapsed state.
         */
        hiddenInCollapsed?: KnockoutObservableBase<boolean>;
        /**
         * Callback for getting the aria label for a cell
         */
        getCellAriaLabel?: (item: any) => string;
        /**
         * Aria label for column header.
         * Only required for accessibility when the column name (header text) is empty.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Grid reset callback.
     */
    interface GridResetCallback {
        (): MsPortalFx.Base.Promise;
    }
    /**
     * Generic grid callback interface.
     */
    interface GridCallback {
        (): MsPortalFx.Base.Promise;
    }
    interface ExtensionContract extends Loadable.Contract {
        /**
         * The bitmask of plugins to be loaded.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions?: number;
    }
    interface ContractBase<TItem> {
        /**
         * Shows the column header.
         */
        showHeader?: boolean;
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items?: KnockoutObservableArray<TItem>;
    }
    interface Contract<TItem, TSelection> extends ContractBase<TItem>, ExtensionContract {
        /**
         * Summary of the table.
         */
        summary: KnockoutObservable<string>;
        /**
         * No rows message when no items are displayed.
         */
        noRowsMessage?: KnockoutObservable<string>;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionsOptions?: ExtensionsOptions<TItem, TSelection>;
        /**
         * Gets the row metadata for an item.
         *
         * @param item The grid item whose metadata is requested.
         * @return Row metadata associated to the item.
         */
        getRowMetadata(item: TItem): RowMetadata<TItem>;
        /**
         * Option to reset the view model state for rebind scenarios.
         * Extension authors can override this method if Grid's default reset action doesn't meet their requirements.
         * This method will be called when DataNavigator's resetNavigation method is called.
         * The reset() method will internally invoke the resetCallback set by the grid control.
         * For pageable extension, calling reset will set empty array to the items, invoke data navigator's resetLoadByContinuationToken method
         * and invoke loadByContinuationToken method to fetch new data.
         */
        reset(): MsPortalFx.Base.Promise;
        /**
         * The resetCallback will be populated internally by the Grid control.
         */
        resetCallback: KnockoutObservableBase<GridResetCallback>;
        /**
         * The list of sortBy data.
         */
        sortByList: KnockoutObservableArray<SortBy>;
    }
}
declare module FxImpl.ViewModels.Controls.Lists.Grid {
    /**
     * Internal grid interface.
     */
    interface Actions {
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ContextMenuShortcut.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.EditableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    const enum EditableRowPlacement {
        /**
         * Put the editable row at the bottom of the grid.
         */
        Bottom = 0,
        /**
         * Put the editable row at the top of the grid.
         */
        Top = 1
    }
    interface Column {
        /**
         * Format used when displaying one cell in edit mode.
         */
        editableFormat?: Format;
        /**
         * Format options associated with the editableFormat.
         */
        editableFormatOptions?: FormatOptions;
    }
    interface EditableRowMetadata<T> extends RowMetadata<T> {
        /**
         * The edit state of the entity in the edit scope.
         */
        editState?: KnockoutObservableBase<MsPortalFx.Data.EditState>;
    }
    interface EditScopeModel<T> {
        /**
         * The model for data stored in the edit scope.
         */
        items: KnockoutObservableArray<T>;
    }
    interface EditableRowOptions<T> {
        /**
         * An observable that supplies an edit scope instance. This instance can change as the enclosing Part is
         * rebound to a different master selection. This property will be nulled out when passed to the view model.
         */
        editScope: KnockoutObservable<MsPortalFx.Data.EditScope<any>>;
        /**
         * An optional function that retrieves the 'items' array from an EditScope instance.
         *
         * @param editScope The edit scope from which to get items.
         * @return The items to be displayed in the grid.
         */
        getItems?: (editScope: MsPortalFx.Data.EditScope<any>) => KnockoutObservableArray<T>;
        /**
         * Indicates if the editable row is at the top or bottom.
         * Defaults to Bottom.
         */
        placement?: EditableRowPlacement;
        /**
         * The maximum number of buffered rows at any time.
         */
        maxBufferedRows?: number | KnockoutObservableBase<number>;
        /**
         * If set to true, clicking on an existing row will go in edit mode.
         * Defaults to false.
         */
        allowEditExistingItems?: boolean;
        /**
         * If set to true, clicking on a newly created row will go in edit mode.
         * Defaults to false.
         */
        allowEditCreatedItems?: boolean;
        /**
         * If set to true, an empty row is displayed at the location defined by the placement property.
         * Defaults to true.
         */
        enableRowAdd?: boolean;
        /**
         * If set to true, right-clicking on a newly created row will show the delete command.
         * Defaults to true.
         */
        enableRowDelete?: boolean;
        /**
         * The title to display for the row delete command.
         * Defaults to Delete.
         */
        deleteRowCommandTitle?: string;
        /**
         * Callback function that gets executed when an item is created.
         *
         * @param item The newly created item.
         */
        created?: (item: T) => void;
        /**
         * When changed ensures validation on the entire grid.
         */
        validate?: KnockoutObservable<number>;
        /**
         * When all form fields in the editable rows in editing mode are valid then true; else false.
         */
        valid?: KnockoutObservable<boolean>;
        /**
         * aria label applied to the add new row
         */
        newRowAriaLabel?: string;
    }
    interface EditableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the EditableRow grid extension. If null, rows will not be editable.
         */
        editableRow?: EditableRowOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the EditableRow grid extension. If null, rows will not be editable.
         */
        editableRow?: EditableRowOptions<TItem>;
    }
    interface EditableRowContract<TItem, TSelection> extends Contract<TItem, TSelection> {
        /**
         * Contains all the created items used by the EditableRow extension.
         */
        createdItems?: KnockoutObservableArray<TItem>;
        /**
         * The callback that is executed when a row is added.
         */
        rowAdd: JQueryEventHandler;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.FieldInfo.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    /**
     * View model data required by HtmlBindingsType.TextBox for rendering the text form field.
     */
    interface TextFormFieldInfo extends HtmlBindingsData {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText?: string;
    }
    /**
     * View model data required by HtmlBindingsType.CheckBox for rendering the checkbox form field.
     */
    interface CheckBoxFormFieldInfo extends HtmlBindingsData {
    }
    /**
     * Item type for the dropdown fields
     */
    interface DropDownItem<T> {
        text: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        selectedItemOverride?: string | KnockoutObservableBase<string>;
        value: T;
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria label for item.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Group type for the dropdown fields
     */
    interface DropDownGroup<T> {
        /**
         * Content to render for the item.
         */
        text?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Items to render under this group.
         */
        children?: Array<DropDownItem<T> | DropDownGroup<T>> | KnockoutObservableBase<Array<DropDownItem<T> | DropDownGroup<T>>>;
        /**
         * Disabled state of group.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * This dropdown field is no longer supported. Please switch to using either the DropDownFormFieldInfo or GroupDropDownFormFieldInfo.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type MultiselectDropDownFormFieldInfo = Obsolete;
    interface DropDownFormFieldInfo<T> extends HtmlBindingsData {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<DropDownItem<T>>;
    }
    interface GroupDropDownFormFieldInfo<T> extends HtmlBindingsData {
        items: KnockoutObservableBase<Array<DropDownItem<T> | DropDownGroup<T>>>;
        filter?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sets the filter textbox's placeholder.
         * Default is blank.
         */
        filterPlaceholder?: string | KnockoutObservable<string>;
        /**
         * Callback which will override our simple substring filtering.
         * Return list of items you wish to filter.
         * Doesn't do anything unless filter is true.
         */
        customFilter?: (value: string) => MsPortalFx.Base.PromiseV<T[]>;
        multiselect?: boolean | KnockoutObservableBase<boolean>;
        selectAll?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override our selectAll functionality.
         * Allows you to select any items you wish, we don't do any selecting when you provide this override.
         */
        selectAllOverride?: () => MsPortalFx.Base.PromiseV<any>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Filterable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface Column {
        /**
         * Format used when filtering a grid.
         */
        filterableFormat?: Format;
        /**
         * Format options associated with the filterableFormat.
         */
        filterableFormatOptions?: FormatOptions;
    }
    interface FilterableOptions {
        /**
         * Whether the filter search box close button is visible or not.
         */
        searchBoxCloseButtonVisible?: KnockoutObservableBase<boolean>;
        /**
         * The placeholder text to be shown in the search box.
         */
        searchBoxPlaceholder?: KnockoutObservable<string>;
        /**
         * Whether the filter search box is visible or not.
         */
        searchBoxVisible?: KnockoutObservableBase<boolean>;
        /**
         * The subset of visible column names to search through.
         */
        searchableColumns?: KnockoutObservableArray<string>;
        /**
         * The query string of the searchbox.
         */
        queryString?: KnockoutObservableBase<string>;
        serverFilter?: KnockoutObservableBase<boolean>;
        /**
         * Specify a delay timeout to control when filter value change notification should be done.
         * For server filtering, based on the backend processing capabilities, fine tune this value.
         * For slow backends, have this value higher so that repeated callbacks to backends are not made.
         */
        valueUpdateDelayTimeout?: KnockoutObservableBase<number>;
    }
    interface FilterableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the filterable plugin.
         */
        filterable?: FilterableOptions;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the filterable plugin.
         */
        filterable?: FilterableOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.FocusableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface FocusableRowMetadata<T> extends RowMetadata<T> {
        /**
         * Indicates if the row is disabled.
         */
        disabled?: KnockoutObservable<boolean>;
    }
    interface FocusableOption {
        focusable?: KnockoutObservableBase<boolean>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Formatters.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum Format {
        /**
         * HTML format, raw HTML is allowed.
         */
        Html = 1,
        /**
         * Text format, HTML gets encoded.
         * The value can also be simple text or a KnockoutObservable object.
         */
        Text = 2,
        /**
         * Short time format, outputs something similar to 11:20 AM.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        ShortTime = 100,
        /**
         * Long time format, outputs something similar to 11:20:19 AM.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        LongTime = 101,
        /**
         * Short date format, outputs something similar to 7/18/2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        ShortDate = 102,
        /**
         * Long date format, outputs something similar to Thursday, July 18, 2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        LongDate = 103,
        /**
         * Month and day format, outputs something similar to July 18.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        MonthDay = 104,
        /**
         * Year and month format, outputs something similar to July, 2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        YearMonth = 105,
        /**
         * Custom date format, outputs the format based on formatOptions.dateFormat
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        CustomDate = 106,
        /**
         * URI format, outputs a clickable URI.
         * The value can be an URI, or this format: { uri: string; text: string; target?: string } .
         */
        Uri = 107,
        /**
         * Icon format, outputs an icon with optionally text beside it.
         * The value can be an icon URI, or this format: { uri: string; text?: string; } .
         */
        Icon = 108,
        /**
         * Icon Lookup format, outputs an icon based on a dictionary you provide in formatOptions.iconLookup.
         * The value is the key that matches the iconLookup dictionary.
         * The iconLookup dictionary can be { key: iconUri, ... } or { key: { uri: string, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        IconLookup = 109,
        /**
         * Text Lookup format, outputs text based on a dictionary you provide in formatOptions.textLookup.
         * The value is the key that matches the textLookup dictionary.
         * The textLookup dictionary is { key: text, ... } .
         */
        TextLookup = 110,
        /**
         * Svg icon format, outputs an svg icon with optional text beside it.
         * The value can be an SVG, or this format: { svg: MsPortalFx.Base.Image; text?: string; } .
         */
        SvgIcon = 111,
        /**
         * Svg icon lookup format, outputs an icon based on a dictionary you provide in formatOptions.svgIconLookup.
         * The value is the key that matches the svgIconLookup dictionary.
         * The svgIconLookup dictionary can be { key: MsPortalFx.Base.Image, ... } or { key: { svg: MsPortalFx.Base.Image, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        SvgIconLookup = 112,
        /**
         * Visually represents a percentage (values between 0-100) with a bar.
         */
        PercentageBar = 113,
        /**
         * Displays globalized numbers
         */
        Number = 114,
        /**
         * Html Bindings format, uses a template defined in formatOptions.htmlBindingsTemplate and apply the binding defined in formatOptions.htmlBindingsViewModel.
         * The value can be anything that the view model can understand. See the HtmlBindingsType for more details.
         */
        HtmlBindings = 1000
    }
    enum HtmlBindingsType {
        /**
         * Will return an object containing the following:
         * { value: any, settings?: CellFormatterSettings }
         *
         * The value is the one from your itemKey, the settings vary depending on which plugin is loaded into the grid.
         */
        Default = 0,
        /**
         * Uses a CheckBox control for the cell.
         */
        CheckBox = 1,
        /**
         * Uses a TextBox control for the cell.
         */
        TextBox = 2,
        /**
         * CheckBox ViewModel which maps your data with the state of the row, selected/unselected for checked/unchecked.
         */
        CheckBoxRowSelection = 4,
        /**
         * Uses a DropDown control for the cell.
         */
        DropDown = 5,
        /**
         * Uses a GroupDropDown control for the cell.
         */
        GroupDropDown = 6
    }
    /**
     * Controls the location of text in a PercentageBar formatter.
     */
    const enum PercentageBarTextLocation {
        /**
         * Text is not displayed in the formatter.
         */
        None = 0,
        /**
         * Text is displayed above the bar.
         */
        Above = 1,
        /**
         * Text is displayed below the bar.
         */
        Below = 2,
        /**
         * Text is displayed over the bar.
         */
        Overlay = 3
    }
    interface TextAndSvg {
        /**
         * SVG icon.
         */
        svg: MsPortalFx.Base.Image;
        /**
         * Value representing the text.
         */
        text?: string;
        /**
         * Css value for height of svg icon.
         */
        height?: string;
        /**
         * Css value for width of svg icon.
         */
        width?: string;
    }
    interface PercentageBarOptions {
        /**
         * Determines if a distinct background for the bar is drawn so the user can see exactly where 100% would be.
         * Accepts color codes like "a2" and "f0".  See the color palette style guide for more info.
         * Defaults to null, which is transparent
         */
        backgroundColor?: string;
        /**
         * Sets the default percentage bar color. Accepts color codes like "a2" and "f0".
         * See the color palette style guide for more info.
         */
        barColorDefault?: string;
        /**
         * The location of text in relation to the bar.  by default, text labels are not displayed, equivalent to PercentageBarTextLocation.None.
         */
        textLocation?: PercentageBarTextLocation;
        /**
         * If set, this key is used to specify a label for the bar. If not set, the value from the column is used as the text for the bar.
         * This is similar to how you specify where a column value comes from using Column.itemKey.
         */
        textKey?: any;
        /**
         * Specifies a property name on the row item that will contain a color code like "a2" or "f0" that should be used for the bar on that particular row.
         * This is similar to how you specify where a column value comes from using Column.itemKey.
         */
        barColorKey?: string;
    }
    /**
     * Data required by the specified htmlBindingType for rendering the HtmlBinding.
     */
    interface HtmlBindingsData {
        /**
         * The label for the form field.
         */
        label?: string;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: MsPortalFx.ViewModels.FormValidation[];
        /**
         * When changed forces validation on this column of the grid for all rows that are in editing mode.
         */
        validate?: KnockoutObservable<number>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent?: string;
    }
    interface FormatOptions {
        /**
         * Date format if using the CustomDate.
         * Accepts standard javascript formats: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         * string entries are deprecated.
         * http://msdn.microsoft.com/en-us/library/az4se3k1.aspx
         */
        dateFormat?: string | MsPortalFx.Intl.DateTimeFormatOptions;
        /**
         * Number format.
         * Accepts standard javascript formats: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
         * Not specifying any format options causes the default globalization formatter to be used.
         */
        numberFormat?: MsPortalFx.Intl.NumberFormatOptions;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value can be either the iconUri or an object as such { uri: string, text?: string } .
         */
        iconLookup?: any;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value is the text mapped to the value.
         */
        textLookup?: any;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value can be either the MsPortalFx.Base.Image or an object as such { uri: MsPortalFx.Base.Image, text?: string } .
         * The svgIconLookup dictionary can be { key: MsPortalFx.Base.Image, ... } or { key: { svg: MsPortalFx.Base.Image, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        svgIconLookup?: any;
        /**
         * Can specify the default color and toggle background of the percentage bar.
         */
        percentageBar?: PercentageBarOptions;
        /**
         * HTML which applyBindings will be executed on.
         * To know which variables will be available, see the HtmlBindingsType.
         */
        htmlBindingsTemplate?: string;
        /**
         * ViewModel bound to the htmlBindingsTemplate.
         */
        htmlBindingsType?: HtmlBindingsType;
        /**
         * Data required by the specified htmlBindingType for rendering the HtmlBinding.
         */
        htmlBindingsData?: HtmlBindingsData | TextFormFieldInfo | CheckBoxFormFieldInfo | DropDownFormFieldInfo<any> | GroupDropDownFormFieldInfo<any>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Groupable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum SortFunction {
        /**
         * Uses the built-in Array.sort() function.
         */
        Default = 0,
        /**
         * Uses the getTime() value of Date object to sort.
         */
        DateTime = 1,
        /**
         * Uses the setting list sorting, that ensures some groups are prioritized over others.
         */
        SettingListGroupOrder = 9999
    }
    interface GroupableRowMetadata<T> extends RowMetadata<T> {
        /**
         * The ID of the group, typically mapping to a unique value in the column being grouped by.
         */
        groupId?: KnockoutObservable<string>;
    }
    interface Group {
        /**
         * The unique value corresponding to the group.
         * This value will be passed to the formatter.
         */
        value: any;
        /**
         * The format used to display the group header.
         * By default, the plain text formatter is used if none is specified.
         */
        format?: Format;
        /**
         * The format used to sort the group header.
         * By default, it matches the group.format.
         */
        sortFormat?: Format;
        /**
         * Format options associated with the chosen format.
         */
        formatOptions?: FormatOptions;
        /**
         * Format options associated with the chosen sortFormat.
         */
        sortFormatOptions?: FormatOptions;
    }
    interface GroupableOptions {
        /**
         * The item field/column in the data set that the groups map to/are created from.
         * When groups are determined automatically, uniqueness is determined by taking the toString() of the
         * value this key maps to for each item.
         */
        groupKey: KnockoutObservable<string>;
        /**
         * Format used when displaying group headers.
         * By default, the plain text formatter is used.
         */
        headerFormat?: Format;
        /**
         * Format options associated with the chosen header format.
         */
        headerFormatOptions?: FormatOptions;
        /**
         * An observable array of Group objects, to be rendered in indexed order.
         * If this array is not provided, it is inferred from the column values mapped to groupKey.
         */
        groups?: KnockoutObservableArray<Group>;
        /**
         * Format used when displaying the group header for groupless items.
         * By default, the plain text formatter is used if none is specified.
         */
        noGroupLabelFormat?: Format;
        /**
         * Format options associated with the chosen format.
         */
        noGroupLabelFormatOptions?: FormatOptions;
        /**
         * Sort order to display groups in (Unsorted, Ascending, or Descending).
         */
        sortOrder?: KnockoutObservableBase<SortOrder>;
        /**
         * Sort function to apply to the group values. Defaults to the built-in sort function.
         */
        sortFunction?: SortFunction;
        /**
         * callback to get the aria label of a group.
         */
        getGroupAriaLabel?: (groupValue: any) => string;
    }
    interface GroupableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the groupable plugin.
         */
        groupable?: GroupableOptions;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the groupable plugin.
         */
        groupable?: GroupableOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Hierarchical.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface Column {
        /**
         * Indicate that the column should be displayed as a hierarchy with expand/collapse indicators.
         */
        hierarchical?: boolean;
    }
    interface HierarchicalItem {
        /**
         * Depth of item nesting.
         * Zero for top-level items.
         */
        depth: KnockoutObservableBase<number>;
        /**
         * Indicates if the item is expandable.
         * Undefined indicates expandability is unknown yet.
         */
        expandable: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is expanded or collapsed.
         */
        expanded: KnockoutObservableBase<boolean>;
    }
    interface Hierarchy<THierarchicalItem extends HierarchicalItem> {
        /**
         * The items to display in the grid.
         */
        items: KnockoutObservableBase<THierarchicalItem[]>;
        /**
         * Expands a hierarchy item.
         * @param item The item to expand.
         */
        expand: (item: THierarchicalItem) => void;
        /**
         * Collapses a hierarchy item.
         * @param item The item to expand.
         */
        collapse: (item: THierarchicalItem) => void;
        /**
         * Expands all hierarchy items.
         */
        expandAll: () => void;
        /**
         * Collapses all hierarchy items.
         */
        collapseAll: () => void;
    }
    interface HierarchicalOptions<THierarchicalItem extends HierarchicalItem> {
        /**
         * Provides the hierarchical data to the grid.
         */
        hierarchy: Hierarchy<THierarchicalItem>;
    }
    interface HierarchicalExtensionOptions<THierarchicalItem extends HierarchicalItem, TSelection> extends ExtensionsOptions<THierarchicalItem, TSelection> {
        /**
         * The options to configure the hierarchical plugin.
         */
        hierarchical?: HierarchicalOptions<THierarchicalItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the hierarchical plugin.
         */
        hierarchical?: HierarchicalOptions<TItem & HierarchicalItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Hoverable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface HoverableOption extends FocusableOption {
        hoverIDKey?: KnockoutObservableBase<string>;
        hoveredID?: KnockoutObservableBase<string>;
    }
    interface FocusableRowHoverExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        hoverable?: HoverableOption;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        hoverable?: HoverableOption;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Pageable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    /**
     * Defines the pageable options.
     */
    enum PageableType {
        /**
         * Sequential will load a "Load more" button.
         */
        Sequential = 0,
        /**
         * Pageable will load a paging control allowing to go on different pages.
         */
        Pageable = 1
    }
    interface PageableOptions<TItem> {
        /**
         * Type of pager to load with the extension.
         */
        type?: PageableType;
        /**
         * Optionally change the label text that's displayed to load more data for squential pageable type.
         */
        label?: KnockoutObservableBase<string>;
        /**
         * Optionally show or hide the load more display label for squential pageable type.
         */
        showLabel?: KnockoutObservableBase<boolean>;
        /**
         * Specifies the data source which supports pageable data access.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
        itemsPerPage?: KnockoutObservable<number>;
        /**
         * Maximum number of expanded pages to show in the pager before collapsing the pager into a textbox.
         */
        pagerMaxPages?: number;
    }
    interface PageableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the pageable plugin.
         */
        pageable?: PageableOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the pageable plugin.
         */
        pageable?: PageableOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ReorderRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ReorderRowEventObject<T> {
        /**
         * Metadata for moved row items.
         */
        rowMetadata: RowMetadata<T>[];
        /**
         * 0-Index position where the row got dropped.
         */
        position: number;
    }
    interface ReorderRowOptions<TItem> {
        /**
         * Disables the reorder plugin. Defaults to false.
         */
        disabled?: KnockoutObservable<boolean>;
        /**
         * Automatically reorder rows after a drop happened. If set to false, the developer needs to change the inner view model.
         * Defaults to true.
         */
        automaticallyReorderRows?: boolean;
        /**
         * Callback when a row gets reordered.
         *
         * @param evt Event used for the row reordering.
         * @param args Reordered row object.
         */
        rowReorder?: (evt: JQueryEventObject, args: ReorderRowEventObject<TItem>) => void;
    }
    interface ReorderRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ReorderRow grid extension.
         */
        reorderRow?: ReorderRowOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ReorderRow grid extension.
         */
        reorderRow?: ReorderRowOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ResizableColumn.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ResizableColumn extends Column {
        /**
         * Disables resizable for a specific column.
         */
        disableResizable?: KnockoutObservable<boolean>;
        /**
         * Column displays a resize handle.
         */
        hasHandle?: KnockoutObservable<boolean>;
    }
    interface ResizableColumnOptions<TItem> {
        "--noUnusedLocals"?: TItem;
        /**
         * Indicates if columns are resizable. Defaults to true.
         */
        resizable?: KnockoutObservable<boolean>;
        /**
         * @deprecated ResizableColumnOptions.resizeToPercent
         * This is no longer used.
         * Column widths will preserve units.
         */
        resizeToPercent?: KnockoutObservable<boolean>;
        /**
         * @deprecated ResizableColumnOptions.minWidth
         * This is no longer used.
         * The default minimum width is now provided by the portal framework to a value determined by the UX team.
         * You may override the default on an individual column instead.
         */
        minWidth?: number;
    }
    interface ResizableColumnExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ResizableColumn grid extension.
         */
        resizableColumn?: ResizableColumnOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ResizableColumn grid extension.
         */
        resizableColumn?: ResizableColumnOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.RightClickableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface RightClickableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Commands used for control composition purposes.
         */
        controlCommands: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Command.ViewModel[]>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Commands used for control composition purposes.
         */
        controlCommands?: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Command.ViewModel[]>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Scrollable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ScrollableOptions<TItem> {
        /**
         * Specifies the data source which supports random data access.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (%/fr) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * For backwards compatibility vertical scrolling is enabled by default when:
         *   scrollable options are provided
         *   or the scrollable plugin is explicitly specified
         * For backwards compatibility vertical scrolling is disabled by default when:
         *   scrollable options are not provided
         *   and the scrollable plugin is not explicitly specified.
         * If you do not want the default behavior set this option explicitly.
         */
        vertical?: boolean;
    }
    interface ScrollableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the scrollable plugin.
         */
        scrollable?: ScrollableOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the scrollable plugin.
         */
        scrollable?: ScrollableOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.SelectableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    const enum RowSelectionMode {
        /**
         * Indicates that the user cannot select or unselect rows by clicking.
         */
        Off = 0,
        /**
         * Indicates that the user can select one row at at time by clicking.
         */
        Single = 1,
        /**
         * Indicates that the user can select and unselect multiple rows at at time by clicking and control-clicking.
         */
        Multiple = 2,
        /**
         * Indicates that the user can toggle selection on multiple rows
         */
        MultipleToggle = 3
    }
    /**
     * Link data for browser navigation.
     */
    interface Link {
        /**
         * The uri to open when the link is activated.
         */
        uri: string;
        /**
         * The target to use them the link is activated.
         */
        target?: string;
    }
    interface SelectableRowMetadata<T> extends FocusableRowMetadata<T> {
        /**
         * Indicates if the row is selected.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * Indicates the columnKey if the row is activated. null if deactivated.
         */
        activated?: KnockoutObservableBase<string>;
        /**
         * Additional information for this Activated cell.
         */
        activatedInfo?: KnockoutObservableBase<string>;
        /**
         * Link that is invoked when row is clicked or space bar is pressed instead of blade activation.
         */
        link?: KnockoutObservableBase<Link>;
        /**
         * This can be set to 'false' to suppress the default activation behavior (which is to open a child Blade) for the associated row.
         * This should be used in tandem with the 'SelectableRowExtensionOptions.onRowClicked' callback
         * to supply activation behavior (often, in-place activation) that is custom to the extension.
         */
        useDefaultActivation?: KnockoutObservableBase<boolean>;
    }
    interface SelectableRowEventObject<T> {
        /**
         * Selected row.
         */
        selected?: SelectableRowMetadata<T>;
        /**
         * Unselected row.
         */
        unselected?: SelectableRowMetadata<T>[];
    }
    /**
     * Options for the SelectableRow grid extension.
     */
    interface SelectableRowOptions<TItem, TSelection> {
        /**
         * Specifies what type of selectability is allowed for rows.
         */
        selectionMode?: RowSelectionMode;
        /**
         * Disables selecting all rows at once by the header checkbox
         * and ctrl+a when in multiselect selection mode.
         */
        disableSelectAll?: boolean;
        /**
         * A function that determines if an item matches a selection.
         *
         * @param item The grid row item to be matched.
         * @param selection The selection to match the item to.
         * @return True if the item matches the selection; else false.
         */
        itemMatchesSelection?: (item: TItem, selection: TSelection) => boolean;
        /**
         * A factory function that creates a selection based on an item.
         *
         * @param item The grid row item for which selection needs to be created.
         * @return The selection for the specified item.
         */
        createSelection?: (item: TItem) => TSelection;
        /**
         * Selection state that has been previously saved as part of view state for this grid.
         */
        initialSelection?: MsPortalFx.ViewModels.SetSelection<TSelection>;
        /**
         * Currently Activated Column Key.
         */
        activatedColumnKey?: KnockoutObservableBase<string>;
        /**
         * Primary Activate Column Key.  This is to support double click, context menu and activateOnSelected.
         */
        primaryActivateColumnKey?: KnockoutObservableBase<string>;
        /**
         * Indicates that the row should activate when selected.
         */
        activateOnSelected?: KnockoutObservableBase<boolean>;
        /**
         * Callback when a row gets selected.
         *
         * @param evt Event used for the row selection.
         * @param args Selected and unselected objects.
         */
        rowSelect?: (evt: JQueryEventObject, args: SelectableRowEventObject<TItem>) => void;
        /**
         * Disable require Ctrl or Shift Key for Single Mode mode to toggle selection on Click.
         */
        disableRequireSingleModeAssistKey?: KnockoutObservable<boolean>;
        /**
         * Enable selectable cursor to move to next or previous selected item.
         */
        enableSelectableCursor?: KnockoutObservableBase<boolean>;
        /**
         * Method that may designate links for row items.
         * When a link is returned the link will be opened when clicking on the row instead of blade activation.
         */
        linkProvider?: (litetime: MsPortalFx.Base.LifetimeManager, item: TItem) => KnockoutObservableBase<Link>;
        /**
         * If provided, this method returns the context menu items to be displayed for the selected item.
         */
        supplyCommands?: (dataItem: TItem) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        /**
         * If set this will leave activated & selected items in a selected state after they are deactivated.
         * This defaults to true for single select mode & false for multiselect modes.
         */
        leaveSelectionOnDeactivation?: boolean;
    }
    interface SelectableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the SelectableRow grid extension. If null, rows will not be selectable.
         */
        selectableRow?: SelectableRowOptions<TItem, TSelection>;
        /**
         * Add custom click handler for grid row.
         */
        onRowClicked?: (item: TItem) => void;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the SelectableRow grid extension. If null, rows will not be selectable.
         */
        selectableRow?: SelectableRowOptions<TItem, TSelection>;
        /**
         * Add custom click handler for grid row.
         */
        onRowClicked?: (item: TItem) => void;
    }
    interface SelectableContract<TItem, TSelection> extends Contract<TItem, TSelection> {
        /**
         * Items displayed in the table based on the column definitions when selection is enabled.
         * It is set in the constructor. Do not directly replace it.
         */
        selectableData: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.SortableColumn.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    const enum SortOrder {
        /**
         * Column is unsorted.
         */
        Unsorted = 0,
        /**
         * Column is sorted ascending.
         */
        Ascending = 1,
        /**
         * Column is sorted descending.
         */
        Descending = 2
    }
    interface SortBy {
        /**
         * The item key to sort by.
         */
        itemKey: string;
        /**
         * The direction of the sort either ascending or descending.
         */
        sortOrder: SortOrder;
    }
    interface Column {
        /**
         * Indicates if the column is sortable.
         */
        sortable?: boolean;
        /**
         * Sort order.
         */
        sortOrder?: KnockoutObservable<SortOrder>;
    }
    interface SortableColumnOptions<TItem> {
        /**
         * The sort callback.
         */
        sortCallback?: (sortByList: SortBy[]) => void;
        /**
         * Specifies the data source.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
    }
    interface SortableColumnExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the sortable plugin.
         */
        sortableColumn?: SortableColumnOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the sortable plugin.
         */
        sortableColumn?: SortableColumnOptions<TItem>;
    }
}
declare module FxImpl.ViewModels.Controls.Lists.Grid {
    /**
     * Internal grid interface.
     */
    interface Actions {
        /**
         * Internal grid action.
         */
        sort?(sortByList: MsPortalFx.ViewModels.Controls.Lists.Grid.SortBy[]): MsPortalFx.Base.Promise;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\List1\Gallery.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Gallery {
    interface Contract extends ListView.Contract {
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Lists.Gallery is deprecated.  Please use "Fx/Controls/ListView" in gallery mode instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    class ViewModel extends ListView.ViewModel implements Contract {
        /**
         * Constructs a Gallery view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param extensions Bitmask of extension plugins to be loaded.
         * @param extensionOptions The extension options for the plugins.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, extensions?: number, extensionOptions?: ListView.ExtensionOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\List1\ListView.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.ListView {
    /**
     * The plugin identifiers for the listview.
     */
    enum Extensions {
        /**
         * Plugin to have item selection.
         */
        Selectable = 1,
        /**
         * Plugin to have grouped items.
         */
        Groupable = 2,
        /**
         * Plugin to have context menu items.
         */
        ContextMenu = 4,
        /**
         * Plugin to filter items.
         */
        Filterable = 8
    }
    /**
     * The group order for grouping items in the listview.
     */
    enum GroupOrder {
        /**
         * Display groups in collection order.
         */
        Collection = 0,
        /**
         * Display groups in ascending order.
         */
        Ascending = 1,
        /**
         * Display groups in descending order.
         */
        Descending = 2
    }
    /**
     * The selection mode for selecting items in the listview.
     */
    enum SelectionMode {
        /**
         * Indicates that the user can select one item at at time by clicking.
         */
        Single = 0,
        /**
         * Indicates that the user can select and unselect multiple items at at time by clicking and control-clicking.
         */
        Multiple = 1
    }
    /**
     * A metadata entry corresponding to a single item in the list.
     */
    interface ItemMetadata {
        /**
         * Indicates if the item is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is focused.
         */
        focused?: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is selected.
         */
        selected?: KnockoutObservableBase<boolean>;
        /**
         * The ID of the group, typically mapping to a unique value in the item being grouped by.
         */
        groupId?: KnockoutObservableBase<any>;
    }
    type ListViewItem = Item | string;
    interface Item {
        /**
         * Css class specific to this item.
         */
        cssClass?: KnockoutObservableBase<string>;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Metadata information about this item.
         */
        metadata?: ItemMetadata;
        /**
         * Specifies the item's custom properties
         */
        [prop: string]: any;
    }
    interface SelectableEventObject {
        /**
         * Selected items.
         */
        selected: ListViewItem[];
        /**
         * Unselected items.
         */
        unselected: ListViewItem[];
    }
    interface GroupableOptions {
        /**
         * The item field/column in the data set that the groups map to/are created from.
         */
        groupKey: KnockoutObservable<string>;
        /**
         * The template to apply to each group headers.
         */
        headerTemplate?: string;
        /**
         * An observable array of Group objects, to be rendered in indexed order.
         * If this array is not provided, it is inferred from the column values mapped to groupKey.
         */
        groups?: KnockoutObservableArray<Group>;
        /**
         * The group name shown for all items that don't have a groupId set.
         */
        noGroupLabel?: string;
        /**
         * Optional alternate text for screen reader
         */
        noGroupAriaLabel?: string;
        /**
         * Order to display groups in (Collection, Ascending, or Descending).
         */
        order?: KnockoutObservableBase<GroupOrder>;
    }
    interface SelectableOptions {
        /**
         * Indicates selection mode or single or multiple selection (default Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Gets or sets the selected item for single selection backward compatibility.
         */
        selectedItem?: KnockoutObservable<ListViewItem>;
        /**
         * Gets or sets the selected items.
         */
        selection?: MsPortalFx.ViewModels.SelectableSet<ListViewItem, any>;
        /**
         * Indicates that the item should activate when selected (default true).
         */
        activateOnSelected?: boolean;
    }
    interface FilterableOptions {
        /**
         * Observable text to filter items with.
         */
        filterText: KnockoutObservableBase<string>;
        /**
         * Property to filter items on.
         */
        filterKey: KnockoutObservableBase<string>;
    }
    interface ExtensionOptions {
        /**
         * The accessibility label for the list.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Grouping options.
         */
        groupable?: GroupableOptions;
        /**
         * Selection options.
         */
        selectable?: SelectableOptions;
        /**
         * Filtering options.
         */
        filterable?: FilterableOptions;
    }
    interface Group {
        /**
         * The unique value corresponding to the group.
         */
        value: any;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    interface Contract extends Loadable.Contract {
        /**
         * The accessibility label for the list.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Items displayed in the list.
         */
        items: KnockoutObservableArray<ListViewItem>;
        /**
         * Important events which the viewModel might want to react.
         */
        events: (type: string, args?: any) => void;
        /**
         * Template used on each item.
         */
        itemTemplate: string;
        /**
         * Message displayed when list is empty.
         */
        noItemsMessage: KnockoutObservableBase<string>;
        /**
         * The bitmask of plugins to be loaded.
         * Use '|' or '+' to specify multiple extensions.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions?: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
        /**
         * indicates whether the list item should have an outline style when it's focused/hovered/selected, it's true by default
         */
        outlineStyle: KnockoutObservableBase<boolean>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Lists.ListView is deprecated. Please use "Fx/Controls/ListView" instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Items displayed in the list.
         */
        items: KnockoutObservableArray<ListViewItem>;
        /**
         * Important events which the viewModel might want to react.
         */
        events: (type: string, args?: any) => void;
        /**
         * The template used on each item.
         */
        itemTemplate: string;
        /**
         * Message displayed when list is empty.
         */
        noItemsMessage: KnockoutObservableBase<string>;
        /**
         * The bitmask of plugins to be loaded.
         * Use '|' or '+' to specify multiple extensions.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
        /**
         * indicates whether the list item should have an outline style when it's focused/hovered/selected, it's true by default
         */
        readonly outlineStyle: KnockoutObservableBase<boolean>;
        /**
         * The accessibility label for the list.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a ListView view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param extensions Bitmask of extension plugins to be loaded.
         * @param extensionOptions The extension options for the plugins.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, extensions?: number, extensionOptions?: ExtensionOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Tree1\TreeView.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.TreeView {
    /**
     * A query result interface from load by continuation token.
     */
    interface TreeContinuationTokenQueryResult<TItem> {
        /**
         * newly fetched items.
         */
        items: TItem[];
        /**
         * the continuation token that are used to request next chunk of data.
         */
        continuationToken: any;
    }
    /**
     * A metadata entry correspendong to a single item in the tree.
     */
    interface ItemMetadata {
        /**
         * Gets or sets whether the item is expanded or not (effective if the item has child items).
         */
        expanded?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is disabled.
         */
        disabled?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is focused.
         */
        focused?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is selected.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is selectable. Observably changing this value will not change selected state of the item.
         */
        selectable?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is on-demand loadable.
         */
        loadable?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is loadable by a continuation token.
         */
        loadableByContinuationToken?: KnockoutObservable<boolean>;
    }
    /**
     * Html template for an item.
     */
    interface ItemTemplate {
        /**
         * Key of this template.
         */
        key: string;
        /**
         * Html template to be used by items.
         */
        html: string;
    }
    const enum Extensions {
        /**
         * Plugin to have selectable items.
         */
        Selectable = 1,
        /**
         * Plugin to have on-demand loadable items.
         */
        OnDemandLoadable = 2,
        /**
         * Plugin to have right clickable items.
         */
        RightClickable = 4,
        /**
         * Plugin to have load by continuation token items.
         */
        LoadableByContinuationToken = 8
    }
    interface LoadableByContinuationTokenOptions<TItem extends Item> {
        /**
         * Callback for when the user clicks "load more" as a child of the item.
         *
         * @param item the item that is getting more children.
         * @param continuationToken the continuation token supplied by previous calls for this item.
         *
         * @return a promise for the newly loaded children and a continuation token for the next call.
         */
        loadMoreNode?(item: TItem, continuationToken: any): MsPortalFx.Base.PromiseV<TreeContinuationTokenQueryResult<TItem>>;
        /**
         * Callback for when the user clicks "load more" at the root of the tree.
         * Note: The tree will show a "load more" item at the root as long as canLoadMoreRootItems is set to true.
         * If there are no more items to fetch after this call, set canLoadMoreRootItems to false.
         * Extension authors are responsible for keeping track of what items to load next.
         *
         * @return a promise for the items to load into the tree.
         */
        loadMoreRootItems?(): Q.Promise<TItem[]>;
    }
    /**
     * Selection modes supported by the tree view control
     */
    const enum SelectionMode {
        /**
         * Single selection
         */
        Single = 0,
        /**
         * multiple selection
         */
        Multiple = 1
    }
    /**
     * Options for the Selectable treeView extension.
     */
    interface SelectableOptions<TItem extends Item, TSelection> {
        /**
         * A factory function that creates a selection based on an item.
         */
        createSelection(item: TItem, path: string): TSelection;
        /**
         * Initial selection state for single select trees.  Ignored by multiselect trees.
         */
        initialPath?: string;
        /**
         * Selection mode of the tree.  Defaults to single selection
         */
        selectionMode?: SelectionMode;
        /**
         * If provided, this method returns the context menu items to be displayed for the selected item.
         */
        supplyCommands?: (dataItem: TItem) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        /**
         * Add custom click handler for tree item.
         */
        onItemClicked?: (item: TItem) => void;
    }
    /**
     * Defines the contract about selectable properties.
     */
    interface SelectableData<TSelection> {
        /**
         * Specifies the currently selected item.  Not used in multiselect mode.  In multiselect mode use the selectedItems property instead.
         */
        selectedItem: KnockoutObservable<TSelection>;
        /**
         * Specifies the path of the currently selected item.
         * This property is meant to be set only by base widget.
         */
        selectedPath: KnockoutObservable<string>;
        /**
         * Selection mode of the tree.  Defaults to single selection
         */
        selectionMode: SelectionMode;
        /**
         * Selected items of the tree.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TSelection>;
        /**
         * Paths to the selected items.
         */
        readonly selectedPaths: KnockoutObservableArray<string>;
    }
    /**
     * Options for the On-Demand Loadable treeView extension.
     */
    interface OnDemandLoadableOptions<TItem extends Item> {
        /**
         * A factory function that notifies a load is required
         */
        loadItem?(item: TItem, path: string): void;
    }
    /**
     * Defines the contract about on-demand loadable properties.
     */
    interface OnDemandLoadableData {
        /**
         * Gets the path of the item which is being loaded.
         * This property is meant to be set only by base widget.
         */
        loadingPath: KnockoutObservable<string>;
    }
    interface ExtensionsOptions<TItem extends Item, TSelection> {
        /**
         * Options for the Selectable treeView extension.  If null, items will not be selectable.
         */
        selectable?: SelectableOptions<TItem, TSelection>;
        /**
         * Options for the On-Demand Loadable treeView extension.  If null, items will not be on-demand loadable
         * and all the hierarchy needs to be loaded up-front.
         */
        onDemandLoadable?: OnDemandLoadableOptions<TItem>;
        /**
         * Options for the Loadable by continuation token treeView extension. If null, items will not be loadable by continuation token.
         */
        loadableByContinuationToken?: LoadableByContinuationTokenOptions<TItem>;
    }
    /**
     * A node of the tree.
     */
    interface Item {
        /**
         * Text of the item.
         */
        text: KnockoutObservable<string>;
        /**
         * Child items of this item.
         */
        items?: KnockoutObservableArray<Item>;
        /**
         * Icon specified to the item to be displayed with text.
         */
        icon?: KnockoutObservable<string | MsPortalFx.Base.Image>;
        /**
         * Css class specific to this item.
         */
        cssClass?: KnockoutObservable<string>;
        /**
         * Metadata information about this item.
         */
        metadata?: ItemMetadata;
        /**
         * Key of the template for this item.
         */
        templateKey?: KnockoutObservable<string>;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservable<string>;
        /**
         * if set, suppresses context menu commands and hides the context menu icon for this item.
         */
        noContextMenu?: KnockoutObservable<boolean>;
        /**
         * Old pattern for determining if this item has context menu commands.  Maps to a command group pointing to commands defined in pdl.
         */
        commandGroup?: string;
    }
    /**
     * Callback set and used by the framework to expand and collapse nodes.
     */
    interface ToggleNodeCallback {
        (item: Item, expandState: boolean): void;
    }
    /**
     * Internal implementation details.  do not use.
     */
    interface InternalTreeContract<TItem> {
        SupplyCommands: (dataItem: TItem) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        CurrentCommands: KnockoutObservableArray<MsPortalFx.ViewModels.Toolbars.ToolbarItemContract>;
        OnItemClicked: (dataItem: TItem) => void;
    }
    interface Contract<TItem extends Item, TSelection> extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * Items displayed in the tree.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * Amount of child item padding in px.
         */
        padding: KnockoutObservable<number>;
        /**
         * Separator used to build the path of an item.
         */
        pathSeparator: string;
        /**
         * Indicates whether all the items in tree are visible and expand/collapse icons are invisible.
         */
        alwaysExpanded: KnockoutObservable<boolean>;
        /**
         * A list of html templates to be used by the items.
         */
        htmlTemplates: ItemTemplate[];
        /**
         * The bitmask of plugins to be loaded.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions?: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions?: ExtensionsOptions<TItem, TSelection>;
        /**
         * Expands a treeview item.
         *
         * @param item The treeview item to expand
         */
        expandNode(item: Item): void;
        /**
         * Collapses a treeview item.
         *
         * @param item The treeview item to collapses
         */
        collapseNode(item: Item): void;
        /**
         * Toggles the expanded state of a treeview item.
         *
         * @param item The treeview item to collapses
         * @param expanded Optional. The desired expanded state of the treeview item.
         */
        toggleNode(item: Item, expanded?: boolean): void;
        /**
         * Load more nodes by continuation token.
         *
         * @param item The treeview item to be appended (parentNode)
         * @return new continuationToken or null (no data to be fetched)
         */
        loadMoreNode(item: TItem, continuationToken: any): MsPortalFx.Base.PromiseV<TreeContinuationTokenQueryResult<TItem>>;
        /**
         * Requests more items be loaded into the tree at the root level.
         */
        loadMoreRootItems(): Q.Promise<void>;
        /**
         * Sync stored tokens between widget side and viewmodel side.
         * For internal use only.
         *
         * @param path the key of the token which is a node's path in the tree
         * @param continuationToken the unique token value
         */
        syncToken(path: string, continuationToken: any): void;
        /**
         * Callback set and used by the framework to expand and collapse nodes.  Do not modify or set this property.
         */
        toggleNodeCallback: KnockoutObservableBase<ToggleNodeCallback>;
        /**
         * Determines whether or not to show the "load more" button at the root of the tree.
         */
        readonly canLoadMoreRootItems: KnockoutObservable<boolean>;
        /**
         * Text label to be read out loud by screen readers for the tree root.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    class ViewModel<TItem extends Item, TSelection> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract<TItem, TSelection> {
        items: KnockoutObservableArray<TItem>;
        padding: KnockoutObservable<number>;
        pathSeparator: string;
        alwaysExpanded: KnockoutObservable<boolean>;
        /**
         * A list of html templates to be used by the items.
         */
        htmlTemplates: ItemTemplate[];
        extensions: number;
        extensionsOptions: ExtensionsOptions<TItem, TSelection>;
        /**
         * A bridge between the widget and extension viewmodel to reflect control selection changes.
         */
        selectableData: SelectableData<TSelection>;
        /**
         * A bridge between the widget and extension viewmodel to notify items being loaded on-demand.
         */
        onDemandLoadableData: OnDemandLoadableData;
        private _tokenStorage;
        /**
         * Callback set and used by the framework to expand and collapse nodes.  Do not modify or set this property.
         */
        toggleNodeCallback: KnockoutObservableBase<ToggleNodeCallback>;
        /**
         * Determines whether or not to show the "load more" button at the root of the tree.
         */
        readonly canLoadMoreRootItems: KnockoutObservable<boolean>;
        /**
         * Text label to be read out loud by screen readers for the tree root.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Creates a treeview.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items Items for the view model.
         * @param extensions Extensions for the view model.
         * @param extensionsOptions Extension options for the view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableArray<TItem>, extensions?: number, extensionsOptions?: ExtensionsOptions<TItem, TSelection>);
        loadMoreNode(item: TItem, continuationToken: any): MsPortalFx.Base.PromiseV<TreeContinuationTokenQueryResult<TItem>>;
        /**
         * Requests more items be loaded into the tree at the root level.
         */
        loadMoreRootItems(): Q.Promise<void>;
        syncToken(path: string, continuationToken: any): void;
        getTokenByPath(path: string): any;
        /**
         * Expands a treeview item.
         *
         * @param item The treeview item to expand
         */
        expandNode(item: Item): void;
        /**
         * Collapses a treeview item.
         *
         * @param item The treeview item to collapse
         */
        collapseNode(item: Item): void;
        /**
         * Collapses a treeview item.
         *
         * @param item The treeview item to collapse
         */
        toggleNode(item: Item, expanded?: boolean): void;
        /**
         *  Finds an item in the tree items collection
         *
         * @param path The path of the item
         *
         * @returns the item with the corresponding path.  Returns null if the item is not found.
         */
        findItemByPath(path: string): TItem;
        private get _selectableExists();
        private get _loadableExists();
        private _processCallBack;
        private _processItems;
        private _processItem;
        private _setupSelectable;
        private _setupOnDemandLoadable;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\PartPinner.d.ts
declare module MsPortalFx.ViewModels.Controls.PartPinner {
    import FxBase = MsPortalFx.Base;
    import FxComposition = MsPortalFx.Composition;
    interface Options<TParameters> {
        "--noUnusedLocals"?: TParameters | any;
        /**
         * Gets the part reference to be pinned.
         */
        supplyPartReference<TParameters>(): FxComposition.PartReference<TParameters> | FxComposition.PartReference<TParameters>[];
        /**
         * The display text of the part pin.
         */
        text?: KnockoutObservableBase<string>;
        /**
         * The icon of the part pin.
         */
        icon?: KnockoutObservableBase<FxBase.Image>;
        /**
         * Gets or sets if the control is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    class ViewModel<TParameters> extends Base.ViewModel {
        options: Options<TParameters>;
        /**
         * Constructs an PartPinner view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options The set of options to configure the PartPinner control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: Options<TParameters>);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\PreviewTag.d.ts
declare module MsPortalFx.ViewModels.Controls.PreviewTag {
    /**
     * MsPortalFx.ViewModels.Controls.PreviewTag is no longer supported. Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.PreviewTag is no longer supported. Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\SearchBox.d.ts
declare module MsPortalFx.ViewModels.Controls.SearchBox {
    /**
     * The update callback interface.
     */
    interface UpdateHandler {
        (value: string): MsPortalFx.Base.PromiseV<string[]>;
    }
    /**
     * The submit callback interface.
     * @param value user selected value.
     * @param typedValue value user typed into textbox (may be different if user clicked on dropdown) for telemetry.
     */
    interface SubmitHandler {
        (value: string, typedValue: string): MsPortalFx.Base.PromiseV<boolean>;
    }
    /**
     * This control is no longer supported. Use Fx/Controls/SearchBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/SearchBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Settings.d.ts
declare module MsPortalFx.ViewModels.Controls.Settings {
    /**
     * MsPortalFx.ViewModels.Controls.Settings has been deprecated.
     */
    const Size: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Settings has been deprecated.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Settings has been deprecated.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\SimpleButton.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.SimpleButton {
    export import Image = MsPortalFx.Base.Image;
    /**
     * Icon used for buttons
     */
    interface IconAndPosition {
        /**
         * The image to use as an icon.
         */
        image: Image;
        /**
         * The position of the icon in the button.
         */
        position: IconPosition;
    }
    const enum IconPosition {
        Left = 0,
        Right = 1
    }
    /**
     * This control is no longer supported. Use Fx/Controls/Button instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/Button instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\SingleSetting.d.ts
declare module MsPortalFx.ViewModels.Controls.SingleSetting {
    /**
     * MsPortalFx.ViewModels.Controls.SingleSetting has been deprecated.
     */
    type Option = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.SingleSetting has been deprecated.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.SingleSetting has been deprecated.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\SpecComparisonTable.d.ts
declare module MsPortalFx.ViewModels.Controls.SpecComparisonTable {
    interface Options {
        /**
         * Table headers.
         */
        headers?: KnockoutObservableArray<Header>;
        /**
         * Table rows.
         */
        rows?: KnockoutObservableArray<Row>;
    }
    /**
     * Header background colors
     */
    enum Colors {
        Orange = 0,
        DarkOrchid = 1,
        YellowGreen = 2,
        MediumBlue = 3
    }
    /**
     * Table header
     */
    interface Header {
        /**
         * Text displayed as a colum header
         */
        title: string;
        /**
         * Header cell background color.
         */
        color: Colors;
    }
    /**
     * Table row
     */
    interface Row {
        /**
         * Row label
         */
        label: string;
        /**
         * Row values for each column.
         */
        values: string[];
    }
    class ViewModel extends Base.ViewModel {
        /**
         * Table headers.
         */
        headers: KnockoutObservableArray<Header>;
        /**
         * Table rows.
         */
        rows: KnockoutObservableArray<Row>;
        /**
         * Constructs a spec comparison table view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MsPortalFx.ViewModels.Controls.SpecComparisonTable.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\TextBlock.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.TextBlock {
    /**
     * This control is no longer supported. Use Fx/Controls/TextBlock instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/TextBlock instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ValidatableControl.d.ts
declare module MsPortalFx.ViewModels.Controls.ValidatableControl {
    let DefaultDelayValidationTimeout: number;
    interface Contract<TValue> extends EditableControl.Contract<TValue>, MsPortalFx.ViewModels.Controls.Validators.Validatable<TValue> {
    }
    class ViewModel<TValue> extends EditableControl.ViewModel<TValue> implements Contract<TValue> {
        /**
         * Indicates if validation should be skipped or not.
         */
        enableValidation: KnockoutObservable<boolean>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Indicates the current validation state. The validation state is useful when there are async validators and
         * validation completion should be notified.
         */
        validationState: KnockoutObservable<MsPortalFx.ViewModels.Controls.Validators.ValidationState>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Validators to apply to the value when validating.
         */
        validators: KnockoutObservableArray<MsPortalFx.ViewModels.Controls.Validators.Validator<TValue>>;
        /**
         * List of current validation results.
         */
        validationResults: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * Creates a validatable control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Validators.d.ts
declare module MsPortalFx.ViewModels.Controls.Validators {
    const escapeRegExpOperators: typeof regexEscape;
    /**
     * ValidationState represents the current validation state when list of validators are run.
     */
    const enum ValidationState {
        /**
         * Default validation state.
         */
        None = 0,
        /**
         * Validation failed.
         */
        Invalid = 1,
        /**
         * Validation succeeded.
         */
        Valid = 2,
        /**
         * Validation pending during async validation calls.
         */
        Pending = 3
    }
    interface Validatable<TValue> {
        /**
         * Indicates if validation should be skipped or not.
         */
        enableValidation: KnockoutObservable<boolean>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Indicates the current validation state. The validation state is useful when there are async validators and
         * validation completion should be notified.
         */
        validationState: KnockoutObservable<ValidationState>;
        /**
         * Validators to apply to the value when validating.
         */
        validators: KnockoutObservableArray<Validator<TValue>>;
        /**
         * List of current validation results.
         */
        validationResults?: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
    }
    interface ValidationPlacement<TValue> {
        /**
         * Initializes the ValidationPlacement.
         *
         * @param element The widget element.
         * @param validatable Interface containing validation specific validators and valid flag.
         */
        initialize(element: JQuery, validatable: Validatable<TValue>): void;
        /**
         * Destroys the artifacts related to the validation placement.
         */
        dispose(): void;
        /**
         * Dispose() has been called.
         */
        isDestroyed(): boolean;
        /**
         * Triggers when the errorMessages ViewModel property changes.
         *
         * @param newValue Array of validation error messages.
         */
        onErrorMessageChanged(newValue: string): void;
        /**
         * Triggers when the validationState ViewModel property changes.
         *
         * @param newValue Current ValidationState value.
         */
        onValidationStateChanged(newValue: ValidationState): void;
    }
    /**
     * Validator base class. Used to define validators that can be attached to an
     * validatable control view model to validate the value.
     */
    class Validator<TValue> {
        private readonly _ltm;
        /**
         * Validation rule error message.
         */
        message: KnockoutObservable<string>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * Indicates if the current validation state.
         */
        validationState: KnockoutObservable<ValidationState>;
        /**
         * Evaluates if the value is valid (works cross IFRAME).
         */
        validate: KnockoutObservable<TValue>;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid: KnockoutObservable<boolean>;
        /**
         * Constructs a validator.
         *
         * @param message Describes the validation rule.
         */
        constructor(message?: string);
        /**
         * Releases resources held by the validator.
         */
        dispose(): void;
        /**
         * Determines if the value is valid.
         * Should be overridden in derived classes.
         *
         * @param value The value to check.
         * @return Indicates the current validation state.
         */
        _validate(value: TValue): ValidationState;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ValueUpdateTrigger.d.ts
declare module MsPortalFx.ViewModels.Controls {
    /**
     * Enum to indicate when to trigger value updates.
     */
    const enum ValueUpdateTrigger {
        /**
         * Maps to one of the other value update trigger values. Which one is up to the controls code to decide.
         */
        Default = 0,
        /**
         * Trigger value update on blur.
         */
        Blur = 3,
        /**
         * Trigger value update on input Event (IE 9+) .
         */
        Input = 4
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.BaseHotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    /**
     * View model for Base hotspots.
     */
    class BaseViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel {
        /**
         * Hotspot disabled state.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.BaseInfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    import Base = MsPortalFx.Base;
    /**
     * The size options for info box
     */
    const enum Size {
        Small = 0,
        Normal = 1
    }
    /**
     * The base view model for info box.
     */
    class BaseViewModel extends Loadable.ViewModel {
        /**
         * The image to display in the control.
         */
        image: KnockoutObservableBase<Base.Image>;
        /**
         * The text or html to display in the control.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Size of the infobox
         */
        size: KnockoutObservableBase<Size>;
        /**
         * Constructs and instance of a view model.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options view model properties.
         */
        constructor(lifetimeManager: Base.LifetimeManager, options?: BaseInfoBoxOptions);
    }
    /**
     * The view model options for info box.
     */
    interface BaseInfoBoxOptions {
        /**
         * The image to display in the control.
         */
        image: KnockoutObservableBase<Base.Image>;
        /**
         * The text or html to display in the control.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Size of the infobox
         */
        size?: KnockoutObservableBase<Size>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.DeleteAssetConfirmation.d.ts
declare module MsPortalFx.ViewModels.Controls.DeleteAssetConfirmation {
    /**
     * The options of the grid.
     */
    interface GridOptions<TItem, TSelection> {
        /**
         * The items of the grid.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * The columns of the grid.
         */
        columns: KnockoutObservableArray<MsPortalFx.ViewModels.Controls.Lists.Grid.Column>;
        /**
         * The message displayed when the grid has no data.
         */
        noRowsMessage: KnockoutObservable<string>;
        /**
         * Shows the header of the grid.
         */
        showHeader?: boolean;
        /**
         * The options of the selectable row extensions.
         */
        selectableRowExtensionOptions?: MsPortalFx.ViewModels.Controls.Lists.Grid.SelectableRowExtensionOptions<TItem, TSelection>;
    }
    /**
     * The options of the view model.
     */
    interface Options<TItem, TSelection> {
        /**
         * The display name of the asset type. It will be overwritten if it is also provided via input binding.
         */
        assetTypeDisplayName: string;
        /**
         * The options of the grid.
         */
        grid?: GridOptions<TItem, TSelection>;
    }
    /**
     * View model for the DeleteAssetConfirmation control.
     */
    class ViewModel<TItem, TSelection> extends Loadable.ViewModel {
        /**
         * Gets if it is valid.
         */
        valid: KnockoutComputed<boolean>;
        selectedItems: KnockoutObservableArray<TSelection>;
        /**
         * Gets or sets the grid items.
         */
        _gridItems: KnockoutObservableArray<TItem>;
        /**
         * Gets the options of the view model.
         */
        _options: Options<TItem, TSelection>;
        /**
         * Gets the asset name.
         */
        _assetName: KnockoutObservable<string>;
        /**
         * Gets the display name of the asset type.
         */
        _assetTypeDisplayName: KnockoutObservable<string>;
        private grid;
        private confirmationEditor;
        private warning;
        private confirmationLabel;
        protected affectedItemsLabel: KnockoutObservable<string>;
        /**
         * Instantiates a view model.
         *
         * @param options The view model options.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: Options<TItem, TSelection>);
        /**
         * Updates the warning text.
         * Subclass can provide its own warning text by overriding this method.
         *
         * @param assetName The asset name.
         * @return the warning text.
         */
        _onUpdateWarningText(assetName: string): string;
        /**
         * Updates the confirmation label.
         * Subclass can provide its own confirmation label by overriding this method.
         *
         * @param assetTypeDisplayName The display name of the asset type.
         * @return the confirmation label.
         */
        _onUpdateConfirmationLabel(assetTypeDisplayName: string): string;
        /**
         * Selects all the items in the grid.
         */
        _selectAll(): void;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.HeroBanner.d.ts
declare module MsPortalFx.ViewModels.Controls.HeroBanner {
    /**
     * MsPortalFx.ViewModels.Controls.HeroBanner is not longer supported. You would need to build this experience using custom HTML if needed.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.Hotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    import BaseViewModel = MsPortalFx.ViewModels.Controls.HotSpot.BaseViewModel;
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.HotSpot.ViewModel is deprecated. Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * View model for hotspots
     */
    class ViewModel extends BaseViewModel implements SelectableSource {
        /**
         * Selectable that tracks if hotspot selection state
         */
        selectable: Selectable<any>;
        /**
         * If the hotspot should be clickable during Customize mode
         */
        clickableDuringCustomize: boolean;
        /**
         * @deprecated MsPortalFx.ViewModels.Controls.HotSpot.ViewModel is deprecated. Use fxclick directly in your HTML template instead.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.InfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.InfoBox.ViewModel is deprecated. Use the Fx/Controls/Infobox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends InfoBox.BaseViewModel {
        /**
         * The selectable used in launching another blade.
         */
        selectable: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * Constructs and instance of a view model.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, initialState: any, loading?: boolean, options?: BaseInfoBoxOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.LinkHotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    /**
     * View model for Clickable hotspots
     */
    class LinkViewModel extends MsPortalFx.ViewModels.Controls.HotSpot.BaseViewModel {
        /**
         * Link that can be launched from the hotspot.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
        /**
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: LinkHotSpotOptions);
    }
    /**
     * View model options for hotspots.
     */
    interface LinkHotSpotOptions {
        /**
         * Link that can be launched from the hotspot.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.LinkInfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    class LinkViewModel extends InfoBox.BaseViewModel {
        /**
         * The clickableLink used to launch a link from info box.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
        /**
         * Constructs and instance of a view model.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Info box options.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: LinkInfoBoxOptions);
    }
    /**
     * The view model options for link info box.
     */
    interface LinkInfoBoxOptions extends BaseInfoBoxOptions {
        /**
         * The clickableLink used to launch a link from info box.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.Notice.d.ts
declare module MsPortalFx.ViewModels.Controls.Notice {
    /**
     * Types of images for the notice control.
     */
    const enum ImageType {
        /**
         * Default image.
         */
        Default = 0,
        /**
         * Image for coming soon.
         */
        ComingSoon = 1,
        /**
         * Image for no subscription.
         */
        NoSubscription = 2,
        /**
         * Image for unauthorized.
         */
        Unauthorized = 3
    }
    /**
     * Contract for the notice control.
     */
    class ViewModel extends Loadable.ViewModel {
        header: KnockoutObservableBase<string>;
        title: KnockoutObservableBase<string>;
        description: KnockoutObservableBase<string>;
        callToActionText: KnockoutObservableBase<string>;
        callToActionUri: KnockoutObservableBase<string>;
        callToSecondaryActionText: KnockoutObservableBase<string>;
        callToSecondaryActionUri: KnockoutObservableBase<string>;
        imageType: KnockoutObservableBase<ImageType>;
        /**
         * Creates a balloon.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.Wizard.d.ts
declare module MsPortalFx.ViewModels.Controls.Wizard {
    /**
     * @deprecated Wizard.WizardMode is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    enum WizardMode {
        /**
         * Indicates that the wizard consists of a sequence of steps.
         */
        Sequential = 0,
        /**
         * Indicates that the wizard consists of a set of steps accessible in any order.
         */
        NonSequential = 1
    }
    /**
     * @deprecated Wizard.StepType is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    enum StepType {
        /**
         * Indicates a step that contains a form.
         */
        Form = 0,
        /**
         * Indicates a step that selects a single value or entity.
         */
        Selector = 1
    }
    /**
     * @deprecated Wizard.WizardStepSelection is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface WizardStepSelection extends DynamicBladeSelection {
        /**
         * The ID that uniquely identifies the step.
         */
        stepId: string;
    }
    /**
     * @deprecated Wizard.StepState is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StepState {
        /**
         * The ID that uniquely identifies the step.
         */
        stepId: string;
        /**
         * The status of the step.
         */
        status: ActionBars.Base.Status;
    }
    /**
     * @deprecated Wizard.StepInput is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StepInput extends StepState {
        /**
         * A value indicating whether this is the first step.
         */
        isFirstStep: boolean;
        /**
         * A value indicating whether this is the last step.
         */
        isLastStep: boolean;
        /**
         * A value indicating whether the step is optional.
         */
        isOptional: boolean;
        /**
         * A value indicating whether or not the step is disabled.
         * This value specifies whether or not there are any prerequisite steps that have not been completed.
         */
        disabled: boolean;
        /**
         * True, if user can choose whether provisioning happens on blade or startboard part.
         * Else false.
         */
        allowToggleProvisioningLocation?: boolean;
        /**
         * True if the master part that opened the create blade is a provisioning part; else false.
         */
        masterIsProvisioningPart?: boolean;
    }
    /**
     * @deprecated Wizard.StepOutput is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StepOutput extends StepState {
        /**
         * The action to perform.
         */
        action: ActionBars.Base.Action;
    }
    /**
     * @deprecated Wizard.WizardState is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface WizardState {
        /**
         * The current statuses of all steps in the wizard.
         */
        stepStatuses: StepState[];
        /**
         * The ID of the currently selected step.
         */
        selectedStepId?: string;
    }
    /**
     * @deprecated Wizard.Contract is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Contract extends Loadable.Contract {
        /**
         * The mode in which the wizard is currently operating.
         */
        mode: WizardMode;
        /**
         * The observable set of steps for the Wizard.
         */
        steps: KnockoutObservableArray<WizardStep>;
        /**
         * The selection instance corresponding to the current step.
         */
        selection: KnockoutObservable<WizardStepSelection>;
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<WizardState>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<WizardState>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<StepOutput>;
        /**
         * A value used to indicate to the consumer to start executing the wizard command.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
        /**
         * Invoked when a step is complete. Optional.
         */
        complete?: () => MsPortalFx.Base.Promise;
    }
    /**
     * @deprecated Wizard.WizardStepBase is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class WizardStepBase {
        /**
         * Creates a new wizard step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param stepType The type of the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade contianing the form for the wizard step.
         * @param extension The extension that hosts the blade contianing the form for the wizard step.
         */
        constructor(stepId: string, stepType: StepType, title: string, formBlade: string, extension?: string);
        stepType: StepType;
        stepId: string;
        title: KnockoutObservable<string>;
        description: KnockoutObservable<string>;
        iconUri: KnockoutObservable<string>;
        status: KnockoutObservable<ActionBars.Base.Status>;
        isOptional: boolean;
        formBlade: string;
        extension: string;
        /**
         * Invoked just prior to a step being loaded.
         */
        stepLoad: (step: WizardStep) => MsPortalFx.Base.Promise;
        /**
         * Invoked when a step is complete.
         */
        stepComplete: (step: WizardStep) => MsPortalFx.Base.Promise;
    }
    /**
     * @deprecated Wizard.ViewModel is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Loadable.ViewModel {
        mode: WizardMode;
        steps: KnockoutObservableArray<WizardStep>;
        selection: KnockoutObservable<WizardStepSelection>;
        savedState: KnockoutObservable<WizardState>;
        currentState: KnockoutObservable<WizardState>;
        stepOutput: KnockoutObservable<StepOutput>;
        beginExecuteCommand: KnockoutObservable<boolean>;
        /**
         * Invoked when a step is complete.
         */
        complete: () => JQueryDeferred;
        private _autoOpenFirstStep;
        /**
         * Creates the view model for a wizard.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param initialState The initial state of the wizard. Properties on this object will be used to initialize properties on the view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, initialState?: any);
        /**
         * Initializes the wizard and auto-selects the first step if no initial state and not already selected.
         */
        initialize(): void;
    }
    /**
     * @deprecated Wizard.WizardStep is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class WizardStep extends WizardStepBase {
        /**
         * Creates a new wizard step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade contianing the form for the wizard step.
         * @param status The status for the step.
         * @param isOptional A value indicating whether or not the step is optional. Defaults to false.
         * @param extension The extension that hosts the blade contianing the form for the wizard step.
         */
        constructor(stepId: string, title: string, formBlade: string, status?: ActionBars.Base.Status, isOptional?: boolean, extension?: string);
    }
    /**
     * @deprecated Wizard.SelectorStep is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SelectorStep<T> extends WizardStepBase {
        /**
         * Creates a new selector step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade contianing the form for the wizard step.
         * @param extension The extension that hosts the blade contianing the form for the wizard step.
         */
        constructor(stepId: string, title: string, formBlade: string, extension?: string);
        value: KnockoutObservableBase<T>;
        defaultValue: KnockoutObservableBase<T>;
        isDefault: KnockoutObservableBase<boolean>;
        displayText: KnockoutObservableBase<string>;
        locked: KnockoutObservableBase<boolean>;
        infoBalloonText: KnockoutObservableBase<string>;
        lockedBalloonText: KnockoutObservableBase<string>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\Chart.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Chart {
    import DockedBalloon = MsPortalFx.ViewModels.Controls.DockedBalloon;
    /**
     * Defines chart types.
     *
     * @deprecated ChartType has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum ChartType {
        /**
         * Line chart type.
         */
        Line = 0,
        /**
         * Area chart type.
         */
        Area = 1,
        /**
         * Scatter chart type.
         */
        Scatter = 2,
        /**
         * Stacked bar chart type.
         */
        StackedBar = 3,
        /**
         * Grouped bar chart type.
         */
        GroupedBar = 4,
        /**
         * Split bar chart type.
         */
        SplitBar = 5,
        /**
         * Stacked area chart type.
         */
        StackedArea = 6
    }
    /**
     * Defines interpolation of lines of the line chart.
     *
     * @deprecated Interpolation has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum Interpolation {
        /**
         * The series interpolation when data points are connected by straight lines.
         */
        Linear = 0,
        /**
         * The series interpolation when data points are connected by smooth curves. The monotone is a mode of D3 interpolation style.
         */
        Monotone = 1,
        /**
         * The series interpolation when series are connected by two lines: the first one (from the left side) is horizontal and the second one is vertical.
         */
        StepAfter = 2
    }
    /**
     * Defines line styles of the line chart.
     *
     * @deprecated LineStyle has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum LineStyle {
        /**
         * The series line is solid.
         */
        Solid = 0,
        /**
         * The series line is dotted.
         */
        Dotted = 1,
        /**
         * The series line is dashed.
         */
        Dashed = 2,
        /**
         * The series line is a trendline.
         */
        Trendline = 3,
        /**
         * The series line is a usage threshold.
         */
        UsageThreshold = 4,
        /**
         * The series line is a warning threshold.
         */
        WarningThreshold = 5
    }
    /**
     * Display type for optional line and coordinate plots for stacked area charts.
     *
     * @deprecated LineState has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum LineState {
        /**
         * Display stacked area chart line with coordinate points. Use this for old api behavior showLines(true).
         */
        ShowLineWithPoints = 0,
        /**
         * Hide stacked area chart line. Use this for old api behavior showLines(false).
         */
        HideLine = 1,
        /**
         * Display stacked area chart line with the point nearest to x slider only.
         */
        ShowLineWithXHoverPoint = 2
    }
    /**
     * Defines hatching patterns of the area chart.
     *
     * @deprecated AreaHatchingPattern has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum AreaHatchingPattern {
        /**
         * The area is solid.
         */
        Solid = 0,
        /**
         * The area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The area is hatched with main diagonal (\) thin lines. Alternate name aligning with new enums - CounterDiagonalThinLine.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched with horizontal think lines. Alternate name aligning with new enums - HorizontalThickLine
         */
        DottedHatching = 3,
        /**
         * The area is hatched with main diagonal (\) thin lines.
         */
        MainDiagonalThinLine = 4,
        /**
         * The area is hatched with horizontal thin lines.
         */
        HorizontalThinLine = 5,
        /**
         * The area is hatched with vertical thin lines.
         */
        VerticalThinLine = 6,
        /**
         * The area is hatched with main diagonal (\) thick lines.
         */
        MainDiagonalThickLine = 7,
        /**
         * The area is hatched with counter diagonal (/) thick lines.
         */
        CounterDiagonalThickLine = 8,
        /**
         * The area is hatched with vertical thick lines.
         */
        VerticalThickLine = 9,
        /**
         * The area is hatched with main diagonal (\) lines in a smoothed out pattern.
         */
        MainDiagonalSmoothLine = 10,
        /**
         * The area is hatched with counter diagonal (/) lines in a smoothed out pattern.
         */
        CounterDiagonalSmoothLine = 11,
        /**
         * The area is hatched with horizontal lines in a smoothed out pattern.
         */
        HorizontalSmoothLine = 12,
        /**
         * The area is hatched with vertical lines in a smoothed out pattern.
         */
        VerticalSmoothLine = 13,
        /**
         * The area has square pattern.
         */
        Square = 14,
        /**
         * The area has diagonal square pattern.
         */
        DiagonalSquare = 15,
        /**
         * The area has circle pattern.
         */
        Circle = 16,
        /**
         * The area has quarter circle(quadrant) pattern.
         */
        Quadrant = 17
    }
    /**
     * Defines the various sub-types for bar chart.
     *
     * @deprecated BarChartType has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum BarChartType {
        /**
         * The data series will be rendered as stacked bars for each x value.
         */
        Stacked = 0,
        /**
         * The data series will be rendered as grouped bars for each x value.
         */
        Grouped = 1,
        /**
         * The data series which has positive and negative values will be rendered with axis in the center of the chart.
         */
        Split = 2
    }
    /**
     * Indicates where the chart axis should be visually positioned on the chart.
     *
     * @deprecated AxisPosition has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum AxisPosition {
        /**
         * The axis should not be displayed in the chart.
         */
        None = 0,
        /**
         * The axis should be displayed horizontally above the chart.
         */
        Top = 1,
        /**
         * The axis should be displayed vertically and aligned right of the chart.
         */
        Right = 2,
        /**
         * The axis should be displayed horizontally below chart.
         */
        Bottom = 3,
        /**
         * The axis should be displayed vertically and aligned left of the chart.
         */
        Left = 4
    }
    enum InteractionBehavior {
        /**
         * All Interaction is enabled
         */
        All = 0,
        /**
         * Opt out XSlider behavior
         */
        XSlider_Off = 1,
        /**
         * Opt out XSlider callout Text. Not Yet Implemented.
         */
        XSlider_noCallout = 2,
        /**
         * Opt out any interaction in ChartArea.
         */
        ChartArea_Off = 4,
        /**
         * Opt out any ChartArea Click-select behavior. Not Yet Implemented.
         */
        ChartArea_noClick = 8,
        /**
         * Opt out any ChartArea hover behavior. Not Yet Implemented.
         */
        ChartArea_noHover = 16
    }
    /**
     * Indicates where the chart legend should be visually positioned on the chart.
     *
     * @deprecated LegendPosition has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum LegendPosition {
        /**
         * The chart legend should not be displayed in the chart.
         */
        None = 0,
        /**
         * The legend should be displayed horizontally above the chart.
         */
        Top = 1,
        /**
         * The legend should be displayed vertically and aligned right of the chart.
         */
        Right = 2,
        /**
         * The legend should be displayed horizontally below chart.
         */
        Bottom = 3,
        /**
         * The legend should be displayed vertically and aligned left of the chart.
         */
        Left = 4
    }
    /**
     * Specifies the data label context.
     *
     * @deprecated DataLabelContext has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum DataLabelContext {
        /**
         * The data label should be displayed near the max value of the series.
         */
        Max = 0,
        /**
         * The data label should be displayed near the min value of the series.
         */
        Min = 1,
        /**
         * The data label should be displayed near the first value of the series.
         */
        First = 2,
        /**
         * The data label should be displayed near the last value of the series.
         */
        Last = 3,
        /**
         * The data label should be displayed near every value of the series.
         */
        Every = 4,
        /**
         * The data label should be displayed near custom points.
         */
        Custom = 5
    }
    /**
     * Specifies the data label style.
     *
     * @deprecated DataLabelStyle has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum DataLabelStyle {
        /**
         * The data label should be displayed as a callout.
         */
        Callout = 0,
        /**
         * The data label should be displayed as a badge.
         */
        Badge = 1
    }
    /**
     * Specifies the scale used on the axis.
     *
     * @deprecated Scale has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum Scale {
        /**
         * Specify this scale for discrete values where the values will be mapped 1:1 on the axis.
         */
        Ordinal = 0,
        /**
         * Specify this scale for continuous values like numeric values in the series which may or may not be sorted.
         */
        Linear = 1,
        /**
         * Specify this scale for date / time values in the series which may or may not be sorted.
         */
        Time = 2,
        /**
         * Logarithmic scale for numeric values
         */
        Log = 3
    }
    /**
     * Specifies where the axis label should be displayed.
     *
     * @deprecated AxisLabelPosition has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum AxisLabelPosition {
        /**
         * The labels are not displayed.
         */
        None = 0,
        /**
         * The labels are displayed at the low end of the axis.
         */
        Low = 1,
        /**
         * The labels are displayed at the high end of the axis.
         */
        High = 2
    }
    /**
     * Specifies conditions checked on rendering a series view.
     *
     * @deprecated ConditionOperator has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum ConditionOperator {
        /**
         * The view should be rendered for series segments exceeding the argument of the condition.
         */
        GreaterThan = 0,
        /**
         * The view should be rendered for series segments not exceeding the argument of the condition.
         */
        LessThan = 1
    }
    /**
     * Specifies series type.
     *
     * @deprecated SeriesType has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum SeriesType {
        /**
         * The series is defined as a set of pairs of x and y values.
         */
        General = 0,
        /**
         * The series is used to draw a horizontal line and is defined as with the y value.
         */
        HorizontalLine = 1,
        /**
         * The series is used to draw a vertical line and is defined as with the x value.
         */
        VerticalLine = 2,
        /**
         * The series has uniform intervals between x-values. It is defined by the start x-value, the grain and the array of y-values.
         */
        Uniform = 3
    }
    /**
     * Specifies the scope of metrics rules.
     *
     * @deprecated MetricRuleScope has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum MetricRuleScope {
        /**
         * The default scope if other rules are not specified.
         */
        Default = 0,
        /**
         * A single data point is in the scope.
         */
        Point = 2,
        /**
         * Multiple data points from the same series are in the scope.
         */
        MultiplePointsSingleSeries = 3,
        /**
         * Multiple data points from multiple series are in the scope.
         */
        MultiplePointsMultipleSeries = 4
    }
    /**
     * Specifies the aggregation scope of a metric rule.
     *
     * @deprecated MetricRuleAggregationScope has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum MetricRuleAggregationScope {
        /**
         * All selected series should be aggregated into a common metric.
         */
        AllTogether = 0,
        /**
         * All selected series should be aggregated separate metrics.
         */
        AllSeparately = 1,
        /**
         * A metric should be aggregated over a single series.
         */
        SingleSeries = 2
    }
    /**
     * Specifies the aggregation type of a metric rule.
     *
     * @deprecated MetricRuleAggregationType has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum MetricRuleAggregationType {
        /**
         * An x-value of the point selected.
         */
        CurrentXValue = 0,
        /**
         * An y-value of the point selected.
         */
        CurrentYValue = 1,
        /**
         * Min of y-value of points selected.
         */
        MinY = 2,
        /**
         * Max of y-value of points selected.
         */
        MaxY = 3,
        /**
         * Average of y-value of points selected.
         */
        AverageY = 4,
        /**
         * Sum of y-value of points selected.
         */
        SumY = 5,
        /**
         * Count of points selected.
         */
        Count = 6,
        /**
         * Custom value.
         */
        CustomValue = 7
    }
    /**
     * Defines the event data associated with chart event notifications.
     *
     * @deprecated EventData<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface EventData<TX, TY> {
        /**
         * Name of the series.
         */
        seriesName: string;
        /**
         * The value of the current target element.
         */
        value: ChartItem<TX, TY>;
    }
    /**
     * This interface specifies data label properties.
     *
     * @deprecated DataLabelContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface DataLabelContract<TX, TY> {
        "--noUnusedLocals"?: TX | TY | any;
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
        /**
         * Defines the data label style.
         */
        style: KnockoutObservable<DataLabelStyle>;
        /**
         * Defines the data label formatter. {0} for series name, {1} for the x-value, {2} for the y-value. X and y values are formatted (date / number) the same way as the corresponding axis tick labels are.
         */
        formatter: KnockoutObservable<string>;
    }
    /**
     * This interface specifies data label properties.
     *
     * @deprecated DataLabel<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class DataLabel<TX, TY> implements DataLabelContract<TX, TY> {
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
        /**
         * Defines the data label style.
         */
        style: KnockoutObservable<DataLabelStyle>;
        /**
         * Defines the data label formatter. {0} for series name, {1} for the x-value, {2} for the y-value. X and y values are formatted (date / number) the same way as the corresponding axis tick labels are.
         */
        formatter: KnockoutObservable<string>;
    }
    /**
     * This class specifies custom data label properties.
     *
     * @deprecated CustomDataLabelContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface CustomDataLabelContract<TX, TY> extends DataLabelContract<TX, TY> {
        /**
         * Defines the chart items for the data label.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * This class specifies custom data label properties.
     *
     * @deprecated CustomDataLabel<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class CustomDataLabel<TX, TY> extends DataLabel<TX, TY> implements CustomDataLabelContract<TX, TY> {
        /**
         * Defines the chart items for the data label.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
    }
    /**
     * This interface specifies the chart axis properties.
     *
     * @deprecated AxisOptions<T> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AxisOptions<T> {
        /**
         * Defines the type of the axis label.
         */
        scale?: Chart.Scale | KnockoutObservable<Chart.Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks?: number | KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis?: boolean | KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        autoScaleUnit?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the padding size for axis labels.
         */
        labelPadding?: number | KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks?: boolean | KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines?: boolean | KnockoutObservable<boolean>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat?: string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter?: string | KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min?: T | KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max?: T | KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        unit?: UnitConversion.Unit | KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit?: boolean | KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding?: number;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding?: number;
    }
    /**
     * This interface specifies the chart axis properties.
     *
     * @deprecated AxisContract<T> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AxisContract<T> {
        /**
         * Name of the axis.
         */
        name: KnockoutObservable<string>;
        /**
         * Defines the type of the axis label.
         */
        scale: KnockoutObservable<Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain?: KnockoutObservableBase<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks: KnockoutObservable<number>;
        /**
         * Defines the position for the axis.
         */
        position: KnockoutObservable<AxisPosition>;
        /**
         * Defines the position index for the placement of the axis when multiple axes should be displayed on the same side.
         * A value of 0 will be placed inner most close to the chart area and value of 1 will be placed further away from
         * the chart area based on the axis label padding.
         */
        positionIndex: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Show the axis name.
         */
        showName: KnockoutObservable<boolean>;
        /**
         * Defines the position at which to show the axis labels.
         */
        showLabel: KnockoutObservable<AxisLabelPosition>;
        /**
         * Defines the padding size for axis labels.
         */
        labelPadding: KnockoutObservable<number>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        rotateLabel: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        showAxisLine: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines: KnockoutObservable<boolean>;
        /**
         * Defines the format to parse the string typed data.
         * The string value can either be a date or a number representation and the specified format will be used to parse the string value to the respective date or number type.
         */
        inputFormat: KnockoutObservable<string>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat: KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * The formatter will use xSliderOutputFormat.date if data is instanceof Date.  It use the basic mechanism as Multi-Time Axis formatting as in
         * http://bl.ocks.org/mbostock/4149176 except for consistency. Please use the DataUtil format.
         * If it is a type of value, it will use the first element of the array.
         */
        xSliderOutputFormat: KnockoutObservable<string[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter: KnockoutObservableBase<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min: KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max: KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        unit: KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit?: KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding: KnockoutObservable<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding: KnockoutObservable<number>;
    }
    /**
     * This class specifies the chart axis properties.
     *
     * @deprecated Axis<T> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Axis<T> implements AxisContract<T> {
        /**
         * Name of the axis.
         */
        name: KnockoutObservable<string>;
        /**
         * Defines the type of the axis label.
         */
        scale: KnockoutObservable<Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain: KnockoutObservable<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks: KnockoutObservable<number>;
        /**
         * Defines the position for the axis.
         */
        position: KnockoutObservable<AxisPosition>;
        /**
         * Defines the position index for the placement of the axis when multiple axes should be displayed on the same side.
         * A value of 0 will be placed inner most close to the chart area and value of 1 will be placed further away from
         * the chart area based on the axis label padding.
         */
        positionIndex: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Show the axis name.
         */
        showName: KnockoutObservable<boolean>;
        /**
         * Defines the position at which to show the axis labels.
         */
        showLabel: KnockoutObservable<AxisLabelPosition>;
        /**
         * Defines the padding size for axis labels.
         * Temporary changed to 50px to fit 1000.0A/BC"
         */
        labelPadding: KnockoutObservable<number>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        rotateLabel: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        showAxisLine: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines: KnockoutObservable<boolean>;
        /**
         * Defines the format to parse the string typed data.
         * The string value can either be a date or a number representation and the specified format will be used to parse the string value to the respective date or number type.
         */
        inputFormat: KnockoutObservable<string>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat: KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * The formatter will use xSliderOutputFormat.date if data is instanceof Date.  It use the basic mechanism as Multi-Time Axis formatting as in
         * http://bl.ocks.org/mbostock/4149176 except for consistency. Please use the DataUtil format.
         * If it is a type of value, it will use the first element of the array.
         */
        xSliderOutputFormat: KnockoutObservable<string[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter: KnockoutObservable<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min: KnockoutObservable<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max: KnockoutObservable<T>;
        /**
         * Specify the unit of the axis.
         */
        unit: KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit: KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding: KnockoutObservable<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding: KnockoutObservable<number>;
        /**
         * If true, all the axis labels except the current slider value will be hidden.
         */
        hideAxisLabelsOnXSliderHover: KnockoutObservableBase<boolean>;
        constructor(position?: AxisPosition, scale?: Scale);
    }
    /**
     * Defines a contract for spans such as time spans or number spans. It is used to provide a uniform subtraction operation for numbers and for dates used in uniform series.
     *
     * @deprecated SpanContract<T> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SpanContract<T> {
        "--noUnusedLocals"?: T | any;
        [others: string]: any;
    }
    /**
     * Defines the date span used for subtraction date/time intervals from dates.
     *
     * @deprecated DateSpan has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class DateSpan implements SpanContract<Date> {
        /**
         * The number of years in the span.
         */
        years: number;
        /**
         * The number of months in the span.
         */
        months: number;
        /**
         * The number of days in the span.
         */
        days: number;
        /**
         * The number of hours in the span.
         */
        hours: number;
        /**
         * The number of minutes in the span.
         */
        minutes: number;
        /**
         * The number of seconds in the span.
         */
        seconds: number;
        /**
         * The number of milliseconds in the span.
         */
        milliseconds: number;
        /**
         * Creates a new instance of the DateSpan.
         *
         * @param years The number of years in the span.
         * @param months The number of months in the span.
         * @param days The number of dates in the span.
         * @param hours The number of hours in the span.
         * @param minutes The number of minutes in the span.
         * @param seconds The number of seconds in the span.
         * @param milliseconds The number of milliseconds in the span.
         */
        constructor(years: number, months: number, days?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number);
    }
    /**
     * Defines the date span used for subtraction numbers from numbers. Need to provide a uniform interface of setting spans at uniform series.
     *
     * @deprecated NumberSpan has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class NumberSpan implements SpanContract<number> {
        /**
         * The span value.
         */
        value: number;
        /**
         * Creates a new instance of the NumberSpan.
         *
         * @param value The span value.
         */
        constructor(value: number);
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     *
     * @deprecated SeriesBaseContract has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesBaseContract {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The name of the series.
         */
        name: KnockoutObservable<string>;
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     *
     * @deprecated SeriesBase has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesBase implements SeriesBaseContract {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The name of the series.
         */
        name: KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a single series and its associated axis.
     *
     * @deprecated SeriesContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesContract<TX, TY> extends SeriesBaseContract {
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single series and its associated axis.
     *
     * @deprecated Series<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Series<TX, TY> extends SeriesBase implements SeriesContract<TX, TY> {
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single uniform series and its associated axis.
     *
     * @deprecated UniformSeriesContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UniformSeriesContract<TX, TY> extends SeriesBase {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The start (smallest) x-value of the series.
         */
        startXValue: KnockoutObservable<TX>;
        /**
         * The span between two x neighbor x values. It is a number if TX is number and a number of milliseconds is TX is DateTime.
         */
        span: KnockoutObservable<SpanContract<TX>>;
        /**
         * The array of y-values.
         */
        yValues: KnockoutObservableArray<TY>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single uniform series and its associated axis.
     *
     * @deprecated UniformSeries<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class UniformSeries<TX, TY> extends SeriesBase implements UniformSeriesContract<TX, TY> {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The start (smallest) x-value of the series.
         */
        startXValue: KnockoutObservable<TX>;
        /**
         * The span between two x neighbor x values. It is a number if TX is number and a number of milliseconds is TX is DateTime.
         */
        span: KnockoutObservable<SpanContract<TX>>;
        /**
         * The array of y-values.
         */
        yValues: KnockoutObservableArray<TY>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a line series and its associated axis.
     *
     * @deprecated LineSeriesContract<T> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface LineSeriesContract<T> extends SeriesBase {
        /**
         * The data source for the line.
         */
        value: KnockoutObservable<T>;
        /**
         * Name of axis associated with the data series' value.
         */
        axisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a line series and its associated axis.
     *
     * @deprecated LineSeries<T> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class LineSeries<T> extends SeriesBase implements LineSeriesContract<T> {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The data source for the line.
         */
        value: KnockoutObservable<T>;
        /**
         * Name of axis associated with the data series' value.
         */
        axisName: KnockoutObservable<string>;
    }
    /**
     * Specifies a chart item selection within a metric.
     *
     * @deprecated MetricRuleContract has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleContract {
        /**
         * Specifies the scope of the rule.
         */
        scope: MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName: string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics: MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
    }
    /**
     * Specifies a chart item selection within a metric.
     *
     * @deprecated MetricRuleOptions has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleOptions {
        /**
         * Specifies the scope of the rule.
         */
        scope?: MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName?: string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics?: MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
    }
    /**
     * MetricRule's single metric contract.
     *
     * @deprecated MetricRuleMetricContract has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleMetricContract {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope: MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType: MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName: string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor: boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode: string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern: AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * Specifies the output formatter of the rule.
         * Note: This option will be deprecated. Please use the globalized date time format.
         */
        outputFormat: string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values if DateFormatOptions is not specified a built-in multi-formatter for dates will be used.
         * For number values if NumberFormatOptions is not specified a built-in format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title: string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit: string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue: string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon?: DockedBalloon.ViewModel | KnockoutObservable<DockedBalloon.ViewModel>;
    }
    /**
     * MetricRule's single metric options.
     *
     * @deprecated MetricRuleMetricOptions has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleMetricOptions {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope?: MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType?: MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName?: string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor?: boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode?: string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern?: AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values if DateFormatOptions is not specified a built-in multi-formatter for dates will be used.
         * For number values if NumberFormatOptions is not specified a built-in format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title?: string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit?: string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue?: string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon?: DockedBalloon.ViewModel | KnockoutObservable<DockedBalloon.ViewModel>;
    }
    /**
     * Specifies a chart item selection within a metric.
     * Note: "any" in the union type is added as a workaround to avoid compiletime ton of compile time breaks due to union between standard type and observable (function).
     * Retaining the actual union types matching the signature of the contract/options.
     *
     * @deprecated MetricRule has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class MetricRule implements MetricRuleContract {
        /**
         * Specifies the scope of the rule.
         */
        scope: any | MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName: any | string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics: any | MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
        /**
         * Creates an instance of metric rule.
         *
         * @param options Specify the properties on MetricRule that extension author will be using to set / get / update.
         *                If the view model property needs to be observably updated then initialize with observable.
         *                If the view model property needs to be statically set one time, use non observable.
         *                If the view model property is not touched and default behavior is fine, don't initialize the property. That will avoid sending it across iframe boundary.
         */
        constructor(options?: MetricRuleOptions);
        private _initOptions;
        private _initLegacyDefaults;
    }
    /**
     * ViewModel for metric rule.
     * Note: "any" in the union type is added as a workaround to avoid ton of compile time breaks due to union between standard type and observable (function).
     * Retaining the actual union types matching the signature of the contract/options.
     *
     * @deprecated MetricRuleMetric has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class MetricRuleMetric implements MetricRuleMetricContract {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope: any | MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType: any | MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName: any | string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor: any | boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode: any | string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern: any | AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * Specifies the output formatter of the rule.
         * Note: This option will be deprecated. Please use the globalized date time format.
         */
        outputFormat: any | string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values, if DateFormatOptions is not specified, the charts default multi-formatter for the date's resolution will be used.
         * For number values, if NumberFormatOptions is not specified, a default format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: any | MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title: any | string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit: any | string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue: any | string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon: any | DockedBalloon.ViewModel | KnockoutObservable<DockedBalloon.ViewModel>;
        /**
         * Creates an instance of metric rule metrics.
         *
         * @param options Specify the properties on MetricRuleMetric that extension author will be using to set / get / update.
         *                If this needs to be observably updated then initialize with observable.
         *                If a view model property needs to be statically set one time, use non observable.
         *                if the view model property is not touched and default behavior is fine, don't initialize the property. That will avoid sending it across iframe boundary.
         */
        constructor(options?: MetricRuleMetricOptions);
        private _initOptions;
        private _initLegacyDefaults;
    }
    /**
     * Identifies a series.
     *
     * @deprecated SeriesIdContract has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesIdContract {
        /**
         * Specifies the view index.
         */
        chartViewIndex: KnockoutObservable<number>;
        /**
         * Specifies the series view index.
         */
        seriesViewIndex: KnockoutObservable<number>;
    }
    /**
     * Identifies a series.
     *
     * @deprecated SeriesId has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesId implements SeriesIdContract {
        /**
         * Specifies the view index.
         */
        chartViewIndex: KnockoutObservable<number>;
        /**
         * Specifies the series view index.
         */
        seriesViewIndex: KnockoutObservable<number>;
    }
    /**
     * Specifies a chart item selection within a series.
     *
     * @deprecated SeriesSubsetContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesSubsetContract<TX, TY> extends SeriesId {
        /**
         * Specifies an array of chart items selected.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * Specifies a chart item selection within a series.
     *
     * @deprecated SeriesSubset<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesSubset<TX, TY> extends SeriesId implements SeriesSubsetContract<TX, TY> {
        /**
         * Specifies an array of chart items selected.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * Chart Event call back.
     *
     * @param x The number of x coordinate
     * @param y The number of y coordinate.
     *
     * @deprecated ChartEventCallBack<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ChartEventCallBack {
        (x?: number, y?: number): void;
    }
    /**
     * Chart Event call back.
     *
     * @param x The pixel value of x coordinate
     * @param y The pixel value of y coordinate.
     * @param xValue The x axis value at the x coordinate.
     * @param yValue The y axis value at the y coordinate.
     *
     * @deprecated ChartEventCallbackEx<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ChartEventCallbackEx<TX, TY> {
        (x?: number, y?: number, xValue?: TX, yValue?: TY): void;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Line and bar chart can provide additional events by extending the base events.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated EventsContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface EventsContract<TX, TY> {
        /**
         * MouseEnter on the plot area.
         */
        plotAreaMouseEnter: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaMouseLeave: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaClick: ChartEventCallbackEx<TX, TY>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Line and bar chart can provide additional events by extending the base events.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated Events<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Events<TX, TY> implements EventsContract<TX, TY> {
        /**
         * MouseEnter on the plot area.
         */
        plotAreaMouseEnter: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaMouseLeave: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaClick: ChartEventCallbackEx<TX, TY>;
    }
    /**
     * Defines the event notification supported by line / area / scatter plot charts.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated SeriesChartEventsContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesChartEventsContract<TX, TY> {
        /**
         * Click on a point.
         */
        pointClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a point.
         */
        pointMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a point.
         */
        pointMouseLeave: (data: EventData<TX, TY>) => any;
        /**
         * Click on a series.
         */
        seriesClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a series.
         */
        seriesMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a series.
         */
        seriesMouseLeave: (data: EventData<TX, TY>) => any;
    }
    /**
     * Defines the event notification supported by line / area / scatter plot charts.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated SeriesChartEvents<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesChartEvents<TX, TY> implements SeriesChartEventsContract<TX, TY> {
        /**
         * Click on a point.
         */
        pointClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a point.
         */
        pointMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a point.
         */
        pointMouseLeave: (data: EventData<TX, TY>) => any;
        /**
         * Click on a series.
         */
        seriesClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a series.
         */
        seriesMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a series.
         */
        seriesMouseLeave: (data: MsPortalFx.ViewModels.Controls.Visualization.Chart.EventData<TX, TY>) => any;
    }
    /**
     * Defines the event notification supported by bar chart.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated BarChartEventsContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface BarChartEventsContract<TX, TY> {
        /**
         * Click on a bar.
         */
        barClick: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseEnter on a bar.
         */
        barMouseEnter: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseLeave on a bar.
         */
        barMouseLeave: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
    }
    /**
     * Defines the event notification supported by bar chart.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated BarChartEvents<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BarChartEvents<TX, TY> implements BarChartEventsContract<TX, TY> {
        /**
         * Click on a bar.
         */
        barClick: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseEnter on a bar.
         */
        barMouseEnter: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseLeave on a bar.
         */
        barMouseLeave: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
    }
    /**
     * Specifies the condition used on rendering a series view.
     *
     * @deprecated RenderingConditionContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface RenderingConditionContract {
        /**
         * The name of the series to be compared with.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The condition operator.
         */
        conditionOperator: KnockoutObservable<ConditionOperator>;
        /**
         * The interpolation for the series.
         */
        interpolation: KnockoutObservable<Interpolation>;
    }
    /**
     * Specifies the condition used on rendering a series view.
     *
     * @deprecated RenderingCondition<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class RenderingCondition implements RenderingConditionContract {
        /**
         * The name of the series to be compared with.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The condition operator.
         */
        conditionOperator: KnockoutObservable<ConditionOperator>;
        /**
         * The interpolation for the series.
         */
        interpolation: KnockoutObservable<Interpolation>;
    }
    /**
     * This base interface defines the how a series should be rendered on the chart.
     *
     * @deprecated SeriesViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesViewContract<TX, TY> {
        /**
         * The name of the series.
         */
        seriesName: KnockoutObservableBase<string>;
        /**
         * The display name of the series.
         */
        displayName: KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass: KnockoutObservable<string>;
        /**
         * Data labels for the series.
         */
        dataLabels: KnockoutObservableArray<DataLabelContract<TX, TY>>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Specify the display formatter to show the value in the tooltip.
         * Formatter by default will add the x, y value and the associated series name. Eg, "Series: '{0}' Point: {1} Value: {2}".
         * The default formatter is borrowed from Microsoft Excel and seems to be valuable.
         * {0} will be populated with the series name.
         * {1} will be populated with the x value.
         * {2} will be populated the y value.
         */
        tooltipFormatter: KnockoutObservable<string>;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        renderingConditions: KnockoutObservableArray<RenderingConditionContract>;
        /**
         * Indicates if the series is selectable.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hidden from the legend.
         */
        hideFromLegend: KnockoutObservable<boolean>;
    }
    /**
     * This base class defines the how a series should be rendered on the chart.
     *
     * @deprecated SeriesView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesView<TX, TY> implements SeriesViewContract<TX, TY> {
        /**
         * The name of the series.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The display name of the series.
         */
        displayName: KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass: KnockoutObservable<string>;
        /**
         * Data labels for the series.
         */
        dataLabels: KnockoutObservableArray<DataLabel<TX, TY>>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Specify the display formatter to show the value in the tooltip.
         * Formatter by default will add the x, y value and the associated series name. Eg, "Series: '{0}' Point: {1} Value: {2}".
         * The default formatter is borrowed from Microsoft Excel and seems to be valuable.
         * {0} will be populated with the series name.
         * {1} will be populated with the x value.
         * {2} will be populated the y value.
         */
        tooltipFormatter: KnockoutObservable<string>;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        renderingConditions: KnockoutObservableArray<RenderingCondition>;
        /**
         * Indicates if the series is selectable.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hoverable.
         */
        hoverable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hidden from the legend
         */
        hideFromLegend: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is autoGenerated
         */
        autoGenerated: boolean;
    }
    /**
     * This interface defines the how a line chart series should be rendered on the chart.
     *
     * @deprecated LineChartSeriesViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface LineChartSeriesViewContract<TX, TY> {
        "--noUnusedLocals"?: TX | TY | any;
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the line type for the series in the current view.
         */
        lineStyle: KnockoutObservable<LineStyle>;
        /**
         * Optionally show a circle for the data point.
         */
        showDataPoints: KnockoutObservable<boolean>;
    }
    /**
     * This class defines the how a line chart series should be rendered on the chart.
     *
     * @deprecated LineChartSeriesView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class LineChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements LineChartSeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the line type for the series in the current view.
         */
        lineStyle: KnockoutObservable<LineStyle>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Optionally show a circle for the data point.
         */
        showDataPoints: KnockoutObservable<boolean>;
    }
    /**
     * This base interface defines the how an area chart series should be rendered on the chart.
     *
     * @deprecated AreaChartSeriesViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AreaChartSeriesViewContract<TX, TY> extends SeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the hatching pattern type for the series in the current view.
         */
        areaHatchingPattern: KnockoutObservable<AreaHatchingPattern>;
    }
    /**
     * This base class defines the how an area chart series should be rendered on the chart.
     *
     * @deprecated AreaChartSeriesView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class AreaChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements AreaChartSeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the hatching pattern type for the series in the current view.
         */
        areaHatchingPattern: KnockoutObservable<AreaHatchingPattern>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
    }
    /**
     * This base class defines the how a stacked area chart series should be rendered on the chart.
     *
     * @deprecated StackedAreaChartSeriesView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class StackedAreaChartSeriesView<TX, TY> extends AreaChartSeriesView<TX, TY> {
    }
    /**
     * This base interface defines the how a scatter chart series should be rendered on the chart.
     *
     * @deprecated ScatterChartSeriesViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ScatterChartSeriesViewContract<TX, TY> extends SeriesViewContract<TX, TY> {
        /**
         * Defines the radius of circles.
         */
        radius: KnockoutObservable<number>;
    }
    /**
     * This base class defines the how a scatter chart series should be rendered on the chart.
     *
     * @deprecated ScatterChartSeriesView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ScatterChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements ScatterChartSeriesViewContract<TX, TY> {
        /**
         * Defines the radius of circles.
         */
        radius: KnockoutObservable<number>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
    }
    /**
     * This interface defines the how a chart view should be rendered on the chart.
     *
     * @deprecated ViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<SeriesView<TX, TY>>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This class defines the how a chart view should be rendered on the chart.
     *
     * @deprecated View<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class View<TX, TY> implements ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<SeriesView<TX, TY>>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a line chart view should be rendered on the chart.
     *
     * @deprecated LineChartViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface LineChartViewContract<TX, TY> extends ViewContract<TX, TY> {
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<LineChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a line chart view should be rendered on the chart.
     *
     * @deprecated LineChartView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class LineChartView<TX, TY> extends View<TX, TY> implements LineChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<LineChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): LineChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how an area chart view should be rendered on the chart.
     *
     * @deprecated AreaChartViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AreaChartViewContract<TX, TY> extends ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<AreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This interface defines the how an area chart view should be rendered on the chart.
     *
     * @deprecated AreaChartView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class AreaChartView<TX, TY> extends View<TX, TY> implements AreaChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<AreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): AreaChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a stacked chart view should be rendered on the chart.
     *
     * @deprecated StackedChartViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StackedChartViewContract<TX, TY> extends View<TX, TY> {
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
    }
    /**
     * This class defines the how a stacked chart view should be rendered on the chart.
     *
     * @deprecated StackedChartView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class StackedChartView<TX, TY> implements StackedChartViewContract<TX, TY> {
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<SeriesView<TX, TY>>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a stacked area chart view should be rendered on the chart.
     *
     * @deprecated StackedAreaChartViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StackedAreaChartViewContract<TX, TY> extends StackedChartViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<StackedAreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Whether to show StackedLine charts for the StackedArea charts.
         */
        lineState: KnockoutObservableBase<LineState>;
    }
    /**
     * This class defines the how a stacked area chart view should be rendered on the chart.
     *
     * @deprecated StackedAreaChartView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class StackedAreaChartView<TX, TY> implements StackedAreaChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<StackedAreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Whether to show stacked lines for the stacked areas.
         */
        lineState: KnockoutObservable<LineState>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): StackedAreaChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a scatter chart view should be rendered on the chart.
     *
     * @deprecated ScatterChartViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ScatterChartViewContract<TX, TY> extends ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<ScatterChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a scatter chart view should be rendered on the chart.
     *
     * @deprecated ScatterChartView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ScatterChartView<TX, TY> extends View<TX, TY> implements ScatterChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<ScatterChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): ScatterChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a bar chart view should be rendered on the chart.
     *
     * @deprecated BarChartViewContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface BarChartViewContract<TX, TY> extends StackedChartViewContract<TX, TY> {
        /**
         * A padding ratio which is relative to bar size. The ratio will be used as padding between two bars.
         */
        barPaddingRatio: KnockoutObservable<number>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        barChartType: KnockoutObservable<BarChartType>;
        /**
         * The span for the x-axis.
         */
        xAxisSpan: KnockoutObservable<SpanContract<TX>>;
        /**
         * Specify the event handlers for this view.
         */
        events: BarChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a bar chart view should be rendered on the chart.
     *
     * @deprecated BarChartView<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BarChartView<TX, TY> extends View<TX, TY> implements BarChartViewContract<TX, TY> {
        /**
         * A padding ratio which is relative to bar size. The ratio will be used as padding between two bars.
         */
        barPaddingRatio: KnockoutObservable<number>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        barChartType: KnockoutObservable<BarChartType>;
        /**
         * The span for the x-axis.
         */
        xAxisSpan: KnockoutObservable<SpanContract<TX>>;
        /**
         * Specify the event handlers for this view.
         */
        events: BarChartEvents<TX, TY>;
        constructor(barChartType: BarChartType);
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This interface defines a single data point for the chart.
     *
     * @deprecated ChartItemContract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ChartItemContract<TX, TY> {
        /**
         * The X value for an item.
         */
        xValue: TX;
        /**
         * The Y values for an item for all series.
         */
        yValue: TY;
    }
    /**
     * This class defines a single data point for the chart.
     *
     * @deprecated ChartItem<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ChartItem<TX, TY> implements ChartItemContract<TX, TY> {
        /**
         * The X value for an item.
         */
        xValue: TX;
        /**
         * The Y values for an item for all series.
         */
        yValue: TY;
        constructor(xValue: TX, yValue: TY);
    }
    /**
     * This interface defines the input data for the chart, axes and its properties.
     *
     * @deprecated Contract<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Contract<TX, TY> extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * The title of the chart.
         */
        title: KnockoutObservable<string>;
        /**
         * Optionally show the title of the chart.
         * The property is temporary ignored.
         */
        showTitle: KnockoutObservable<boolean>;
        /**
         * The width of the chart. If width is 0 then the chart will pick up container's width.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the chart. If height is 0 then the chart will pick up container's height.
         */
        height: KnockoutObservable<number>;
        /**
         * The sizeChanged notification, should only get update from UI. User should not set it.
         */
        sizeChanged: KnockoutObservable<{
            width: number;
            height: number;
        }>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         * To maintain runtime back compat, union type is used.
         */
        noDataMessage: string | KnockoutObservableBase<string>;
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<SeriesBaseContract>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Axis<TY>;
        /**
         * An array of secondary X-axis that can be optionally disabled.
         */
        secondaryXAxes: KnockoutObservableArray<AxisContract<TX>>;
        /**
         * An array of secondary Y-axis that can be optionally disabled.
         */
        secondaryYAxes: KnockoutObservableArray<AxisContract<TY>>;
        /**
         * An array of views that should be rendered on the chart.
         */
        views: KnockoutObservableArray<ViewContract<TX, TY>>;
        /**
         * Set to 'none' to hide the legend. NOTE: Legend will always be shown to the right of the chart if it's visible.
         */
        legendPosition: KnockoutObservable<LegendPosition>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        legendWidth: KnockoutObservableBase<number>;
        /**
         * the interaction behavior
         */
        interactionBehavior: KnockoutObservable<InteractionBehavior>;
        /**
         * A value indicating whether or not to auto generate SeriesViews when there is no SeriesViews provided
         */
        autogenerateSeriesViews: KnockoutObservableBase<boolean>;
        /**
         * Events supported by the control.
         */
        events: EventsContract<TX, TY>;
        /**
         * Metrics used by the control.
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.Contract;
        /**
         * Specifies selections on the chart.
         */
        seriesSelections: KnockoutObservableArray<SeriesSubsetContract<TX, TY>>;
        /**
         * Specifies all the items related to hover on the chart.
         */
        seriesHovers: KnockoutObservableArray<SeriesSubsetContract<TX, TY>>;
        /**
         * Specifies the items being hovered on the chart.
         */
        hoveredID: KnockoutObservableArray<SeriesIdContract>;
        /**
         * Metric rules used by the control
         */
        metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Enable Track XSlider coordination.
         */
        enableTrackXSlider: KnockoutObservableBase<boolean>;
        /**
         * If enableTrackXSlider() is true, the xSliderCoordinate is reported in this variable.
         */
        xSliderCoordinate: KnockoutObservableBase<number>;
        /**
         * If xSlider is enabled, Distance from the nearest datapoint in your chart that will trigger the hover animation as a ratio (xSliderFilterHover) of the width of the chart.
         * For example, .05 means that the distance between the selected chartData can't be bigger than 0.05 * width of the chart.
         * This number can't be bigger than .5 or less than 0.  It will fall back to default behavior.
         */
        xSliderFilterHoverThreshold: KnockoutObservableBase<number>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        noData: KnockoutObservableBase<boolean>;
        /**
         * Aria label for the chart.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria description for the chart.
         */
        ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * This class defines the input data for the chart, axes and its properties.
     *
     * @deprecated ViewModel<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel<TX, TY> extends Loadable.ViewModel implements Contract<TX, TY> {
        /**
         * The title of the chart.
         */
        title: KnockoutObservable<string>;
        /**
         * Optionally show the title of the chart.
         * The property is temporary ignored.
         */
        showTitle: KnockoutObservable<boolean>;
        /**
         * The width of the chart.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the chart.
         */
        height: KnockoutObservable<number>;
        /**
         * The sizeChanged notification, should only get update from UI. User should not set it.
         */
        sizeChanged: KnockoutObservable<{
            width: number;
            height: number;
        }>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         * To maintain runtime back compat, union type is used.
         */
        noDataMessage: string | KnockoutObservableBase<string>;
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<SeriesBase>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Axis<TY>;
        /**
         * An array of secondary X-axis that can be optionally disabled.
         */
        secondaryXAxes: KnockoutObservableArray<Axis<TX>>;
        /**
         * An array of secondary Y-axis that can be optionally disabled.
         */
        secondaryYAxes: KnockoutObservableArray<Axis<TY>>;
        /**
         * An array of views that should be rendered on the chart.
         */
        views: KnockoutObservableArray<View<TX, TY>>;
        /**
         * The position where the legend should be placed. None option will not display the legend.
         */
        legendPosition: KnockoutObservable<LegendPosition>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        legendWidth: KnockoutObservableBase<number>;
        /**
         * the interaction behavior
         */
        interactionBehavior: KnockoutObservable<InteractionBehavior>;
        /**
         * A value indicating whether or not to auto generate SeriesViews when there is no SeriesViews provided
         */
        autogenerateSeriesViews: KnockoutObservableBase<boolean>;
        /**
         * Events supported by the control.
         */
        events: Events<TX, TY>;
        /**
         * Metrics used by the control
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.ViewModel;
        /**
         * Specifies selections on the chart.
         */
        seriesSelections: KnockoutObservableArray<SeriesSubset<TX, TY>>;
        /**
         * Specifies all the items related to hover on the chart.
         */
        seriesHovers: KnockoutObservableArray<SeriesSubset<TX, TY>>;
        /**
         * Specifies the item being hovered on the chart.
         */
        hoveredID: KnockoutObservableArray<SeriesId>;
        /**
         * Metric rules used by the control.
         */
        metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Enable Track XSlider coordination.
         */
        enableTrackXSlider: KnockoutObservableBase<boolean>;
        /**
         * If enableTrackXSlider() is true, the xSliderCoordinate is reported in this variable.
         */
        xSliderCoordinate: KnockoutObservableBase<number>;
        /**
         * If xSlider is enabled, Distance from the nearest datapoint in your chart that will trigger the hover animation as a ratio (xSliderFilterHover) of the width of the chart.
         * For example, .05 means that the distance between the selected chartData can't be bigger than 0.05 * width of the chart.
         * This number can't be bigger than .5 or less than 0.  It will fall back to default behavior.
         */
        xSliderFilterHoverThreshold: KnockoutObservableBase<number>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservable<string>;
        /**
         * Aria description for the chart.
         */
        readonly ariaDesc: KnockoutObservable<string>;
        static defaultYAxisLabelPadding: number;
        static getDefaultSeriesViewCreator<TX, TY>(chartType: ChartType): (dataSeries: SeriesBaseContract, view: View<TX, TY>) => SeriesView<TX, TY>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        noData: KnockoutObservableBase<boolean>;
        private _seriesHelpers;
        /**
         * Creates a chart.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\Donut.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Donut {
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Donut has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/Donut.
     */
    type GaugeSize = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Donut has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/Donut.
     */
    type ItemData = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Donut has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/Donut.
     */
    type ItemSetting = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Donut has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/Donut.
     */
    type GroupInfo = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Donut has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/Donut.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Donut has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/Donut.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Donut has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/Donut.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\Map.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Map {
    /**
     * Extension for Map
     *
     * @deprecated Extensions has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    enum Extensions {
        /**
         * Plugin to HexagonLayout UX
         */
        HexagonLayout = 1
    }
    /**
     * Location for Map Item
     *
     * @deprecated Location has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Location {
        /**
         * Latitude coordinate for the map item.
         */
        latitude: number;
        /**
         * Longitude coordinate for the map item.
         */
        longitude: number;
        /**
         * @param latitude The latitude of the location
         * @param longitude The longitude of the location
         */
        constructor(latitude: number, longitude: number);
    }
    /**
     * The links that represents HexagonLayout link
     *
     * @deprecated Link has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Link {
        /**
         * Source of the link
         */
        source: Item;
        /**
         * Target of the link
         */
        target: Item;
        /**
         * Type of the link
         */
        linkType: LinkType;
    }
    /**
     * The enum for HexagonLayout Link type
     *
     * @deprecated LinkType has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum LinkType {
        /**
         * The Link is solid line
         */
        Solid = 0,
        /**
         * Dashed line with animation
         */
        AnimatedDashed = 1
    }
    /**
     * Map Item contract
     *
     * @deprecated ItemContract has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ItemContract {
        /**
         * Id for the item.
         */
        id: string;
        /**
         * Location for the item.
         */
        location: Location;
        /**
         * Metadata for the item.
         */
        metadata: ItemMetadataContract;
    }
    /**
     * Map Item contract
     *
     * @deprecated Item has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Item implements ItemContract {
        /**
         * Id for the item.
         */
        id: string;
        /**
         * Location for the item.
         */
        location: Location;
        /**
         * Metadata for the item.
         */
        metadata: ItemMetadataContract;
    }
    /**
     * The enum for HexagonLayout link
     *
     * @deprecated ItemType has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum ItemType {
        /**
         * The primary in a HexagonLayout link relationship
         */
        Source = 0,
        /**
         * The secondary in a HexagonLayout link relationship
         */
        Target = 1,
        /**
         * The hexagon only has icon displayed.
         */
        IconOnly = 2
    }
    /**
     * A metadata entry corresponding to a single item in the list.
     *
     * @deprecated ItemMetadataContract has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ItemMetadataContract {
        /**
         * Icon displayed on the hexagon.
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The width of the icon
         */
        iconWidth?: KnockoutObservable<number>;
        /**
         * The height of the icon
         */
        iconHeight?: KnockoutObservable<number>;
    }
    /**
     * A metadata entry corresponding to a single item in the list for HexagonLayout
     *
     * @deprecated HexagonLayoutItemMetadataContract has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface HexagonLayoutItemMetadataContract extends ItemMetadataContract {
        /**
         * Type in HexagonLayout relationship
         */
        type?: ItemType;
        /**
         * Text to show for the item
         */
        text?: KnockoutObservable<string>;
        /**
         * Indicates whether to fill the polygon
         */
        hasFill?: KnockoutObservable<boolean>;
        /**
         * The icon displayed on the hexagon.
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * Scale the item based on hexagon size. 1.0 means the size is the same as hexagon grid.
         */
        itemScale?: KnockoutObservable<number>;
    }
    /**
     * A metadata entry corresponding to a single item in the list.
     *
     * @deprecated ItemMetadata has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ItemMetadata implements ItemMetadataContract {
        /**
         * The icon displayed on the hexagon.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * The width of the icon
         */
        iconWidth: KnockoutObservable<number>;
        /**
         * The height of the icon
         */
        iconHeight: KnockoutObservable<number>;
    }
    /**
     * A metadata entry corresponding to a single item in the list for HexagonLayout
     *
     * @deprecated HexagonLayoutItemMetadata has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class HexagonLayoutItemMetadata extends ItemMetadata implements HexagonLayoutItemMetadataContract {
        /**
         * Type in HexagonLayout link relationship
         */
        type: ItemType;
        /**
         * Text to show for the item
         */
        text: KnockoutObservable<string>;
        /**
         * Indicates whether to fill the polygon
         */
        hasFill: KnockoutObservable<boolean>;
        /**
         * Scale the item based on hexagon size. 1.0 means the size is the same as hexagon grid.
         */
        itemScale: KnockoutObservable<number>;
    }
    /**
     * Defines HexagonLayout Extension options
     *
     * @deprecated HexagonLayoutOptions has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface HexagonLayoutOptions {
        /**
         * Indicates whether to show links on the map.
         */
        showLinks?: KnockoutObservable<boolean>;
        /**
         * Links among the items on the Map control.
         */
        links?: KnockoutObservable<Link[]>;
        /**
         * Number of rows for the hexagon grid
         */
        rows?: KnockoutObservable<number>;
        /**
         * Number of columns for the hexagon grid
         */
        columns?: KnockoutObservable<number>;
    }
    /**
     * Options for Extension
     *
     * @deprecated ExtensionOptions has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ExtensionOptions {
        /**
         * HexagonLayout options.
         */
        hexagonLayout?: HexagonLayoutOptions;
        /**
         * Aria label for the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Aria description for the control.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * Event callback for Map items.
     *
     * @deprecated Events has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Events {
        /**
         * Click on an item.
         */
        itemClick: (item: Item) => void;
        /**
         * Mouse enter on an item.
         */
        itemMouseEnter: (item: Item) => void;
        /**
         * Mouse leave on an item.
         */
        itemMouseLeave: (item: Item) => void;
    }
    /**
     * View model contract for the map widget.
     *
     * @deprecated Contract has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Contract extends Loadable.Contract {
        /**
         * Map items to be displayed.
         */
        items: KnockoutObservable<Item[]>;
        /**
         * Events supported by the map control.
         */
        events: Events;
        /**
         * The width of the control.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the control.
         */
        height: KnockoutObservable<number>;
        /**
         * Aria label for the control.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria description for the control.
         */
        ariaDesc: KnockoutObservableBase<string>;
        extensions?: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions?: ExtensionOptions;
    }
    /**
     * View model for the map widget.
     *
     * @deprecated ViewModel has been deprecated. If you are using basic map, please migrate to Fx/Controls/Map.
     * HexagonLayout map should be used by SQL extension only. Other extensions should migrate to Fx/Controls/Map.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Map items to be displayed.
         */
        items: KnockoutObservable<Item[]>;
        /**
         * Events supported by the map control.
         */
        events: Events;
        /**
         * The width of the map control
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the map control
         */
        height: KnockoutObservable<number>;
        extensions: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria description for the chart.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Constructs a Map view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items map items to be displayed.
         * @param extensions Bitmask of extension plugins to be loaded.
         * @param extensionOptions The extension options for the plugins.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items?: KnockoutObservable<Item[]>, extensions?: number, extensionOptions?: ExtensionOptions);
        /**
         * Constructs a Map view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items map items to be displayed.
         * @param extensionOptions The extension options for the plugins.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items: KnockoutObservable<Item[]>, extensionOptions: ExtensionOptions);
        dispose(): void;
        private _getDefaultOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\Metrics.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Metrics {
    /**
     * Size of the metrics.
     */
    const enum Size {
        /**
         * Shows small metrics - Font: 20px, Height: 32px, Margin: 14px.
         */
        Small = 0,
        /**
         * Shows medium metrics - Font: 40px, Height: 35px, Margin: 30px.
         */
        Medium = 1,
        /**
         * Shows large metrics - Font: 40px, Height: 45px, Margin: 22px.
         */
        Large = 2,
        /**
         * Shows Xlarge metrics - Font: 40px, Height: 45px, Margin: 25px.
         */
        XLarge = 3,
        /**
         * Shows extra small metrics - Font: 20px, Height: 30px, Margin: 12px.
         */
        ExtraSmall = 4
    }
    /**
     * Orientation of the metrics.
     */
    const enum Orientation {
        /**
         * Metrics will be displayed horizontally.
         */
        Horizontal = 0,
        /**
         * Metrics will be displayed vertically.
         */
        Vertical = 1
    }
    const enum Alignment {
        /**
         * Top edge for vertical alignment.
         */
        Top = 1,
        /**
         * Left edge for horizontal alignment.
         */
        Left = 2,
        /**
         * Right edge for horizontal alignment.
         */
        Right = 4,
        /**
         * Bottom edge for vertical alignment.
         */
        Bottom = 8
    }
    /**
     * Defines hatching patterns.
     * New hatching patterns are not supported in MsPortalFx namespace. To get the latest supported hatching pattern, migrate to AMD creation pattern.
     */
    const enum HatchingPattern {
        /**
         * The area is solid.
         */
        Solid = 0,
        /**
         * The area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The area is diagonal hatched.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched horizontally like a dotted line.
         */
        DottedHatching = 3
    }
    interface SingleMetricContract extends Loadable.Contract {
        /**
         * The value of the setting.
         */
        value: KnockoutObservableBase<string>;
        /**
         * The unit of the setting.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * The caption of the setting.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon: KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass: KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor: KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern?: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Visualization.Metrics.HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide: KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
    }
    interface SingleMetricOption extends Loadable.Options {
        /**
         * The value of the setting.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The unit of the setting.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * The caption of the setting.
         */
        caption?: string | KnockoutObservableBase<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon?: MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel | KnockoutObservableBase<MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass?: string | KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern?: HatchingPattern | KnockoutObservableBase<HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        captionAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    class SingleMetric extends Loadable.ViewModel implements SingleMetricContract {
        /**
         * The value of the setting.
         */
        value: KnockoutObservableBase<string>;
        /**
         * The unit of the setting.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * The caption of the setting.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon: KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass: KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor: KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern: KnockoutObservableBase<HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        captionAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide: KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Specifies the prefix string for narrator to announce the content's context like 'Metric item' or 'Donut center text' etc.
         */
        ariaLivePrefix: KnockoutObservableBase<string>;
        /**
         * A flag to indicate aria-live attribute is turned on or off for narrator to read the metric value.
         * The flag will be updated by the control during control/metrics interactions.
         */
        _msPortalFxAriaLive: KnockoutReadOnlyObservableBase<boolean>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: SingleMetricOption);
    }
    interface VisualContract extends Loadable.Contract {
        /**
         * The orientation of the items in the metrics.
         */
        orientation: KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         */
        size: KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        visible: KnockoutObservableBase<boolean>;
    }
    interface Contract extends VisualContract {
        /**
         * Metrics items to display
         */
        items: KnockoutObservableArray<SingleMetric>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
    }
    interface Options extends Loadable.Options {
        /**
         * Metrics items to display
         */
        items?: SingleMetric[] | KnockoutObservableArray<SingleMetric>;
        /**
         * The orientation of the items in the metrics.
         */
        orientation?: Orientation | KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         * This is deprecated. The parent control is responsible for styling the metrics in accordance with the size.
         */
        size?: Size | KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Metrics items to display
         */
        items: KnockoutObservableArray<SingleMetric>;
        /**
         * The orientation of the items in the metrics.
         */
        orientation: KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         * This is deprecated. The parent control is responsible for styling the metrics in accordance with the size.
         */
        size: KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria live flag to turn on or off live region for each metric.
         * The flag will be used for Chart/metrics interactions.
         */
        _msPortalFxAriaLive: KnockoutObservableBase<boolean>;
        /**
         * Creates a metric view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\ProgressBar.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.ProgressBar {
    const enum StatusType {
        /**
         * In progress style.
         */
        InProgress = 0,
        /**
         * Error style.
         */
        Error = 1,
        /**
         * Warning style.
         */
        Warning = 2,
        /**
         * Success style.
         */
        Success = 3,
        /**
         * Indeterminate style.
         */
        Indeterminate = 4,
        /**
         * Vertical indeterminate style.
         */
        IndeterminateVertical = 5
    }
    /**
     * This control is no longer supported. Use Fx/Controls/ProgressBar instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/ProgressBar instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/ProgressBar instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\QuotaGauge.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.QuotaGauge {
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.QuotaGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/QuotaGauge.
     */
    type GaugeSize = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.QuotaGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/QuotaGauge.
     */
    type ErrorWarningShape = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.QuotaGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/QuotaGauge.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.QuotaGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/QuotaGauge.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.QuotaGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/QuotaGauge.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\SimpleChart.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.SimpleChart {
    import Chart = MsPortalFx.ViewModels.Controls.Visualization.Chart;
    /**
     * This base interface defines the how a series should be rendered on the chart.
     *
     * @deprecated SeriesViewOptions<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesViewOptions<TX, TY> {
        "--noUnusedLocals"?: TX | TY | any;
        /**
         * The display name of the series.
         */
        displayName?: string | KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass?: string | KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a single series and its associated axis.
     *
     * @deprecated SeriesOptions<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesOptions<TX, TY> {
        /**
         * The name of the series.
         */
        name?: string | KnockoutObservable<string>;
        /**
         * The data source for the chart.
         */
        values?: KnockoutObservableArray<Chart.ChartItem<TX, TY>>;
        /**
         * Optional display options for the series.
         */
        viewOptions?: SeriesViewOptions<TX, TY>;
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     *
     * @deprecated Series<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Series<TX, TY> {
        /**
         * The name of the series.
         */
        name: string | KnockoutObservable<string>;
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<Chart.ChartItem<TX, TY>>;
        /**
         * Optional display options for the series.
         */
        viewOptions: SeriesViewOptions<TX, TY>;
        constructor(options?: SeriesOptions<TX, TY>);
        private _getDefaultOptions;
        private _initOptions;
    }
    /**
     *  SimpleChart config options.
     *
     * @deprecated SimpleChartOptions<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SimpleChartOptions<TX, TY> {
        /**
         * Provide an array of data series.
         */
        series?: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         * The properties are opt-in. Provide only the properties that will be consumed by extension.
         */
        xAxis?: Chart.AxisOptions<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         * The properties are opt-in. Provide only the properties that will be consumed by extension.
         */
        yAxis?: Chart.AxisOptions<TY>;
        /**
         * Specify the chart type to render. By default line chart will be rendered.
         */
        chartType?: Chart.ChartType | KnockoutObservableBase<Chart.ChartType>;
        /**
         * Metric rules used by the control.
         */
        metricsRules?: KnockoutObservableArray<Chart.MetricRule>;
        /**
         * The position of the legend on the chart.
         */
        legendPosition?: Chart.LegendPosition;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Aria description for the chart.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * This class defines the input data for the chart, axes and its properties.
     *
     * @deprecated ViewModel<TX, TY> has been deprecated. Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel<TX, TY> extends Loadable.ViewModel {
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Chart.AxisOptions<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Chart.AxisOptions<TY>;
        /**
         * Specify the chart type to render. By default line chart will be rendered.
         */
        chartType: Chart.ChartType | KnockoutObservableBase<Chart.ChartType>;
        /**
         * Metric rules used by the control.
         */
        metricsRules: KnockoutObservableArray<Chart.MetricRule>;
        /**
         * The position of the legend on the chart.
         */
        legendPosition: Chart.LegendPosition;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Creates a chart.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: SimpleChartOptions<TX, TY>);
        private _getDefaultOptions;
        private _initOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\SingleValueGauge.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.SingleValueGauge {
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SingleValueGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/SingleValueGauge.
     */
    type GaugeSize = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SingleValueGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/SingleValueGauge.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SingleValueGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/SingleValueGauge.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SingleValueGauge has been obsoleted.
     * Please migrate to the AMD creation pattern using Fx/Controls/SingleValueGauge.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Fields\Base\EditableComboField.d.ts
declare module MsPortalFx.ViewModels {
    import PositioningAlignment = MsPortalFx.ViewModels.Forms.Base.EditableComboBox.PositioningAlignment;
    interface EditableComboFormField<T> extends EditableFormField<T> {
    }
    /**
     * Base class for combo fields
     */
    class EditableComboField<T> extends EditableField<T> implements EditableComboFormField<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText: KnockoutObservable<string>;
        /**
         * Alignment used for drop popup.
         */
        popupAlignment: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment: PositioningAlignment;
        /**
         * Constructs and instance of an editable combo field.
         * (Base class for other combo fields)
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         * @param emptyValueText Optional. Watermark text to display over the form field when it's empty.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], emptyValueText?: string, infoBalloonContent?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\Field.d.ts
declare module MsPortalFx.ViewModels {
    interface FormField<T> extends FormElement {
        /**
         * Label for the field.
         */
        label?: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Label position for the field.
         */
        labelPosition?: KnockoutObservable<MsPortalFx.ViewModels.Forms.LabelPosition>;
        /**
         * Initial value for the field.
         */
        initialValue?: KnockoutObservableBase<T>;
        /**
         * Current value of the field.
         */
        value?: KnockoutObservableBase<T>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation?: KnockoutObservableBase<boolean>;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: KnockoutObservableArray<FormValidation>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout?: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled?: KnockoutObservable<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent?: KnockoutObservable<string | HtmlContent>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation?: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation?: KnockoutObservable<number>;
        /**
         * A function through which the enclosing form will dispose this field.  The field's 'initialValue' and 'value'
         * observables should be disposed if they are disposable.
         */
        dispose(): void;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue?: KnockoutObservableBase<T>;
    }
    class Field<T> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements FormField<T> {
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation: KnockoutObservableBase<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * Label for the field.
         */
        label: KnockoutObservable<string>;
        /**
         * Label for the field.
         */
        labelPosition: KnockoutObservable<MsPortalFx.ViewModels.Forms.LabelPosition>;
        /**
         * Current value of the field.
         */
        value: KnockoutObservableBase<T>;
        /**
         * Initial value for the field.
         */
        initialValue: KnockoutObservableBase<T>;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations: KnockoutObservableArray<FormValidation>;
        /**
         * A list of validation results.
         */
        validationResults: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservable<string>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation: KnockoutObservable<number>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue: KnockoutObservableBase<T>;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        _msPortalFxTriggerValidation: KnockoutObservable<() => Q.Promise<boolean>>;
        _enableValidationReactor: KnockoutComputed<void>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         * @param defaultValue An optional, default value of type T, used when the EditScope underlying the enclosing Form isn't
         * yet loaded.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string, defaultValue?: T);
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): Q.Promise<any>;
        /**
         * Triggers validation on the field.
         * @return A promise that is resolved when the validation has been triggered.
         */
        triggerValidation(): Q.Promise<boolean>;
        setDirty(value: boolean): void;
    }
    interface NullableFormField<T> extends FormField<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutObservableBase<boolean>;
    }
    class NullableField<T> extends Field<T> implements NullableFormField<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutComputed<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface EditableFormField<T> extends NullableFormField<T> {
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservableBase<boolean>;
    }
    class EditableField<T> extends NullableField<T> implements EditableFormField<T> {
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface GroupsFormField<T> extends FormField<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<Forms.IGroup<T>>;
    }
    class GroupsField<T> extends Field<T> implements GroupsFormField<T> {
        /**
         * A list of groups to categorize the selectable options.
         */
        groups: KnockoutObservableArray<Forms.IGroup<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param values A list of groups to categorize the options field value.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, values: Forms.IGroup<T>[], validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface OptionsFormField<T> extends FormField<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<Forms.IDisablableOption<T>>;
    }
    class OptionsField<T> extends Field<T> implements OptionsFormField<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<Forms.IDisablableOption<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param values A list of options the user will choose the field value from.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, values: Forms.IDisablableOption<T>[], validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface SliderBaseFormField<T> extends FormField<T> {
        /**
         * Minimum value of the slider.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
    }
    class SliderBaseField<T> extends Field<T> implements SliderBaseFormField<T> {
        /**
         * Minimum value for the field.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value for the field.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Constructs an instance of a slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param minValue Minimum value for the field.
         * @param maxValue Maximum value for the field.
         * @param validations A list of validations to be applied to the field.
         * @param showStepMarkers If true step markers will be shown on the slider.
         * @param defaultValue An optional, default value of type T, used when the EditScope underlying the enclosing Form isn't
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors?: any, label?: string, minValue?: number, maxValue?: number, validations?: FormValidation[], showStepMarkers?: boolean, infoBalloonContent?: string, defaultValue?: T, step?: number);
    }
    interface TypableFormField<T> extends NullableFormField<T> {
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
    }
    class TypableField<T> extends EditableField<T> implements TypableFormField<T> {
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormElement.d.ts
declare module MsPortalFx.ViewModels {
    interface FormElement extends MsPortalFx.ViewModels.Controls.Base.Contract {
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * When changed forces validation on the field.
         */
        validate: KnockoutObservable<number>;
        /**
         * Clears validations on the control.
         */
        clearValidation(): Q.Promise<any>;
        /**
         * Triggers validations on the control.
         */
        triggerValidation(): Q.Promise<boolean>;
        /**
         * Internal view model properties.
         */
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormGroup.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface IGroup<T> {
        /**
         * Id specifying the groupby key for a group of options.
         */
        key: string;
        /**
         * User friendly label for the grouping.
         */
        text: KnockoutObservable<string>;
        /**
         * Disable state of this group.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * Selectable state of this group.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * A list of options the use can select the field value from.
         * Dynamic update of options array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        options: KnockoutObservableArray<ISelectableOption<T>>;
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormOption.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface IOption<T> {
        /**
         * Text for the drop down option.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Value for the drop down option.
         */
        value: T;
        /**
         * Optional alternate text for screen readers if the text is not explicit enough.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    interface IDisablableOption<T> extends IOption<T> {
        /**
         * Dropdown option can be disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    class Option<T> implements IOption<T> {
        /**
         * Text for list item.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Value bound for list item when the item is selected.
         */
        value: T;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         */
        constructor(text: KnockoutObservableBase<string> | string, value: KnockoutObservableBase<T> | T);
    }
    class DisablableOption<T> extends Option<T> implements IDisablableOption<T> {
        /**
         * Item is disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         * @param disabled The item is disabled.
         */
        constructor(text: KnockoutObservableBase<string> | string, value: KnockoutObservableBase<T> | T, disabled?: KnockoutObservableBase<boolean> | boolean);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormOptionFormatSetting.d.ts
declare module MsPortalFx.ViewModels {
    interface FormOptionFormatSetting {
        /**
         * Formatter used when displaying the drop down option.
         */
        format?: MsPortalFx.ViewModels.Controls.Lists.Grid.Format;
        /**
         * Formatter options associated with the formatters.
         */
        formatOptions?: MsPortalFx.ViewModels.Controls.Lists.Grid.FormatOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormSelectableOption.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface ISelectableOption<T> extends IDisablableOption<T> {
        /**
         * Option is selected. Recommended to use manipulate value to update selection.
         * NOTE: Updates active selected for OptionsGroup control only.
         */
        selected?: KnockoutObservableBase<boolean>;
    }
    class SelectableOption<T> extends DisablableOption<T> implements ISelectableOption<T> {
        /**
         * Option is selected. Recommended to use manipulate value to update selection.
         * NOTE: Updates active selected for OptionsGroup control only.
         */
        selected: KnockoutObservableBase<boolean>;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         * @param disabled The item is disabled.
         * @param selected The item is selected.
         */
        constructor(text: string | KnockoutObservableBase<string>, value: T | KnockoutObservableBase<T>, disabled?: boolean | KnockoutObservableBase<boolean>, selected?: boolean | KnockoutObservableBase<boolean>);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\CaseInsensitiveComparisonValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface CaseInsensitiveComparisonFormValidation extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    class CaseInsensitiveComparisonValidation extends StaticMessageValidation implements CaseInsensitiveComparisonFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
        /**
         * Validation that uses toLowerCase() to compare two values.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(compareTo: string, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\ContainsCharactersValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface ContainsCharactersFormValidation extends StaticMessageFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    class ContainsCharactersValidation extends StaticMessageValidation implements ContainsCharactersFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\ContainsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface ContainsFormValidation extends StaticMessageFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    class ContainsValidation extends StaticMessageValidation implements ContainsFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
        /**
         * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
         *
         * @param search The search string to match.
         * @param message Validation rule error message.
         */
        constructor(searchString: string, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\CustomValidation.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface for a typed validation
     */
    interface CustomFormValidationV<TValue> extends MsPortalFx.ViewModels.FormValidation {
        /**
         * Function that returns whether the data is valid or not.
         *
         * @param value The field value to validate.
         * @return The promise to validate the value.
         */
        validate: (value: TValue) => Q.Promise<MsPortalFx.ViewModels.ValidationResult>;
        /**
         *  The message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
    }
    type CustomFormValidation = CustomFormValidationV<any>;
    /**
     * A typed custom validation
     */
    class CustomValidationV<TValue> extends Validation implements CustomFormValidationV<TValue> {
        /**
         * Function that returns whether the data is valid or not.
         */
        validate: (value: TValue) => Q.Promise<ValidationResult>;
        /**
         *  The message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
        constructor(message: string, validate: (value: TValue) => Q.Promise<ValidationResult>);
    }
    class CustomValidation extends CustomValidationV<any> implements CustomFormValidation {
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\EqualsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface EqualsFormValidation<T> extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: T;
    }
    class EqualsValidation<TValue> extends StaticMessageValidation implements EqualsFormValidation<TValue> {
        /**
         * The value the field value will be compared to.
         */
        compareTo: TValue;
        /**
         * Constructs a validator that compares if the value is equal to a provided value.
         *
         * @param compareTo The value or accessor to get the value to compare to.
         * @param message Validation rule error message.
         */
        constructor(compareTo: TValue, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\FormValidationType.d.ts
declare module MsPortalFx.ViewModels {
    const enum FormValidationType {
        /**
         * Value indicates field has not been set to an appropriate validation type.
         */
        Invalid = 0,
        /**
         * Validation is a value required validation.
         */
        Required = 1,
        /**
         * Validation is a regular expression validation.
         */
        RegExMatch = 2,
        /**
         * Validator that checks if the value does not match a regular expression.
         */
        NotRegExMatch = 3,
        /**
         * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
         */
        Contains = 4,
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         */
        NotContains = 5,
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         */
        ContainsCharacters = 6,
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         */
        NotContainsCharacters = 7,
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         */
        HasDigit = 8,
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         */
        HasLetter = 9,
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         */
        HasUpperCaseLetter = 10,
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         */
        HasLowerCaseLetter = 11,
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         */
        HasPunctuation = 12,
        /**
         * Constructs a base comparison validator that compares the control value to a provided value.
         */
        Equals = 13,
        /**
         * Constructs a validator that checks that the value length is between min and max.
         */
        LengthRange = 14,
        /**
         * Constructs a validator that checks that the value length is at least min.
         */
        MinLength = 15,
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         */
        MaxLength = 16,
        /**
         * Constructs a validator that checks whether the value is a number.
         */
        Numeric = 17,
        /**
         * Constructs a validator that checks whether the value is within the range defined by min and max number.
         */
        Range = 18,
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         */
        MinValue = 19,
        /**
         * Constructs a validator that checks whether the value is less than or equal to the specified maximum number.
         */
        MaxValue = 20,
        /**
         * Validation is implemented by extension author.
         */
        Custom = 21,
        /**
         * Constructs a validator that uses toLowerCase() to compare two values.
         */
        CaseInsensitiveComparison = 22,
        /**
         * Constructs a validator that uses toLocaleLowerCase() to compare two values.
         */
        LocaleAwareCaseInsensitiveComparison = 23,
        /**
         * Contructs a validator that validates an absolute http/https URI.
         */
        Uri = 24
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasDigitValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasDigitFormValidation extends StaticMessageFormValidation {
    }
    class HasDigitValidation extends StaticMessageValidation implements HasDigitFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasLetterValidation extends StaticMessageValidation implements HasLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasLowerCaseLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasLowerCaseLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasLowerCaseLetterValidation extends StaticMessageValidation implements HasLowerCaseLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasPunctuationValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasPunctuationFormValidation extends StaticMessageFormValidation {
    }
    class HasPunctuationValidation extends StaticMessageValidation implements HasPunctuationFormValidation {
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasUpperCaseLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasUpperCaseLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasUpperCaseLetterValidation extends StaticMessageValidation implements HasUpperCaseLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\InvalidValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface InvalidFormValidation extends StaticMessageFormValidation {
    }
    class InvalidValidation extends StaticMessageValidation implements InvalidFormValidation {
        /**
         * Constructs an instance of the invalid validation which is used to force invalid validation state.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\LengthRangeValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface LengthRangeFormValidation extends StaticMessageFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    class LengthRangeValidation extends StaticMessageValidation implements LengthRangeFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
        /**
         * Constructs a validator that checks that the value length is between min and max.
         *
         * @param min The minimum number of characters to be valid. May be null if there is no min.
         * @param max The maximum number of characters to be valid. May be null if there is no max.
         * @param message Validation rule error message.
         */
        constructor(min: number, max: number, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\LocaleAwareCaseInsensitiveComparisonValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface LocaleAwareCaseInsensitiveComparisonFormValidation extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    class LocaleAwareCaseInsensitiveComparisonValidation extends StaticMessageValidation implements LocaleAwareCaseInsensitiveComparisonFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
        /**
         * Validation that uses toLocaleLowerCase() to compare two values.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(compareTo: string, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MaxLengthValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MaxLengthFormValidation extends StaticMessageFormValidation {
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    class MaxLengthValidation extends StaticMessageValidation implements MaxLengthFormValidation {
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         *
         * @param max The maximum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MaxValueValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MaxValueFormValidation extends StaticMessageFormValidation {
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    class MaxValueValidation extends StaticMessageValidation implements MaxValueFormValidation {
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
        /**
         * Constructs a validator that checks whether the value is less than than or equal to the specified maximum number.
         *
         * @param max Maximum field value.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MinLengthValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MinLengthFormValidation extends StaticMessageFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
    }
    class MinLengthValidation extends StaticMessageValidation implements MinLengthFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * Constructs a validator that checks that the value length is at least min.
         *
         * @param min The minimum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MinValueValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MinValueFormValidation extends StaticMessageFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
    }
    class MinValueValidation extends StaticMessageValidation implements MinValueFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         *
         * @param min Minimum field value.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NotContainsCharactersValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotContainsCharactersFormValidation extends StaticMessageFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    class NotContainsCharactersValidation extends StaticMessageValidation implements NotContainsCharactersFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NotContainsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotContainsFormValidation extends StaticMessageFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    class NotContainsValidation extends StaticMessageValidation implements NotContainsFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         *
         * @param search The search string to match.
         * @param message Validation rule error message.
         */
        constructor(searchString: string, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NotRegExMatchValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotRegExMatchFormValidation extends StaticMessageFormValidation {
        /**
         * The regular expression that if matched will cause the field value to fail validation.
         */
        pattern: string;
        /**
         * The message to be displayed when validation fails.
         */
        successMessage?: string;
    }
    class NotRegExMatchValidation extends StaticMessageValidation implements NotRegExMatchFormValidation {
        /**
         * The regular expression that if matched will cause the field value to fail validation.
         */
        pattern: string;
        /**
         * The message to be displayed when validation fails.
         */
        successMessage: string;
        /**
         * Constructs a validator that checks if the value does not match a regular expression.
         *
         * @param pattern Regular expression to test the value against.
         * @param message Validation rule error message.
         */
        constructor(pattern: string, message: string, successMessage?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NumericValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NumericFormValidation extends StaticMessageFormValidation {
    }
    class NumericValidation extends StaticMessageValidation implements NumericFormValidation {
        /**
         * Constructs a validator that checks whether the value is a number.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\RangeValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RangeFormValidation extends StaticMessageFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    class RangeValidation extends StaticMessageValidation implements RangeFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
        constructor(min: number, max: number, message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\RegExMatchValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RegExMatchFormValidation extends StaticMessageFormValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        pattern: string;
        /**
         * The message to be displayed when validation fails.
         */
        successMessage?: string;
    }
    class RegExMatchValidation extends StaticMessageValidation implements RegExMatchFormValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        pattern: string;
        /**
         * The message to be displayed when validation fails.
         */
        successMessage: string;
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param pattern Regular expression pattern to match.
         * @param message The message to show the user when validation fails.
         */
        constructor(pattern: string, message: string, successMessage?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\RequiredValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RequiredFormValidation extends StaticMessageFormValidation {
    }
    class RequiredValidation extends StaticMessageValidation implements RequiredFormValidation {
        /**
         * Constructs and instance of the required validation which will ensure value is non-empty.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(message?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\StaticMessageValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface StaticMessageFormValidation extends FormValidation {
        /**
         * The message to be displayed when validation fails.
         */
        message: string;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid?: KnockoutObservable<boolean>;
    }
    class StaticMessageValidation extends Validation implements StaticMessageFormValidation {
        /**
         * The message to be displayed when validation fails.
         */
        message: string;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(type: FormValidationType, message: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\UriValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface UriValidationOptions {
        /**
         * The url must be an https address.
         */
        requireHttps?: boolean;
    }
    class UriValidation extends StaticMessageValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        options: UriValidationOptions;
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param message The message to show the user when validation fails.
         * @param options Options for the uri validator.
         */
        constructor(message?: string, options?: UriValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\Validation.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Retuns a ValidationResult.
     * If the error message is not a string, returns a success result.
     * Else returns an invalid result with the error message.
     */
    function getValidationResult(err?: string): ValidationResult;
    /**
     * Returns a validation result wrapped in a resolved Q promise.
     * If the error message is not a string, returns a success result.
     * Else returns an invalid result with the error message.
     */
    function getValidationResultPromise(err?: string): Q.Promise<ValidationResult>;
    interface FormValidation {
        /**
         * The type of validation to be performed.
         */
        type: FormValidationType;
        /**
         * Maps the value of the control to the value you want to be validated
         * @param value the value of the control
         * @return the value to be validated
         */
        map?(value: any): any;
    }
    class Validation implements FormValidation {
        /**
         * The type of validation to be performed.
         */
        type: FormValidationType;
        /**
         * Maps the value of the control to the value to be validated
         * @param value the value of the control
         * @return the value to be validated
         */
        map?(value: any): any;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param type The validation type.
         */
        constructor(type: FormValidationType);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\ValidationResult.d.ts
declare module MsPortalFx.ViewModels {
    interface ValidationResult {
        /**
         * Whether or not the field is valid.
         */
        valid: boolean;
        /**
         * The message to show the current state of the validation.
         */
        message: string;
        /**
         * Validation state.
         */
        state?: MsPortalFx.ViewModels.Controls.Validators.ValidationState;
        /**
         * Validation type.
         */
        type?: MsPortalFx.ViewModels.FormValidationType;
    }
}

// FILE: MsPortalFx\ViewModels\FileDownload\FileDownload.d.ts
declare module MsPortalFx.ViewModels.FileDownload {
    import FxBase = MsPortalFx.Base;
    import FxNet = MsPortalFx.Base.Net2;
    const enum Type {
        /**
         * Download file is a text file
         */
        Text = 1,
        /**
         * Download file is a binary file
         */
        Binary = 2
    }
    /**
     * File download status with http response codes.
     */
    class Status {
        /**
         * Indicates the file download status category.
         * Status string will have the AJAX response status ("success", "notmodified", "error", "timeout", "abort", or "parsererror").
         */
        status: string;
        /**
         * Indicates the file download status code which are standard http response code.
         */
        statusCode: number;
        /**
         * Indicates the error message returned by the AJAX call.
         */
        errorMessage: string;
        constructor(status: string, statusCode: number, errorMessage?: string);
    }
    interface DownloadProgressDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        downloadProgressText?: string;
    }
    interface UriCallbackConfirmationDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        uriCallbackProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        uriCallbackProgressText?: string;
        /**
         * MessageBox title string to indicate if file should be downloaded or canceled.
         */
        downloadTitle?: string;
        /**
         * MessageBox description string to indicate if file should be downloaded or canceled.
         */
        downloadText?: string;
        /**
         * MessageBox default button text.
         */
        defaultButtonText?: string;
        /**
         * MessageBox cancel button text.
         */
        cancelButtonText?: string;
    }
    /**
     * Error notification messages for uri callback errors.
     * When uri callback error fails, reject the promise and provide the needed error messages and it will be shown in the hubs notification.
     */
    interface UriCallbackErrorMessage {
        /**
         * Optionally specify the title text for error notification message.
         */
        title?: string;
        /**
         * Optionally specify the description text for error notification message.
         */
        description?: string;
    }
    /**
     * Options for a file download.
     */
    interface Options {
        /**
         * URI for the file download.
         */
        targetUri?: KnockoutObservableBase<string>;
        /**
         * A callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is set, then the targetUri property is not used.
         */
        targetUriCallback?: KnockoutObservableBase<() => MsPortalFx.Base.PromiseV<string>>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod?: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers?: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType?: KnockoutObservableBase<string>;
        /**
         * Optionally specify whether to add default authorization tokens or options for getting authorization tokens.
         */
        addDefaultAuthorizationToken?: boolean | MsPortalFx.Base.Net2.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType?: KnockoutObservableBase<Type>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions?: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart?: () => void;
        /**
         * Callback executed on download end
         */
        onEnd?: (status: Status) => void;
    }
    /**
     * Contract for a file download control.
     */
    class Context {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * A callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is set, then the targetUri property is not used.
         */
        targetUriCallback: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType: KnockoutObservableBase<string>;
        /**
         * Optionally specify options for getting authorization tokens.
         */
        authorizationOptions: FxNet.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType: KnockoutObservableBase<Type>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage: KnockoutObservableBase<string>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<Status>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart: () => void;
        /**
         * Callback executed on download end
         */
        onEnd: (status: Status) => void;
        /**
         * FileDownload command constructor.
         *
         * @param options.
         */
        constructor(options: Options);
    }
}

// FILE: MsPortalFx\ViewModels\FileUpload\FileUpload.d.ts
declare module MsPortalFx.ViewModels.FileUpload {
    import FxPromise = MsPortalFx.Base.Promise;
    import FxPromiseV = MsPortalFx.Base.PromiseV;
    import DynamicBladeSelection = MsPortalFx.ViewModels.DynamicBladeSelection;
    const defaultFullFileUploadMaxSize = 2097152;
    const defaultFullFileUploadChunkSize = 2097152;
    const defaultStreamFileUploadMaxSize = 10737418240;
    const defaultStreamFileUploadChunkSize = 1048576;
    const defaultBlobStoreUploadMaxSize: number;
    const defaultAppendBlobStoreUploadMaxSize: number;
    const defaultPageBlobStoreUploadMaxSize = 1099511627776;
    const defaultAzureFileServiceUploadMaxSize = 1099511627776;
    const defaultBlobStoreUploadChunkSize = 2097152;
    const pageBlobPageSize = 512;
    const defaultResumableTrackingChunkSize: number;
    /**
     *  Specifies how the file content should be uploaded.
     */
    const enum UploadType {
        /**
         *  Full file content will be read. Use this option only for small file sizes less than 2 MB.
         */
        Full = 0,
        /**
         * File content will be read in chunks and provided to user in chunks.
         * Use this option to read large files and if user wants control over where to post the content.
         */
        Stream = 1,
        /**
         *  File upload to block blob store.
         */
        BlockBlobStore = 2,
        /**
         *  File upload to page blob store.
         */
        PageBlobStore = 3,
        /**
         *  File upload to append blob store.
         */
        AppendBlobStore = 4,
        /**
         *  File upload to Azure file service.
         */
        FileService = 5
    }
    /**
     * Specifies how the file content should be read and encoded in memory.
     * These options mimics the html5 file reader options to read the file content.
     */
    const enum ContentType {
        /**
         * By default, file content will be read and stored as binary data in an ArrayBuffer.
         */
        Default = 0,
        /**
         * The file content will be read as plain text.
         * By default the string is encoded in 'UTF-8' format. Use the optional encoding parameter to specify a different format.
         */
        Text = 1,
        /**
         * The file content will be available in an ArrayBuffer.
         */
        ArrayBuffer = 2,
        /**
         * The file content will be encoded in the data uri scheme. Use this option for images and if those need to be directly shown in img tag.
         */
        DataUri = 3
    }
    /**
     * File upload status.
     */
    const enum UploadStatus {
        /**
         * Invalid.
         */
        Invalid = 0,
        /**
         * Pending.
         */
        Pending = 1,
        /**
         * Uploading.
         */
        Uploading = 2,
        /**
         * Paused.
         */
        Paused = 3,
        /**
         * Complete.
         */
        Complete = 4,
        /**
         * Canceled.
         */
        Canceled = 5,
        /**
         * Aborted.
         */
        Aborted = 6
    }
    /**
     * Upload action performed on upload task. This enum is used internally by upload framework.
     */
    const enum UploadAction {
        /**
         * No-op.
         */
        None = 0,
        /**
         * Pause the current upload task.
         */
        Pause = 1,
        /**
         * Resume the current upload task.
         */
        Resume = 2,
        /**
         * Cancel the current upload task
         */
        Cancel = 3,
        /**
         * Dispose the current upload task.
         */
        Dispose = 4,
        /**
         * Add selected file to upload task array.
         */
        AddUploadTasks = 5,
        /**
         * Reset Upload task array.
         */
        ResetUploadTasks = 6,
        /**
         * Complete the current upload task.
         * This action is used for streaming file upload to indicate the completion of the upload.
         */
        Complete = 7,
        /**
         * Abort the current upload task.
         * This action is used for aborting the current upload due to runtime errors.
         */
        Abort = 8,
        /**
         * Gets the next file chunk for streaming upload.
         * This action is used for streaming file upload to get the next file chunk.
         */
        GetNextChunk = 9
    }
    /**
     * Access tier values for blob.
     */
    const enum BlobAccessTier {
        /**
         * Optimized for storing data that is accessed frequently.
         */
        Hot = 0,
        /**
         * Optimized for storing data that is infrequently accessed and stored for at least 30 days.
         */
        Cool = 1,
        /**
         * Optimized for storing data that is rarely accessed and stored for at least 180 days with flexible latency requirements
         */
        Archive = 2
    }
    /**
     * Resource strings to override the default messages.
     */
    interface ResourceStrings {
        /**
         * Override the default validation message for invalid allowed file extension.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileExtensionInvalidErrorMessage?: string;
        /**
         * Override the default validation message for file size greater than provided max file size.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         * {1} - Max file size.
         * {2} - File size.
         */
        fileSizeInvalidErrorMessage?: string;
        /**
         * Override the default message when runtime file read error occurs.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileReadAbortedErrorMessage?: string;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    interface UploadContext {
        /**
         * Specify how/where the file should be uploaded.
         */
        type: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    interface FullFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    interface StreamFileUploadOptions extends FullFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning?: boolean;
    }
    interface BlobStoreFileUploadOptions<T> extends FullFileUploadOptions {
        /**
         * Specify how/where the file should be uploaded.
         */
        type?: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context?: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext?: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand?: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback?: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri?: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext?: AuthorizationContext<T>;
        /**
         * Specifies access tier for blob.
         */
        accessTier?: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders?: ReadonlyStringMap<string>;
    }
    /**
     * Defines how the uploaded file content will be available for the user.
     */
    interface UploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: UploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
    }
    /**
     * Holds the full file uploaded content.
     */
    interface FullFileUploadContent extends UploadContent {
        /**
         * The full file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
    }
    /**
     * Holds the streamed file chunks and start/end bytes.
     */
    interface StreamFileUploadContent extends UploadContent {
        /**
         * The chunked file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
        /**
         * The startbyte of the chunk.
         */
        startByte: number;
        /**
         * The endbyte of the chunk.
         */
        endByte: number;
    }
    /**
     * File upload result will hold the upload status, current progress and upload content.
     */
    interface UploadResult {
        /**
         * The current status of the upload task.
         */
        status: UploadStatus;
        /**
         * The percent complete of the upload task.
         */
        progressPercent: number;
        /**
         * File upload content will be available in memory based on the specified upload type and content type.
         */
        data: UploadContent;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: string;
    }
    /**
     * Each file upload task is represented by a unique key. This is used for all management operations to locate the uploads.
     */
    interface UploadKey {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
    }
    /**
     * Context info sent as part of various upload task actions.
     */
    interface ActionContext {
    }
    /**
     * Resumable context needed to resume uploads across browser session.
     * This is an optional property in ResumeContext and presence of this property in ResumeContext indicates the intent to resume an upload after browser refresh/crash/close.
     */
    interface ResumableContext {
        /**
         * Upload key of the initial upload which was stopped due to browser refresh/crash/close.
         * The upload id is used to lookup the persisted/tracked uploaded byte resumable information.
         */
        originalUploadKey: UploadKey;
    }
    /**
     * Optional context information passed to the resume API.
     * Resume is called to start a new upload, start a new upload overriding upload context, resume an in-memory paused upload and resume an upload across browser session.
     * Resume context provides adequate context to enable above resume scenarios.
     */
    interface ResumeContext extends ActionContext {
        /**
         * Optional upload context information to override the default upload context specified in the view model.
         * For multi-select scenarios the default context will be applied to all uploads.
         * If upload type or content type needs to be overridden for a particular upload,
         * a new upload context information can be sent as part of resume context.
         */
        uploadContext?: UploadContext;
        /**
         * For resuming the upload across browser refresh/crash/close scenario, pass in the resumableContext with the upload key for the paused upload.
         * A list of paused uploads due to browser refresh/crash/close will be made avaiable via getResumableUploadInfo API which will have all necessary information including the upload key.
         */
        resumableContext?: ResumableContext;
    }
    /**
     * Optional abort context information sent when upload is aborted.
     */
    interface AbortContext extends ActionContext {
        /**
         * An error message / reason for aborting the file upload.
         */
        reason?: string;
    }
    /**
     *  Optional dispose context information sent when upload is disposed.
     */
    interface DisposeContext extends ActionContext {
        /**
         * Optional flag to indicate if resumable info needs to be deleted.
         * Setting it to true will cleanup both in-memory resumable info as well as persisted/tracked resumable info unless there is an ongoing upload with that upload key.
         */
        resumable?: boolean;
    }
    /**
     * Optional chunk context sent when fetching the next file chunk via GetNextChunk API.
     */
    interface ChunkContext extends ActionContext {
        /**
         * Optionally specify the start byte offset.
         */
        startByte?: number;
        /**
         * Optionally specify the chunk size otherwise the default 2 MB will be used.
         */
        chunkSize?: number;
    }
    /**
     * Upload action callback interface used by the upload widget.
     */
    interface UploadActionCallback {
        /**
         * Upload action callback interface used by the upload widget.
         *
         * @param uploadKeys Array of unique identifier for the each upload task.
         * @param action Upload action that needs to be performed like resume/pause/cancel/dispose.
         */
        (uploadKeys: UploadKey[], action: UploadAction, context?: ActionContext): FxPromise;
    }
    /**
     * Streaming upload callback interface used by the upload widget.
     */
    interface GetNextChunkCallback {
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param uploadKeys Array of unique identifier for the each upload task.
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        (uploadKey: UploadKey, startByte?: number, chunkSize?: number): FxPromiseV<StreamFileUploadContent>;
    }
    /**
     * File information.
     */
    interface FileInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     */
    interface SelectedFileContract extends FileInfoContract {
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
    }
    /**
     * Upload information.
     */
    interface UploadInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: KnockoutReadOnlyObservableBase<string>;
        /**
         * Upload category tag provided by extension.
         */
        category: KnockoutReadOnlyObservableBase<string>;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Upload type.
         */
        type: KnockoutReadOnlyObservableBase<UploadType>;
        /**
         * Upload destination like target blob store uri .
         */
        target: KnockoutReadOnlyObservableBase<string>;
        /**
         * The current status of the upload task.
         */
        status: KnockoutReadOnlyObservableBase<UploadStatus>;
        /**
         * The total bytes that have been uploaded/streamed.
         */
        uploadedBytes: KnockoutReadOnlyObservableBase<number>;
        /**
         * The percent complete of the upload task. The values will be in 0-100 range.
         */
        progressPercent: KnockoutReadOnlyObservableBase<number>;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * File upload details, status and content.
     */
    interface UploadTaskContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * The object representing the uploaded status/content for this file.
         */
        uploadResult: KnockoutObservableBase<UploadResult>;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         */
        resume: () => void;
        /**
         * Method to dispose the current file upload. Dispose will cacel the ongoing upload and will do the needed cleanup.
         */
        dispose: () => void;
        /**
         * Method to cancel the current file upload.
         */
        cancel: () => void;
        /**
         * Method to pause the current file upload.
         */
        pause?: () => void;
    }
    /**
     * Async file upload task with upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     */
    interface AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @return Promise indicating the success or failure or the operation.
         */
        resume: (context?: ResumeContext) => FxPromise;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        pause?: () => FxPromise;
        /**
         * Method to cancel the current file upload.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        cancel: () => FxPromise;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        complete: () => FxPromise;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @return Promise indicating the success or failure or the operation.
         */
        abort: (context?: AbortContext) => FxPromise;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        dispose: () => FxPromise;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk: (startByte?: number, chunkSize?: number) => FxPromiseV<StreamFileUploadContent>;
    }
    /**
     * View model contract for file upload.
     */
    interface UploadContract {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept?: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection: KnockoutObservableBase<boolean>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress and content.
         * UploadTask is used to initiate the file upload, resume steaming uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutObservableArray<UploadTaskContract>;
    }
    /**
     * Defines SAS uri info needed for periodic SAS uri renewal.
     */
    interface SasUriInfo {
        /**
         * Specify the SAS uri
         */
        uri: string;
        /**
         * Specify the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    interface OauthHeaderInfo {
        /**
         * Specifies the URI including the blob.
         */
        uri: string;
        /**
         * Bearer token with permissions to write to this Storage Account.
         */
        authorizationHeader: string;
        /**
         * Specifies the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    /**
     * The type of Authorization used in making the upload call to the BlobStore.
     */
    const enum BlobStoreAuthorizationType {
        /**
         * Authorization using an Open Authorization (Bearer token) standard.
         */
        Oauth = 0,
        /**
         * Authorization using a Shared Access Signature..
         */
        SAS = 1
    }
    /**
     * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
     */
    interface AuthorizationContext<T> {
        /**
         * Call to fetch required credentials for the given container or storage account.
         * @param fileInfo Metadata about the current file being uploaded. This can be used to renew the correct authorization for that file.
         * @param context The context object specified by the extension to this control. This may be used to pass back specific information needed to fetch authorization in renew scenario.
         * @return A Promise with either the SASUri info or the OAUTHHeader info depending on the type of authentication this control should use.
         */
        fetchAuthorization: (fileInfo: FileInfoContract, context: T) => Q.Promise<SasUriInfo | OauthHeaderInfo>;
    }
    /**
     * API to get the list of upload information for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of upload information.
     */
    function getUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): MsPortalFx.Base.PromiseV<UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of resumable upload information.
     */
    function getResumableUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): MsPortalFx.Base.PromiseV<UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return Promise which contains the array of AsyncUploadTask objects.
     */
    function getAsyncUploadTasks(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): MsPortalFx.Base.PromiseV<AsyncUploadTaskContract[]>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @return A promise indicating success or failure of the management operation.
     */
    function invokeUploadAction<TResult>(uploadKey: UploadKey, action: UploadAction, context?: ActionContext): MsPortalFx.Base.PromiseV<TResult>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the start byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @return A promise indicating success or failure of the operation.
     */
    function getNextChunk(uploadKey: UploadKey, startByte?: number, chunkSize?: number): MsPortalFx.Base.PromiseV<StreamFileUploadContent>;
    /**
     * API to register a SAS uri renewal callback which will be called when the SAS uri is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the
     * SAS uri renewal for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @return A promise returning the SasUriInfo on successful completion.
     */
    function registerRenewSasUriCallback<T>(callback: (fileInfo: FileInfoContract, context?: T) => Q.Promise<SasUriInfo>): void;
    /**
     * API to register an authorization renewal callback which will be called when the current authorization is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the OAUTH or SAS renewal
     * for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     * @param authorizationType: The type of authorization to renew.
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @return A promise returning the SasUriInfo or OauthHeaderInfor on successful completion.
     */
    function registerRenewAuthorizationCallback<T>(callback: (authorizationType: MsPortalFx.ViewModels.FileUpload.BlobStoreAuthorizationType, fileInfo: FileUpload.FileInfoContract, context?: T) => Q.Promise<FileUpload.SasUriInfo | FileUpload.OauthHeaderInfo>): void;
    /**
     * Full file upload context.
     */
    class FullFileUploadContext implements UploadContext {
        /**
         * Full file will be read and the entire content will be available in memory.
         */
        type: UploadType;
        /**
         * File content will be stored by default in an array buffer.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding: string;
        /**
         * Specify the maximum file size that can be uploaded.
         * Recommended max file is less than 2 MB for this upload type.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded.
         * Default chunk size should be same as maxFileSize for fill file download.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings: ResourceStrings;
        constructor(options?: FullFileUploadOptions);
    }
    /**
     * Stream file upload context. File will be read in chunks and chunked content will be available in memory.
     */
    class StreamFileUploadContext extends FullFileUploadContext implements UploadContext {
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning: boolean;
        /**
         * Initialize default properties for stream file upload context.
         */
        constructor(options?: StreamFileUploadOptions);
    }
    /**
     * BlobStore file upload context. File will be uploaded directly to blob store specified by the SAS uri.
     */
    class BlobStoreFileUploadContext<T> extends FullFileUploadContext implements UploadContext {
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext: AuthorizationContext<T>;
        /**
         * Specify the access tier for blob.
         */
        accessTier: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders: ReadonlyStringMap<string>;
        /**
         * Initialize default properties for blob store file upload context.
         */
        constructor(options?: BlobStoreFileUploadOptions<T>);
    }
    /**
     * UploadTask represent the file details, status, upload progress and content.
     */
    class UploadTask implements UploadTaskContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * The object representing the uploaded status/content for this file.
         */
        uploadResult: KnockoutObservableBase<UploadResult>;
        /**
         * An internal enum to track the upload action.
         */
        _msPortalFxUploadAction: KnockoutObservableBase<UploadAction>;
        /**
         * An internal counter to track the upload action.
         */
        _msPortalFxActionTrigger: KnockoutObservableBase<number>;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         */
        resume(): void;
        /**
         * Method to pause the current file upload.
         */
        pause(): void;
        /**
         * Method to cancel the current file upload.
         */
        cancel(): void;
        /**
         * Method to dispose the current file upload. Dispose will cacel the ongoing upload and will do the needed cleanup.
         */
        dispose(): void;
    }
    /**
     * AsyncUploadTask represent the upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     * AsyncUploadTask instance will be returned when getAsyncUploadTasks is called by extension.
     * AsyncUploadTask interacts directly with the shell APIs exposed to interact with global file upload manager.
     */
    class AsyncUploadTask implements AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Creates and instance of AsyncUploadTask.
         *
         * @param uploadInfo Upload information.
         */
        constructor(uploadInfo: UploadInfoContract);
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @return Promise indicating the success or failure or the operation.
         */
        resume(context?: ResumeContext): FxPromise;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        pause(): FxPromise;
        /**
         * Method to cancel the current file upload.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        cancel(): FxPromise;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        complete(): FxPromise;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @return Promise indicating the success or failure or the operation.
         */
        abort(context?: AbortContext): FxPromise;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        dispose(): FxPromise;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk(startByte?: number, chunkSize?: number): FxPromiseV<StreamFileUploadContent>;
    }
    /**
     * AsyncUploadWidgetTask represent the upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     * AsyncUploadWidgetTask is used by the upload widget to manage temprorary UX interaction around file selection.
     * The management operations supported by AsyncUploadWidgetTask will go through the widget and widget will delegate the call to global upload manager.
     */
    class AsyncUploadWidgetTask implements AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Callback to handle upload management operations. The callback is populated by the upload widget which will then delegate the needed action to the global upload manager.
         */
        _msPortalFxActionCallback: KnockoutObservableBase<UploadActionCallback>;
        /**
         * Callback to handle streaming uploads to fetch the next file chunk.
         */
        _msPortalFxGetNextChunkCallback: KnockoutObservableBase<GetNextChunkCallback>;
        /**
         * Creates and instance of AsyncUploadTask.
         *
         * @param uploadInfo Upload information.
         * @param uploadActionCallback Callback to invoke management operation on the upload widget.
         */
        constructor(uploadInfo: UploadInfoContract, uploadActionCallback: UploadActionCallback, getNextChunkCallback: GetNextChunkCallback);
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @return Promise indicating the success or failure of the operation.
         */
        resume(context?: ResumeContext): FxPromise;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        pause(): FxPromise;
        /**
         * Method to cancel the current file upload.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        cancel(): FxPromise;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        complete(): FxPromise;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @return Promise indicating the success or failure or the operation.
         */
        abort(context?: AbortContext): FxPromise;
        /**
         * Method to dispose the current file upload. Dispose will abort the ongoing upload and will do the needed cleanup.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        dispose(): FxPromise;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk(startByte?: number, chunkSize?: number): Q.Promise<StreamFileUploadContent>;
        private _invoke;
        _execCallback<U>(callbackOb: KnockoutObservableBase<UploadActionCallback | GetNextChunkCallback>, ...args: any[]): Q.Promise<U>;
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The SelectedFile has the core file properties that will be surfaced to the extension.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     */
    class SelectedFile implements SelectedFileContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Creates and instance of SelectedFile.
         *
         * @param fileInfo File information.
         */
        constructor(fileInfo: FileInfoContract);
    }
}

// FILE: MsPortalFx\ViewModels\FileUpload\Internal\Internal.FileUpload.UploadManager.d.ts
declare module FxImpl.FileUpload {
    import FxFileUpload = MsPortalFx.ViewModels.FileUpload;
    import Rpc = FxImpl.Rpc;
    import FxLifetime = MsPortalFx.Base.LifetimeManager;
    /**
     * Upload info params used in shell APIs to get the list of uploads.
     */
    interface UploadInfoParams {
        /**
         * Array of upload keys.
         */
        uploadKeys: FxFileUpload.UploadKey[];
        /**
         * Upload category tag provided by extension.
         */
        category?: string;
        /**
         * Get resumable upload information. This is a optional param and when set to true will get the resumable uplaod information.
         */
        resumable?: boolean;
    }
    /**
     * Upload info list.
     */
    interface UploadInfoList {
        /**
         * Array of upload infos.
         */
        uploads: FxFileUpload.UploadInfoContract[];
    }
    /**
     * Upload action params is used to specify what management operation to perform on file uploads.
     */
    interface UploadActionParams {
        /**
         * Unique upload identifier to lookup the async upload task.
         */
        uploadKey: FxFileUpload.UploadKey;
        /**
         * Upload management operation enum.
         */
        action: FxFileUpload.UploadAction;
        /**
         * Upload management action specific context information.
         */
        context?: FxFileUpload.ActionContext;
    }
    /**
     * Parameters that will be passed when SAS uri renewal RPC method is invoked.
     */
    interface UploadRenewSasUriParams<T> {
        /**
         * A FileInfoContract object will be passed.
         */
        fileInfo: FxFileUpload.FileInfoContract;
        /**
         * Extension can optionally provide additional data to the SAS uri callback in the UploadContext's context property.
         */
        context?: T;
    }
    interface UploadRenewAuthorizationParams<T> extends UploadRenewSasUriParams<T> {
        authorizationType: FxFileUpload.BlobStoreAuthorizationType;
    }
    /**
     * Rpc endpoint for communicating with the shell's global file upload manager.
     * ProxiedObjectTypeDefinition is used so that upload info with observable properties can be proxied across via the acquireObject call.
     * The enpoint is used to get the list of upload information for a given set of upload keys.
     */
    const getUploadInfosEndPoint: Rpc.ProxiedObjectTypeDefinition<UploadInfoParams, UploadInfoList>;
    /**
     * Rpc endpoint for communicating with the shell's global file upload manager to perform upload management operations.
     * The endpoint is used to perform Resume/Pause/Cancel/Dispose action on an existing async upload in shell.
     */
    const uploadActionEndPoint: Rpc.ActionEndPointDefinition<UploadActionParams>;
    /**
     * Rpc endpoint for Shell to communicate with the extension to invoke a SAS uri renewal callback.
     * This endpoint will be registered by the extension. The extension can be unloaded while the upload is in progress.
     * This endpoint registration will load the extension and then invoke the registered callback.
     */
    const uploadRenewSasUriEndPoint: Rpc.FuncEndPointDefinition<UploadRenewSasUriParams<any>, FxFileUpload.SasUriInfo>;
    /**
     * Rpc endpoint for Shell to communicate with the extension to invoke an authorization renewal callback.
     * This endpoint will be registered by the extension. The extension can be unloaded while the upload is in progress.
     * This endpoint registration will load the extension and then invoke the registered callback.
     */
    const uploadRenewAuthorizationEndPoint: Rpc.FuncEndPointDefinition<UploadRenewAuthorizationParams<any>, FxFileUpload.SasUriInfo | FxFileUpload.OauthHeaderInfo>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     * This API uses Rpc uploadActionEndPoint to communicate with the shell's global file upload manager.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @return A promise indicating success or failure of the management operation.
     */
    function invokeUploadAction(uploadKey: FxFileUpload.UploadKey, action: FxFileUpload.UploadAction, context?: FxFileUpload.ActionContext): MsPortalFx.Base.Promise;
    /**
     * API to get the list of upload information for given set of upload keys.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of upload information.
     */
    function getUploadInfos(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): Q.Promise<FxFileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of resumable upload information.
     */
    function getResumableUploadInfos(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): Q.Promise<FxFileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return Promise which contains the array of AsyncUploadTask objects.
     */
    function getAsyncUploadTasks(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): Q.Promise<FxFileUpload.AsyncUploadTaskContract[]>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the starting byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @return A promise indicating success or failure of the operation.
     */
    function getNextChunk(uploadKey: FxFileUpload.UploadKey, startByte?: number, chunkSize?: number): MsPortalFx.Base.PromiseV<FxFileUpload.StreamFileUploadContent>;
    /**
     * API to register a SAS uri renewal callback which will be called when the SAS uri is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the
     * SAS uri renewal for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @return A promise returning the SasUriInfo on successful completion.
     */
    function registerRenewSasUriCallback(callback: (fileInfo: FxFileUpload.FileInfoContract, context?: any) => Q.Promise<FxFileUpload.SasUriInfo>): void;
    /**
     * API to register an authorization renewal callback which will be called when the current authorization is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the OAUTH or SAS renewal
     * for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     * @param authorizationType: The type of authorization to renew.
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @return A promise returning the SasUriInfo or OauthHeaderInfor on successful completion.
     */
    function registerRenewAuthorizationCallback(callback: (authorizationType: FxFileUpload.BlobStoreAuthorizationType, fileInfo: FxFileUpload.FileInfoContract, context?: any) => Q.Promise<FxFileUpload.SasUriInfo | FxFileUpload.OauthHeaderInfo>): void;
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Base.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface TelemetryKeys {
        /**
         * Key used in focus logging
         */
        focus: string;
    }
}
declare module MsPortalFx.ViewModels.Forms.Base.Input {
    interface Options<T> extends LabelAndBalloon.Options {
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: KnockoutObservableArray<MsPortalFx.ViewModels.FormValidation>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue?: KnockoutObservableBase<T>;
        /**
         * Keys used in telemetry logging.
         */
        telemetryKeys?: TelemetryKeys;
        /**
         * When set to true, only changes made by the end user are considered dirty.
         * This should not be set when using an edit scope.
         */
        viewModelValueChangesAreClean?: boolean;
        /**
         * Show validation error message below the control (false by default).
         */
        showValidationMessagesBelowControl?: boolean;
    }
    class ViewModel<T> extends LabelAndBalloon.ViewModel {
        /**
         * A list of validations that should be applied to the form field.
         */
        validations: KnockoutObservableArray<MsPortalFx.ViewModels.FormValidation>;
        /**
         * A list of validation results.
         */
        validationResults: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservable<string>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue: KnockoutObservableBase<T>;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation: KnockoutObservableBase<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * Current value of the field.
         */
        value: KnockoutObservableBase<T>;
        /**
         * Initial value for the field.
         */
        initialValue: KnockoutObservableBase<T>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation: KnockoutObservable<number>;
        /**
         * Keys used in telemetry logging
         */
        telemetryKeys: TelemetryKeys;
        /**
         * Show validation error message below the control.
         */
        showValidationMessagesBelowControl: boolean;
        _msPortalFxViewModelValueChangesAreClean: boolean;
        _msPortalFxWidgetValue: KnockoutObservable<T>;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        _msPortalFxTriggerValidation: KnockoutObservable<() => Q.Promise<boolean>>;
        _enableValidationReactor: KnockoutComputed<void>;
        _options: Base.Input.Options<T>;
        private _editScopeAccessors;
        private _form;
        private _previousEditScope;
        private _dirtyLifetime;
        private _originalDirty;
        protected resetDirtyComputed(dirtyComputedFunc: () => void): void;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the Field is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the Field control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, formOrOptions: Form.ViewModel<any>, pathOrAccessor: any, options?: Options<T>);
        /**
         * Set the EditScopeAccessors used to integrate with EditScope for original and edited values.
         * Note: In most cases, it's best to use the observablePath parameter when instantiating a field, which
         *  will automatically configure the field with EditScopeAccessors. Use this override only if you know what you're doing.
         *
         * @param editScopeAccessors The EditScopeAccessors instance to be used for the original and edited values of this field.
         * @param form Optional. The form whose edit scope drives the editScopeAccessors (if one exists).
         */
        _setEditScopeAccessors(editScopeAccessors: EditScopeAccessors<T>, form?: Form.ViewModel<T>): void;
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): Q.Promise<any>;
        /**
         * A helper function for triggering validation of the control.
         * @return A promise that is resolved when the validation has been completed.
         */
        triggerValidation(): Q.Promise<boolean>;
        private _initializeFieldStateObservables;
        private _newThisValueBinding;
        private createValueSubscriptions;
        setDirty(value: boolean): void;
        private setValue;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\EditScopeAccessors.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface EditScopeAccessors<TValue> extends MsPortalFx.Data.EditScopeAccessors<TValue> {
    }
    module EditScopeAccessors {
        /**
         * Describes how to read and write values on an edit scope.
         */
        interface Options<TEditScope, TValue> {
            /**
             * Reads data from an edit scope.
             *
             * @param editScopeData The root data object held by the edit scope.
             * @return The value that this edit scope accessor supplies.
             */
            readFromEditScope: (editScopeData: TEditScope) => TValue;
            /**
             * Writes data to an edit scope.
             *
             * @param editScopeData The root data object held by the edit scope. This method should write the new value to this object.
             * @param newValue The value to be written. Typically this comes from a UI element whose value has changed.
             */
            writeToEditScope: (editScopeData: TEditScope, newValue: TValue) => void;
        }
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Editable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Editable {
    interface Options<T> extends Input.Options<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText?: KnockoutObservableBase<string>;
    }
    class ViewModel<T> extends Nullable.ViewModel<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText: KnockoutObservableBase<string>;
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the EditableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Editable.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\EditableComboBox.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.EditableComboBox {
    const enum PositioningAlignment {
        /**
         * Left edge for horizontal alignment, top edge for vertical alignment.
         */
        LeftTop = 3,
        /**
         * Right edge for horizontal alignment, top edge for vertical alignment.
         */
        RightTop = 5,
        /**
         * Left edge for horizontal alignment, bottom edge for vertical alignment.
         */
        LeftBottom = 10,
        /**
         * Right edge for horizontal alignment, bottom edge for vertical alignment.
         */
        RightBottom = 12
    }
    interface Options<T> extends Editable.Options<T> {
        /**
         * Alignment used for drop popup.
         */
        popupAlignment?: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment?: PositioningAlignment;
    }
    /**
     * Base class for combo fields
     */
    class ViewModel<T> extends Editable.ViewModel<T> {
        /**
         * Alignment used for drop popup.
         */
        popupAlignment: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment: PositioningAlignment;
        /**
         * Constructs and instance of an editable combo field.
         * (Base class for other combo fields)
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the EditableComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: EditableComboBox.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Form.d.ts
declare module MsPortalFx.ViewModels.Forms.Form {
    enum EditScopeObservableType {
        Original = 0,
        Editable = 1
    }
    /**
     * @deprecated Form.FieldValueAccessorType is deprecated Use EditScopeObservableType instead.
     * This type will be removed in the future.
     */
    type FieldValueAccessorType = EditScopeObservableType;
    interface InternalEditScopeAccessors extends EditScopeAccessors<any>, FxImpl.Data.InternalEditScopeAccessors {
        createdByBaseFormClass: boolean;
    }
    /**
     * The function type for those lambdas that are passed to Form's 'createEditScopeAccessor' and 'createCustomEditScopeAccessor'.
     * See Form.createEditScopeAccessor and Form.createCustomEditScopeAccessor.
     */
    interface ObservableAccessorFunction<T, TValue> {
        (data: T, lifetimeManager: MsPortalFx.Base.LifetimeManager, type: EditScopeObservableType): KnockoutObservableBase<TValue>;
    }
    /**
     * A view model representing a form.
     */
    class ViewModel<T> implements MsPortalFx.Base.Disposable {
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * The list of form sections contained in the form.
         */
        sections: KnockoutObservableArray<Base.Section>;
        /**
         * When set to true, changes to viewmodel values initiated by the extension will also write to the initial value of the edit scope.
         * What this means is that the control will not appear dirty to the user, nor will there be an alert if the user does not change the value in the control.
         */
        viewModelValueChangesSetDefaultValues: boolean;
        private _editScope;
        private _getNestedData;
        protected readonly _ltm: MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Creates a Form instance.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param editScope An optional observable that supplies an EditScope to the form (for instance, as master
         * selection changes for this details form).  If not supplied here, then the 'editScope' property should be set
         * before using this view model.
         * @param getNestedData An optional function that returns a nested object from which fields will be retrieved,
         * given either the original or editable root object of the EditScope.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, editScope?: KnockoutObservable<MsPortalFx.Data.EditScope<any>>, getNestedData?: (data: any) => T);
        /**
         * Sets the view model's edit scope observable.
         *
         * @param editScope An observable that supplies an EditScope to the form (for instance, as master selection
         * changes for this details form).
         */
        set editScope(editScope: KnockoutObservable<MsPortalFx.Data.EditScope<any>>);
        /**
         * Gets the view model's edit scope observable.
         *
         * @return The view model's edit scope observable.
         */
        get editScope(): KnockoutObservable<MsPortalFx.Data.EditScope<any>>;
        dispose(): void;
        _createEditScopeAccessorFromPath<TValue>(observablePath: string): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is used by both forms fields and collectors.
         *
         * @param options Methods for reading and writing to an edit scope.
         * @return EditScopeAccessors instance used by a form field and/or by collectors.
         */
        createEditScopeAccessor<TValue>(options: EditScopeAccessors.Options<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is used by both forms fields and collectors.
         *
         * @param observableAccessor A function which accesses a property on the edit scope.  ie: (data) => { return data.myProperty }
         * @return EditScopeAccessors instance used by a form field and/or by collectors.
         */
        createEditScopeAccessor<TValue>(observableAccessor: ObservableAccessorFunction<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is an advanced option without runtime validation of the options passed in.
         * Use createEditScopeAccessor instead of this method wherever possible.
         *
         * @param options Methods for reading and writing to an edit scope.
         * @return EditScopeAccessors instance used by a form field.
         */
        createCustomEditScopeAccessor<TValue>(options: EditScopeAccessors.Options<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is an advanced option without runtime validation of the observableAccessor lambda.
         * Use createEditScopeAccessor instead of this method wherever possible
         *
         * @param observableAccessor A function which accesses the observable.
         * @return EditScopeAccessors instance used by a form field.
         */
        createCustomEditScopeAccessor<TValue>(observableAccessor: ObservableAccessorFunction<T, TValue>): EditScopeAccessors<TValue>;
        protected static _logEditScopeAccessorError(message: string): void;
        private _createEditScopeAccessorFromAccessorFunction;
        private _createEditScopeAccessorFromOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Groups.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Groups {
    interface Options<T> extends Input.Options<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the GroupsField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the GroupsField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Groups.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\LabelAndBalloon.d.ts
declare module MsPortalFx.ViewModels.Forms {
    import Fx = MsPortalFx;
    import FxForms = Fx.ViewModels.Forms;
    /**
     * The position of the label in a form element.
     * Note: Only works within Sections. Check samples here: http://localhost:55555/Portal/#blade/SamplesExtension/LabelPositionFormsBlade
     */
    enum LabelPosition {
        /**
         * A top aligned label. Default.
         */
        Top = 0,
        /**
         * A left aligned label.
         */
        Left = 1,
        /**
         * An invisible label.
         */
        Hidden = 2
    }
    /**
     * The position of the sublabel in a form element.
     */
    enum SubLabelPosition {
        /**
         * A Bottom aligned sublabel. Default.
         */
        Bottom = 0,
        /**
         * A right aligned sublabel.
         */
        Right = 1
    }
    module Base.LabelAndBalloon {
        /**
         * Options to render a form element with a label and info balloon.
         */
        interface Options extends MsPortalFx.ViewModels.Controls.Loadable.Options {
            /**
             * Label for the field.
             */
            label?: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Label position for the field.
             */
            labelPosition?: KnockoutObservable<FxForms.LabelPosition>;
            /**
             * SubLabel position for the field.
             */
            subLabelPosition?: KnockoutObservableBase<FxForms.SubLabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies sanitized HTML that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent?: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies Link object that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonLinkContent?: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
            /**
             * Specifies whether to hide the validation check marks.
             */
            hideValidationCheck?: KnockoutObservableBase<boolean> | boolean;
            /**
             * A custom css class to apply to the control.
             */
            cssClass?: string | KnockoutObservableBase<string>;
            /**
             * Whether the form element is visible.
             */
            visible?: boolean | KnockoutObservableBase<boolean>;
        }
        /**
         * Implements LabelAndBalloonContract.
         */
        class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel {
            /**
             * Label for the field.
             */
            label: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Label for the field.
             */
            labelPosition: KnockoutObservable<FxForms.LabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabelPosition: KnockoutObservableBase<FxForms.SubLabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabel: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies text that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies Link object that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonLinkContent: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
            /**
             * Specifies whether to hide the validation check marks.
             */
            hideValidationCheck: KnockoutObservableBase<boolean> | boolean;
            /**
             * A custom css class to apply to the control.
             */
            readonly cssClass: KnockoutObservableBase<string>;
            /**
             * Whether the form element is visible.
             */
            readonly visible: KnockoutObservableBase<boolean>;
            /**
             * Internal implementation detail.
             */
            _msPortalFxLeftLabelWidth: KnockoutObservable<number>;
            /**
             * Internal implementation detail.
             */
            _msPortalFxRequired: KnockoutObservable<boolean>;
            /**
             * Internal implementation detail.
             */
            _msPortalFxOldControl: boolean;
            /**
             * Abstract base class. Do not use this class directly.
             *
             * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
             * @param label Optional. Text for the label for this form field.
             * @param infoBalloonContent Optional. A list of validations to be applied to the field.
             */
            constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: LabelAndBalloon.Options);
        }
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Nullable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Nullable {
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutComputed<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the NullableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the NullableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Editable.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Options.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Options {
    interface Options<T> extends Input.Options<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options?: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OptionsField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the OptionsField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Options.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\SectionBase.d.ts
declare module MsPortalFx.ViewModels.Forms.Base {
    interface Section extends FormElement {
        /**
         * Indicates if the sections or controls within the widget are currently valid.
         */
        valid: KnockoutObservableBase<boolean>;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\SliderBase.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Slider {
    interface Options<T> extends Input.Options<T> {
        /**
         * Minimum value of the slider.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step?: number | KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optional text for screen reader, name for this slider.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * Minimum value for the field.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value for the field.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Text for screen reader, name for this slider.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs an instance of a slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SliderBaseField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the SliderBaseField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Typable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Typable {
    interface Options<T> extends Editable.Options<T> {
        /**
         * When value update trigger is set to fire on every keypress this is the timeout between value updates before validation runs.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout?: KnockoutObservable<number>;
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger?: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: T) => void;
    }
    class ViewModel<T> extends Editable.ViewModel<T> {
        /**
         * When value update trigger is set to fire on every keypress this is the timeout between value updates before validation runs.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed: (value: T) => void;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the EditableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Typable.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\CheckBox.d.ts
declare module MsPortalFx.ViewModels.Forms.CheckBox {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.CheckBox.Options. Please use Fx/Controls/CheckBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options extends Base.Input.Options<boolean> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel?: boolean;
        /**
         * Aria label for the CheckBox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.CheckBox.ViewModel. Please use Fx/Controls/CheckBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Base.Input.ViewModel<boolean> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel: boolean;
        /**
         * Aria label for CheckBox.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a CheckBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CheckBox.Options);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CheckBox.Options);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<boolean>, options?: CheckBox.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\CreatorAndComboBox.d.ts
declare module FxImpl.ViewModels.Forms.CreatorAndComboBox {
    /**
     * CreatorAndComboBox control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Mode: Obsolete;
    /**
     * CreatorAndComboBox control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const AllowedMode: Obsolete;
    /**
     * CreatorAndComboBox control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * CreatorAndComboBox control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\CreatorAndSelectorV2.d.ts
declare module MsPortalFx.ViewModels.Forms.CreatorAndSelectorV2 {
    /**
     * @deprecated CreatorAndSelectorV2.CreatorAndSelectorValue is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface CreatorAndSelectorValue {
        /**
         * Text box value or selected value
         */
        value: any;
        /**
         * True if displaying creator, false for selector
         */
        createNew: boolean;
    }
    /**
     * @deprecated CreatorAndSelectorV2.Mode is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    enum Mode {
        /**
         * Shows text box only.
         */
        CreateOnly = 0,
        /**
         * Shows selector only.
         */
        SelectOnly = 1,
        /**
         * Shows textbox or selector along with toggle link.
         */
        CreateOrSelect = 2
    }
    /**
     * @deprecated CreatorAndSelectorV2.Options is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options extends Selector.Options<CreatorAndSelectorValue> {
        /**
         * Textbox label: label displayed with the textbox in creator mode
         */
        textBoxLabel?: KnockoutObservableBase<string>;
        /**
         * Link text for select existing option
         */
        selectExistingLinkDisplayText?: KnockoutObservableBase<string>;
        /**
         * Link text for create new option
         */
        createNewLinkDisplayText?: KnockoutObservableBase<string>;
        /**
         * Display mode
         */
        displayMode?: KnockoutObservableBase<Mode>;
        /**
         * Value update mode
         */
        valueUpdateTrigger?: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
    }
    /**
     * @deprecated CreatorAndSelectorV2.ViewModel is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Selector.ViewModel<CreatorAndSelectorValue> {
        /**
         * Textbox label: label displayed with the textbox in creator mode
         */
        textBoxLabel: KnockoutObservableBase<string>;
        /**
         * Link text for select existing option
         */
        selectExistingLinkDisplayText: KnockoutObservableBase<string>;
        /**
         * Link text for create new option
         */
        createNewLinkDisplayText: KnockoutObservableBase<string>;
        /**
         * Display mode
         */
        displayMode: KnockoutObservableBase<Mode>;
        /**
         * Value update trigger for underlying textbox.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Constructs a standalone instance of a CreatorAndSelector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CreatorAndSelectorV2.Options);
        /**
         * Constructs an instance of a CreatorAndSelector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CreatorAndSelectorV2.Options);
        /**
         * Constructs an instance of a CreatorAndSelector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<CreatorAndSelectorValue>, options?: CreatorAndSelectorV2.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\CustomHtml.d.ts
declare module MsPortalFx.ViewModels.Forms.CustomHtml {
    /**
     * Options describing the behavior of custom html form elements.
     * @deprecated MsPortalFx.ViewModels.Forms.CustomHtml.Options. This control is no longer supported. Please use Fx/Controls/CustomHtml.Options instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options extends Base.LabelAndBalloon.Options {
        /**
         * The html template to display as the body of the form.
         */
        htmlTemplate: KnockoutObservable<string> | string;
        /**
         * The object to bind to the template.
         */
        innerViewModel?: any;
        /**
         * Uses a new binding context for the template such that $root is innerViewModel instead of the part view model.
         * Defaults to true.
         */
        isolated?: boolean;
    }
    /**
     * CustomHtml form element view model.
     * @deprecated MsPortalFx.ViewModels.Forms.CustomHtml.Viewmodel. This control is no longer supported. Please use Fx/Controls/CustomHtml instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Base.LabelAndBalloon.ViewModel {
        /**
         * An html template.  value is the object that is bound to this template.
         */
        htmlTemplate: KnockoutObservable<string>;
        /**
         * The object to bind to the template.
         */
        innerViewModel: any;
        /**
         * Uses a new binding context for the template such that $root is innerViewModel instead of the part view model.
         */
        isolated: boolean;
        /**
         * Validity of entries in this form element.  This is set to true if all child form elements are valid, and false otherwise.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Determines if the field is currently loading.  Defaults to false.
         */
        loading: KnockoutObservable<boolean>;
        /**
         * The type of the form element.
         */
        type: MsPortalFx.ViewModels.ControlType;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * When changed forces validation on the field.
         */
        validate: KnockoutObservable<number>;
        /**
         * Internal view model property. Hooks up the clearValidation function from the VM to the widget.
         */
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Internal view model property. Hooks up the triggerValidation function from the VM to the widget.
         */
        _msPortalFxTriggerValidation: KnockoutObservable<() => Q.Promise<boolean>>;
        /**
         * Internal view model property. Hooks up the required validation to the required style we add when it's present.
         */
        _msPortalFxRequired: KnockoutObservable<boolean>;
        /**
         * Constructs a standalone instance of a CustomHtml form element.
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CustomHtmlField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CustomHtml.Options);
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): Q.Promise<any>;
        /**
         * Triggers validation on the field.
         * @return A promise that is resolved when the validation has been triggered.
         */
        triggerValidation(): Q.Promise<boolean>;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\CustomValueSlider.d.ts
declare module MsPortalFx.ViewModels.Forms.CustomValueSlider {
    /**
     * This control is no longer supported. Use CustomSliderOptions from Fx/Controls/Slider instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use createCustomSlider from Fx/Controls/Slider instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\DatePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DatePicker {
    import FxLifetimeManager = MsPortalFx.Base.LifetimeManager;
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.DatePicker.Options. Please use Fx/Controls/DatePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options extends Base.EditableComboBox.Options<Date> {
        /**
         * A valid format string specifier (see DateUtil format), used to format the value.
         */
        formatString?: KnockoutObservable<string>;
        /**
         * Date/time range in which user is able to select date.
         */
        enabledDateTimeRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange> | KnockoutObservableArray<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * Aria label for the DatePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.DatePicker.ViewModel. This control is no longer supported. Please use the Fx/Controls/DatePicker in place of this.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Base.EditableComboBox.ViewModel<Date> {
        /**
         * Date/time range in which user is able to select date.
         */
        enabledDateTimeRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange> | KnockoutObservableArray<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty: boolean;
        /**
         * Aria label for the DatePicker.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a DatePicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DatePicker control.
         */
        constructor(lifetimeManager: FxLifetimeManager, options?: DatePicker.Options);
        /**
         * Constructs an instance of a DatePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DatePicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DatePicker control.
         */
        constructor(lifetimeManager: FxLifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: DatePicker.Options);
        /**
         * Constructs an instance of a DatePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DatePicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DatePicker control.
         */
        constructor(lifetimeManager: FxLifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Date>, options?: DatePicker.Options);
        _setEditScopeAccessors(fieldValueAccessors: EditScopeAccessors<Date>): void;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\DateTimePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DateTimePicker {
    interface Options extends Base.EditableComboBox.Options<Date> {
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange> | KnockoutObservableArray<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown?: boolean | KnockoutObservable<boolean>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * Empty value text for time.
         */
        emptyTimeValueText?: KnockoutObservable<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds?: boolean;
        /**
         * Aria label for the DateTimePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated DateTimePicker.ViewModel. This control is no longer supported. Please use the Fx/Controls/DateTimePicker in place of this.
     */
    class ViewModel extends Base.EditableComboBox.ViewModel<Date> {
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange> | KnockoutObservableArray<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown: KnockoutObservable<boolean>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty: boolean;
        /**
         * Empty value text for time.
         */
        emptyTimeValueText: KnockoutObservable<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds: boolean;
        /**
         * Aria label for the DateTimePicker.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a DateTimePicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DateTimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: DateTimePicker.Options);
        /**
         * Constructs an instance of a DateTimePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimePicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DateTimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: DateTimePicker.Options);
        /**
         * Constructs an instance of a DateTimePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimePicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DateTimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Date>, options?: DateTimePicker.Options);
        _setEditScopeAccessors(fieldValueAccessors: EditScopeAccessors<Date>): void;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\DateTimeRangePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DateTimeRangePicker {
    /**
     * This control is no longer supported. Use Fx/Controls/DateTimeRangePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/DateTimeRangePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\DayPicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DayPicker {
    /**
     * This control is no longer supported. Use Fx/Controls/DayPicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/DayPicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\DropDown.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Forms.DropDown {
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.DropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.DropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: any;
}

// FILE: MsPortalFx\ViewModels\Forms\DurationPicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DurationPicker {
    /**
     * This control is no longer supported. Use Fx/Controls/DurationPicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/DurationPicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\FilterComboBox.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox {
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type FilterComboViewModel = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type HierarchicalFormOption = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Column = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type FilterOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type DatasetType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type AlgorithmType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type SearchFilterContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const HierarchicalFormOptionItem: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Node: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const SearchFilter: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const TreeSearchFilter: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const SearchFilterPrefixTree: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const TreeSearchFilterPrefixTree: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const FilterFactory: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const PrefixTree: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: any;
}

// FILE: MsPortalFx\ViewModels\Forms\GroupDropDown.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Forms.GroupDropDown {
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.GroupDropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Item<T> = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.GroupDropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Group<T> = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.GroupDropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options<T> = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.GroupDropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\MultiLineTextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.MultiLineTextBox {
    interface Options extends Base.Typable.Options<string> {
        /**
         * The number of rows to set the height of the textarea to.
         * This maps to the textarea rows attribute. The default is 7.
         */
        rows?: KnockoutObservable<number>;
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MultiLineTextBox.ViewModel. This control is no longer supported. Please use the Fx/Controls/MultiLineTextBox in place of this.
     */
    class ViewModel extends Base.Typable.ViewModel<string> {
        /**
         * The number of rows to set the height of the textarea to.
         * This maps to the textarea rows attribute. The default is 7.
         */
        readonly rows: KnockoutObservable<number>;
        /**
         * Enable the MultiLintTextBox to be spellcheck. (Warning. Perf hit. Do not enable this for a huge text).
         */
        readonly spellcheck: KnockoutObservableBase<boolean>;
        /**
         * Aria label for the textbox.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a MultiLineTextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the MultiLineTextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MultiLineTextBox.Options);
        /**
         * Constructs an instance of a MultiLineTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the MultiLineTextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the MultiLineTextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: MultiLineTextBox.Options);
        /**
         * Constructs an instance of a MultiLineTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the MultiLineTextField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the MultiLineTextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: MultiLineTextBox.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\MultiSelectDropDown.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Forms.MultiSelectDropDown {
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.MultiSelectDropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options<T> = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.MultiSelectDropDown control is no longer supported. Use Fx/Controls/DropDown instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\NumericTextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.NumericTextBox {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.NumericTextBox.Options is deprecated. Please use Fx/Controls/NumericTextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options extends Base.Typable.Options<number> {
        /**
         * Minimum number allowed.
         */
        min?: KnockoutObservable<number>;
        /**
         * Maximum number allowed.
         */
        max?: KnockoutObservable<number>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        decimalPoint?: KnockoutObservable<number>;
        /**
         * Text to display when entered text is not numeric.
         */
        invalidText?: string;
        /**
         * Placeholder text held by the control.
         */
        placeholder?: KnockoutObservable<string>;
        /**
         * Specifies whether an empty value should be allowed or if it should be replaced with a 0 value.
         */
        allowEmpty?: boolean;
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.NumericTextBox.ViewModel is deprecated. Please use Fx/Controls/NumericTextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Base.Typable.ViewModel<number> {
        /**
         * Minimum number allowed.
         */
        min: KnockoutObservable<number>;
        /**
         * Maximum number allowed.
         */
        max: KnockoutObservable<number>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        decimalPoint: KnockoutObservable<number>;
        /**
         * Text to display when entered text is not numeric.
         */
        invalidText: string;
        /**
         * Placeholder text held by the control.
         * Currently this does not work on IE9 (which does not support placeholder attr on input).
         */
        placeholder: KnockoutObservable<string>;
        /**
         * Specifies whether an empty value is allowed or whether the control should replace it with a 0 value. Should only be set through Options.
         */
        allowEmpty: boolean;
        /**
         * Aria label for the textbox.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a NumericTextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the NumericTextBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: NumericTextBox.Options);
        /**
         * Constructs an instance of a NumericTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the NumericTextBoxField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the NumericTextBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: NumericTextBox.Options);
        /**
         * Constructs an instance of a NumericTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the NumericTextBoxField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the NumericTextBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<number>, options?: NumericTextBox.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\OAuthButton.d.ts
declare module MsPortalFx.ViewModels.Forms.OAuthButton {
    import Fx = MsPortalFx;
    import FxPromise = Fx.Base.Promise;
    /**
     * OAuthButton control options
     */
    interface Options extends Base.Input.Options<string> {
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl: KnockoutObservable<string>;
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText?: KnockoutObservable<string>;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth?: KnockoutObservable<number>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight?: KnockoutObservable<number>;
        /**
         * The style of the OAuthButton. Set to true and show primary style if not specified.
         */
        primary?: KnockoutObservable<boolean> | boolean;
        /**
         * Aria label for the OAuthButton.
         */
        ariaLabel?: KnockoutObservableBase<string> | string;
        /**
         * The function executed before opening the popup.
         */
        beforeRequest?: () => FxPromise;
    }
    /**
     * @deprecated OAuthButton.ViewModel. This control is no longer supported. Please use the Fx/Controls/OAuthButton in place of this.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Base.Input.ViewModel<string> {
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl: KnockoutObservable<string>;
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText: KnockoutObservable<string>;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth: KnockoutObservable<number>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight: KnockoutObservable<number>;
        /**
         * The style of the OAuthButton. Set to true and show primary style if not specified.
         */
        primary?: KnockoutObservable<boolean>;
        /**
         * Aria label for the OAuthButton.
         */
        readonly ariaLabel?: KnockoutObservableBase<string>;
        /**
         * The function executed before opening the popup.
         */
        beforeRequest: () => FxPromise;
        /**
         * Constructs a standalone instance of a OAuthButton form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the OAuthButtonField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: OAuthButton.Options);
        /**
         * Constructs an instance of a OAuthButton form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OAuthButtonField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the OAuthButtonField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: OAuthButton.Options);
        /**
         * Constructs an instance of a OAuthButton form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OAuthButtonField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the OAuthButtonField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: OAuthButton.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\OptionsGroup.d.ts
declare module MsPortalFx.ViewModels.Forms.OptionsGroup {
    interface Options<T> extends Base.Options.Options<T> {
        /**
         * If true, sets the width of each option in the OptionGroup to the size of the content. Otherwise, sets each option to equal width
         * and the total size of the control to the size of the element. Defaults to true.
         */
        sizeToContent?: boolean;
        /**
         * If set, the option groups will appear as an inline set of radio buttons.  Defaults to false.
         */
        radioButtonStyle?: boolean;
        /**
         * If set while using radio button styling, the options in the group will each appear on their own line.  Defaults to false.
         * If not using radio button styling, this is not used.
         */
        singleItemPerLine?: boolean;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    class ViewModel<T> extends Base.Options.ViewModel<T> {
        /**
         * If set the OptionGroup will size each option will size of the text in the option.
         * Otherwise the OptionGroup will expand the size of each option so that it takes up
         * the widget of the element. Defaults to true.
         */
        sizeToContent: boolean;
        /**
         * If set, the option groups will appear as an inline set of radio buttons.  Defaults to false.
         */
        radioButtonStyle: boolean;
        /**
         * If set while using radio button styling, the options in the group will each appear on their own line.  Defaults to false.
         * If not using radio button styling, this is not used.
         */
        singleItemPerLine: boolean;
        /**
         * Text for screen readers.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of an OptionsGroup form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the OptionsGroupField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: OptionsGroup.Options<T>);
        /**
         * Constructs an instance of an OptionsGroup form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OptionsGroupField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the OptionsGroupField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: OptionsGroup.Options<T>);
        /**
         * Constructs an instance of an OptionsGroup form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OptionsGroupField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the OptionsGroupField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: OptionsGroup.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\PasswordBox.d.ts
declare module MsPortalFx.ViewModels.Forms.PasswordBox {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.PasswordBox.Options is deprecated. Please use Fx/Controls/PasswordBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options extends Base.Typable.Options<string> {
        /**
         * Shows validation messages as a popup.
         */
        showValidationsAsPopup?: boolean;
        /**
         * Aria label for the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.PasswordBox.ViewModel is deprecated. Please use Fx/Controls/PasswordBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Base.Typable.ViewModel<string> {
        /**
         * Placeholder text shown when password is empty.
         */
        emptyValueText: KnockoutObservableBase<string>;
        /**
         * Shows validation messages as a popup.
         */
        showValidationsAsPopup: boolean;
        /**
         * Aria label for the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a PasswordBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the PasswordField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: PasswordBox.Options);
        /**
         * Constructs an instance of a PasswordBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the PasswordField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the PasswordField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: PasswordBox.Options);
        /**
         * Constructs an instance of a PasswordBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the PasswordField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the PasswordField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: PasswordBox.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\RangeSlider.d.ts
declare module MsPortalFx.ViewModels.Forms.RangeSlider {
    /**
     * This control is no longer supported. Use Fx/Controls/RangeSlider instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/RangeSlider instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\Section.d.ts
declare module MsPortalFx.ViewModels.Forms.Section {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Section.Options is deprecated. Please use the Fx/Controls/Section.Options instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options {
        /**
         * The sections & controls to nest within the section.
         */
        children?: KnockoutObservableArray<any>;
        /**
         * The name of the section.
         * Can be an HTML template and optional view model. See HtmlContent interface in Fx/Controls/ControlsBase
         * This will be displayed as a tab header if the section is inside a tab control.
         *
         * To track telemetry across locales, please use telemetryName for a consistent identifier.
         */
        name?: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The layout style of the section.
         */
        style?: KnockoutObservableBase<SectionStyle>;
        /**
         * The set width of the section.
         * Value is in %. Any other sibiling sections split the remaining % (from a total of 100%)
         */
        width?: KnockoutObservableBase<number>;
        /**
         * The submit callback.
         */
        submit?: KnockoutObservableBase<SubmitEvent>;
        /**
         * The populate section callback.
         */
        populateSection?: KnockoutObservableBase<PopulateSection>;
        /**
         * A custom css class to apply to the section.
         */
        cssClass?: KnockoutObservableBase<string> | string;
        /**
         * The minimum height of the section in pixels.  Use this to reduce jumpiness in dynamic forms.
         */
        minHeight?: number;
        /**
         * Tab style.
         * ONLY USE when style is set to tabs.
         */
        tabStyle?: TabStyle;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        telemetryName?: KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Section.SectionStyle is deprecated. Please use the Fx/Controls/Section instead, which no longer supports SectionStyle.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum SectionStyle {
        /**
         * A section that creates columns.
         */
        Column = 0,
        /**
         * The default section, used when you don't need columns.
         * NOTE: You don't need to declare a section style when using this.
         */
        Default = 1,
        /**
         * A default column, which is indented.
         */
        Dependent = 2,
        /**
         * A section which contains column sections to create a table layout.
         * NOTE: If it contains no column sections the section reverts to a default section.
         */
        Row = 3,
        /**
         * A section with layers made accessible via tabs.
         */
        Tabs = 4,
        /**
         * Same as Default.
         */
        Wrapper = 5,
        /**
         * Default with reduced padding between controls (used to create the appearance of a single composite control).
         */
        SingleControl = 6
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Section.TabStyle is deprecated. Please use the Fx/Controls/Section instead, which no longer supports TabStyle.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum TabStyle {
        /**
         * Line based tabs.
         */
        Line = 0,
        /**
         * Traditional, block tabs.
         */
        Block = 1
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Section.SubmitEvent is deprecated. Please use the Fx/Controls/Section instead, which no longer supports SubmitEvent.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SubmitEvent {
        (): MsPortalFx.Base.PromiseV<SubmitEventResult>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Section.SubmitEventResult is deprecated. Please use the Fx/Controls/Section instead, which no longer supports SubmitEventResult.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SubmitEventResult {
        success: boolean;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Section.PopulateSection is deprecated. Please use the Fx/Controls/Section instead, which no longer supports PopulateSection.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface PopulateSection {
        (): MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.Forms.Section.ViewModel>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Section.ViewModel is deprecated. Please use the Fx/Controls/Section instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel {
        /**
         * If under a tab, is the active section.
         */
        active: KnockoutObservable<boolean>;
        /**
         * The subsections and form controls to nest within the section.
         */
        children: KnockoutObservableArray<any>;
        /**
         * Indicates if the sections or controls within the widget are currently dirty.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * The name of the section.
         * Can be an HTML template and optional view model. See HtmlContent interface in Fx/Controls/ControlsBase
         * This will be displayed as a tab header if the section is inside a tab control.
         *
         * To track telemetry across locales, please use telemetryName for a consistent identifier.
         */
        name: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The width of the section.
         * Value is in %. Any other sibiling sections split the remaining % (from a total of 100%)
         */
        width: KnockoutObservableBase<number>;
        /**
         * Function which is called on form submit.
         */
        submit: KnockoutObservableBase<SubmitEvent>;
        /**
         * Function which is called to return form submit.
         */
        populateSection: KnockoutObservableBase<PopulateSection>;
        /**
         * The layout style of the section.
         */
        style: KnockoutObservableBase<SectionStyle>;
        /**
         * Indicates if the sections or controls within the widget are currently valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Stub to conform with the FormElement viewmodel.
         */
        validate: KnockoutObservable<number>;
        /**
         * For tabs, this is a empty viewmodel until it is loaded.
         */
        tabSection: KnockoutObservable<MsPortalFx.ViewModels.Forms.Section.ViewModel>;
        /**
         * For tabs, indicates if the section has been loaded.
         */
        tabHasBeenLoaded: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the section.
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * The minimum height of the section in pixels. Use this to reduce jumpiness in dynamic forms.
         */
        minHeight: number;
        /**
         * Whether the section is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Tab style. Default is Line style.
         */
        tabStyle: TabStyle;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        telemetryName: KnockoutObservableBase<string>;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Constructs a standalone instance of a form Section.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the Section control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Section.Options);
        clearValidation(): Q.Promise<any>;
        triggerValidation(): Q.Promise<boolean>;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Selector.d.ts
declare module MsPortalFx.ViewModels.Forms.Selector {
    /**
     * @deprecated Selector.OptionsBase is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OptionsBase<T> extends Base.Input.Options<T> {
        /**
         * True if the value is displayed, else false.
         */
        showValue?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The display text for the value in the selector.
         */
        displayText?: string | KnockoutObservableBase<string>;
        /**
         * The icon displayed next to the label and value.
         */
        icon?: MsPortalFx.Base.Image | KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * True if the field is locked; else false.
         */
        locked?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Text to display on the balloon shown next to the label.
         */
        infoBalloonText?: string | KnockoutObservableBase<string>;
        /**
         * Text to display on the balloon shown over the locked indicator.
         */
        lockedBalloonText?: string | KnockoutObservableBase<string>;
        /**
         * Link to display on the balloon shown next to the label.
         */
        infoBalloonLink?: MsPortalFx.ViewModels.Controls.Balloon.Link | KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        /**
         * Alternate text for screen reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated Selector.Options is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options<T> extends OptionsBase<T> {
        /**
         * The initial state of the Selector.
         */
        initialState?: any;
        selectedValue?: MsPortalFx.ViewModels.DynamicBladeSelection;
    }
    /**
     * @deprecated Selector.ClicableOptions is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ClickableOptions<T> extends OptionsBase<T> {
        /**
         * A function that is called when the selector is clicked.
         * If a onClick callback is provided then initialState and selectedValue are ignored
         * This option is mutually exclusive with initialState and selectedValue.
         */
        onClick?: () => void;
    }
    /**
     * @deprecated Selector.ViewModelBase is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    abstract class ViewModelBase<T> extends Base.Editable.ViewModel<T> {
        /**
         * True if the value is displayed, else false.
         */
        showValue: KnockoutObservableBase<boolean>;
        /**
         * The display text for the value in the selector.
         */
        displayText: KnockoutObservableBase<string>;
        /**
         * The icon displayed next to the label and value.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * True if the field is locked; else false.
         */
        locked: KnockoutObservableBase<boolean>;
        /**
         * Text to display on the balloon shown next to the label.
         */
        infoBalloonText: KnockoutObservableBase<string>;
        /**
         * Text to display on the balloon shown over the locked indicator.
         */
        lockedBalloonText: KnockoutObservableBase<string>;
        /**
         * Link to display within the balloon underneath the text, the balloon is shown next to the label.
         */
        infoBalloonLink: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        /**
         * True if the current value is the default; else false.
         */
        isDefault: KnockoutObservableBase<boolean>;
        /**
         * Alternate text for screen reader
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a Selector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Selector.OptionsBase<T>);
        /**
         * Constructs an instance of a Selector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Selector.OptionsBase<T>);
        /**
         * Constructs an instance of a Selector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: Selector.OptionsBase<T>);
    }
    /**
     * @deprecated Selector.Selector is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel<T> extends ViewModelBase<T> {
        private _msPortalFxOnClick;
        selectable: Selectable<DynamicBladeSelection>;
        /**
         * Constructs a standalone instance of a Selector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<T> | ClickableOptions<T>);
        /**
         * Constructs an instance of a Selector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Options<T> | ClickableOptions<T>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: Options<T> | ClickableOptions<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Slider.d.ts
declare module MsPortalFx.ViewModels.Forms.Slider {
    interface Options extends Base.Slider.Options<number> {
    }
    /**
     * @deprecated  MsPortalFx.ViewModels.Forms.Slider.ViewModel. This control is no longer supported. Please use the Fx/Controls/Slider in place of this.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Base.Slider.ViewModel<number> {
        /**
         * Constructs a standalone instance of a Slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SliderField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Constructs an instance of a Slider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SliderField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SliderField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Slider.Options);
        /**
         * Constructs an instance of a Slider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SliderField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the SliderField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<number>, options?: Slider.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Splitter.d.ts
declare module MsPortalFx.ViewModels.Controls.Splitter {
    const enum Panes {
        Primary = 0,
        Secondary = 1,
        Both = 2
    }
    /**
     * This control is no longer supported. Use Fx/Controls/Splitter instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/Splitter instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\StaticSection.d.ts
declare module MsPortalFx.ViewModels.Forms.StaticSection {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.StaticSection.ViewModel is no longer supported. Please use the Fx/Controls/Section in place of this.
     * Please refer to https://aka.ms/portalfx/breaking for more details
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel implements Base.Section {
        /**
         * Enum that defines the type of form element.
         */
        controlType: ControlType;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutComputed<boolean>;
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservable<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * The list of form fields contained in the section.
         */
        fields: KnockoutObservableArray<FormField<any>>;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Constructs an instance of a form section.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fields Optional. An array of fields that will go in the form section.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fields?: FormField<any>[]);
        clearValidation(): Q.Promise<any>;
        triggerValidation(): Q.Promise<boolean>;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\TextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.TextBox {
    interface Options extends Base.Typable.Options<string> {
        /**
         * Makes the textbox read only.
         */
        readOnly?: boolean | KnockoutObservable<boolean>;
        /**
         * The viewmodel of a list/grid control that can be controlled by this textbox.
         * The list will treat this textbox as a search text box by doing the following:
         *      enter keystrokes: Activate the first result
         *      down arrow keystrokes: Focus the first result
         *      focus and blur: highlight/remove highlight from the first result
         */
        actionHandler?: KnockoutObservableBase<FxImpl.ViewModels.Controls.Lists.Base.ActionHandler> | FxImpl.ViewModels.Controls.Lists.Base.ActionHandler;
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Shows validation as a popup.
         */
        showValidationsAsPopup?: boolean;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: string) => void;
    }
    class ViewModel extends Base.Typable.ViewModel<string> implements FxImpl.ViewModels.Controls.Lists.Base.ActionSource {
        /**
         * The viewmodel of a list/grid control that can be controlled by this textbox.
         * The list will treat this textbox as a search text box by doing the following:
         *      enter keystrokes: Activate the first result
         *      down arrow keystrokes: Focus the first result
         *      focus and blur: highlight/remove highlight from the first result
         */
        actionHandler: KnockoutObservableBase<FxImpl.ViewModels.Controls.Lists.Base.ActionHandler> | FxImpl.ViewModels.Controls.Lists.Base.ActionHandler;
        /**
         * When not enabled, this control will not send events to the handler.
         */
        actionsEnabled: KnockoutObservable<boolean>;
        /**
         * Makes the textbox read only.
         */
        readOnly: boolean | KnockoutObservable<boolean>;
        /**
         * Enable the textbox to be spellcheck. (Warning. Perf hit.  Do not enable this for a huge text).
         */
        spellcheck: boolean | KnockoutObservable<boolean>;
        /**
         * Aria label for the textbox.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Shows validation messages as a popup.
         */
        showValidationsAsPopup: boolean;
        /**
         * Constructs a standalone instance of a TextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: TextBox.Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: TextBox.Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: TextBox.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\TimePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.TimePicker {
    /**
     * This control is no longer supported. Use Fx/Controls/TimePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/TimePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\ViewModels.AsyncFileUpload.d.ts
declare module MsPortalFx.ViewModels.Forms.AsyncFileUpload {
    import FxFileUpload = MsPortalFx.ViewModels.FileUpload;
    import FxPromise = MsPortalFx.Base.Promise;
    import UploadAction = FxFileUpload.UploadAction;
    /**
     * Options to initialize the file upload view model.
     */
    interface Options extends Base.Editable.Options<string> {
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        accept?: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        allowedFileExtensions?: string | KnockoutObservableBase<string>;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext?: KnockoutObservableBase<FxFileUpload.UploadContext>;
        /**
         * The user selected files via browse dialog is surfaced as SelectedFile in the selectedFiles array.
         * For scenarios where selected files should automatically be associated with an UploadTask, set this value to true.
         * If this option is set to false, the extension author is responsible for explicitly adding the selectedFile to uploadTasks by invoking
         * the addUploadTasks() method on view model to create an UploadTask representation and have it available in uploadTasks array.
         * By default, this option is set to true.
         */
        autoAddUploadTasks?: boolean;
        /**
         * Aria label for the file upload control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    function execUpload(callback: FxFileUpload.UploadActionCallback, selectedFiles: FxFileUpload.SelectedFile[], action: UploadAction): Q.Promise<any>;
    /**
     * Async file upload ViewModel.
     */
    class ViewModel extends Base.Editable.ViewModel<string> {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        accept: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        allowedFileExtensions: string | KnockoutObservableBase<string>;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<FxFileUpload.UploadContext>;
        /**
         * Each time user clicks on the browse dialog, user can choose one or multiple files and each selected file is represented as SelectedFile on the extension iframe.
         * The selected files are surfaced in the selectedFiles array.
         * The array will be cleared if user chooses to click browse dialog to pick a different set of files.
         * Setting the value property null or calling resetUploadTasks() will clear the array.
         */
        selectedFiles: KnockoutReadOnlyObservableArray<FxFileUpload.SelectedFileContract>;
        /**
         * The user selected files via browse dialog is surfaced as SelectedFile in the selectedFiles array.
         * For scenarios where selected files should automatically be associated with an UploadTask, set this value to true.
         * If this option is set to false, the extension author is responsible for explicitly adding the selectedFile to uploadTasks by invoking
         * the addUploadTasks() method on view model to create an UploadTask representation and have it available in uploadTasks array.
         * By default, this option is set to true.
         */
        autoAddUploadTasks: boolean;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress etc.
         * UploadTask is used to initiate the file upload, pause/resume uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutReadOnlyObservableArray<FxFileUpload.AsyncUploadTaskContract>;
        /**
         * Aria label for the file upload control.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Callback to handle upload management operations. The callback is populated by the upload widget which will then delegate the needed action to the global upload manager.
         */
        _msPortalFxUploadActionCallback: KnockoutObservableBase<FxFileUpload.UploadActionCallback>;
        /**
         * Constructs a standalone instance of a TextBox form field.
         *
         * @param lifetime A lifetime object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetime A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the AsyncFileUpload control.
         */
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Options);
        /**
         * Method to create an UploadTask associated with the selected file and populate that in the uploadTasks array.
         * File browse selections can be made any number of times. When autoAddUploadTaks is set to true, the selected files will be added automatically to the uploadTasks array.
         * If autoAddploadTasks is false, the selected file should be explicitly added to uploadTasks array by calling the addUploadTasks() method.
         * Extension authors will then be able to start the upload.
         *
         * @param selectedFiles User selected files to add to uploadTasks array to prepare for the file upload.
         */
        addUploadTasks(selectedFiles: FxFileUpload.SelectedFile[]): FxPromise;
        /**
         * Method to reset the uploadTasks array. This method will use the widget callback to intialize the uploadTasks array with empty array.
         * Calling this method will not dispose(abort) the uploads.
         * Uploads which have already started will continue upload in the background.
         * Uploads which have not been started will be cleaned up.
         * Invoking this method will clear the uploadTasks array, selectedFiles array and the value property.
         */
        resetUploadTasks(): Q.Promise<void>;
    }
}

// FILE: MsPortalFx\ViewModels\Model.ReactModel.d.ts
declare module MsPortalFx.Models {
    interface Action<T = any> {
        type: T;
    }
    interface AnyAction extends Action {
        [extraProps: string]: any;
    }
    type ProxyablePrimitive = number | string | Date | boolean | void | undefined;
    interface PrimitiveObject {
        [key: string]: PrimitiveObject | ProxyablePrimitive | Array<ProxyablePrimitive | PrimitiveObject> | ReadonlyArray<ProxyablePrimitive | PrimitiveObject>;
    }
    type Proxyable = PrimitiveObject | ProxyablePrimitive | Array<PrimitiveObject | ProxyablePrimitive>;
    type ProxyableData<T> = {
        [P in keyof T]: Proxyable;
    };
    interface FunctionProxy<TP extends ProxyableData<TR>, TR extends ProxyableData<TP>> {
        register<K extends keyof TP>(name: K, func: (arg: TP[K]) => Promise<TR[K]> | TR[K]): void;
        invoke<K extends keyof TP>(name: K, param: TP[K]): Promise<TR[K]>;
        invoke<K extends keyof TP>(name: K, param: TP[K], ignoreResponse: true): void;
    }
    /**
     * A store is an object that holds the application's state tree.
     * There should only be a single store in a Redux app, as the composition
     * happens on the reducer level.
     *
     * @template S The type of state held by this store.
     * @template A the type of actions which may be dispatched by this store.
     */
    interface AsyncStore<S = any, A extends Action = AnyAction> {
        /**
         * Dispatches an action. It is the only way to trigger a state change.
         *
         * The `reducer` function, used to create the store, will be called with the
         * current state tree and the given `action`. Its return value will be
         * considered the **next** state of the tree, and the change listeners will
         * be notified.
         *
         * The base implementation only supports plain object actions. If you want
         * to dispatch a Promise, an Observable, a thunk, or something else, you
         * need to wrap your store creating function into the corresponding
         * middleware. For example, see the documentation for the `redux-thunk`
         * package. Even the middleware will eventually dispatch plain object
         * actions using this method.
         *
         * @param action A plain object representing “what changed”. It is a good
         *   idea to keep actions serializable so you can record and replay user
         *   sessions, or use the time travelling `redux-devtools`. An action must
         *   have a `type` property which may not be `undefined`. It is a good idea
         *   to use string constants for action types.
         *
         * @returns For convenience, the same action object you dispatched.
         *
         * Note that, if you use a custom middleware, it may wrap `dispatch()` to
         * return something else (for example, a Promise you can await).
         */
        dispatch(action: A): A;
        /**
         * Reads the state tree managed by the store.
         *
         * @returns The current state tree of your application.
         */
        getState(): S;
        /**
         * Adds a change listener. It will be called any time an action is
         * dispatched, and some part of the state tree may potentially have changed.
         * You may then call `getState()` to read the current state tree inside the
         * callback.
         *
         * You may call `dispatch()` from a change listener, with the following
         * caveats:
         *
         * 1. The subscriptions are snapshotted just before every `dispatch()` call.
         * If you subscribe or unsubscribe while the listeners are being invoked,
         * this will not have any effect on the `dispatch()` that is currently in
         * progress. However, the next `dispatch()` call, whether nested or not,
         * will use a more recent snapshot of the subscription list.
         *
         * 2. The listener should not expect to see all states changes, as the state
         * might have been updated multiple times during a nested `dispatch()` before
         * the listener is called. It is, however, guaranteed that all subscribers
         * registered before the `dispatch()` started will be called with the latest
         * state by the time it exits.
         *
         * @param listener A callback to be invoked on every dispatch.
         * @param selector A function that takes in state and returns a single property of the state you are interested in,
         * the callback will only be called if the references of the selector have changed.
         * @returns A function to remove this change listener.
         */
        subscribe(listener: () => void): () => void;
    }
    interface Options<S = {}, A extends Action = AnyAction, TP extends ProxyableData<TR> = any, TR extends ProxyableData<TP> = any> {
        lifetime: MsPortalFx.Base.LifetimeManager;
        asyncStore: Promise<AsyncStore<S, A>>;
        functionProxy: FunctionProxy<TP, TR>;
    }
    /**
     * A model class that is linked to the equivelant ReactView view.
     */
    class React<S = {}, A extends Action = AnyAction, TP extends ProxyableData<TR> = any, TR extends ProxyableData<TP> = any> {
        lifetime: MsPortalFx.Base.LifetimeManager;
        asyncStore: Promise<AsyncStore<S, A>>;
        functionProxy: FunctionProxy<TP, TR>;
        constructor(reactModelArguments: Options<S, A, TP, TR>);
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\Internal\ProvisioningTelemetry.d.ts
declare module FxImpl.ProvisioningTelemetry {
    import FxBase = MsPortalFx.Base;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    import TelemetryEvent = Telemetry.TelemetryEvent;
    const ActionModifier: {
        Failed: string;
        Succeeded: string;
    };
    const ProvisioningStatus: {
        NoPromise: string;
        Resolved: string;
        UnknownFailure: string;
    };
    /**
     * Sets up the Shell-side counterpart to the Provisioner telemetry submitter.
     */
    function registerTelemetrySubmissionHandler(): void;
    /**
     * Traces create deployment start/end/preflight events.
     */
    function traceDeployment(entry: TelemetryEvent): void;
    /**
     * Traces provisioning started event.
     */
    function traceProvisioningStarted(event?: TelemetryEvent): TelemetryEvent;
    /**
     * Traces provisioning ended event.
     */
    function traceProvisioningEnded(event: TelemetryEvent): TelemetryEvent;
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\Internals.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection.Internal {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    /**
     * The model for the "collector" parameter collection binding.
     */
    class CollectorBindingInternals {
        /**
         * The inputs from the collector to the provider.
         */
        inputs: KnockoutObservable<ParameterCollectionInput>;
        /**
         * The errors passed down from the colletor to the provider.
         */
        errors: KnockoutObservable<ParameterCollectionError[]>;
    }
    /**
     * The model for the "provider" parameter collection binding.
     */
    class ProviderBindingInternals {
        /**
         * The outputs of the provider to the collector.
         */
        outputs: KnockoutObservable<ParameterCollectionOutput>;
        /**
         * A Guid that when changes, triggers the process of commiting the changes in the provider
         * and sending them to the collector.
         */
        commit: KnockoutObservable<string>;
    }
    /**
     * The contract for the parameter collection "collector" binding.
     */
    interface ParameterCollectorBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: CollectorBindingInternals;
    }
    /**
     * The contract for the parameter collection "provider" binding.
     */
    interface ParameterProviderBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: ProviderBindingInternals;
    }
    interface IProvisioner {
        /**
         * The mapped outputs generated by processing the outputs using the mapOutputsForProvisioning function.
         */
        mappedOutputs: ParameterCollectionOutput;
        /**
         * Executes the provisioning command.
         *
         * @param data The parameter collection outputs from the create flow that will be used in the provisioning process.
         * @param options The options used for the provisioning process.
         * @return A Promise object signaling the completion of the provisioning process.
         */
        executeProvisioning(data: ParameterCollectionOutput, options: StringMap<any>): FxBase.Promise;
    }
    /**
     * The provisioner, an entity responsible for executing a provisioning command at the end of a
     * parameter collection process.
     */
    class Provisioner implements FxBase.Disposable {
        /**
         * The deployment response on starting provisioning.
         */
        deploymentResponse: any;
        private _provisioningEntity;
        private _data;
        private _options;
        private _executionDeferred;
        private readonly _lifetimeManager;
        private _mappedOutputs;
        /**
         * Constructs the provisioner.
         *
         * @param provisioningEntity The provisioning entity.
         */
        constructor(provisioningEntity: ProvisioningEntity);
        get mappedOutputs(): ParameterCollectionOutput;
        executeProvisioning(data: ParameterCollectionOutput, options: StringMap<any>): FxBase.Promise;
        dispose(): void;
        private _beginExecution;
        private _executeProvisioning;
        private _createEventBase;
        private _traceProvisioningStarted;
        private _traceProvisioningEnded;
    }
    /**
     * Provisioning command status.
     */
    enum ProvisioningCommandStatus {
        /**
         * Command has not being executed yet.
         */
        Idle = 0,
        /**
         * Command is in the process of executing.
         */
        InProgress = 1,
        /**
         * Command has been executed and succeeded.
         */
        Succeeded = 2,
        /**
         * Command has been executed and failed.
         */
        Failed = 3
    }
    /**
     * A class that represents a provisioning command.
     */
    interface ProvisioningCommand {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservable<ProvisioningCommandStatus>;
        /**
         * Executes the provisioning command.
         *
         * @param options The options needed to configure/execute the command.
         * @return A Promise object indicating whether the provisioning command has succeeded or not.
         */
        execute(options: StringMap<any>): FxBase.PromiseV<any>;
    }
    /**
     * The contract for a parameter collection entity that also does provisioning.
     */
    interface ProvisioningEntity {
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         * Set this true to enable the provisioning logic.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * True if provisioning should be done using a provisioning part; else false.
         */
        provisionOnStartboardPart?: KnockoutObservable<boolean>;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: ProvisioningEntityBindingInternals;
        /**
         * Executes the provisioning command. Override this method for custom provisioning.
         *
         * @param data The parameter collection outputs from the create flow that will be used in
         *      the provisioning process.
         * @return A Promise object signaling the completion of the provisioning process.
         */
        executeProvisioning?(data: ParameterCollectionOutput): FxBase.Promise;
        /**
         * Maps the outputs of the parameter collection flow to what the provisioning command expects.
         * Override this method to implement custom mapping.
         *
         * @param originalOutputs The original outputs of the parameter collection flow.
         * @return The mapped outputs, to what the provisioning command expects.
         */
        mapOutputsForProvisioning?(originalOutputs: ParameterCollectionOutput): ParameterCollectionOutput;
    }
    /**
     * The contract for a parameter collection entity that also does provisioning.
     */
    class ProvisioningEntityBindingInternals {
        /**
         * Signals fetching the provisioning command from Shell.
         */
        triggerProvisioningCommand: KnockoutObservable<string>;
        /**
         * The name of the extension that contains the provisioning part.
         */
        provisioningPartExtensionName: KnockoutObservable<string>;
        /**
         * The name of the provisioning part in which to do provisioning.
         */
        provisioningPartName: KnockoutObservable<string>;
        /**
         * Signals the start of provisioning on a startboard part using the specified model.
         * If the startboard part is not already present, it is added.
         */
        triggerProvisioningInStartboardPart: KnockoutObservable<any>;
        /**
         * True if provisioning should be done using a provisioning part; else false.
         */
        masterIsProvisioningPart: KnockoutObservable<boolean>;
        /**
         * Force discards the journey when provisioning starts.
         */
        forceDiscardJourney: KnockoutObservable<boolean>;
        /**
         * The fetched provisioning command.
         */
        provisioningCommand: KnockoutObservable<ProvisioningCommand>;
        /**
         * Signal to the shell that an attempt was made to start provisioning.
         */
        provisioningAttempted: KnockoutObservable<any>;
        /**
         * Signal to the shell that provisioning has started. This means that the attempt to start provisioning was
         * successfully and acknowledged by the service.
         */
        provisioningStarted: KnockoutObservable<any>;
        /**
         * Signal to the provisioner that provisioning has completed.
         */
        provisioningCompleted: KnockoutObservable<any>;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\ParameterCollectionData.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * The model for the parameter collection inputs.
     */
    class ParameterCollectionInput {
        /**
         * The input parameters (key-value pairs).
         */
        inputParameters: StringMap<StringMap<string>>;
        /**
         * The input parameters metadata (key-value pairs). The key is the parameter name.
         */
        inputMetadata: StringMap<StringMap<ParameterMetadata>>;
        /**
         * The options needed to configure the behavior of the provider.
         */
        options: StringMap<any>;
    }
    /**
     * The model for the parameter collection outputs.
     */
    class ParameterCollectionOutput {
        /**
         * The output parameters (key-value pairs).
         */
        outputParameters: StringMap<StringMap<string>>;
    }
    /**
     * The model for a parameter collection metadata object. Useful for generated flows.
     */
    interface ParameterMetadata {
        /**
         * The display name for the parameter.
         */
        displayName: string;
        /**
         * The default value for the parameter.
         */
        defaultValue?: any;
        /**
         * The description for the parameter.
         */
        description?: string;
        /**
         * The text for the tool-tip.
         */
        toolTip?: string;
        /**
         * The UI hint used to find and render a suitable control that will capture the value for
         * the parameter (e.g. password, email, url, date, etc.). Used in generated UIs only, and
         * limited to types supported by controls that already exist in MsPortalFx.
         */
        uiHint?: string;
        /**
         * Constraints for rendering and validating the parameter.
         */
        constraints?: ParameterMetadataConstraints;
    }
    /**
     * The model for a parameter collection metadata constraints.
     */
    interface ParameterMetadataConstraints {
        /**
         * A flag indicating whether this parameter is required or not. Defaults to true.
         */
        required?: boolean;
        /**
         * A flag indicating whether this parameter is hidden or not. Defaults to false.
         */
        hidden?: boolean;
        /**
         * A list of possible values for the parameter (key-value pairs). Could be used for
         * validation and/or populating a list or a drop-down.
         */
        allowedValues?: {
            text: string;
            value: any;
        }[];
        /**
         * The range defining the parameter value.
         */
        range?: {
            lowerBind: number;
            upperBound: number;
        };
        /**
         * The length of the parameter value.
         */
        length?: {
            min: number;
            max: number;
        };
        /**
         * The characters the parameter value must contain.
         */
        containsCharacters?: string;
        /**
         * The characters the parameter value must not contain.
         */
        notContainsCharacters?: string;
        /**
         * Whether the parameter value has at least one digit or not.
         */
        hasDigit?: boolean;
        /**
         * Whether the parameter value has at least one letter or not.
         */
        hasLetter?: boolean;
        /**
         * Whether the parameter value has at least one upper-case letter or not.
         */
        hasUpperCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one lower-case letter or not.
         */
        hasLowerCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one special character or not.
         */
        hasPunctuation?: boolean;
        /**
         * Whether the parameter value is a number or not.
         */
        numeric?: boolean;
        /**
         * A custom list of constraints (key-value pairs). Useful for custom generated UI.
         */
        custom?: {
            key: string;
            value: string;
        }[];
    }
    /**
     * The model defining a parameter collection error object.
     */
    interface ParameterCollectionError {
        /**
         * The error message.
         */
        errorMessage: string;
        /**
         * The name of the associated parameter, if any.
         */
        parameterName?: string;
    }
    /**
     * A helper class with model transformation methods.
     */
    class Models {
        /**
         * Transforms an editable model object to a list of parameter-sets.
         *
         * @param model The editable model object.
         * @return The list if parameter-sets.
         */
        static modelToParameters<T>(model: T): StringMap<StringMap<string>>;
        /**
         * Transforms a list of parameter-sets to an editable model object.
         *
         * @param data The list if parameter-sets.
         * @return The editable model object.
         */
        static parametersToModel<T>(data: StringMap<StringMap<string>>): T;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\ParameterCollector.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * The contract for the parameter collection "collector" role.
     * Enables the implementer to collect parameters from parameter provider(s).
     */
    interface ParameterCollector {
        /**
         * Gets the inputs that will be sent to a given provider when launched.
         *
         * @param providerId The id of the provider.
         * @return The inputs for the provider.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the committing provider.
         * @param outputs The outputs from the provider.
         * @return A JQuery promise (boolean) indicating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): MsPortalFx.Base.PromiseV<boolean>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
    }
}
declare module MsPortalFx.ViewModels.ParameterCollection.Internal {
    import Fx = MsPortalFx;
    import FxViewModels = Fx.ViewModels;
    import ParameterCollection = Fx.ViewModels.ParameterCollection;
    import ParameterCollectionOutput = ParameterCollection.ParameterCollectionOutput;
    /**
     * Class implementing collector-specific functionality.
     */
    class CollectorBase {
        private _provisioner;
        private _previousOutputs;
        private _previousCommit;
        private _previousDetailBladeOutput;
        /**
         * Creates the collector internal instance.
         *
         * @param provisioner The provisioner to use to execute provisioning.
         */
        constructor(provisioner: IProvisioner);
        /**
         * Executed when the provider binding internals have been received.
         *
         * @param providerBindingInternals The provider binding internals.
         * @param options The options for provisioning.
         * @param detailBladeOutput The actionbar output from the detail blade.
         * @param onProviderCommit The onProviderCommit callback to execute when provider commit conditions have been met.
         * @param onCommitSuccessAction The callback to execute if committed successfully.
         * @param onCommitFailedAction The callback to execute if commit failed.
         */
        onProviderBindingInternalsReceived(providerBindingInternals: ProviderBindingInternals, options: StringMap<any>, detailBladeOutput: FxViewModels.ActionBars.Base.ActionBarOutput, onProviderCommit: (selectorId: string, outputs: ParameterCollectionOutput) => MsPortalFx.Base.PromiseV<boolean>, onCommitSuccessAction: () => void, onCommitFailedAction: () => void): void;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\ViewModels.BaseGalleryButtonPart.d.ts
declare module FxImpl.ViewModels.ParameterCollection {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Wizard = FxViewModels.Controls.Wizard;
    import ParameterCollectionInternal = MsPortalFx.ViewModels.ParameterCollection.Internal;
    /**
     * The contract for the view model for a parameter collection button part.
     */
    interface BaseGalleryButtonPartContract {
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<Wizard.StepInput>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<Wizard.StepOutput>;
        /**
         * A value used to determine when to call executeCommand.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
    }
    /**
     * The base class for a parameter collection button part (provider only).
     *
     * IMPORTANT: An instance of this class can be used to kick off the create flow (following the
     * Samples Extension). However, once the gallery hub is available, it will invoke the create flows
     * directly with the correct parameters (from the Gallery service) and replace this button.
     */
    class BaseGalleryButtonPartViewModel extends FxViewModels.ButtonPart implements FxBase.Disposable, BaseGalleryButtonPartContract, MsPortalFx.ViewModels.ParameterCollection.ParameterCollector, ParameterCollectionInternal.ParameterCollectorBinding {
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionError[]>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: ParameterCollectionInternal.CollectorBindingInternals;
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<Wizard.StepInput>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<Wizard.StepOutput>;
        /**
         * A value indicating whether or not to start the command.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
        _commit: KnockoutObservable<string>;
        private _baseButtonContainer;
        private _baseProviderCommit;
        private _initialLoadComplete;
        protected readonly _ltm: MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Constructs the view model.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState: any, allowToggleProvisioningLocation?: boolean, isProvisioningPart?: boolean);
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): FxBase.Promise;
        /**
         * Gets the inputs for a given provider.
         *
         * @param providerId The id of the provider.
         * @return The inputs for the provider.
         */
        getProviderInputs(providerId: string): MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the provider.
         * @param outputs The outputs from the provider.
         * @return A JQuery promise (boolean) dictating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionOutput): FxBase.PromiseV<boolean>;
        dispose(): void;
        _processStepOutput(stepOutput: Wizard.StepOutput): void;
    }
}
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * @deprecated ParameterCollection.BaseGalleryButtonPartContract. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    type BaseGalleryButtonPartContract = FxImpl.ViewModels.ParameterCollection.BaseGalleryButtonPartContract;
    /**
     * @deprecated ParameterCollection.BaseGalleryButtonPartViewModel. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    const BaseGalleryButtonPartViewModel: typeof FxImpl.ViewModels.ParameterCollection.BaseGalleryButtonPartViewModel;
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterCollection.Common.d.ts
declare module MsPortalFx.ViewModels.Internal {
    /**
     * A message passed from collector to provider when the provider is opened.
     */
    interface ParameterProviderOpenMessage {
        /**
         * Initial data for the provider.
         */
        initialData: any;
        /**
         * Additional configuration for the provider.
         */
        providerConfig: any;
    }
    /**
     * A message passed from provider to collector when a result is available.
     */
    interface ParameterProviderResultMessage {
        /**
         * The result supplied by the parameter provider.
         */
        resultData: any;
    }
    /**
     * A subscriber to the results committed by the provider back to the collector.
     */
    interface ProviderResultSubscriber<TResult> {
        /**
         * A callback on the subscriber to receive the results.
         */
        receiveResult: (result: TResult) => void;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterCollector.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Options for constructing a parameter collector.
     */
    interface ParameterCollectorOptions<TResult> {
        /**
         * The selectable associated with the same <BladeAction> as this
         * parameter collector. The parameter collector will supply initial
         * data to the child blade when this becomes selected.
         *
         * If not specified, this defaults to container.selectable (so it
         * works with selectable parts without configuration).
         *
         * This option is mutually exclusive with 'selectableSet'.
         */
        selectable?: SelectableContract<any>;
        /**
         * The selectable set associated with the same <BladeAction> as this
         * parameter collector. The parameter collector will supply initial
         * data to the child blade when this becomes selected.
         *
         * This option is mutually exclusive with 'selectable'.
         */
        selectableSet?: SelectableSet<any, any>;
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Initial data for the child blade.
         */
        supplyInitialData?(activatedItem: any): TResult;
        /**
         * A callback that supplies additional configuration options for the
         * provider each time it opens. You can use this to pass non-editable
         * data, for example configuring how a form will be displayed.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Arbitrary configuration options for the child blade.
         */
        supplyProviderConfig?(activatedItem: any): any;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
         */
        receiveResult?(result: TResult, activatedItem: any): void;
        /**
         * Provides an easy way to integrate a parameter collector with an EditScope.
         *
         * The collector will supply initial data to the provider from this edit scope
         * property, and will automatically insert the provider's output into this edit
         * scope property. The net result is that your parameter collector will act as
         * an editor for the specified edit scope property.
         *
         * If you specify this option, do not also specify either supplyInitialData or
         * receiveResult.
         */
        formFieldValueAccessor?: Forms.EditScopeAccessors<TResult>;
        /**
         * For internal use only
         */
        fxInternalFI?: boolean;
    }
    /**
     * A parameter collector opens a child blade, supplies initial data to it, and may later
     * receive back completed data.
     */
    class ParameterCollector<TResult> {
        private bladeCaller;
        /**
         * Constructs an instance of ParameterCollector.
         *
         * @param inputsCallbackRegistrar The container to register with for callbacks
         * @param options Options for the instance.
         *
         */
        constructor(inputsCallbackRegistrar: InputsCallbacksRegistrar, options: ParameterCollectorOptions<TResult>);
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterProvider.d.ts
declare module MsPortalFx.ViewModels {
    import FxData = MsPortalFx.Data;
    import ActionBarOutput = MsPortalFx.ViewModels.ActionBars.Base.ActionBarOutput;
    /**
     * The default parameter provider commit arguments with the action bar output.
     */
    interface ParameterProviderActionBarCommitArgs {
        /**
         * The action bar output.
         */
        actionBarOutput: ActionBarOutput;
    }
    /**
     * Options for constructing a parameter provider.
     */
    interface ParameterProviderOptions<TResult, TEditScope> {
        /**
         * A callback that supplies the initial data for the provider's edit scope.
         * This callback is mandatory, and must account for the possibility of the
         * collector supplying incomplete information (or none at all) by returning
         * the complete initial state for the edit scope.
         *
         * @param dataFromCollector The incoming initial data from the parameter collector, or null if the collector did not supply any.
         * @return The desired initial edit scope data.
         */
        mapIncomingDataForEditScope?(dataFromCollector: TResult): TEditScope;
        /**
         * An asynchronous callback that supplies the initial data for the provider's edit scope.
         * This callback is mandatory, and must account for the possibility of the
         * collector supplying incomplete information (or none at all) by returning
         * the complete initial state for the edit scope.
         *
         * @param dataFromCollector The incoming initial data from the parameter collector, or null if the collector did not supply any.
         * @return The desired initial edit scope data.
         */
        mapIncomingDataForEditScopeAsync?(dataFromCollector: TResult): Base.PromiseV<TEditScope>;
        /**
         * The metadata type corresponding to the TResult generic parameter. This is
         * used to configure the edit scope.
         */
        editScopeMetadataType?: string;
        /**
         * A mapping function that converts outgoing data from the provider's edit scope
         * into the format you wish to return to the collector.
         *
         * Note that the object received by the parameter collector will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed in a serialized form.
         *
         * @param editScopeData The data currently held by the parameter provider.
         * @param commitArgs The optional commit arguments.
         * @return The data that should be returned to the calling parameter collector.
         */
        mapOutgoingDataForCollector(editScopeData: TEditScope, commitArgs?: any): TResult;
        /**
         * A callback invoked when the user dismisses the provider. If you need to begin a
         * provisioning operation that adds a startboard part and collapses the current
         * journey, you can do so in this callback. You should not commence any other
         * server-side operation from this callback, because the blade will have closed
         * before it completes, so the user would not be able to see the result.
         *
         * @param editScopeData The data stored in the provider's edit scope.
         */
        commitResult?(editScopeData: TEditScope): void;
    }
    /**
     * A parameter provider receives parameters from its parent blade, then later, when the user clicks
     * on an action bar, supplies a result object to the parent blade and closes.
     */
    class ParameterProvider<TResult, TEditScope> {
        private bladeCallable;
        protected defaultActionBarInput: KnockoutObservable<ActionBars.CreateActionBar.ActionBarInput>;
        private _options;
        private _configFromCollector;
        private _hasSentResult;
        private _editScopeId;
        private _editScopeCache;
        private _editScopeView;
        private _getResultSubscribers;
        /**
         * Constructs an instance of ParameterProvider.
         *
         * @param container The container associated with the part or other composition item hosting this parameter provider.
         * @params options Options for the instance.
         */
        constructor(container: ContainerContract, options: ParameterProviderOptions<TResult, TEditScope>);
        /**
         * The edit scope holding the data being edited in this provider blade.
         */
        get editScope(): KnockoutObservable<FxData.EditScope<TEditScope>>;
        /**
         * The arbitrary configuration object supplied by the collector, if any.
         */
        get configFromCollector(): KnockoutObservable<any>;
        protected getResultsBeforeCommit(subscriber: Internal.ProviderResultSubscriber<TResult>): void;
        protected getResults(): TResult;
        private _prepareEditScopeWithInitialData;
        private _setUpActionBarWatcher;
        private _discardEditScopeAndSendResult;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.PickerBase.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV3.Pickers {
    import FxViewModels = MsPortalFx.ViewModels;
    import Grid = FxViewModels.Controls.Lists.Grid;
    /**
     * Picker base module
     */
    module PickerBase {
        /**
         * Options for the create new blade launched from the picker.
         *
         * Create new will be an entry at the top of the picker and will launch a blade.
         * This blade has to implement a Parameter Provider V3 and return data in the same type as the picker.
         */
        interface CreateNewOptions<TDataModel> {
            /**
             * The title to show for the create new entry.
             */
            title: string;
            /**
             * The blade to launch when the create new entry is selected.
             * This blade has to implement Parameter Provider V3 to receive inputs and send outputs.
             */
            dynamicBladeSelection: FxViewModels.DynamicBladeSelection;
            /**
             * Optional method to supply intial data to the provider in the create new blade.
             * If this method is implemented, the create new blade will get passed these inputs from the picker.
             */
            supplyInitialData?(): TDataModel;
            /**
             * Optional method to supply config to the provider in the create new blade.
             * By default, the create new blade will get the same inputs that the picker received but this can be
             * overridden by implementing this method.
             */
            supplyProviderConfig?(): any;
            /**
             * Optional method that receives results from the create new provider.
             * Once the create new blade closes, the results received are passed to this method if it is implemented.
             */
            receiveResults?(result: TDataModel): void;
        }
        /**
         * Options for the picker.
         */
        interface Options<TItem, TDataModel> {
            /**
             * The data navigator that returns the list of picker items. It has to be a sequential data navigator for now.
             * This is mutually exclusive with the observable list of items provided.
             */
            dataNavigator?: MsPortalFx.Data.DataNavigatorBase<TItem>;
            /**
             * The list of items shown in the picker.
             * This is mutually exclusive with the data navigator.
             */
            items?: KnockoutObservableArray<TItem>;
            /**
             * Callback to map incoming data to data model.
             *
             * @param data Incoming data that gets written to the edit scope.
             */
            mapIncomingDataToDataModel(data: any): TDataModel;
            /**
             * Callback to load picker items. This is called after the parameter collector is ready.
             *
             * @pickerInputs List of inputs that the picker defines
             * @dataModel The data model. If this is set and the picker is multiselect, the items in the data model must be returned in the first page.
             */
            loadPickerItems(pickerOptions: any, dataModel?: TDataModel): void;
            /**
             * Callback to map items to the data model. This is called with a list of selected items.
             *
             * @param items List of selected picker items
             */
            mapItemsToDataModel(items: TItem[]): TDataModel;
            /**
             * Callback to check if a picker item is in or equal the data model.
             *
             * @item The picker item in the grid
             * @dataModel The data model.
             */
            isItemInDataModel(pickerItem: TItem, dataModel: TDataModel): boolean;
            /**
             * The text to show for the create new entry.
             */
            createNewOptions?: CreateNewOptions<TDataModel>;
            /**
             * If set to true, allows multiple items to be selected in the picker. Defaults to false.
             * Note that when multi-select is set, the loadPickerItems should return all the pre-selected items in the first page.
             */
            allowMultiSelect?: boolean;
        }
        /**
         * Picker item interface
         */
        interface Item {
            /**
             * The title of the item displayed.
             */
            title: KnockoutObservable<string>;
            /**
             * The sub title of the item.
             */
            subtitle?: KnockoutObservable<string>;
            /**
             * Text next to sub title on the second row.
             */
            detail?: KnockoutObservable<string>;
            /**
             * The icon to display for this picker item.
             */
            icon?: KnockoutObservable<MsPortalFx.Base.Image>;
            /**
             * Flag indicating if the item is disabled.
             */
            disabled?: KnockoutObservable<boolean>;
            /**
             * The info balloon shown next to the item.
             */
            infoBalloon?: FxViewModels.Controls.DockedBalloon.ViewModel;
            /**
             * The item associated with this picker item.
             */
            item: any;
        }
        /**
         * Inputs to picker. Picker implementations can extend this interface to add additional options.
         * But it is expected to contain the options supported by the base picker.
         */
        interface Config {
        }
    }
    /**
     * The base picker class.
     */
    class PickerBase<TItem, TDataModel> extends FxViewModels.Controls.Loadable.ViewModel {
        /**
         * The parameter provider defined in this this part.
         */
        parameterProvider: FxViewModels.ParameterProvider<any, {
            pickedItems: KnockoutObservable<TDataModel>;
        }>;
        /**
         * The parameter collector that gets data for new items.
         */
        addNewItemCollector: FxViewModels.ParameterCollector<TDataModel>;
        /**
         * Flag indicating if the picker allows create new.
         */
        showCreateAction: KnockoutObservable<boolean>;
        /**
         * Add new grid that launches a new blade
         */
        addNewGrid: Grid.ViewModel<any, any>;
        /**
         * The grid that lists the picker items.
         */
        pickerGrid: Grid.ViewModel<TItem, any>;
        /**
         * Option that shows or disables a select button.
         * This is controlled by the multiSelectEnabled flag from the collector and should not be changed by the deriving picker.
         */
        showSelectButton: KnockoutObservable<boolean>;
        /**
         * Used to automatically trigger the select button when single select is enabled.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * Boolean indicating if an info box should be shown.
         */
        showInfoBox: KnockoutObservable<boolean>;
        /**
         * The info box view model.
         */
        infoBoxViewModel: FxViewModels.Controls.InfoBox.BaseViewModel;
        private _basicTemplate;
        /**
         * Creates a new instance of the
         */
        constructor(container: PartContainerContract, initialState: any, options: PickerBase.Options<TItem, TDataModel>);
        /**
         * If the picker implementation supports create new and wants to programatically open the create new blade
         * based on certain inputs/config, it can call this method.
         */
        openCreateNewBlade(): void;
        /**
         * If the picker implementation supports create new and wants to programatically disable the create new option
         * based on certain inputs/config, it can call this method.
         */
        disableCreateNewOption(): void;
        private _saveToEditScope;
        /**
         * Create the picker grid.
         */
        private _buildPickerGrid;
        /**
         * Create an add new grid.
         */
        private _buildAddNewGrid;
        /**
         * Gets the data model from the edit scope.
         */
        private get dataModel();
        /**
         * Selects the grid item based on given index.
         *
         * @param item Picker item to select in the grid.
         */
        private _selectGridItem;
        /**
         * Selects the grid item based on given index.
         *
         * @param item Picker item to disable in the grid.
         */
        private _disableGridItem;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.Provisioner.d.ts
declare module FxImpl.ViewModels.ParameterCollectionV3 {
    import FxBase = MsPortalFx.Base;
    import Rpc = FxImpl.Rpc;
    import ParameterCollection = MsPortalFx.ViewModels.ParameterCollectionV3;
    interface ProvisioningInitiationId {
        provisionerId: string;
        provisioningRefKey: string;
    }
    interface ProvisioningRequest {
        provisioningConfig: ParameterCollection.Provisioner.Config;
        provisioningRefKey: string;
        provisioningPromise: FxBase.PromiseVN<any, any>;
        startboardInfo: ParameterCollection.StartboardInfo;
    }
    interface ProvisioningOperation {
        provisioningPromise: FxBase.PromiseVN<any, any>;
        data: any;
    }
    interface ProvisioningPartInitialData {
        provisioningConfig: ParameterCollection.Provisioner.Config;
        provisioningRefKey: string;
        startboardPart: ParameterCollection.ExtensionElement;
    }
    let initiateProvisioningRequestEndPoint: Rpc.ProxiedObjectTypeDefinition<ProvisioningInitiationId, ProvisioningInitiationId>;
    let getProvisioningRequestEndPoint: Rpc.ProxiedObjectTypeDefinition<ProvisioningInitiationId, ProvisioningRequest>;
    let getProvisioningOperationEndPoint: Rpc.ProxiedObjectTypeDefinition<string, ProvisioningOperation>;
    function getProvisioningOperation(provisioningRefKey: string, rpcClient?: Rpc.Client): Q.Promise<ProvisioningOperation>;
    /**
     * Interface for the internal provisioner endpoints.
     */
    interface Provisioner<TData> extends ParameterCollection.Provisioner<TData> {
        traceValidation: (eventType: ParameterCollection.ValidationEvent) => void;
    }
}
declare module MsPortalFx.ViewModels.ParameterCollectionV3 {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    type ValidationEvent = "FailedFormValidation" | "FailedArmValidation" | "PassedValidation" | "DeployWithoutValidate";
    /**
     * @deprecated MsPortalFx.ViewModels.ParameterCollectionV3.Provisioner. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    class Provisioner<TData> implements FxBase.Disposable {
        /**
         * The provisioner configuration that the collector passes to the provider part.
         */
        provisioningConfig: KnockoutObservable<Provisioner.Config>;
        /**
         * A promise representing the provisioning operation. The observable is updated with the result
         * of the 'supplyProvisioningPromise' callback.
         */
        provisioningPromise: KnockoutObservable<FxBase.PromiseVN<any, any>>;
        /**
         * A flag indicating whether provisioning is happening on the startboard or not.
         */
        provisionOnStartboard: KnockoutObservable<boolean>;
        /**
         * The tracking id of the deployment.
         */
        protected get _telemetryId(): string;
        /**
         * A flag indicating whether provisioning is custom or not custom (going through ARM).
         */
        protected _isCustomProvisioning: boolean;
        /**
         * The launching context.
         */
        protected readonly _launchingContext: MsPortalFx.Azure.ResourceManager.LaunchingContext;
        /**
         * The inputs for the post provisioning blade.
         */
        protected _postProvisioningInputsDeferred: Q.Deferred<Provisioner.PostProvisioningBladeInputs>;
        private static rpcClient;
        private static provisioningRequestsLookup;
        private static provisionersList;
        private static _rpcRegistered;
        protected _actionBar: FxViewModels.ActionBars.CreateActionBar.Contract;
        protected _actionBarSupportsForceInProgressStatus: boolean;
        protected _actionBarSupportsIsProvisioningBlade: boolean;
        protected _actionBarSupportsProvisionOnStartboardPart: boolean;
        protected _actionBarSupportsSecondaryLinkDisplayText: boolean;
        protected _actionBarSupportsSecondaryLinkValidation: boolean;
        protected _actionBarSupportsShowActionBar: boolean;
        protected _validationEvents: Telemetry.TelemetryEvent[];
        private _options;
        private _provisionerId;
        /**
         * Constructs a new instance of a parameter collection provisioner.
         *
         * @param container The container into which the part containing the provisioner is being placed.
         * @param options The provisioner options.
         */
        constructor(container: FxViewModels.ContainerContract, options: Provisioner.Options<TData>);
        dispose(): void;
        /**
         * Manually start provisioning. This is usually used with collector view models. This must
         * not be used if the provisioner is configured with a provider and an action bar (automatically)
         * triggered). This method uses the 'supplyStartboardInfo' to define a startboard part if you
         * want provisioning to happen on the startboard, or return null or undefined if you want it
         * to run in the background.
         *
         * @param data The provisioning data that will be passed to the provisioning operation.
         * @return A promise that represents the provisioning operation.
         */
        startProvisioning(data: TData): FxBase.PromiseVN<any, any>;
        /**
         * Trace a validation event.
         */
        protected _traceValidation(eventType: ValidationEvent): void;
        protected receiveResult(result: TData): void;
        private _beginProvisioning;
        private _initiateProvisioningRequest;
        private static _registerRpcCallbacks;
        private getProvisioningRequest;
        protected _createEventBase(): Telemetry.TelemetryEvent;
        protected _traceProvisioningStarted(eventData?: Telemetry.TelemetryEvent): Telemetry.TelemetryEvent;
        protected _traceProvisioningEnded(result: any, resolved: boolean, eventData?: Telemetry.TelemetryEvent): Telemetry.TelemetryEvent;
    }
    module Provisioner {
        /**
         * Options for constructing a provisioner.
         */
        interface Options<TData> {
            /**
             * A callback that supplies the promise that represents the provisioning operation.
             *
             * Note that the promise returned cannot be persisted. So in the case when the user closes
             * the browser, navigates away, or loses connection. It's advisable to make the operation as
             * short as possible, make it return some sort of an operation id, and then use that operation
             * id to continuously check on the status of the operation (i.e. poll for updates).
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically, the data is the same data returned to the collector (by the
             *      'mapOutgoingDataForCollector' method). If the provisioner is triggered automatically,
             *      the data is whatever is passed to the 'startProvisioning' method.
             * @return A promise representing the provisioning operation, that is resolved with data passed
             *      to the provisioning part, if one exists.
             */
            supplyProvisioningPromise: (data: TData) => FxBase.PromiseVN<any, any>;
            /**
             * A callback that supplies the provisioner with the startboard info.
             *
             * If provisioning is automatically triggered, and if the user wants provisioning to happen
             * on the startboard, the startboard info returned by used for that purpose. If invalid
             * startboard info is returned, the provisioner will throw an exception and provisioning will
             * fail. Null or undefined are not acceptable.
             *
             * If provisioning is manually triggered, returning null or undefined indicates that you don't
             * want provisioning to happen on the startboard. If you return invalid startboard info, the
             * provisioner will throw an exception. If you return valid startboard info, a provisioning
             * part will be added to the startboard for provisioning to take place.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically (it's hooked up with a provider and an action bar), the data
             *      is the same data returned to the collector (by the 'mapOutgoingDataForCollector'
             *      method). If the provisioner is triggered automatically, the data is whatever was
             *      passed to the 'startProvisioning' method.
             * @return A startboard info object indicating which provisioning part to use and which
             *      startboard the provisioning part will mutate into.
             */
            supplyStartboardInfo: (data: TData) => StartboardInfo;
            /**
             * The action bar view model. This is the action bar on your provider blade. Defining this
             * property means you also need to define a parameter provider.
             */
            actionBar?: FxViewModels.ActionBars.Base.Contract;
            /**
             * The parameter provider. This is the parameter provider on your provider view model.
             * Defining this property means you also need to define an action bar.
             */
            parameterProvider?: FxViewModels.ParameterProvider<TData, any>;
        }
        /**
         * The parameters for the blade shown following submission of a provisioning request.
         */
        interface PostProvisioningBladeInputs {
            /**
             * The deployment Id.
             */
            readonly deploymentId: string;
            /**
             * The gallery item id.
             */
            readonly galleryItemId: string;
            /**
             * The absolute URI of the medium icon image for the gallery item.
             */
            readonly galleryItemIconUri: string;
            /**
             * The ID of the primary resource being created by the deployment.
             */
            readonly primaryResourceId: string;
            /**
             * The key used to locate the relevant extension-provided content for the blade.
             * If this is provided, the packageId parameter must also be provided.
             */
            readonly provisioningHash?: string;
            /**
             * Metadata about the blade that initiated the deployment.
             */
            readonly createBlade?: {
                /**
                 * The name of the create blade that initiated the deployment.
                 */
                readonly bladeName: string;
                /**
                 * The name of the extension containing the create blade that initiated the deployment.
                 */
                readonly extension: string;
            };
        }
        /**
         * The provisioner configuration that a collector can pass to the provider part.
         */
        interface Config {
            /**
             * A flag that indicates whether provisioning is enabled or not.
             * Valid only in the automatic triggering scenario.
             */
            provisioningEnabled: boolean;
            /**
             * (Optional) The startboard info used in the provisioning process.
             */
            startboardProvisioningInfo?: StartboardInfo;
            /**
             * (Optional) Prevents the provisioner from discarding the journey. Only works if
             * provisioning does not happen on the startboard (because choosing to add a part on the
             * startboard means the journey must be discarded). Defaults to false.
             *
             */
            dontDiscardJourney?: boolean;
            /**
             * (Optional) Show the post-create blade after deployment has started.
             */
            launchPostCreate?: boolean;
            /**
             * (Optional) The inputs for the blade to open after deployment has started.
             */
            postProvisioningBladeInputs?: Q.Promise<PostProvisioningBladeInputs>;
        }
    }
    /**
     * An extension element definition (e.g. part or blade) .
     */
    interface ExtensionElement {
        /**
         * The extension element extension.
         */
        extension: string;
        /**
         * The extension element name.
         */
        name: string;
    }
    /**
     * Startboard info. Used by the provisioner to know which provisioning part to add to the
     * startboard, and which part it will mutate into.
     */
    class StartboardInfo {
        /**
         * The provisioning part definition.
         */
        provisioningPart: ExtensionElement;
        /**
         * The startboard part definition (the one the provisioning part will mutate into).
         */
        startboardPart: ExtensionElement;
        /**
         * The name of the id property on the startboard part.
         */
        startboardPartKeyId: string;
        /**
         * Validates a startboard info object.
         * Validates against null, undefined, and incomplete data.
         *
         * @param startboardInfo The startboard info.
         * @return A boolean indicating whether the startboard info object is valid or not.
         */
        static isValid(startboardInfo: StartboardInfo): boolean;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ProvisioningPart.d.ts
declare module FxImpl.ViewModels.ParameterCollectionV3 {
    let pollingInterval: number;
    let pollingRetries: number;
}
declare module MsPortalFx.ViewModels.ParameterCollectionV3 {
    import Internal = FxImpl.ViewModels.ParameterCollectionV3;
    /**
     * @deprecated MsPortalFx.ViewModels.ParameterCollectionV3.ProvisioningPart. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    class ProvisioningPart extends ButtonPart {
        /**
         * The description displayed on the provisioning part.
         */
        description: KnockoutObservable<string>;
        /**
         * Error message displayed when there is an error during provisioning.
         */
        errorMessage: KnockoutObservable<string>;
        /**
         * The URI for the icon displayed on the provisioning part.
         */
        icon: KnockoutObservable<Base.Image>;
        /**
         * The initial inputs the provisioning part receives when added to the startboard. This is
         * persisted to the part's view state, and used to resume polling for deployment updates in
         * case of refresh.
         */
        initialData: KnockoutObservable<Internal.ProvisioningPartInitialData>;
        /**
         * The updated data, the last data sent by the provisioning promise in the progress or then
         * callbacks. This is useful if we need to notify the part with some data, but we're not sure
         * whether it's set up or not. This helps the provisioning part catch up on the last update
         * while it wasn't ready with the callbacks.
         */
        updatedData: KnockoutObservable<any>;
        /**
         * A promise representing the provisioning operation. The part mutates into the target startboard
         * part when this promise is resolved.
         */
        provisioningPromise: KnockoutObservable<Base.PromiseVN<any, any>>;
        /**
         * A flag indicating whether or not provisioning has started.
         */
        provisioningStarted: KnockoutObservable<boolean>;
        /**
         * True if the status of the deployment cannot be obtained; else false.
         */
        statusUnknown: KnockoutObservable<boolean>;
        /**
         * Callback invoked when the provisioning promise is acquired. Unless the subclass implements
         * it, the default behavior is mutating the part into the target startboard part on success,
         * and errors are thrown (unless 'onProvisioningPromiseError' is also implemented).
         */
        onProvisioningPromiseAcquired: (promise: Base.PromiseVN<any, any>) => void;
        /**
         * Callback invoked when an error occurs due to the provisioning promise being rejected.
         * Unless the subclass implements it, the default behavior is updating the part's title to
         * the error message and throwing the error.
         */
        onProvisioningPromiseError: (error: any) => void;
        /**
         * The title displayed on the provisioning part.
         */
        title: KnockoutObservable<string>;
        _shouldBlockUiWhenProvisioning: boolean;
        private _delayPromise;
        private _partContainer;
        private _provisioningConfig;
        /**
         * Initializes a new instance of the parameter collection provisioning part view model class.
         *
         * @param container The container into which the part is being placed.
         * @param initialState Initial state for the part.
         */
        constructor(container: PartContainerContract, initialState: any);
        /**
         * Gets the provisioner configuration passed originally from the collector, to the provisioner,
         * to this provisioning part.
         */
        get provisioningConfig(): Provisioner.Config;
        /**
         * Sets the provisioner configuration passed originally from the collector, to the provisioner,
         * to this provisioning part.
         */
        set provisioningConfig(provisioningConfig: Provisioner.Config);
        onInputsSet(inputs: any): Base.Promise;
        /**
         * Finds the startboard part and mutates into it.
         *
         * @param partInputs The inputs to the startboard part.
         */
        mutateIntoStartboardPart(partInputs: any): void;
        private _fetchProvisioningPromise;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.AssetPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface that defines the view model that represents an asset part. Extends resizable.
     */
    interface AssetPartContract extends Resizable {
        /**
         * The friendly-name of the type.
         */
        assetType: KnockoutObservableBase<string>;
        /**
         * The name of the part.
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * The asset's image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The id of the part.
         */
        assetId: KnockoutObservableBase<any>;
        /**
         * The state of the part.
         */
        status?: KnockoutObservableBase<string>;
        /**
         * The colored line beside the part.
         */
        state?: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
    }
    /**
     * A view model class that respresents an asset part.
     */
    class AssetPart implements AssetPartContract {
        /**
         * The friendly-name of the type.
         */
        assetType: KnockoutObservableBase<string>;
        /**
         * The name of the part.
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * The asset's image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The id of the part.
         */
        assetId: KnockoutObservableBase<any>;
        /**
         * The state of the part.
         */
        status: KnockoutObservableBase<string>;
        /**
         * The colored line beside the part.
         */
        state: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ButtonPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface that defines the view model that respresents a button part. Extends resizable.
     */
    interface ButtonPartContract extends Resizable {
        /**
         * The title of the part.
         */
        title: KnockoutObservableBase<string>;
        /**
         * A shorter title of the part (for size: mini).
         */
        shortTitle: KnockoutObservableBase<string>;
        /**
         * A description for the part.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon for the the part.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
    }
    /**
     * A view model class that respresents a button part.
     */
    class ButtonPart implements ButtonPartContract {
        /**
         * The title of the part.
         */
        title: KnockoutObservableBase<string>;
        /**
         * A shorter title of the part (for size: mini).
         */
        shortTitle: KnockoutObservableBase<string>;
        /**
         * A description for the part.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon for the the part.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ChartPart.d.ts
declare module MsPortalFx.ViewModels {
    import PartSize = MsPortalFx.Parts.PartSize;
    /**
     * A view model class that respresents a chart part.
     */
    class ChartPart<TX, TY> extends MsPortalFx.ViewModels.Controls.Visualization.Chart.ViewModel<TX, TY> implements Resizable {
        /**
         * The size of the part (makes it adaptive).
         */
        size: KnockoutObservable<PartSize>;
        /**
         * The selectable for the edit button.
         */
        editButtonSelectable: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * The text for the edit button.
         */
        editButtonText: KnockoutObservable<string>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.CollectionPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Collection {
    import Fx = MsPortalFx;
    import BaseFx = Fx.Base;
    import PartSize = Fx.Parts.PartSize;
    import FxViewModels = Fx.ViewModels;
    import FxGrid = FxViewModels.Controls.Lists.Grid;
    /**
     * The modes of the grid in collection part.
     */
    enum GridMode {
        /**
         * Shows no grid. 0 is falsy.
         */
        None = 0,
        /**
         * Shows raw data grid.
         */
        Data = 1,
        /**
         * Shows the aggregated rollup data grid.
         */
        Rollup = 2
    }
    /**
     * The contract for the grid on the collection part.
     */
    interface GridContract {
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<FxGrid.Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items?: KnockoutObservableArray<any>;
    }
    /**
     * The options for the collection part view model
     */
    interface CollectionOptions {
        /**
         * The raw data.
         */
        data: GridContract;
        /**
         * The rollup data.
         */
        rollupData?: GridContract;
        /**
         * Shows the header of the grid.
         */
        showHeader?: boolean;
        /**
         * Options for the SelectableRow grid extension.  If null, rows will not be selectable.
         */
        selectableRowExtensionOptions?: FxGrid.SelectableRowExtensionOptions<any, any>;
        /**
         * The label to show when the grid has no rows.
         */
        noRowsMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally show some HTML when there are no grid rows.
         */
        noRowsHtml?: KnockoutObservableBase<FxViewModels.Forms.CustomHtml.ViewModel>;
    }
    /**
     * A view model class that respresents a collection part.
     */
    class ViewModel implements Resizable {
        size: KnockoutObservable<PartSize>;
        alwaysShowRollupCount: KnockoutObservable<boolean>;
        rollupCount: KnockoutObservable<number>;
        selectableData: FxViewModels.SelectableSet<any, any>;
        rollupCountIconUri: KnockoutObservable<string>;
        rollupCountIcon: KnockoutObservableBase<BaseFx.Image>;
        rollupCountLabel: KnockoutObservable<string>;
        /**
         * The mode of the grid.
         */
        gridMode: KnockoutObservable<GridMode>;
        /**
         * The no rows HTML.
         */
        noRowsHtml: KnockoutObservableBase<FxViewModels.Forms.CustomHtml.ViewModel>;
        /**
         * Boolean indicating if the grid is empty.
         */
        emptyGrid: KnockoutObservableBase<boolean>;
        _options: CollectionOptions;
        _container: FxViewModels.PartContainerContract;
        private grid;
        private hasMoreData;
        private noRollupCount;
        /**
         * The constructor of the collection part view model.
         */
        constructor(container: FxViewModels.PartContainerContract, options: CollectionOptions);
        private _reactToDataChange;
        private _reactToSizeChange;
        private _updateGrid;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.CollectionSummary.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model interface that respresents summary information for a collection of resource instances.
     */
    interface CollectionSummaryContract extends Resizable {
        /**
         * The count of instances of the resource.
         */
        resourceCount: KnockoutObservableBase<number>;
        /**
         * If the resourceCount is a lower limit
         */
        countIsMinimum?: KnockoutObservableBase<boolean>;
        /**
         * The description text or resource data.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon to an image representing the resource type.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The label associated with the resource count.
         */
        label?: KnockoutObservableBase<string>;
    }
    /**
     * A view model class that represents summary information for a collection of resource instances.
     */
    class CollectionSummary implements CollectionSummaryContract {
        /**
         * The count of instances of the resource.
         */
        resourceCount: KnockoutObservableBase<number>;
        /**
         * If the resourceCount is a lower limit
         */
        countIsMinimum: KnockoutObservableBase<boolean>;
        /**
         * The description text or resource data.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon to an image representing the resource type.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The label associated with the resource count.
         */
        label: KnockoutObservableBase<string>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.CreatePart.d.ts
declare module MsPortalFx.ViewModels {
    interface CreatePartContract extends ButtonPartContract {
        /**
         * The name of the create definition.
         */
        createName: KnockoutObservable<string>;
    }
    class CreatePart extends ButtonPart implements CreatePartContract {
        createName: KnockoutObservable<string>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.DiffEditorPart.d.ts
declare module MsPortalFx.ViewModels.Parts.DiffEditor {
    const ViewModel_base: any;
    /**
     * The view model that implements the DiffEditor part interface.
     */
    export class ViewModel extends ViewModel_base {
        /**
         * The size of the part.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * Constructs a DiffEditor part view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
    export {};
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.DonutPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Donut {
    /**
     * @deprecated Donut.ItemData. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Item represents a row.
     */
    interface ItemData {
    }
    /**
     * @deprecated Donut.GroupInfo. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * GroupInfo is the ViewModel for a particular <optGroup>
     */
    interface GroupInfo {
        /**
         * Id for mapping from Item GroupID column to this user friendly GroupInfo.
         */
        key: string;
        /**
         * User friendly label for the grouping. It can be either string or ko.obserable<string>.
         */
        text: any;
        /**
         * Disable state of this group. It can be either boolean or ko.obserable<boolean>.
         */
        disable: any;
    }
    /**
     * @deprecated Donut.ItemSetting. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * ItemSetting is the fields setting to inform the ViewModel to construct the donut items.
     */
    interface ItemSetting {
        /**
         * Data key used to identify the color.  This is optional, if not provided, it will use default color wheel.
         */
        colorKey?: string;
        /**
         * Data key used to identify the row.  Data have to be string, we use it on the object map to quickly identify item's element.
         */
        rowIdKey?: string;
        /**
         * Data key used to label the row for display purpose.  Data have to be string, we use to show center caption for quick indication of the item.
         */
        labelKey?: string;
        /**
         * RowId of current hovered slice in donut.
         */
        hoveredIndex?: KnockoutObservable<string>;
        /**
         * Property used for display item. If it is not set, it uses items[index] to display.
         */
        textKey?: string;
        /**
         * Property used for Value of an item. If it is not set, it uses items[index] as Value.
         */
        valueKey?: string;
        /**
         * Property used for disable state of an item. If it is not set, default to false.
         */
        disableKey?: string;
        /**
         * Property used for select state of an item. If it is not set, default to false.
         */
        selectedKey?: string;
        /**
         * Property used for grouping of an item. If it is not set, there is no grouping for the items.
         */
        groupIdKey?: string;
        /**
         * Data key of the hatching pattern.
         */
        hatchingKey?: string;
    }
    /**
     * @deprecated Donut.ViewModel. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The ViewModel class that implementes the Donut interface.
     */
    class ViewModel implements Resizable {
        /**
         * See Contract interface.
         */
        groupInfos: KnockoutObservableArray<GroupInfo>;
        /**
         * See Contract interface.
         */
        itemsDataArray: KnockoutObservableArray<ItemData>;
        /**
         * See Contract interface.
         */
        itemSetting: KnockoutObservableBase<ItemSetting>;
        /**
         * See Contract interface.
         */
        valueInitialized: boolean;
        /**
         * total value. The total value of all instances.
         */
        total: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}".
         * {0}: current value.
         * {1}: maximum value.
         */
        totalFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        unitFormat: KnockoutObservableBase<string | UnitConversion.Unit>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        infoFormat: KnockoutObservableBase<string>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space contraints in the center of the Donut.
         */
        numberFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentange.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        hoveredUnit: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text.
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        hoverInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        selectedInfoFormat: KnockoutObservableBase<string>;
        /**
         * Disable selected change on click.
         */
        disableSelectOnClick: KnockoutObservableBase<boolean>;
        /**
         * Title of the Gauge, a short description, will be utilized by screen-reader.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        ariaDesc: KnockoutObservableBase<string>;
        /**
         * Show or hide the legend. For some part size, the size will dictate whether legend should present or not.
         */
        showLegend: KnockoutObservableBase<boolean>;
        /**
         * Metrics used by the control
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.ViewModel;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        _msPortalFxRerenderTrigger: KnockoutObservableBase<number>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        render(): void;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.EditorPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Editor {
    import FxViewModelsControlsDocumentsEditor = MsPortalFx.ViewModels.Controls.Documents.Editor;
    /**
     * The view model that implements the Editor part interface.
     */
    class ViewModel extends FxViewModelsControlsDocumentsEditor.ViewModel {
        /**
         * The size of the part.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * Constructs an Editor part view model.
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.InfoListPart.d.ts
declare module MsPortalFx.ViewModels.Parts.InfoList {
    /**
     * The interface that defines the view model that respresents an InfoList. Extends resizable.
     */
    interface Contract {
        /**
         * The sections.
         */
        sections: KnockoutObservableArray<Section>;
    }
    interface Section {
        /**
         * The icon. Leave null if numbering is preferred.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The section header text.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The multi-line description text.
         */
        description: KnockoutObservableBase<string>;
        /**
         * The Link entries.
         */
        links?: Link[];
        /**
         * A section-wide click effect.
         */
        selection?: Link;
    }
    class Link {
        /**
         * Display Text.
         */
        text: KnockoutObservableBase<string>;
        /**
         * The hyperlink target.
         */
        uri: KnockoutObservableBase<string>;
        /**
         * Describes the blade that should be opened when this link is selected.
         */
        bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param uri The target to open in a new browser tab.
         */
        constructor(text: string, uri: string);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param uri The target to open in a new browser tab.
         */
        constructor(text: KnockoutObservableBase<string>, uri: KnockoutObservableBase<string>);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param bladeSelection The blade to open.
         */
        constructor(text: string, bladeSelection: MsPortalFx.ViewModels.DynamicBladeSelection);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param bladeSelection The blade to open.
         */
        constructor(text: KnockoutObservableBase<string>, bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>);
    }
    /**
     * A view model class that respresents an InfoList Part.
     */
    class ViewModel implements Contract, Base.Disposable {
        /**
         * See Contract.
         */
        sections: KnockoutObservableArray<Section>;
        private selection;
        private bladeLinks;
        constructor(initialState?: any);
        dispose(): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param sectionTargetUri The URI visited or blade opened on click. Text is ignored.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, sectionTargetUri: string, icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param sectionTarget The URI visited or blade opened on click. Text is ignored.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, sectionTargetSelectable: MsPortalFx.ViewModels.DynamicBladeSelection, icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param links The links provided after the description.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, links: Link[], icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param links The links provided after the description.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: KnockoutObservableBase<string>, description: KnockoutObservableBase<string>, links: any, icon?: MsPortalFx.Base.Image): void;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ItemSummary.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model that respresents summary information for an item.
     */
    interface ItemSummary {
        /**
         * The name of the item.
         */
        name: KnockoutObservable<string>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.PropertiesPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Properties {
    import InternalProperties = FxImpl.ViewModels.Parts.Properties;
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    /**
     * Part contract.
     */
    interface Contract {
        /**
         * The collection of properties.
         */
        properties: KnockoutObservableArray<Property>;
    }
    /**
     * Part view model.
     */
    class ViewModel implements MsPortalFx.ViewModels.Parts.Properties.Contract, MsPortalFx.Base.Disposable {
        private _openBladeProperties;
        private _openBladeAsyncProperties;
        private _moveResourceProperties;
        selection: MsPortalFx.ViewModels.SelectableSet<OpenBladeProperty, MsPortalFx.ViewModels.DynamicBladeSelection>;
        asyncSelection: MsPortalFx.ViewModels.SelectableSet<InternalProperties.OpenBladeAsyncProperty, MsPortalFx.ViewModels.DynamicBladeSelection>;
        moveResourceSelection: MsPortalFx.ViewModels.SelectableSet<Property, MsPortalFx.ViewModels.DynamicBladeSelection>;
        properties: KnockoutObservableArray<Property>;
        constructor(initialState?: any);
        /**
         * Sets the properties.
         */
        setProperties(properties: Property[]): void;
        /**
         * Removes all properties.
         */
        removeAllProperties(): void;
        dispose(): void;
    }
    /**
     * Property types.
     */
    const enum PropertyType {
        /**
         * Property with only text.
         */
        Text = 0,
        /**
         * Property with a link.
         */
        Link = 1,
        /**
         * Property with a copy field.
         */
        CopyField = 2,
        /**
         * Property with a callback.
         */
        Callback = 3,
        /**
         * Property to open a blade.
         */
        OpenBlade = 4,
        /**
         * Property to have a list of links.
         */
        MultiLinks = 5,
        /**
         * Property to have an of Svg.
         */
        Image = 6,
        /**
         * Property to have a list of open blade properties.
         */
        MultiOpenBlades = 7,
        /**
         * Property to open an asynchronously determined blade.
         */
        OpenBladeAsync = 8
    }
    /**
     * Supported edit types.
     */
    const enum EditType {
        /**
         * Unknown edit type.
         */
        Unknown = 0,
        /**
         * Allows to edit Resource Group or Subscription properties of a resource.
         */
        MoveResource = 1
    }
    /**
     * Options that can be set for all properties
     */
    interface CommonOptions {
        /**
         * Label of the property.
         */
        label: string;
        /**
         * If the property is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * If the property value should be wrapped.
         */
        wrappable?: KnockoutObservableBase<boolean> | boolean;
        /**
         * Value reflecting whether the property is loading its value.
         */
        isLoading?: KnockoutObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon?: MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel;
    }
    /**
     * Options for properties that can launch a blade
     */
    interface OpenBladeOptionalOptions {
        /**
         * Info of the blade to open
         */
        blade?: OpenBlade;
    }
    /**
     * Options for properties that are editable.
     */
    interface EditBladeOptionalOptions {
        /**
         * Info of the blade to open which allows editing property.
         */
        editBlade?: OpenBlade;
    }
    /**
     * Options for an OpenBladeProperty
     */
    interface OpenBladeOptions extends CommonOptions, EditBladeOptionalOptions, OpenBlade {
    }
    /**
     * The interface of a blade link.
     */
    interface OpenBlade {
        /**
         * The uri of the link.
         */
        bladeSelection: MsPortalFx.ViewModels.DynamicBladeSelection | KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * The display text of the link.
         */
        displayValue?: string | KnockoutObservableBase<string>;
        /**
         * Supported edit type if it's an edit blade.
         */
        editType?: EditType;
        /**
         * The edit link if it's an edit blade.
         */
        showLink?: boolean;
    }
    /**
     * Options for a TextProperty
     */
    interface TextOptions extends OpenBladeOptionalOptions, CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
        /**
         * Optional icon to display before the text
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    /**
     * Options for a LinkProperty
     */
    interface LinkOptions extends CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
        /**
         * Link display value of the property.
         */
        displayValue?: KnockoutObservableBase<string> | string;
        /**
         * Target value of the property.
         */
        target?: LinkTargetOptions;
    }
    /**
     * Options for a CopyFieldProperty
     */
    interface CopyFieldOptions extends OpenBladeOptionalOptions, EditBladeOptionalOptions, CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
    }
    /**
     * Options for an ImageProperty
     */
    interface ImageOptions extends OpenBladeOptionalOptions, CommonOptions {
        /**
         * The icon for callback and image
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    /**
     * Options for a MultiOpenBladeProperty
     */
    interface MultiOpenBladeOptions extends CommonOptions {
        /**
         * A collection of link for multiopenblade
         */
        bladeLinks: KnockoutObservableArray<OpenBlade>;
    }
    /**
     * Options for a MultiLinksProperty
     */
    interface MultiLinksOptions extends CommonOptions {
        /**
         * The observable array of links for multilinks
         */
        links: KnockoutObservableArray<Link>;
    }
    /**
     * Options for a CallbackProperty
     */
    interface CallbackOptions extends CommonOptions {
        /**
         * Displayed text for the link to execute the callback.
         */
        displayValue: KnockoutObservableBase<string> | string;
        /**
         * The callback for callback
         */
        callback: () => void;
        /**
         * The icon for callback and image
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    interface MoveResourceOptions extends CopyFieldOptions {
        /**
         * Resource Id
         */
        resourceId: string;
        /**
         * Resource move type
         */
        moveType: MsPortalFx.Azure.ResourceManager.MoveType;
    }
    /**
     * Property base class.
     */
    class Property implements MsPortalFx.Base.Disposable {
        /**
         * Gets the label of the property.
         */
        label: string;
        /**
         * Gets the display value of the property.
         */
        displayValue: KnockoutObservableBase<string>;
        /**
         * Gets the value of the property.
         * Note : this should be a KnockoutObservableBase<string>, but external code uses this
         * as a CopyField ViewModel because this property was an "any" and either a string,
         * or a CopyField ViewModel.  Can't separate them as this API is public and in use.
         */
        value: any;
        /**
         * Gets the value that is copied
         */
        copyableValue: KnockoutObservableBase<string>;
        /**
         * Gets or sets if the property is visible. It is true by default.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets if the property value should be wrapped. It is false by default.
         */
        wrappable: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets a link to open another blade.
         */
        bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * Get a value reflecting whether the property is loading its value.
         */
        isLoading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon: MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel;
        /**
         * Get the type of this property.
         */
        type: PropertyType;
        /**
         * A link to open a blade to edit the property.
         */
        editBlade: OpenBlade;
        /**
         * text for edit blade link.
         */
        editBladeText: string;
        _supportsIsLoading: boolean;
        hasValidBladeSelection: KnockoutComputed<boolean>;
        private readonly _lifetimeManager;
        protected get lifetimeManager(): FxBase.DisposableLifetimeManager;
        constructor(options: InternalProperties.AllOptions);
        /**
         * Get the property type.
         */
        getType(): PropertyType;
        dispose(): void;
    }
    /**
     * Text property class.
     */
    class TextProperty extends Property {
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        constructor(label: string, value: string);
        constructor(label: string, value: KnockoutObservableBase<string>);
        constructor(options: TextOptions);
        getType(): PropertyType;
    }
    type LinkTargetOptions = "_self" | "_blank";
    /**
     * Link property class.
     */
    class LinkProperty extends Property {
        target: LinkTargetOptions;
        constructor(label: string, uri: string, displayUri?: string);
        constructor(label: string, uri: KnockoutObservableBase<string>, displayUri?: KnockoutObservableBase<string>);
        constructor(options: LinkOptions);
        getType(): PropertyType;
    }
    /**
     * Copy field property.
     */
    class CopyFieldProperty extends Property {
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, value: string);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, value: KnockoutObservableBase<string>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: CopyFieldOptions);
        getType(): PropertyType;
    }
    /**
     * Callback property class.
     */
    class CallbackProperty extends Property {
        callback: () => void;
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        private callbackWrapper;
        constructor(label: string, displayValue: string, callback: () => void, icon?: MsPortalFx.Base.Image);
        constructor(label: string, displayValue: KnockoutObservableBase<string>, callback: () => void, icon?: KnockoutObservableBase<MsPortalFx.Base.Image>);
        constructor(options: CallbackOptions);
        getType(): PropertyType;
    }
    /**
     * The property to open a specified blade.
     */
    class OpenBladeProperty extends Property {
        constructor(label: string, displayValue: string, bladeSelection: MsPortalFx.ViewModels.DynamicBladeSelection);
        constructor(label: string, displayValue: KnockoutObservableBase<string>, bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>);
        constructor(options: OpenBladeOptions);
        getType(): PropertyType;
    }
    /**
     * The property to have a list of open blade properties
     */
    class MultiOpenBladeProperty extends Property {
        /**
         * The observable array of blade links.
         */
        bladeLinks: KnockoutObservableArray<OpenBladeProperty>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, bladeLinks: KnockoutObservableArray<OpenBlade>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: MultiOpenBladeOptions);
        getType(): PropertyType;
    }
    /**
     * The interface of a html link.
     */
    interface Link {
        /**
         * The display text of the link.
         */
        text: string;
        /**
         * The uri of the link.
         */
        uri: string;
    }
    /**
     * The property to have a list of html links
     */
    class MultiLinksProperty extends Property {
        /**
         * The observable array of links.
         */
        links: KnockoutObservableArray<Link>;
        constructor(label: string, links: KnockoutObservableArray<Link>);
        constructor(options: MultiLinksOptions);
        getType(): PropertyType;
    }
    /**
     * The property to have a image
     */
    class ImageProperty extends Property {
        /**
         * The observable image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        constructor(label: string, icon: KnockoutObservableBase<MsPortalFx.Base.Image>);
        constructor(options: ImageOptions);
        getType(): PropertyType;
    }
}
declare module FxImpl.ViewModels.Parts.Properties {
    import Properties = MsPortalFx.ViewModels.Parts.Properties;
    /**
     * Values permitted for the target property on an link control.
     */
    type LinkTargetOptions = Properties.LinkTargetOptions;
    /**
     * All options that can be set for a property
     */
    interface AllOptions {
        /**
         * Label of the property.
         */
        label?: string;
        /**
         * Value of the property.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Value that is copied.
         */
        copyableValue?: KnockoutObservableBase<string> | string;
        /**
         * If the property is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * If the property value should be wrapped.
         */
        wrappable?: KnockoutObservableBase<boolean> | boolean;
        /**
         * Blade link display value of the property.
         */
        displayValue?: KnockoutObservableBase<string> | string;
        /**
         * Blade link display value of the property.
         */
        target?: LinkTargetOptions;
        /**
         * A link to open another blade.
         */
        blade?: Properties.OpenBlade | OpenBladeAsync;
        /**
         * A link to open a blade to edit the property.
         */
        editBlade?: Properties.OpenBlade;
        /**
         * The icon for the property
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
        /**
         * A collection of link for multiopenblade
         */
        bladeLinks?: KnockoutObservableArray<Properties.OpenBlade>;
        /**
         * The observable array of links for multilinks
         */
        links?: KnockoutObservableArray<Properties.Link>;
        /**
         * The callback for callback
         */
        callback?: () => void;
        /**
         * Value reflecting whether the property is loading its value.
         */
        isLoading?: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon?: MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel;
    }
    /**
     * Options for an OpenBladeAsyncProperty
     */
    interface OpenBladeAsyncOptions extends Properties.CommonOptions, Properties.EditBladeOptionalOptions, OpenBladeAsync {
    }
    /**
     * The interface of a blade link.
     */
    interface OpenBladeAsync {
        /**
         * The display text of the link.
         */
        displayValue: string | KnockoutObservableBase<string>;
        /**
         * The uri of the link.
         */
        resolveBlade: () => MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicSelection>;
    }
    /**
     * The property to open a blade that is determined asynchronously.
     */
    class OpenBladeAsyncProperty extends Properties.Property {
        resolveBlade: () => MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicSelection>;
        constructor(options: OpenBladeAsyncOptions);
        getType(): Properties.PropertyType;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ProvisioningPart.d.ts
declare module FxImpl.ViewModels.ProvisioningPart {
    import ParameterCollectionInternal = MsPortalFx.ViewModels.ParameterCollection.Internal;
    /**
     * @deprecated FxImpl.ViewModels.ProvisioningPart.ContentContract. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    interface ContentContract extends MsPortalFx.ViewModels.PartContent {
        /**
         * The title displayed on the provisioning part.
         */
        title: KnockoutObservable<string>;
        /**
         * The description displayed on the provisioning part.
         */
        description: KnockoutObservable<string>;
        /**
         * The URI for the icon displayed on the provisioning part.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
    }
    /**
     * @deprecated FxImpl.ViewModels.ProvisioningPart.ContentViewModel. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    class ContentViewModel extends FxImpl.ViewModels.ParameterCollection.BaseGalleryButtonPartViewModel implements ContentContract, MsPortalFx.Base.Disposable {
        private _partContainer;
        /**
         * Creates the view model that drives the content within the unprovisioned part.
         *
         * @param container The view model for the part container.
         * @param initialState The saved state defining the current progress of the wizard.
         * @param allowToggleProvisioningLocation True, if user can choose whether provisioning happens on blade or startboard part; else false.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any, allowToggleProvisioningLocation?: boolean);
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        title: KnockoutObservable<string>;
        description: KnockoutObservable<string>;
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * @deprecated ContentViewModel.enableProvisioning This is no longer supported http://aka.ms/portalfx/breaking
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * Error message displayed when there is an error during provisioning.
         */
        errorMessage: KnockoutObservable<string>;
        /**
         * @deprecated ContentViewModel.privatePcPrBI This is no longer supported http://aka.ms/portalfx/breaking
         */
        privatePcPrBI: ParameterCollectionInternal.ProvisioningEntityBindingInternals;
        mutate(containerModel: any): void;
    }
}
declare module MsPortalFx.ViewModels.ProvisioningPart {
    /**
     * @deprecated MsPortalFx.ViewModels.ProvisioningPart.ContentContract. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    type ContentContract = FxImpl.ViewModels.ProvisioningPart.ContentContract;
    /**
     * @deprecated MsPortalFx.ViewModels.ProvisioningPart.ContentViewModel. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    const ContentViewModel: typeof FxImpl.ViewModels.ProvisioningPart.ContentViewModel;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.QuickStartPart.d.ts
declare module MsPortalFx.ViewModels {
    interface QuickStartPartContract extends ButtonPartContract {
        /**
         * The color to use for the background of the quickstart button.
         */
        backgroundColor: MsPortalFx.Parts.PartColor;
    }
    class QuickStartPart extends ButtonPart implements QuickStartPartContract {
        backgroundColor: MsPortalFx.Parts.PartColor;
        /**
         * Initialize the part.
         */
        constructor();
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.QuotaGaugePart.d.ts
declare module MsPortalFx.ViewModels.Parts.QuotaGauge {
    /**
     * @deprecated QuotaGauge.MetricColorBarKind. This part is no longer supported. Please use custom part with QuotaGauge and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The color of the bar in the metric.
     */
    enum MetricColorBarKind {
        /**
         * No bar color. This is the default.
         */
        None = 0,
        /**
         * Color used for the current value in the gauge.
         */
        CurrentValue = 1,
        /**
         * Color used for the background of the arc of the gauge (max - current).
         */
        GaugeBackground = 2,
        /**
         * Color used for the total value in the gauge.
         */
        TotalValue = 3
    }
    /**
     * @deprecated QuotaGauge.MetricContract. This part is no longer supported. Please use custom part with QuotaGauge and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The interface that defines the information for each metric.
     */
    interface MetricContract {
        /**
         * Value of the metric.
         */
        value: KnockoutObservableBase<string>;
        /**
         * Unit of the metric.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Caption of the metric.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * Color bar for the metric.
         */
        metricColorBarKind?: KnockoutObservable<MetricColorBarKind>;
    }
    /**
     * @deprecated QuotaGauge.Contract. This part is no longer supported. Please use custom part with QuotaGauge and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The interface for the QuotaGauge control.
     */
    interface Contract extends Resizable {
        /**
         * Current instance value of the gauge.
         */
        instance: KnockoutObservable<number>;
        /**
         * Current instance quota value.
         */
        instanceQuota: KnockoutObservable<number>;
        /**
         * Total value of the grouped instances.
         */
        total: KnockoutObservable<number>;
        /**
         * Total quota value of the grouped instances.
         */
        totalQuota: KnockoutObservable<number>;
        /**
         * Unit of measurement.
         */
        unit: KnockoutObservable<string>;
        /**
         * Hide the Total bar.
         */
        hideTotal: KnockoutObservableBase<boolean>;
        /**
         * Hide quota verification.
         */
        hideQuota: KnockoutObservableBase<boolean>;
        /**
         * Hide the current tick mark.
         */
        hideTick: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Total Arc of the gauge. (units in degree). Gauge total arc must be less than 360.
         */
        totalArc: KnockoutObservableBase<number>;
        /**
         * captionDisplayFormat value.
         *  {0} is intance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         *  {4} is maximum
         *  You can also override with custom text.
         */
        captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * valueDisplayFormat value.
         *  {0} is intance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         *  {4} is maximum
         */
        valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * List of metrics.
         */
        metrics: KnockoutObservableArray<MetricContract>;
    }
    /**
     * @deprecated QuotaGauge.ViewModel. This part is no longer supported. Please use custom part with QuotaGauge and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The ViewModel class that implementes the QuotaGauge interface.
     */
    class ViewModel implements Contract {
        /**
         * Current instance value of the gauge.
         */
        instance: KnockoutObservable<number>;
        /**
         * Total value of the grouped instances.
         */
        total: KnockoutObservable<number>;
        /**
         * Current instance quota value .
         */
        instanceQuota: KnockoutObservable<number>;
        /**
         * Total quota value of the grouped instances.
         */
        totalQuota: KnockoutObservable<number>;
        unit: KnockoutObservable<string>;
        hideTotal: KnockoutObservableBase<boolean>;
        hideQuota: KnockoutObservableBase<boolean>;
        hideTick: KnockoutObservableBase<boolean>;
        maximum: KnockoutObservableBase<number>;
        /**
         *  See interface.
         */
        startOffset: KnockoutObservableBase<number>;
        totalArc: KnockoutObservableBase<number>;
        captionDisplayFormat: KnockoutObservableBase<string>;
        valueDisplayFormat: KnockoutObservableBase<string>;
        metrics: KnockoutObservableArray<MetricContract>;
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ResourceSummaryPart.d.ts
declare module MsPortalFx.ViewModels.Parts.ResourceSummary {
    import FxViewModels = MsPortalFx.ViewModels;
    import Property = FxViewModels.Parts.Properties.Property;
    import PropertiesPart = FxViewModels.Parts.Properties;
    import Base = MsPortalFx.Base;
    import ResourceManager = MsPortalFx.Azure.ResourceManager;
    import MoveType = ResourceManager.MoveType;
    let includedResourceTypes: StringMap<MoveType>;
    /**
     * @deprecated ResourceSummary.Contract. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Resource summary part contract.
     */
    interface Contract {
    }
    /**
     * @deprecated ResourceSummary.GetDynamicBladeSelection. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The function contract to get dynamic blade selection.
     */
    interface GetDynamicBladeSelection {
        (inputs: any): ViewModels.DynamicBladeSelection;
    }
    /**
     * @deprecated ResourceSummary.Options. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Resource summary part options.
     */
    interface Options {
        /**
         * The function to get selection for settings blade.
         */
        getSettingsSelection?: GetDynamicBladeSelection;
        getQuickStartSelection?: GetDynamicBladeSelection;
        /**
         * The function to get selection for keys blade.
         */
        getKeysSelection?: GetDynamicBladeSelection;
        /**
         * Sets if the resource summary is collapsed by default.
         */
        collapsed?: boolean;
        /**
         * Sets if the resource group property should be added.
         */
        noResourceGroup?: boolean;
        /**
         * Sets if the tags shortcut should be added.
         */
        noTags?: boolean;
        /**
         * Sets if the rbac shortcut should be added.
         */
        noRbac?: boolean;
        /**
         * Sets if the change resource group/subscription is supported.
         */
        supportsResourceMove?: MoveType;
    }
    /**
     * @deprecated ResourceSummary.ViewModel. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Resource summary part view model.
     */
    class ViewModel extends PropertiesPart.ViewModel implements Contract {
        /**
         * Gets or sets if the tags shortcut should be visible.
         */
        tagsVisible: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets the title of resource summary.
         */
        title: KnockoutObservableBase<string>;
        /**
         * Gets or sets the label of the all settings button.
         */
        settingsLabel: KnockoutObservableBase<string>;
        protected collapsed: KnockoutObservableBase<boolean>;
        resourceGroupSelectable: ViewModels.Selectable<ViewModels.DynamicAssetSelection>;
        quickStartSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        settingsSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        accessSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        tagsSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        keysSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        private hasKeys;
        private hasQuickStart;
        private hasSettings;
        private noTags;
        private noRbac;
        private _editRg;
        private _partContainer;
        protected _options: Options;
        protected _loadingPromise: Base.Promise;
        private _loadingLM;
        private _inputs;
        protected _currentResourceId: KnockoutObservable<string>;
        protected _ensureRGProperty: () => Property;
        constructor(initialState: any, options: Options, container: ViewModels.PartContainerContract);
        onInputsSet(inputs: any, settings: any): Base.Promise;
        /**
         * It invokes whenever the resource summary is expanded.
         *
         * @param lifetimeManager The lifetime manager helps manage the life cycle of data loading.
         * @param inputs The inputs sent to resource summary.
         * @return A promise that will be used to decide the completion of an operation.
         */
        protected onExpanded(lifetimeManager: Base.LifetimeManager, inputs: any): Base.Promise;
        setProperties(properties: Property[]): void;
        protected _setProperties(properties: Property[]): void;
        protected _startRebind(resourceId: string): void;
        private _updateDataLoading;
        private _resetLoadingState;
        private _createResourceGroupProperty;
    }
    /**
     * @deprecated ResourceSummary.BuiltInPropertyKind. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Reflects the different built-in properties that are typically displayed in the left-hand column of the
     * ResourceSummary Part.
     */
    const enum BuiltInPropertyKind {
        ResourceGroup = 0,
        Status = 1,
        Location = 2,
        SubscriptionName = 3,
        SubscriptionId = 4
    }
    /**
     * @deprecated ResourceSummary.Layout. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * For advanced cases, describes the layout of properties in the left- and right-hand columns of the ResourceSummary
     * Part.
     */
    interface Layout {
        left: (Property | BuiltInPropertyKind)[];
        right: (Property | BuiltInPropertyKind)[];
    }
    /**
     * @deprecated ResourceSummary.Options2. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Options for the ResourceSummary Part view model.
     */
    interface Options2 extends Options {
        /**
         * Observables that represent the 'status' of the resource and an indication of whether the 'status' is
         * currently loading (which controls a loading indicator for the 'status' property).  Supply null/undefined
         * here to explicitly not include this property.
         */
        status: {
            /**
             * Indicates the status value for the resource.
             */
            value: KnockoutObservableBase<string>;
            /**
             * Reflects whether the status value for the resource is currently being loaded.
             * This controls a loading indicator for the 'status' property.
             */
            isLoading: KnockoutObservableBase<boolean>;
        };
        /**
         * An optional observable the extension can supply/populate in order to customize the 'location' property
         * to be different than the default for this built-in property.
         */
        location?: KnockoutObservableBase<string>;
        /**
         * An array of properties that should be displayed for all instances of this resource type.
         */
        staticProperties: Property[];
        /**
         * For advanced cases, an optional object that describes the layout of properties into the left- and right-hand
         * columns of the ResourceSummary Part.
         */
        layout?: Layout;
    }
    /**
     * @deprecated ResourceSummary.ViewModel2. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The view model for the ResourceSummary Part.
     */
    class ViewModel2 extends ViewModel {
        private _dynamicProperties;
        private _dependencies;
        private _editSub;
        constructor(initialState: any, options: Options2, container: ViewModels.PartContainerContract);
        /**
         * Called by the extension before the Part's 'onInputsSet' promise resolves, this appends dynamic,
         * data-specific properties to the view.
         *
         * @param properties The properties to be apppended.
         */
        setDynamicProperties(properties: Property[]): void;
        /**
         * Not supported by this view model class.  The set of displayed properties is managed implicitly by this class.
         * The displayed properties can be controlled by the extension by supplying 'options' to the constructor and
         * by calling 'setDynamicProperties' during data-loading/rebinding of this Part.
         */
        setProperties(properties: Property[]): void;
        private _createBuiltInProperties;
        private _layoutProperties;
        protected _startRebind(resourceId: string): void;
    }
}
declare module FxImpl.ViewModels.Parts.ResourceSummary {
    import Base = MsPortalFx.Base;
    import ViewModels = MsPortalFx.ViewModels;
    import ResourceSummaryPart = MsPortalFx.ViewModels.Parts.ResourceSummary;
    /**
     * @deprecated ResourceSummary.Dependencies. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Dependencies {
        /**
         * Gets the resource location for a given resource ID.
         * @param resourceId The resource ID.
         * @return A promise that resolves with the resource location string.
         */
        getLocation?: (resourceId: string) => Base.PromiseV<string>;
        /**
         * Gets the name of a subscription, given a subscription ID.
         * @param subscriptionID The subscription ID.
         * @return A promise that resolves with the subscription name string.
         */
        getSubscriptionName?: (subscriptionId: string) => Base.PromiseV<string>;
        /**
         * Gets a descriptor of the Blade to be opened for the given subscription ID.
         * @param subscriptionID The subscription ID.
         * @return A promise that resolves with the descriptor of the Blade to be opened.
         */
        getSubscriptionBlade?: (subscriptionId: string) => Base.PromiseV<ViewModels.DynamicBladeSelection>;
    }
    /**
     * @deprecated ResourceSummary.setDependencies. This part is no longer supported. Please use Fx/Controls/Essentials instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * For testing purposes, mocks the dependencies of this ResourceSummary Part view model.
     * @param viewModel The ResourceSummary Part view model.
     * @param dependencies The dependencies.
     */
    function setDependencies(viewModel: ResourceSummaryPart.ViewModel2, dependencies: Dependencies): void;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SettingList.d.ts
declare module MsPortalFx.ViewModels.Parts.SettingList {
    import Fx = MsPortalFx;
    import BaseFx = Fx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import ViewModels = Fx.ViewModels;
    import Selectable = ViewModels.Selectable;
    import GridFx = ViewModels.Controls.Lists.Grid;
    import PartContainerContract = ViewModels.PartContainerContract;
    function ShouldRemoveSupportSettings(value: boolean): void;
    /**
     * The contract of the setting selection.
     */
    interface SettingSelection extends FxViewModels.DynamicBladeSelection {
        /**
         * The identifier of the setting.
         */
        key: string;
        /**
         * Gets if the setting using parameter collector.
         */
        isParameterCollector: boolean;
    }
    /**
     * The options of the settings.
     */
    interface SettingOptions<TParameterCollectorResult> {
        /**
         * The parameter collector callbacks.
         */
        parameterCollector?: ParameterCollectorSettingOptions<TParameterCollectorResult>;
    }
    /**
     * The options of the parameter collector for the settings.
     */
    interface ParameterCollectorSettingOptions<TResult> {
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Initial data for the child blade.
         */
        supplyInitialData(): TResult;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
         */
        receiveResult(result: TResult): void;
        /**
         * A callback that supplies additional configuration options for the
         * provider each time it opens. You can use this to pass non-editable
         * data, for example configuring how a form will be displayed.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Arbitrary configuration options for the child blade.
         */
        supplyProviderConfig?(): any;
    }
    /**
     * The class of the setting list item.
     */
    class Setting {
        /**
         * Gets or sets the display text for the setting.
         */
        displayText: KnockoutObservable<string>;
        /**
         * Gets or sets the icon for the setting.
         */
        icon: KnockoutObservable<BaseFx.Image>;
        /**
         * Gets or sets the keywords for the setting.
         */
        keywords: KnockoutObservableArray<string>;
        /**
         * Gets or sets the group name for the setting.
         */
        group: KnockoutObservable<string>;
        protected aggregatedKeywords: KnockoutObservable<string>;
        private _key;
        private _blade;
        protected _bladeInputs: KnockoutObservableBase<any>;
        protected _extension: KnockoutObservableBase<string>;
        private _options;
        /**
         * Gets the key of the setting.
         */
        get key(): string;
        /**
         * Gets the setting options.
         */
        getOptions(): SettingOptions<any>;
        constructor(key: string, detailBlade: string | KnockoutObservableBase<string>, detailBladeInputs: KnockoutObservableBase<any>, extension?: string | KnockoutObservableBase<string>, options?: SettingOptions<any>);
        /**
         * Gets the setting selection.
         */
        toSelection(): SettingSelection;
    }
    /**
     * The options of the setting list part.
     */
    interface Options {
        /**
         * Indicates whether the export template menu item should be enabled. Enabled by defualt for subscription resources and resource groups.
         */
        enableExportTemplate?: boolean;
        /**
         * Enables the settings for roles and users.
         */
        enableRbac?: boolean;
        /**
         * Enables the settings for help request support.
         */
        enableSupportHelpRequest?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshoot?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshootV2?: boolean;
        /**
         * Enables the settings for resource health support.
         */
        enableSupportResourceHealth?: boolean;
        /**
         * Enables the settings for the event logs.
         */
        enableSupportEventLogs?: boolean;
        /**
         * Enables the setting for tags.
         */
        enableTags?: boolean;
        /**
         * Enables grouping of the settings.
         */
        groupable?: boolean;
        /**
         * Enables the setting for management certs.
         */
        enableManagementCerts?: boolean;
        /**
         * Enables the setting for access details.
         */
        enableAccessDetails?: boolean;
        /**
         * Enables the setting for resource provider details.
         */
        enableResourceProviders?: boolean;
    }
    abstract class BaseViewModel {
        resourceId: KnockoutObservableBase<string>;
        settingList: GridFx.ViewModel<Setting, SettingSelection>;
        searchBoxPlaceholder: KnockoutObservableBase<string>;
        private _searchText;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
        protected isPCv3(): boolean;
        private _updateSettings;
        private _processSettings;
        private _removeSetting;
        private _trace;
    }
    /**
     * The view model of the setting list part.
     */
    class ViewModel extends BaseViewModel {
        /**
         * This is only here to cause compile time breaks between V1 and V2, for migrating from V1 to V2 see
         * https://auxdocs.azurewebsites.net/en-us/documentation/articles/portalfx-blades-bladekinds-settinglist-migration
         */
        protected _1: string;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
    }
    /**
     * The setting list part view model v2 enables the parameter collector V3 for the settings.
     * It is fully back-compatible with setting list part view model v1.
     */
    class ViewModelV2 extends BaseViewModel {
        selectable: Selectable<SettingSelection>;
        pcSelectable: Selectable<SettingSelection>;
        parameterCollector: ViewModels.ParameterCollector<any>;
        protected isPCv3(): boolean;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
        private _initParameterCollector;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SetupPart.d.ts
declare module FxImpl.ViewModels.SetupPart {
    import ParameterCollectionInternal = MsPortalFx.ViewModels.ParameterCollection.Internal;
    /**
     * Interface for the content of a create part.
     */
    interface ContentContract extends FxImpl.ViewModels.ProvisioningPart.ContentContract {
        /**
         * A parameter collection entity that does provisioning.
         */
        provisioningEntity: ParameterCollectionInternal.ProvisioningEntity;
    }
    /**
     * Base class for the content view model of a create part.
     */
    class Content extends FxImpl.ViewModels.ProvisioningPart.ContentViewModel implements ContentContract, MsPortalFx.Base.Disposable {
        private _setupPartContainer;
        private _previousCommit;
        private _outputs;
        provisioningEntity: ParameterCollectionInternal.ProvisioningEntity;
        /**
         * Creates the view model for the setup part.
         *
         * @param container The view model for the part container.
         * @param initialState The initial state of the part.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any);
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Allows subclasses to provide a promise that indicates whether to load the content for the setup part
         * or mutate into another part.
         *
         * @return Null to proceed straight to the content for this part or a promise. If a promise is returned
         * the setup part will wait in a loading state until it is resolved with one of the following values:
         *   * null - The setup part will proceed to load it's content.
         *   * string - The string is the name of a part in this extension's part catalog. The setup part will mutate into that part.
         *   * object - The object must have 'partName' and 'extensionName' properties. The setup part will find the part in the specified extension's part
         * catalog and mutate into that part.
         */
        mutateOnLoad(): MsPortalFx.Base.PromiseV<any>;
        /**
         * Mutates setup part into another part.
         *
         * @param newPart The name of the part in the part catalog.
         * @param exetensionForPart Name of the extension containing the part. Optional.
         */
        mutate(newPart: string, extensionForPart?: string): void;
        onProviderCommit(providerId: string, outputs: MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionOutput): MsPortalFx.Base.PromiseV<boolean>;
        private _loadContent;
        private _executeProvisioningIfApplicable;
    }
}
declare module MsPortalFx.ViewModels.SetupPart {
    /**
     * @deprecated MsPortalFx.ViewModels.SetupPart.ContentContract. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    type ContentContract = FxImpl.ViewModels.SetupPart.ContentContract;
    /**
     * @deprecated MsPortalFx.ViewModels.SetupPart.Content. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    const Content: typeof FxImpl.ViewModels.SetupPart.Content;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SimpleChartPart.d.ts
declare module MsPortalFx.ViewModels {
    interface SimpleChartPartOptions<TX, TY> extends MsPortalFx.ViewModels.Controls.Visualization.SimpleChart.SimpleChartOptions<TX, TY> {
        /**
         * The size of the part (makes it adaptive).
         */
        size?: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * The selectable for the edit button.
         */
        editButtonSelectable?: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * The text for the edit button.
         */
        editButtonText?: string | KnockoutObservableBase<string>;
    }
    /**
     * A view model class that respresents a chart part.
     */
    class SimpleChartPart<TX, TY> extends MsPortalFx.ViewModels.Controls.Visualization.SimpleChart.ViewModel<TX, TY> implements Resizable {
        /**
         * The size of the part (makes it adaptive).
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * The selectable for the edit button.
         */
        editButtonSelectable: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * The text for the edit button.
         */
        editButtonText: string | KnockoutObservableBase<string>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: SimpleChartPartOptions<TX, TY>);
        private _initSimpleChartPartOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SingleValueGaugePart.d.ts
declare module MsPortalFx.ViewModels.Parts.SingleValueGauge {
    /**
     * @deprecated SingleValueGauge.MetricColorBarkind. This part is no longer supported.  Please use a custom part with SingleValueGauge and Metrics control.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The color of the bar in the metric.
     */
    enum MetricColorBarKind {
        /**
         * No bar color. This is the default.
         */
        None = 0,
        /**
         * Color used for the current value in the gauge.
         */
        CurrentValue = 1,
        /**
         * Color used for the background of the arc of the gauge (max - current).
         */
        GaugeBackground = 2
    }
    /**
     * @deprecated SingleValueGauge.MetricContract. This part is no longer supported.  Please use a custom part with SingleValueGauge and Metrics control.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The interface that defines the information for each metric.
     */
    interface MetricContract {
        /**
         * Value of the metric.
         */
        value: KnockoutObservableBase<string>;
        /**
         * Unit of the metric.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Caption of the metric.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * Color bar for the metric.
         */
        metricColorBarKind?: KnockoutObservable<MetricColorBarKind>;
    }
    /**
     * @deprecated SingleValueGauge.Contract. This part is no longer supported.  Please use a custom part with SingleValueGauge and Metrics control.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The interface for the SingleValueGauge control.
     */
    interface Contract extends Resizable {
        /**
         * Maximum value of the gauge.
         */
        maximum: KnockoutObservable<number>;
        /**
         * Current value for the gauge.
         */
        current: KnockoutObservable<number>;
        /**
         * Unit of measurement.
         */
        unit: KnockoutObservable<string>;
        /**
         * List of metrics.
         */
        metrics: KnockoutObservableArray<MetricContract>;
    }
    /**
     * @deprecated SingleValueGauge.ViewModel. This part is no longer supported.  Please use a custom part with SingleValueGauge and Metrics control.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The ViewModel class that implementes the SingleValueGauge interface.
     */
    class ViewModel implements Contract {
        maximum: KnockoutObservable<number>;
        current: KnockoutObservable<number>;
        unit: KnockoutObservable<string>;
        metrics: KnockoutObservableArray<MetricContract>;
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Services\Browse.d.ts
declare module MsPortalFx.ViewModels.Services.Browse {
    import FxServices = MsPortalFx.Services;
    /**
     * The browse criteria provides the information for browse as a data contract.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Criteria = Obsolete;
    /**
     * The browse operation contract for a running browse.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the browse service base class.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service<T> {
        initialized: Obsolete;
        results: Obsolete;
        canceled: Obsolete;
        private _dataLifetime;
        private readonly _lifetimeManager;
        constructor();
        /**
         * Disposes any resources owned by this object.
         */
        dispose(): void;
        /**
         * Invoked when the inputs change.
         *
         * @deprecated 04/30/2020 - No longer supported.
         *
         * @param inputs The inputs object with all the input parameters.
         * @return A promise if there is async loading, else null.
         */
        onInputsSet(_inputs: any): Obsolete;
        /**
         * Connects the data source for the browse to the results.
         *
         * @deprecated 04/30/2020 - No longer supported.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param items The observable array representing the data source.
         * @param mapper The callback function to map the items in the data source to their asset details.
         */
        connectDataSource(items: KnockoutObservableArray<T>, mapper: (value: T) => FxServices.AssetDetails): Obsolete;
        private _releaseDataSub;
    }
    /**
     * The deserialized browse provides a wrapper for the criteria and use current browse flag.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type DeserializedBrowse = Obsolete;
    /**
     * The browse serializer class is used to serialize a use current browse flag to a string.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BrowseSerializer {
        /**
         * Serializes the use browse key to a string.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param browseCriteria The browse criteria for the saved browse.
         * @param newBrowse The optional new browse flag for the saved browse (default is false).
         * @param useBrowseKey The optional browse key to use for the saved browse (default is null).
         * @return The browse serialized as a string value.
         */
        static serialize(browseCriteria: Criteria, newBrowse?: boolean, useBrowseKey?: string): Obsolete;
        /**
         * Deserializes a saved browse to the use current browse flag.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param savedBrowse The browse that was serialized into a string.
         * @return An object that will contain the asset owner and type, the new browse flag and use browse key.
         */
        static deserialize(savedBrowse: string): Obsolete;
    }
    /**
     * The browse results view model provides the view model for the results of an initiated browse.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ResultsViewModel {
        /**
         * The initialized flag signifies that the initial browse results are initialized.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        initialized: Obsolete;
        /**
         * The results array contains all the results of the browse.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        results: Obsolete;
        /**
         * Creates an instance of the browse results view model.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param criteria The browse criteria for the browse.
         * @param results The initial collection for the results.
         */
        constructor(criteria: Criteria, results: any[]);
        /**
         * Gets the browse criteria of the browse.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        readonly browseCriteria: Obsolete;
    }
}

// FILE: MsPortalFx\ViewModels\Services\Diagnostics.d.ts
declare module MsPortalFx.ViewModels.Services.Diagnostics {
    interface HubsDiagnosticsProvider {
        /**
         * Gets the cached permissions for the current logged in user.
         *
         * @return The promise for the permissions results.
         */
        getPermissions(): MsPortalFx.Base.PromiseV<any>;
    }
}

// FILE: MsPortalFx\ViewModels\Services\DynamicBlade.d.ts
declare module MsPortalFx.ViewModels.Services.DynamicBlade {
    /**
     * The dynamic blade contract for an asset.
     *
     * @deprecated 04/30/2020 - Dynamic blade service is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the dynamic blade service base class.
     *
     * @deprecated 04/30/2020 - Dynamic blade service is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service {
        extensionName: Obsolete;
        bladeName: Obsolete;
        /**
         * Initialize a new instance of the dynamic blade service.
         */
        constructor();
    }
    /**
     * Prepares a dynamic selection from a dynamic blade service, an asset ID and the extension and asset type names.
     *
     * @deprecated 04/30/2020 - Dynamic blade service is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * @param dynamicBladeService The dynamic blade service to check for a blade override.
     * @param assetId The asset ID to use for the selection.
     * @param extensionName The name of the extension that owns the asset type.
     * @param assetTypeName The name of the asset type.
     * @return A promise to supply the dynamic selection.
     */
    function prepareDynamicSelection(dynamicBladeService: Service, assetId: any, extensionName: string, assetTypeName: string): Obsolete;
}

// FILE: MsPortalFx\ViewModels\Services\GridColumns.d.ts
declare module MsPortalFx.ViewModels.Services.GridColumns {
    /**
     * The global grid columns base columns.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BaseColumns {
        /**
         * Gets the base columns for assets which do not provide columns or for multiple-asset type grids.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        static get base(): Obsolete;
    }
    /**
     * The grid columns usage values.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Usage = Obsolete;
    /**
     * A grid columns definition for an asset.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the grid columns service base class.
     *
     * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service {
        includeAssetIcon: Obsolete;
        columns: Obsolete;
    }
}

// FILE: MsPortalFx\ViewModels\Services\PropertyProvider.d.ts
declare module MsPortalFx.ViewModels.Services.PropertyProvider {
    /**
     * A property definition returned via the property provider.
     */
    interface PropertyDefinition {
        /**
         * The name of the property.
         */
        property: string;
        /**
         * The value of the property.
         */
        value: any;
    }
    /**
     * The property provider contract for providing properties.
     */
    interface Contract {
        /**
         * The result set which will contain the properties provided.
         */
        properties: KnockoutObservableArray<PropertyDefinition>;
    }
    /**
     * Represents the property provider service base class.
     */
    class Service implements Contract {
        properties: KnockoutObservableArray<PropertyDefinition>;
        /**
         * Initialize a new instance of the security service.
         */
        constructor();
        /**
         * Sets a property to the result property set.
         */
        setProperty(property: string, value: any): void;
    }
}

// FILE: MsPortalFx\ViewModels\Services\ResourceTypes.d.ts
declare module MsPortalFx.ViewModels {
    module Services.ResourceTypes {
        /**
         * Determines if a given resource is a tenant level resource.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isTenantResource(resource))
         *
         * becomes: if (ArmId.parse(resource).kind === ArmId.Kind.TenantResource)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resource The resource to check.
         * @return Boolean true if the resource is a tenant level resource, otherwise false.
         */
        const isTenantResource: (resource: string) => boolean;
        /**
         * Determines if a given ID is a subscription ID.
         * Eg: /subscriptions/sub123
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isSubscriptionId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The ID to check.
         * @return Boolean true if the ID is a resource group ID, otherwise false.
         */
        const isSubscriptionId: (id: string) => boolean;
        /**
         * Determines if a given ID is a resource group ID.
         * Eg: /subscriptions/sub123/resourceGroups/rg123
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isResourceGroupId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The ID to check.
         * @return Boolean true if the ID is a resource group ID, otherwise false.
         */
        const isResourceGroupId: (id: string) => boolean;
        /**
         * Determines if a given ID is a resource ID.
         * Eg: /subscriptions/sub123/resourceGroups/rg123/providers/pro123/type123/res123
         *     /subscriptions/sub123/resourceGroups/rg123/providers/pro123/type123/res123[/type456/res456[/type789/res789[...]]]
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isResourceId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.Resource)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The ID to check.
         * @return Boolean true if the ID is a resource ID, otherwise false.
         */
        const isResourceId: (id: string) => boolean;
        /**
         * Determines if a given ID is a deployment ID.
         * Supports ids of the form:
         * /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.Resources/deployments/{deploymentName}
         * /subscriptions/{subId}/resourceGroups/{rgName}/deployments/{deploymentName}
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * Deployments are ARM resources with a specific provider and resource type.  You need to check that the:
         * provider = "Microsoft.Resources"
         * resourceTypes = ["deployments"]
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The ID to check.
         * @return Boolean true if the ID is a deployment ID, otherwise false.
         */
        function isDeploymentId(id: string): boolean;
        /**
         * Determines if a given ID is a tag ID.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isTagId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.SubscriptionTagValue)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The ID to check.
         * @return Boolean true if the ID is a tag ID, otherwise false.
         */
        const isTagId: (id: string) => boolean;
        /**
         * Determines if a given ID is a resource manager ID. This includes resource IDs, resource group IDs,
         * subscription IDs, deployment IDs and tag IDs.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * For resource manager ID, it is simple enough to check is the parsed kind is not invalid:
         *
         * if (ArmId.parse(id).kind !== ArmId.Kind.Invalid) {
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The ID to check.
         * @param supportsSecurity Optional boolean to indicate to only check for resource manager IDs which
         *                         support security (RBAC), default is false.
         * @return Boolean true if the ID is a resource manager ID, otherwise false.
         */
        function isResourceManagerId(id: string, supportsSecurity?: boolean): boolean;
        /**
         * A resource type mapping for resource types.
         *
         * @deprecated 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface MappingContract extends Obsolete {
        }
        /**
         * Enum to indicate the current resource status.
         *
         * @deprecated 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type ResourceStatus = Obsolete;
        /**
         * The resource type mapping rejection reason enumeration provides named constants for rejection reason.
         *
         * @deprecated 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type MappingRejectionReason = Obsolete;
        /**
         * The resource type mapping rejection interface provides the contract for rejections on the resource type mapping
         * view model.
         *
         * @deprecated 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type MappingRejection = Obsolete;
        /**
         * The resource type contract for returning resource type information.
         *
         * @deprecated 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type Contract = Obsolete;
        /**
         * Deprecated.
         *
         * @deprecated 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type IService = Obsolete;
        /**
         * Deprecated.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface ISubscriptionDescriptor {
            /**
             * The subscription ID for the resource group.
             */
            readonly subscription: string;
        }
        /**
         * Deprecated
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceGroupDescriptor extends ISubscriptionDescriptor {
            /**
             * The resource group name for the resource group.
             */
            readonly resourceGroup: string;
        }
        /**
         * Base interface for ARM entities.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceManagerDescriptor {
            /**
             * The provider name for the resource.
             */
            readonly provider: string;
            /**
             * The resource name for the resource.
             */
            readonly resource?: string;
            /**
             * The resource group name for the resource group.
             */
            readonly resourceGroup?: string;
            /**
             * The subscription ID for the resource group.
             */
            readonly subscription?: string;
            /**
             * The type for the resource (this is the most nested type).
             */
            readonly type?: string;
            /**
             * The collection of types for the resource (from left-to-right from the URI).
             * This will have more than one item for nested resources, one for each level of nesting.
             */
            readonly types: ReadonlyArray<string>;
            /**
             * The collection of resource names for the resource (from left-to-right from the URI).
             * This will have more than one item for nested resources, one for each level of nesting.
             */
            readonly resources: ReadonlyArray<string>;
            /**
             * The resource map maps a partial type to a resource name.
             * For the resource ID: /subscriptions/sub123/resourceGroups/rg123/providers/prov123/type1/resource1/type2/resource2/type3/resource3
             * the map includes:
             * "prov123/type1" => resource1
             * "prov123/type1/type2" => resource2
             * "prov123/type1/type2/type3" => resource3
             */
            readonly resourceMap: StringMap<string>;
        }
        /**
         * Base interface for both tenant and subscription level resources.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceDescriptorBase extends IResourceManagerDescriptor {
            /**
             * The resource name for the resource.
             */
            readonly resource: string;
            /**
             * The type for the resource (this is the most nested type).
             */
            readonly type: string;
        }
        /**
         * Subscription level resources.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceDescriptor extends IResourceDescriptorBase, IResourceGroupDescriptor {
            /**
             * The resource group name for the resource group.
             */
            readonly resourceGroup: string;
            /**
             * The subscription ID for the resource group.
             */
            readonly subscription: string;
        }
        /**
         * Deprecated.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IDeploymentDescriptor extends IResourceGroupDescriptor {
            /**
             * The deployment name.
             */
            readonly deploymentName: string;
        }
        /**
         * Deprecated.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface ITagDescriptor extends ISubscriptionDescriptor {
            /**
             * The tag name.
             */
            readonly tagName: string;
            /**
             * The tag name.
             */
            readonly tagValue: string;
        }
        /**
         * Sanitizes a resource ID to prevent PI leakage.
         *
         * @deprecated 04/30/2020 - No longer supported. If you need to sanitize a resource ID, the ArmId functionality
         * in the Fx/ResourceManagement module includes a sanitizeId() method.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The ID to sanitize.
         * @return The sanitized ID.
         */
        function sanitizeId(id: string): string;
        /**
         * Parses a subscription ID into a subscription descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The subscription ID to parse.
         * @return The subscription descriptor object.
         */
        const parseSubscriptionDescriptor: Func1<string, ISubscriptionDescriptor>;
        /**
         * Parses a resource group ID into a resource group descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The resource group ID to parse.
         * @return The resource group descriptor object.
         */
        const parseResourceGroupDescriptor: Func1<string, IResourceGroupDescriptor>;
        /**
         * Parses a resource ID into a resource descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The resource ID to parse.
         * @return The resource descriptor object.
         */
        const parseResourceDescriptor: Func1<string, IResourceDescriptor>;
        /**
         * Parses a resource manager ID into a resource descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The resource manager ID to parse.
         * @return The resource descriptor object.
         */
        const parseResourceManagerDescriptor: Func1<string, IResourceManagerDescriptor>;
        /**
         * Parses a deployment ID into a deployment descriptor.
         *
         * Supports deployment ids of the forms:
         * /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.Resources/deployments/{deploymentName}
         * /subscriptions/{subId}/resourceGroups/{rgName}/deployments/{deploymentName}
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The deployment ID to parse.
         * @return The deployment descriptor object.
         */
        const parseDeploymentDescriptor: Func1<string, IDeploymentDescriptor>;
        /**
         * Parses a tag ID into a tag descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The tag ID to parse.
         * @return The tag descriptor object.
         */
        const parseTagDescriptor: Func1<string, ITagDescriptor>;
        /**
         * Builds a deployment id from a subscription id, resource group name, and deployment name.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * Deployment IDs use:
         * provider = "Microsoft.Resources"
         * resourceTypes = ["deployments"]
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscriptionId The subscription id for the deployment.
         * @param resourceGroupName The resource group name for the deployment.
         * @param deploymentName The deployment name for the deployment.
         * @return The deployment id.
         */
        function buildDeploymentId(subscriptionId: string, resourceGroupName: string, deploymentName: string): string;
        /**
         * Builds a subscription ID from a subscription descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscriptionDescriptor The subscription descriptor.
         * @return The subscription ID.
         */
        function buildSubscriptionIdFromDescriptor(subscriptionDescriptor: ISubscriptionDescriptor): string;
        /**
         * Builds a subscription ID from a resource group descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceGroupDescriptor The resource group descriptor.
         * @return The subscription ID.
         */
        function buildSubscriptionIdFromResourceGroupDescriptor(resourceGroupDescriptor: IResourceGroupDescriptor): string;
        /**
         * Builds a subscription ID from a resource descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceDescriptor The resource descriptor.
         * @return The subscription ID.
         */
        function buildSubscriptionIdFromResourceDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds a subscription ID from a resource group ID.
         *
         * @deprecated 04/30/2020 - No longer supported.
         *
         * use: ArmId.stringify(ArmId.parse(resourceGroupId), ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceGroupId The resource group ID.
         * @return The subscription ID.
         */
        function buildSubscriptionIdFromResourceGroupId(resourceGroupId: string): string;
        /**
         * Builds a subscription ID from a resource ID.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(ArmId.parse(resourceId), ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId The resource ID.
         * @return The subscription ID.
         */
        function buildSubscriptionIdFromResourceId(resourceId: string): string;
        /**
         * Builds a subscription ID from it's subscription.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: `/subscriptions/${subscription}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscription The subscription for the subscription.
         * @return The subscription ID.
         */
        function buildSubscriptionIdFromSubscriptionName(subscription: string): string;
        /**
         * Builds a resource group ID from a resource group descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceGroupDescriptor The resource group descriptor.
         * @return The resource group ID.
         */
        function buildResourceGroupIdFromDescriptor(resourceGroupDescriptor: IResourceGroupDescriptor): string;
        /**
         * Builds a resource group ID from a resource descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceDescriptor The resource descriptor.
         * @return The resource group ID.
         */
        function buildResourceGroupIdFromResourceDescriptor(resourceDescriptor: IResourceManagerDescriptor): string;
        /**
         * Builds a resource group ID from a resource ID.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(ArmId.parse(resourceId), ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId The resource ID.
         * @return The resource group ID.
         */
        function buildResourceGroupIdFromResourceId(resourceId: string): string;
        /**
         * Builds a resource group ID from it's subscription and resource group name.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: subscription ? `/subscriptions/${subscription}${resourceGroup ? `/resourceGroups/${resourceGroup}` : ``}` : ``
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscription The subscription for the resource group.
         * @param resourceGroup The resource group for the resource group.
         * @return The resource group ID.
         */
        function buildResourceGroupIdFromSubscriptionAndResourceGroupName(subscription: string, resourceGroup?: string): string;
        /**
         * Builds a subscription entity ID from the subscription ID.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: `/subscriptions/${subscription}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The subscription ID.
         * @return The subscription entity ID.
         */
        let buildSubscriptionFromId: typeof buildSubscriptionIdFromSubscriptionName;
        /**
         * Builds a resource type from a resource descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: armId.resourceType
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceDescriptor The resource descriptor.
         * @return The resource type.
         */
        function buildResourceTypeFromResourceDescriptor(resourceDescriptor: IResourceManagerDescriptor): string;
        /**
         * Builds a resource type from a resource ID.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(resourceId).resourceType
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId The resource ID.
         * @return The resource type.
         */
        const buildResourceTypeFromResourceId: (resourceId: string) => string;
        /**
         * Builds a resource type from a resource manager ID.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(resourceId).resourceType
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId The resource ID.
         * @return The resource type.
         */
        const buildResourceTypeFromResourceManagerId: (resourceId: string) => string;
        /**
         * Builds a resource ID from a resource descriptor.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceDescriptor The resource descriptor.
         * @return The resource ID.
         */
        function buildResourceIdFromDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds the topmost parent resource ID from a resource descriptor with nested types.
         * If the resource is not nested, this will return the resource id.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * For the top-most parent, you need to trim the resource types and IDs to the first item only or use this code:
         *
         * `/subscriptions/${armId.subscription}/resourceGroups/${armId.resourceGroup}/providers/${armId.provider}/${armId.resourceTypes[0]}/${armId.resourceIds[0]}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceDescriptor The resource descriptor.
         * @return The topmost parent resource ID.
         */
        function buildTopmostParentResourceIdFromDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds a parent resource ID from a resource descriptor with nested types.
         * If the resource is not nested, this will throw an error.
         *
         * @deprecated 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * For the parent, you need to trim the last resource type and ID.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceDescriptor The resource descriptor.
         * @return The parent resource ID.
         */
        function buildParentResourceIdFromDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Determines if the given possible parent resource ID is a parent of the given possible child resource ID.
         *
         * @deprecated 04/30/2020 - Please use this code instead (no equivalent exists):
         *
         * use:
         * const pattern = toLowerCase(parentResourceId) + "/";
         * return startsWith(toLowerCase(childResourceId), pattern);
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param parentResourceId The possible parent resource ID.
         * @param childResourceId The given possible child resource ID.
         * @return Boolean true if the parent resource ID was a parent of the child resource ID, else false.
         */
        function isParentResource(parentResourceId: string, childResourceId: string): boolean;
        /**
         * Builds an association tag name for the resource manager for the given resource ID with the given prefix.
         *
         * @deprecated 04/30/2020 - No longer supported. This should not be used by any code but simply use this code
         * (don't parse the resource ID to a resource descriptor).
         *
         * use: `${tagPrefix}:${resourceId}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param tagPrefix The tag prefix for the association tag (should be 'Related' or 'Link').
         * @param resourceDescriptor The resource descriptor for the resource.
         * @return The tag name string for the link association tag.
         */
        function buildTagName(tagPrefix: string, resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds a related tag name for the resource manager for the given resource ID.
         *
         * @deprecated 04/30/2020 - No longer supported. This should not be used by any code but simply use this code
         * (don't parse the resource ID to a resource descriptor).
         *
         * user: `hidden-related:${resourceId}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId The fully qualified resource ID in the format '/subscriptions/{subID}/resourceGroups/{rgID}/providers/{provID}/{type1}/{name1}[/{typeN}/{nameN}].
         * @return The tag name string for the related association tag.
         */
        const buildRelatedTagName: (resourceId: string) => string;
        /**
         * Builds a link tag name for the resource manager for the given resource ID.
         *
         * @deprecated 04/30/2020 - No longer supported. This should not be used by any code but simply use this code
         * (don't parse the resource ID to a resource descriptor).
         *
         * use: `hidden-link:${resourceId}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId The fully qualified resource ID in the format '/subscriptions/{subID}/resourceGroups/{rgID}/providers/{provID}/{type1}/{name1}[/{typeN}/{nameN}].
         * @return The tag name string for the link association tag.
         */
        const buildLinkTagName: (resourceId: string) => string;
        /**
         * Compares two subscription ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (subscriptionId1.toLowerCase() === subscriptionId2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscriptionId1 The first subscription ID to compare.
         * @param subscriptionId2 The second subscription ID to compare.
         * @return Boolean true if the subscription ID's are a match, else boolean false.
         */
        const compareSubscriptionId: (subscriptionId1: string, subscriptionId2: string) => boolean;
        /**
         * Compares two resource group ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (resourceGroupId1.toLowerCase() === resourceGroupId2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceGroupId1 The first resource group ID to compare.
         * @param resourceGroupId2 The second resource group ID to compare.
         * @return Boolean true if the resource group ID's are a match, else boolean false.
         */
        const compareResourceGroupId: (resourceGroupId1: string, resourceGroupId2: string) => boolean;
        /**
         * Compares two resource ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (resourceId1.toLowerCase() === resourceId2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId1 The first resource ID to compare.
         * @param resourceId2 The second resource ID to compare.
         * @return Boolean true if the resource ID's are a match, else boolean false.
         */
        const compareResourceId: (resourceId1: string, resourceId2: string) => boolean;
        /**
         * Compares two resource manager ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (id1.toLowerCase() === id2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id1 The first resource manager ID to compare.
         * @param id2 The second resource manager ID to compare.
         * @return Boolean true if the resource manager ID's are a match, else boolean false.
         */
        const compareResourceManagerId: (id1: string, id2: string) => boolean;
        /**
         * Builds a lower-case copy of the given resource group ID using the resource manager rules of case sensitivity.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * resourceGroupId1.toLowerCase()
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceGroupId The resource group ID to create the lower-case copy from.
         * @return The lower-case copy of the resource group ID.
         */
        const buildLowerCaseResourceGroupId: (resourceGroupId: string) => string;
        /**
         * Builds a lower-case copy of the given subscription ID using the resource manager rules of case sensitivity.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * subscriptionId1.toLowerCase()
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscriptionId The subscription ID to create the lower-case copy from.
         * @return The lower-case copy of the subscription ID.
         */
        const buildLowerCaseSubscriptionId: (subscriptionId: string) => string;
        /**
         * Builds a lower-case copy of the given resource ID using the resource manager rules of case sensitivity.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * resourceId1.toLowerCase()
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceId The resource ID to create the lower-case copy from.
         * @return The lower-case copy of the resource ID.
         */
        const buildLowerCaseResourceId: (resourceId: string) => string;
        /**
         * Builds a resource manager key from a resource manager ID.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use: ArmId.parse(id) !== ArmId.Kind.Invalid ? id.toLowerCase() : null
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param id The resource manager ID.
         * @return The resource manager key for the ID if the ID was a valid resource manager ID, otherwise null.
         */
        function tryBuildResourceManagerKey(id: string): string;
        /**
         * Determines if the subscription contains the resource group.
         *
         * @deprecated 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use:
         * const subscriptionArmId = ArmId.parse(subscriptionId);
         * if (subscriptionArmId.subscription === ArmId.parse(resourceGroupId).subscription && subscriptionArmId.kind === ArmId.Kind.Subscription) {}
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscriptionId The subscription ID.
         * @param resourceGroupId The resource group ID.
         * @return Boolean true if the subscription contains the resource group, else boolean false.
         */
        function subscriptionContainsResourceGroup(subscriptionId: string, resourceGroupId: string): boolean;
        /**
         * Determines if the subscription contains the resource.
         *
         * @deprecated 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use:
         * const subscriptionArmId = ArmId.parse(subscriptionId);
         * if (subscriptionArmId.subscription === ArmId.parse(resourceId).subscription && subscriptionArmId.kind === ArmId.Kind.Subscription) {}
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param subscriptionId The subscription ID.
         * @param resourceId The resource ID.
         * @return Boolean true if the subscription contains the resource, else boolean false.
         */
        function subscriptionContainsResource(subscriptionId: string, resourceId: string): boolean;
        /**
         * Determines if the resource group contains the resource.
         *
         * @deprecated 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use:
         * const rgArmId = ArmId.parse(resourceGroupId);
         * const resArmId = ArmId.parse(resourceId);
         * if (rgArmId.subscription === resArmId.subscription && rgArmId.resourceGroup === resArmId.resourceGroup && rgArmId.kind === ArmId.Kind.ResourceGroup) {}
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * @param resourceGroupId The resource group ID.
         * @param resourceId The resource ID.
         * @return Boolean true if the resource group contains the resource, else boolean false.
         */
        function resourceGroupContainsResource(resourceGroupId: string, resourceId: string): boolean;
        /**
         * The resource part extender view model is an extender view model for the resource map and list parts.
         */
        interface ResourcePartExtenderViewModel {
            /**
             * The refresh key is used to signal the part that the cache for it's resource group or resource should be
             * invalidated. When the host changes this value, it signals the part to update.
             */
            refreshPacket: KnockoutObservableBase<ResourcePartRefreshPacketContract>;
        }
        /**
         * The resource part refresh packet is the base refresh packet contract.
         */
        interface ResourcePartRefreshPacketContract {
        }
        /**
         * The resource group refresh packet is the contract for refreshing a resource group part.
         * This is used for the resource group list part and the resource group map part.
         */
        interface ResourceGroupRefreshPacket extends ResourcePartRefreshPacketContract {
            /**
             * The ID of the resource group to refresh.
             */
            resourceGroupId: string;
        }
        /**
         * The resource refresh packet is the contract for refreshing a resource part.
         * This is used for the resource list part.
         */
        interface ResourceRefreshPacket extends ResourcePartRefreshPacketContract {
            /**
             * The ID of the resource.
             */
            resourceId: any;
        }
        /**
         * The asset refresh packet is the contract for refreshing a resource part.
         * This is used for the resource map part.
         */
        interface AssetRefreshPacket extends ResourcePartRefreshPacketContract {
            /**
             * The extension name of the extension that owns the asset.
             */
            assetOwner: string;
            /**
             * The asset type of the asset.
             */
            assetType: string;
            /**
             * The ID of the asset.
             */
            assetId: any;
        }
        /**
         * The resource part extender provides a base class implementation of the resource part extender view model.
         */
        class ResourcePartExtender implements ResourcePartExtenderViewModel {
            refreshPacket: KnockoutObservableBase<ResourcePartRefreshPacketContract>;
            /**
             * Initialize a new instance of the resource part extender class.
             */
            constructor();
            /**
             * Signals a resource group refresh for resource group list part and resource group map part.
             *
             * @param resourceGroupId The ID of the resource group.
             */
            signalResourceGroupRefresh(resourceGroupId: string): void;
            /**
             * Signals a resource refresh for resource list part.
             *
             * @param resourceId The ID of the resource.
             */
            signalResourceRefresh(resourceId: string): void;
            /**
             * Signals an asset refresh for resource map part.
             *
             * @param assetOwner The extension name of the extension that owns the asset.
             * @param assetType The asset type of the asset.
             * @param assetId The ID of the asset.
             */
            signalAssetRefresh(assetOwner: string, assetType: string, assetId: any): void;
        }
    }
}

// FILE: MsPortalFx\ViewModels\Services\Security.d.ts
declare module MsPortalFx.ViewModels.Services.Security {
    /**
     * The security provider contract for a running security check.
     *
     * @deprecated 04/30/2020 - Security provider is no longer supported and no one is using this, it is safe to
     * remove this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the security service base class.
     *
     * @deprecated 04/30/2020 - Security provider is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service {
        actions: Obsolete;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.d.ts
declare module FxImpl.ViewModels {
    /**
     * Internal interface that the shell uses to manage a selectable instance
     */
    interface SelectableState {
        /**
         * Method invoked by the shell to obtain exclusive access to the selectedValue
         */
        lock(): void;
        /**
         * Method invoked by the shell to internally change the selectedValue
         *
         * @param value New Value to assign selected value too.
         */
        setInternalSelectedValue(value: any): void;
        /**
         * Gets if the selectable is locked
         */
        isLocked(): boolean;
    }
    /**
     * Gets a dynamic asset selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param assetType The name of the asset type.
     * @param inputs The blade inputs.
     * @returns The dynamic asset selection.
     */
    function getAssetSelection(extensionName: string, assetType: string, inputs: any): MsPortalFx.ViewModels.DynamicAssetSelection;
    /**
     * Gets a dynamic blade selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param detailBlade The name of the blade.
     * @param inputs The blade inputs.
     * @returns The dynamic blade selection.
     */
    function getBladeSelection(extensionName: string, detailBlade: string, inputs: any): MsPortalFx.ViewModels.DynamicBladeSelection;
}
declare module MsPortalFx.ViewModels {
    module Commands {
        interface Command<T> {
            /**
             * A value indicating whether or not the command can be executed.
             */
            canExecute: KnockoutObservableBase<boolean>;
            /**
             * Executes the specified command.
             *
             * @param context The context under which the command is executed.
             * @returns The promise for execution completion.
             */
            execute(context: T): MsPortalFx.Base.Promise;
        }
    }
    /**
     * A view model that represents a list of items, each of which can be selected.
     */
    interface SelectableItems<T> {
        /**
         * A list of items, each of which can be selected.
         */
        selectableItems: KnockoutObservableArray<SelectableItem<T>>;
    }
    /**
     * A view model representing an item that can be selected.
     */
    interface SelectableItem<T> {
        /**
         * Reflects whether the item is currently in a selected state.
         */
        isSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the item is currently in an activated state.
         * Activation is a further level of selection that may invoke
         * additional behavior, such as opening the 'details' view in
         * a master-details scenario.
         */
        isActivated: KnockoutObservable<boolean>;
        /**
         * Reflects whether the item currently has journey children that are in an edited state.
         */
        hasChildEdits: KnockoutObservableBase<boolean>;
        /**
         * The model data.
         */
        data: T;
    }
    /**
     * A view model that represents an edited, selected item.
     */
    interface EditedItem<U> {
        /**
         * A representation of the edited item.
         */
        item: U;
        /**
         * The EditScope identifier for the edited item.
         */
        editScopeId: string;
    }
    /**
     * A view model that represents a sparse list of currently selected and/or activated items.
     */
    interface SetSelection<U> {
        /**
         * A representation of the items currently selected.
         */
        selectedItems: KnockoutObservableArray<U>;
        /**
         * A representation of the items currently activated.
         */
        activatedItems: KnockoutObservableArray<U>;
        /**
         * A representation of the items that currently have journey children that are in edited state.
         */
        itemsWithChildEdits: KnockoutObservableArray<EditedItem<U>>;
    }
    /**
     * Interface that allows extension authors to provide named parameters to SelectableSet's constructor
     */
    interface SelectableSetOptions<T, U> {
        /**
         * A list of items.
         */
        items: KnockoutObservableArray<T>;
        /**
         * A function that determines if an item matches a selection.
         */
        itemMatchesSelection?: (item: T, selection: U) => boolean;
        /**
         * A factory function that creates a selection object based on an item.
         */
        createSelection?: (item: T) => U;
        /**
         * Initial state of the view model.
         */
        initialState?: SetSelection<U>;
        /**
         * Function that supplies commands for a given data item.
         */
        supplyCommands?: (dataItem: T) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        /**
         * When set SelectableSet will not deactivate an item when it's deselected.
         */
        keepDeselectedItemsActivated?: boolean;
        /**
         * When set SelectableSet will not deselect an item when it is deactivated.
         */
        leaveSelectionOnDeactivation?: boolean;
    }
    /**
     * A view model implementation that captures both a list of selectable items as well as a separate, sparse list of
     * representations of only the currently selected items and only the currently activated items.
     */
    class SelectableSet<T, U> implements SelectableItems<T>, SetSelection<U>, MsPortalFx.Base.Disposable {
        selectableItems: KnockoutObservableArray<SelectableItem<T>>;
        selectedItems: KnockoutObservableArray<U>;
        activatedItems: KnockoutObservableArray<U>;
        itemsWithChildEdits: KnockoutObservableArray<EditedItem<U>>;
        /**
         * Allows right-click context menu commands to produce a selection, given an item.
         */
        createSelection: (item: T) => U;
        /**
         * Enables the data to be pinned in a context menu
         */
        itemsArePinnable: KnockoutObservable<boolean>;
        /**
         * The comparison function that determines how items and their corresponding selection value are related.
         */
        itemMatchesSelection: (item: T, selection: U) => boolean;
        getDefaultSelection: () => MsPortalFx.Base.PromiseV<U>;
        /**
         * Utility method used to located the data item given the provided selected item
         *
         * @param selectedItem item to search for
         * @param properties list if properties to compare using deepEquals.  If omitted then itemMatchesSelection is used.
         */
        _msPortalFxFindDataItem: (selectedItem: U, properties?: string[]) => T;
        _msPortalFxHasCreateSelection: boolean;
        /**
         * This is the means by which this SelectableSet communicates a delayed Blade-opening to the Shell.  The Shell
         * proceeds to manage the opening of the delayed Blade and the eventual update to 'activatedItems'.
         */
        _msPortalFxDelayedBladeSelection: KnockoutObservable<MsPortalFx.ViewModels.Internal.DelayedBladeSelectionOptions<U>>;
        /**
         * Allows right-click context menu commands to produce a selection, given an item.
         */
        _msPortalFxCreateSelectionAsync: (item: T) => MsPortalFx.Base.PromiseV<U>;
        /**
         * Optional method to supply toolbar items to be displayed in the context menu
         */
        _msPortalFxSupplyCommands: (dataItem: T) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        /**
         * This member only exists to pin the current toolbar items so the PO layer doesn't release the proxies.
         */
        _msPortalFxCurrentCommands: KnockoutObservable<Toolbars.ToolbarItemContract[]>;
        /**
         * For now, only FX code can plug in an async 'createDelayedBladeSelection' callback that will be preferred over
         * the synchronous 'createSelection'.
         * NOTE: This private member is set by MsPortalFx.ViewModels.Internal.SelectableSet.setCreateDelayedBladeSelection.
         */
        private _createDelayedBladeSelection;
        private _lifetime;
        /**
         * Constructs an instance of this view model.
         * @param options A SelectableSetOptions options object with named properties to configure the SelectableSet.
         */
        constructor(options: SelectableSetOptions<T, U>);
        /**
         * Constructs an instance of this view model.
         * @param items A list of items.
         * @param itemMatchesSelection A function that determines if an item matches a selection.
         * @param createSelection A factory function that creates a selection object based on an item.
         * @param initialState Initial state of the view model.
         * @param supplyCommands Function that supplies commands for a given data item.
         * @param keepDeselectedItemsActivated When set SelectableSet will not deactivate an item when it's deselected.
         * @param leaveSelectionOnDeactivation When set SelectableSet will not deselect an item when it is deactivated.
         */
        constructor(items: KnockoutObservableArray<T>, itemMatchesSelection?: (item: T, selection: U) => boolean, createSelection?: (item: T) => U, initialState?: SetSelection<U>, supplyCommands?: (dataItem: T) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[], keepDeselectedItemsActivated?: boolean, leaveSelectionOnDeactivation?: boolean);
        /**
         * Makes all items activated if and only if they are selected.
         */
        activateAllSelectedItems(): void;
        dispose(): void;
        protected _setCreateDelayedBladeSelection(createDelayedBladeSelection: Internal.SelectableSet.CreateDelayedBladeSelection<T, U>): void;
    }
    /**
     * Options that can be supplied when instantiating Selectable<T>.
     */
    interface SelectableOptions<T> {
        /**
         * Determines whether the click target can be unselected by clicking.  Defaults to 'true'.
         */
        allowUnselect?: boolean;
        /**
         * The initial value of this view model's 'value' property when in its selected state.  Can be supplied
         * dynamically using part binding.
         */
        selectedValue?: T;
        /**
         * Determines whether the click target is initially in its selected state.  Defaults to 'false'.
         */
        isSelected?: boolean;
        /**
         * Determines whether the click target is initially in its command selected state.  Defaults to 'false'.
         */
        isCommandSelected?: boolean;
        /**
         * Determines whether the click target is initially in its activated state.  Defaults to 'false'.
         */
        isActivated?: boolean;
    }
    /**
     * Common interface that selectabe 1 and selectable 2 implementations share
     */
    interface SelectableContract<T> {
        isSelected: KnockoutObservableBase<boolean>;
        onClick: () => void;
        isCommandSelected?: KnockoutObservable<boolean>;
        isClickable(): boolean;
        value: KnockoutObservableBase<T>;
    }
    /**
     * A view model that represents a click target that is selectable.
     */
    class Selectable<T> implements MsPortalFx.Base.Disposable, SelectableContract<T> {
        /**
         * A property that will be set to the value of 'selectedValue' whenever the click target is
         * selected.  The property can be set to 'undefined' via part binding to unselect.
         */
        value: KnockoutObservableBase<T>;
        /**
         * The value to which 'value' will be set when the click target is selected.  The property can be set to
         * via part binding to dynamically change 'value' when the click target is selected.
         */
        selectedValue: KnockoutObservableBase<T>;
        /**
         * Reflects whether the click target can currently be clicked to unselect.
         */
        isClickable: KnockoutObservableBase<boolean>;
        /**
         * Reflects whether the click target is currently in a selected state.
         */
        isSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target is currently in a command selected state.
         */
        isCommandSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target is currently in an activated state.
         */
        isActivated: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target has journey children that are in an edited state.
         */
        hasChildEdits: KnockoutObservable<boolean>;
        getDefaultSelection: () => MsPortalFx.Base.PromiseV<T>;
        private readonly _lifetime;
        /**
         * Construct an instance of the view model.
         * @param options Options to configure the instance.
         */
        constructor(options?: SelectableOptions<T>);
        dispose(): void;
        setIsSelected(initialState?: any, selectedByDefault?: boolean): void;
        /**
         * Called from a left-click event handler when the click target is clicked.
         */
        onClick(): void;
    }
    /**
     * Note: By new convention, this should be "FxImpl.ViewModels", but typescript generates the wrong
     *   .d.ts file and downstream projects fail to compile. It gets confused with the use of MsPortalFx.Base.PromiseV.
     */
    module Internal {
        /**
         * Options to configure a delayed blade selection.
         */
        interface DelayedBladeSelectionOptions<TSelection> {
            /**
             * The expected size of the blade.
             */
            bladeWidth: MsPortalFx.Blades.BladeWidth;
            /**
             * Promise that resolves when the selection once it is known.
             */
            selectedValuePromise: MsPortalFx.Base.PromiseV<TSelection>;
        }
        /**
         * Internal interface that represents selectable component.
         */
        class Selectable<TSelection> extends MsPortalFx.ViewModels.Selectable<TSelection> {
            /**
             * Informs the shell that a delayed blade selection is going to occur.
             */
            delayedBladeSelection: KnockoutObservable<DelayedBladeSelectionOptions<TSelection>>;
            constructor(options?: SelectableOptions<TSelection>);
        }
        module SelectableSet {
            interface CreateDelayedBladeSelection<TItem, TSelection> {
                (item: TItem): MsPortalFx.ViewModels.Internal.DelayedBladeSelectionOptions<TSelection>;
            }
            function setCreateDelayedBladeSelection<TItem, TSelection>(selectableSet: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>, createDelayedBladeSelection: CreateDelayedBladeSelection<TItem, TSelection>): void;
        }
    }
    /**
     * Selection that provides information about the detail blade to open dynamically.
     */
    interface DynamicSelection {
        /**
         * Object that maps to the blade inputs of the detail blade.
         */
        detailBladeInputs: Object;
        /**
         * Name of extension that contains the blade. Defaults to same extension as part that uses this selection.
         */
        extension?: string;
        /**
         * If true the blade should be opened in the context pane
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    /**
     * Selection that provides detail blade name to open.
     */
    interface DynamicBladeSelection extends DynamicSelection {
        /**
         * Name of the detail blade to open.
         */
        detailBlade: string;
    }
    /**
     * Gets a dynamic blade selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param detailBlade The name of the blade.
     * @param inputs The blade inputs.
     * @returns The dynamic blade selection.
     */
    function getBladeSelection(extensionName: string, detailBlade: string, inputs: any): DynamicBladeSelection;
    /**
     * Selection that provides asset type to use to resolve detail blade to open.
     */
    interface DynamicAssetSelection extends DynamicSelection {
        /**
         * Name of asset used to retrieve the detail blade.
         */
        assetType: string;
    }
    /**
     * Gets a dynamic asset selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param assetType The name of the asset type.
     * @param inputs The blade inputs.
     * @returns The dynamic asset selection.
     */
    function getAssetSelection(extensionName: string, assetType: string, inputs: any): DynamicAssetSelection;
    /**
     * Selection that provides resource ID to use to resolve detail blade to open.
     */
    interface DynamicResourceSelection extends DynamicSelection {
        /**
         * Resource ID for the selection used to retrieve the detail blade.
         */
        resourceId: string;
    }
    /**
     * A helper type pointing to all functional implementation of DynamicSelection interface.
     */
    type DynamicSelectionImpl = DynamicSelection | DynamicBladeSelection | DynamicAssetSelection | DynamicResourceSelection;
    /**
     * Compares DynamicSelection instances.
     * @param selection1 The first selection
     * @param selection2 The second selection
     * @return A boolean value reflecting whether the two selections are equal.
     */
    function equalDynamicSelections(selection1: DynamicSelection, selection2: DynamicSelection): boolean;
    interface ContextualCommands {
        /**
         * Commands for the item.
         */
        commandGroup: string;
        /**
         * Optional string that specifies the extension that owns the commands. If omitted it is
         * assumed to be the extension that defined the containing part.
         */
        commandGroupOwner?: string;
    }
    /**
     * Represents the set of operations (e.g., loading data) that a Part is currently executing.
     */
    class PartOperationList implements Base.Disposable {
        /**
         * Specifies whether or not there is at least one operation in progress.
         */
        inProgress: KnockoutComputed<boolean>;
        /**
         * This field is no longer supported.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         *
         * Provides a viewmodel that can be bound to a pcProgressBar control.
         */
        progressBarViewModel: Obsolete;
        /**
         * Specifies whether or not at least one of the active operations is intended to block the UI.
         */
        blockingUi: KnockoutComputed<boolean>;
        /**
         * The type of blocking shield that will appear if UI is blocked.
         */
        shieldType: KnockoutComputed<ShieldType>;
        private _operations;
        /**
         * Constructs an instance of PartOperationList.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        dispose(): void;
        /**
         * Adds an operation to the list.
         *
         * @param promise A promise representing the operation to be added.
         * @param options Additional options describing how the operation should be visualized.
         */
        add(promise: MsPortalFx.Base.Promise, options?: PartOperationOptions): void;
        /**
         * Removes an operation from the list.
         *
         * @param promise The promise matching the operation to remove.
         */
        remove(promise: MsPortalFx.Base.Promise): void;
        /**
         * Updates the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @param options New options for the operation.
         */
        update(promise: MsPortalFx.Base.Promise, options: PartOperationOptions): void;
        /**
         * Describes the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @return Options associated with the operations.
         */
        getOptionsForOperation(promise: MsPortalFx.Base.Promise): PartOperationOptions;
    }
    const enum ShieldType {
        /**
         * The shield is opaque.
         */
        Opaque = 0,
        /**
         * The shield is translucent.
         */
        Translucent = 1
    }
    interface PartOperationOptions {
        /**
         * The type of blocking shield that will appear if UI is blocked.
         */
        shieldType?: ShieldType;
    }
    /**
     * A set of options describing how an operation should be visualized.
     */
    class PartOperationOptions {
        /**
         * If true, indicates that the Part UI should be blocked (non-interactive) until the operation finishes.
         */
        blockUi: boolean;
    }
    /**
     * A view model for the content displayed in a Part.
     */
    interface PartContent {
        /**
         * Optional. Invoked by the Shell when the Part's inputs change to a new,
         * complete set of values. The view model should handle this by
         * loading whatever data corresponds to the input properties.
         *
         * @param inputs The Part's current set of input property values as a name/value collection.
         * @param partSettings Object with settings loaded for these set of inputs.
         * @return A promise representing a data access operation that has been initiated, or null.
         */
        onInputsSet?(inputs: any, partSettings?: any): MsPortalFx.Base.Promise;
    }
    /**
     * A view model that is resizable.
     */
    interface Resizable {
        /**
         * Represents the size for a part.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
    /**
     * The fully qualified type name of the resource id.
     */
    const ResourceIdTypeName = "MsPortalFx.ViewModels.ResourceId";
    /**
     * The type of the resource id.
     * It is equivalent to string.
     */
    type ResourceId = string;
}

// FILE: MsPortalFx\ViewModels\ViewModels.ActionBars.d.ts
declare module MsPortalFx.ViewModels.ActionBars {
    import FxBase = MsPortalFx.Base;
    module Base {
        /**
         * The style for the secondary link.
         */
        const enum SecondaryLinkStyle {
            /**
             * Leave the secondary link unstyled.
             */
            Unstyled = 0,
            /**
             * Shows the secondary link as a bottom banner.
             */
            BottomBanner = 1
        }
        /**
         * Specifies the status of the operation.
         */
        const enum Status {
            /**
             * Indicates that the operation in the enclosing blade is not started.
             */
            NotStarted = 0,
            /**
             * Indicates that the operation in the enclosing blade is in progress.
             */
            InProgress = 1,
            /**
             * Indicates that the operation in the enclosing blade is in an erroneous state.
             */
            Error = 2,
            /**
             * Indicates that the operation in the enclosing blade is completed.
             */
            Completed = 3
        }
        /**
         * Specifies the action to be taken.
         */
        const enum Action {
            /**
             * No action should be taken.
             */
            None = 0,
            /**
             * Go to the previous step.
             */
            Previous = 1,
            /**
             * Go to the next step.
             */
            Next = 2,
            /**
             * Skip and go to the next step.
             */
            Skip = 3,
            /**
             * Complete the wizard.
             */
            Complete = 4,
            /**
             * Cancel the action.
             */
            Cancel = 5
        }
        interface InputOutputBase {
            /**
             * The status of the operation.
             */
            status: Status;
            /**
             * The ID uniquely identifying the create step.
             */
            stepId?: string;
        }
        /**
         * Specifies the source of the action/click.
         */
        const enum ActionSource {
            /**
             * The primary/default button.
             */
            Default = 0,
            /**
             * The secondary link.
             */
            SecondaryLink = 1
        }
        interface ActionBarInput extends InputOutputBase {
            /**
             * A value indicating whether this is the first step.
             */
            isFirstStep?: boolean;
            /**
             * True if this is the last step in a create flow; else false.
             */
            isLastStep?: boolean;
            /**
             * A value indicating whether the step is optional.
             */
            isOptional?: boolean;
            /**
             * A value indicating whether or not the step is disabled.
             * This value specifies whether or not there are any prerequisite steps that have not been completed.
             */
            disabled?: boolean;
        }
        interface ActionBarOutput extends InputOutputBase {
            /**
             * The action to perform.
             */
            action: Action;
            /**
             * A unique id to track changes.
             */
            commitId?: string;
        }
        interface Contract extends Controls.Loadable.Contract {
            /**
             * Indicates whether the blade enclosing the action bar is valid.
             */
            valid: KnockoutObservable<boolean>;
            /**
             * The input data for the current step.
             */
            input: KnockoutObservable<ActionBarInput>;
            /**
             * The data outputted by the current step.
             */
            output: KnockoutObservable<ActionBarOutput>;
        }
        /**
         * Checks if the specified wizard/form/selector action is completed.
         *
         * @param actionBarOutput The output from the action bar for the wizard/form/selector to verify.
         * @return True if the action is completed; else false.
         */
        function isCompleted(actionBarOutput: any): boolean;
        /**
         * The view model class for Wizard portal control.
         */
        class ViewModel extends Controls.Loadable.ViewModel implements Contract {
            valid: KnockoutObservable<boolean>;
            input: KnockoutObservable<ActionBarInput>;
            output: KnockoutObservable<ActionBarOutput>;
            onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        }
    }
    module ErrorInfoBoxActionBar {
        interface AsyncValidationResult extends ValidationResult {
            /**
             * Blade to open from the infobox
             */
            blade?: DynamicBladeSelection;
        }
        interface AsyncValidation {
            /**
             * Validation function returning a ValidationResult promise.
             *
             * @param source The source of the click (e.g. default button, secondary link, etc.).
             * @return A promise resolved with an async validation result object.
             */
            validate: (source: Base.ActionSource) => MsPortalFx.Base.PromiseV<AsyncValidationResult>;
        }
        interface GroupValidation extends AsyncValidation {
        }
        interface Contract extends Base.Contract {
            /**
             * Displays the error info box when the primary button is clicked and the form is invalid.
             */
            enableErrorInfoBox?: KnockoutObservable<boolean>;
            /**
             * If defined, the action bar will run this validation in addition to the form validation before submitting
             */
            groupValidation?: GroupValidation;
            /**
             * The action bar will run these validations (in addition to the form validation) before submitting.
             */
            asyncValidations: AsyncValidation[];
        }
        class ViewModel extends Base.ViewModel implements Contract {
            /**
             * Displays the error info box when the primary button is clicked and the form is invalid.
             */
            enableErrorInfoBox: KnockoutObservable<boolean>;
            /**
             * Hide the infobox when it shows the group validation error message
             */
            clearGroupValidationMessage(): void;
            /**
             * InfoBox selectable
             */
            infoBoxSelectable: MsPortalFx.ViewModels.Selectable<MsPortalFx.ViewModels.DynamicBladeSelection>;
            /**
             * Internal - handle to clear group validation message
             */
            _msPortalFxClearGroupValidationMessage: KnockoutObservable<typeof noop>;
            /**
             * The action bar will run these validations (in addition to the form validation) before submitting.
             */
            asyncValidations: AsyncValidation[];
            /**
             * If defined, the action bar will run this validation in addition to the form validation before submitting
             */
            groupValidation: GroupValidation;
        }
    }
    module DeleteActionBar {
        /**
         * The actionbar output of the delete asset confirmation blade.
         */
        interface ActionBarOutput extends Base.ActionBarOutput {
            /**
             * The identifier of the user actions on the action bar.
             */
            userActionId: string;
        }
        interface Contract extends Base.Contract {
            /**
             * Callback to execute when the save button is clicked.
             */
            deleteButtonClick(): void;
            /**
             * Callback to execute when the save button is clicked.
             */
            cancelButtonClick(): void;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            deleteButtonClick(): void;
            cancelButtonClick(): void;
            private _onButtonClicked;
        }
    }
    module FormActionBar {
        interface Contract extends Base.Contract {
            /**
             * Callback to execute when the save button is clicked.
             */
            saveButtonClick(): void;
            /**
             * Callback to execute when the save button is clicked.
             */
            discardButtonClick(): void;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            saveButtonClick(): void;
            discardButtonClick(): void;
        }
    }
    module FilterActionBar {
        interface Contract extends Base.Contract {
            /**
             * Callback to execute when the update button is clicked.
             */
            updateButtonClick(): void;
            /**
             * Callback to execute when the reset button is clicked.
             */
            resetButtonClick(): void;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            /**
             * Callback to execute when the update button is clicked.
             */
            updateButtonClick(): void;
            /**
             * Callback to execute when the reset button is clicked.
             */
            resetButtonClick(): void;
        }
    }
    module GenericActionBar {
        import SecondaryLinkStyle = Base.SecondaryLinkStyle;
        interface ActionBarOutput extends Base.ActionBarOutput {
            /**
             * An optional link text used in create action bar scenarios.
             */
            secondaryLinkClicked?: string;
        }
        interface Contract extends ErrorInfoBoxActionBar.Contract {
            /**
             * The display text for the action button.
             */
            actionButtonLabel?: KnockoutObservable<string>;
            /**
             * If defined, clicking the action button will also launch a URI in a new window.
             * NOTE : this feature is not compatible with groupValidation & asyncValidations
             */
            actionButtonUri?: KnockoutObservable<string>;
            /**
             * If defined, specifies the value of the strWindowFeatures parameter to the
             * window.open call used to open the actionButtonUri.
             */
            actionButtonUriWindowFeatures?: KnockoutObservable<string>;
            /**
             * The summary html displayed on top of the action button.
             */
            actionSummaryHtml?: KnockoutObservable<string>;
            /**
             * Callback to execute when the action button is clicked.
             */
            actionButtonClick(): void;
            /**
             * True, if user can choose whether provisioning happens on blade or startboard part.
             * Else false.
             */
            allowToggleProvisioningLocation?: KnockoutObservable<boolean>;
            /**
             * The display text for the link to the right of the create button.
             */
            secondaryLinkDisplayText: KnockoutObservable<string>;
            /**
             * Boolean indicating if clicking on the secondary link should trigger validation.
             */
            secondaryLinkTriggerValidation?: KnockoutObservable<boolean>;
            /**
             * The display style for the link to the right of the create button.
             * The link can also be styled to show at the bottom as a banner, or other value according to the enum.
             */
            secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
        }
        class ViewModel extends ErrorInfoBoxActionBar.ViewModel implements Contract {
            /**
             * Displays the error info box when the primary button is clicked and the form is invalid.
             */
            enableErrorInfoBox: KnockoutObservable<boolean>;
            actionButtonLabel: KnockoutObservable<string>;
            actionButtonUri: KnockoutObservable<string>;
            actionButtonUriWindowFeatures: KnockoutObservable<string>;
            actionSummaryHtml: KnockoutObservable<string>;
            actionButtonClick(): void;
            allowToggleProvisioningLocation: KnockoutObservable<boolean>;
            secondaryLinkDisplayText: KnockoutObservable<string>;
            secondaryLinkTriggerValidation: KnockoutObservable<boolean>;
            secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
            onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        }
    }
    module CreateActionBar {
        const enum ActionButtonText {
            /**
             * Shows the default action button text
             * 'Create' for provisioning blade and 'OK' for non-provisioning blade
             */
            Default = 0,
            /**
             * Change the action button text to 'Purchase'
             */
            Purchase = 1
        }
        const enum SecondaryLinkStyle {
            /**
             * Leave the secondary link unstyled.
             */
            Unstyled = 0,
            /**
             * Shows the secondary link as a bottom banner.
             */
            BottomBanner = 1
        }
        interface ActionBarInput extends Base.ActionBarInput {
            /**
             * True, if user can choose whether provisioning happens on blade or startboard part.
             * Else false.
             */
            allowToggleProvisioningLocation: boolean;
            /**
             * True if the master part that opened the create blade is a provisioning part; else false.
             */
            masterIsProvisioningPart?: boolean;
        }
        interface ActionBarOutput extends Base.ActionBarOutput {
            /**
             * An optional link text used in create action bar scenarios.
             */
            secondaryLinkClicked?: string;
        }
        interface Options {
            /**
             * Optional. Hides the action bar.
             */
            hideActionBar?: boolean;
        }
        interface Contract extends ErrorInfoBoxActionBar.Contract {
            /**
             * INTERNAL USE ONLY
             * Indicates whether an action is in progress or not.
             * An action in progress will disable the action button regardless of its validity.
             */
            actionInProgress: KnockoutObservable<boolean>;
            /**
             * The input data for the current step.
             */
            input: KnockoutObservable<ActionBarInput>;
            /**
             * True, if the enclosing blade is used for provisioning; else false.
             */
            isProvisioningBlade: KnockoutObservable<boolean>;
            /**
             * True, if the enclosing blade should do provisioning; false, if provisioning should be done in a startboard part.
             */
            provisionOnStartboardPart: KnockoutObservable<boolean>;
            /**
             * True if the master part that opened the create blade is a provisioning part; else false.
             */
            masterIsProvisioningPart?: KnockoutObservable<boolean>;
            /**
             * The summary and/or link to the EULA for the create step.
             */
            eula: KnockoutObservable<string>;
            /**
             * The display text for the link to the right of the create button.
             */
            secondaryLinkDisplayText: KnockoutObservable<string>;
            /**
             * Boolean indicating if clicking on the secondary link should trigger validation.
             */
            secondaryLinkTriggerValidation?: KnockoutObservable<boolean>;
            /**
             * The display style for the link to the right of the create button.
             * The link can also be styled to show at the bottom as a banner, or other value according to the enum.
             */
            secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
            /**
             * Disables the primary button on the action bar.
             */
            disablePrimaryButton?: KnockoutObservable<boolean>;
            /**
             * Triggers the select action.
             */
            triggerSelectAction: KnockoutObservable<string>;
            /**
             * Forces the an in progress status when the create button is clicked.
             */
            forceInProgressStatus: KnockoutObservable<boolean>;
            /**
             * 'dropDown' property is no longer supported. Please refer to https://aka.ms/portalfx/breaking for more details.
             */
            dropDown?: Obsolete;
            /**
             * Shows/hides the action bar.
             */
            showActionBar: KnockoutObservable<boolean>;
            /**
             * If defined, clicking the action bar will launch a URI in a new window instead the default
             * behavior.
             */
            actionButtonUri?: KnockoutObservable<string>;
            /**
             * Specifies what the action button display text should be.
             */
            actionButtonLabel?: KnockoutObservable<ActionButtonText>;
        }
        class ViewModel extends ErrorInfoBoxActionBar.ViewModel implements Contract {
            actionInProgress: KnockoutObservable<boolean>;
            input: KnockoutObservable<ActionBarInput>;
            isProvisioningBlade: KnockoutObservable<boolean>;
            provisionOnStartboardPart: KnockoutObservable<boolean>;
            masterIsProvisioningPart: KnockoutObservable<boolean>;
            eula: KnockoutObservable<string>;
            secondaryLinkDisplayText: KnockoutObservable<string>;
            secondaryLinkTriggerValidation: KnockoutObservable<boolean>;
            secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
            /**
             * Disables the primary button on the action bar.
             */
            disablePrimaryButton: KnockoutObservable<boolean>;
            triggerSelectAction: KnockoutObservable<string>;
            forceInProgressStatus: KnockoutObservable<boolean>;
            dropDown: Obsolete;
            showActionBar: KnockoutObservable<boolean>;
            actionButtonUri: KnockoutObservable<string>;
            actionButtonLabel: KnockoutObservable<ActionButtonText>;
            /**
             * Creates a create action bar view model.
             *
             * @param lifetimeManager Lifetime manager for this view model.
             * @param options The options to configure the create action bar.
             */
            constructor(lifetimeManager: FxBase.LifetimeManager, options?: Options);
            onInputsSet(inputs?: any): FxBase.Promise;
        }
    }
    module PickerActionBar {
        interface Contract extends Base.Contract {
            /**
             * Triggers the select action.
             */
            triggerSelectAction: KnockoutObservable<string>;
            /**
             * The summary and/or link to the EULA.
             */
            eula: KnockoutObservable<string>;
            /**
             * Indicates if the associated picker supports multiselect.
             */
            showSelectButton: KnockoutObservable<boolean>;
            /**
             * Optional. An alternate text to use for the select button label.
             */
            selectButtonText?: KnockoutObservable<string>;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            triggerSelectAction: KnockoutObservable<string>;
            eula: KnockoutObservable<string>;
            showSelectButton: KnockoutObservable<boolean>;
            selectButtonText: KnockoutObservable<string>;
            onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.AppBlade.d.ts
declare module MsPortalFx.ViewModels.AppBlade {
    import ViewModels = MsPortalFx.ViewModels;
    import FxContainerContract = ViewModels.ContainerContract;
    /**
     * The options of the app blade.
     */
    interface Options {
        source: string;
    }
    type MessageHandler = (data: any) => void;
    /**
     * The message envelope.
     */
    class Message {
        /**
         * The message signature.
         */
        signature: string;
        /**
         * The message kind.
         */
        kind: string;
        /**
         * The message data.
         */
        data: any;
        constructor(kind: string, data?: any);
    }
    /**
     * The view model of the app blade.
     */
    class ViewModel extends ViewModels.Blade {
        private iFrame;
        private _handlers;
        private _queue;
        constructor(container: FxContainerContract, options: Options);
        postMessage(message: Message): void;
        on(kind: string, callback: MessageHandler): void;
        off(kind: string, callback: MessageHandler): void;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Blade.d.ts
declare module MsPortalFx.ViewModels {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxBase = MsPortalFx.Base;
    /**
     * The status bar of the blade.
     */
    interface BladeStatusBar {
        /**
         * The text to display in the blade's status bar.
         */
        text: string;
        /**
         * The state of the blade.
         */
        state: FxViewModels.ContentState;
        /**
         * The blade selection that blade's status bar can activate.
         */
        selection?: FxViewModels.DynamicSelectionImpl;
        /**
         * The callback executed whenever the status bar is activated.
         */
        onActivated?: (() => void) | ClickableLink;
    }
    /**
     * A view model for a Blade.
     */
    interface BladeContract {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle?: KnockoutObservableBase<string>;
        /**
         * The displayed description of the blade.
         */
        description?: KnockoutObservableBase<string>;
        /**
         * The help uri of the blade.
         */
        helpUri?: KnockoutObservableBase<string>;
        /**
         * The SVG of the icon to display for the given blade.
         */
        icon: KnockoutObservableBase<FxBase.Image>;
        /**
         * The URI of the image in the title of the blade.
         */
        titleImageUri?: KnockoutObservableBase<string>;
        /**
         * The status bar of the blade.
         * Once initialized, it will take precedence over contentState and contentStateDisplayText.
         */
        statusBar?: KnockoutObservableBase<BladeStatusBar>;
        /**
         * The content state of the blade.
         */
        contentState?: KnockoutObservableBase<FxViewModels.ContentState>;
        /**
         * The text to display in the blade's status bar.
         */
        contentStateDisplayText?: KnockoutObservableBase<string>;
    }
    /**
     * Defines an entity that contains a title and subtitle.
     */
    interface ItemWithTitleAndSubtitle {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle: KnockoutObservableBase<string>;
    }
    /**
     * Defines attributes used to configure a blade hosted within a menu blade.
     */
    interface HostedInMenuBlade {
        /**
         * Defines attributes to use when the blade is displayed as the content of a menu blade.
         */
        menuContent: ItemWithTitleAndSubtitle;
    }
    /**
     * A view model class that respresents a Blade.
     */
    class Blade implements BladeContract, ItemWithTitleAndSubtitle {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle: KnockoutObservableBase<string>;
        /**
         * The displayed description of the blade.
         */
        description: KnockoutObservableBase<string>;
        /**
         * The learn more link provided in the description of the blade.
         */
        helpUri: KnockoutObservable<string>;
        /**
         * The SVG of the image in the title of the blade.
         */
        icon: KnockoutObservableBase<FxBase.Image>;
        /**
         * The URI of the image in the title of the blade.
         */
        titleImageUri: KnockoutObservableBase<string>;
        /**
         * The status bar of the blade. The default value is null.
         * Once initialized, it will take precedence over contentState and contentStateDisplayText.
         */
        statusBar: KnockoutObservableBase<BladeStatusBar>;
        /**
         * The content state of the blade.
         */
        contentState: KnockoutObservableBase<FxViewModels.ContentState>;
        /**
         * The text to display in the blade's status bar.
         */
        contentStateDisplayText: KnockoutObservableBase<string>;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.BladeCaller.d.ts
declare module MsPortalFx.ViewModels.Internal {
    /**
     * Describes options for constructing a BladeCaller.
     */
    interface BladeCallerOptions<TParams, TResult, TSelectable> {
        /**
         * A selectable that, when selected, causes the child blade to be invoked.
         *
         * This option is mutually exclusive with 'invokeOnSelectableSet'.
         */
        invokeOnSelectable?: MsPortalFx.ViewModels.SelectableContract<TSelectable>;
        /**
         * A selectable set that, when selected, causes the child blade to be invoked.
         *
         * This option is mutually exclusive with 'invokeOnSelectable'.
         */
        invokeOnSelectableSet?: MsPortalFx.ViewModels.SelectableSet<TSelectable, any>;
        /**
         * A callback that supplies parameters for a child blade that is being opened.
         *
         * @param activatedItem The object that has been activated, causing this blade call to begin.
         * @return The parameters to supply.
         */
        supplyParams(activatedItem: TSelectable): TParams;
        /**
         * A callback that receives result values from the called child blade.
         *
         * @param result The result value sent from the child blade.
         * @param activatedItem The object that was activated when the blade call began. The result refers to that object.
         */
        receiveResult(result: TResult, activatedItem: TSelectable): void;
        /**
         * If true the blade is always invoked regardless of the selectable state.
         * This is for internal shell use.
         */
        forceInvocation?: boolean;
    }
    /**
     * Describes options for constructing a BladeCallable.
     */
    interface BladeCallableOptions<TParams, TResult> {
        "--noUnusedLocals"?: TResult | any;
        /**
         * A callback that receives parameter values from the parent blade.
         *
         * @param params The parameter values received from the parent blade.
         */
        receiveParams(params: TParams): void;
    }
    /**
     * Determines if the given Part/Blade/Command input is one injected by the FX BladeCaller component.
     *
     * @param inputName The name of the input.
     * @return A boolean reflecting whether this input is an injected BladeCaller input.
     */
    function isBladeCallerInput(propertyName: string): boolean;
    /**
     * A viewmodel that can call a child blade, i.e., supply parameters to it and
     * receive result values.
     */
    class BladeCaller<TParams, TResult, TSelectable> {
        private internal_bladeCallId;
        private internal_bladeCallerParams;
        /**
         * Constructs an instance of BladeCaller.
         *
         * @param container The container instance associated with the part or other composition element hosting this BladeCaller.
         * @param options Options for the instance.
         */
        constructor(container: MsPortalFx.ViewModels.InputsCallbacksRegistrar, options: BladeCallerOptions<TParams, TResult, TSelectable>);
    }
    /**
     * A viewmodel that can be called by a parent part or other composition item. It
     * can receive parameters from the parent, and send back results to it.
     */
    class BladeCallable<TParams, TResult> {
        private _bladeCallId;
        private internal_bladeCallerResult;
        /**
         * Constructs an instance of BladeCallable.
         *
         * @param container The container instance associated with the part or other composition element hosting this BladeCallable.
         * @param options Options for the instance.
         */
        constructor(container: MsPortalFx.ViewModels.ContainerContract, options: BladeCallableOptions<TParams, TResult>);
        /**
         * Sends a result value back to the associated BladeCaller.
         *
         * @param result The result to send.
         */
        sendResult(result: TResult): void;
    }
    /**
     * Represents binding inputs that a blade callback expects to receive from its caller.
     */
    interface BladeCallableInputs<TParams> {
        /**
         * The unique ID representing the blade call. This is used to ensure that, later,
         * the child blade's output is directed to the correct BladeCaller, and that the
         * BladeCaller doesn't accept more than one result per call.
         */
        internal_bladeCallId: number;
        /**
         * Parameters sent from the BladeCaller to its child blade.
         */
        internal_bladeCallerParams: TParams;
    }
    /**
     * A message sent from a child blade to its parent BladeCaller.
     */
    interface BladeCallableResultMessage<TResult> {
        /**
         * The unique ID representing the blade call. This is used to ensure that, later,
         * the child blade's output is directed to the correct BladeCaller, and that the
         * BladeCaller doesn't accept more than one result per call.
         */
        bladeCallId: number;
        /**
         * The result value sent from the child blade to its parent BladeCaller.
         */
        result: TResult;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Command.d.ts
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxNet = FxBase.Net2;
    import FxImage = FxBase.Image;
    /**
     * Command execution status.
     */
    const enum CommandStatus {
        /**
         * Command is not executing or displaying a message.
         */
        None = 0,
        /**
         * Command is in the process of executing. Command may display dialogs
         * in the blade while in an executing state.
         */
        Executing = 1
    }
    const enum FileDownloadType {
        /**
         * Download file is a text file
         */
        Text = 1,
        /**
         * Download file is a binary file
         */
        Binary = 2
    }
    interface UriCallbackConfirmationDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        uriCallbackProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        uriCallbackProgressText?: string;
        /**
         * MessageBox title string to indicate if file should be downloaded or canceled.
         */
        downloadTitle?: string;
        /**
         * MessageBox description string to indicate if file should be downloaded or canceled.
         */
        downloadText?: string;
        /**
         * MessageBox default button text.
         */
        defaultButtonText?: string;
        /**
         * MessageBox cancel button text.
         */
        cancelButtonText?: string;
    }
    interface DownloadProgressDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        downloadProgressText?: string;
    }
    /**
     * Error notification messages for uri callback errors.
     * When uri callback error fails, reject the promise and provide the needed error messages and it will be shown in the hubs notification.
     */
    interface UriCallbackErrorMessage {
        /**
         * Optionally specify the title text for error notification message.
         */
        title?: string;
        /**
         * Optionally specify the description text for error notification message.
         */
        description?: string;
    }
    /**
     * View model
     */
    interface CommandBaseContract {
        /**
         * Whether the command is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Icon object for the command.
         */
        icon?: KnockoutObservableBase<FxBase.Image>;
        /**
         * Text for the command.
         */
        text?: KnockoutObservableBase<string>;
        /**
         * Optional. Sets a label alternative used by accessibility tools.
         */
        ariaLabel?: KnockoutObservableBase<string>;
        /**
         * Tooltip for the command.
         */
        tooltip?: KnockoutObservableBase<string>;
    }
    /**
     * A view model for the command container.
     */
    interface CommandContainerContract extends MsPortalFx.ViewModels.ContainerContract {
        /**
         * View model reflecting the selection state of the Command. The value is null if the command is not selectable.
         */
        selectable?: Selectable<any>;
    }
    /**
     * A view model for the command container.
     */
    class CommandContainerContract {
        constructor();
    }
    /**
     * A view model that respresents an executable command.
     */
    interface CommandContract extends CommandBaseContract {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservableBase<CommandStatus>;
        /**
         * Function called when command is executed.
         * @param formValid Contains the validation status of form elements contained within the command's blade or part.
         */
        execute(formValid?: boolean): void;
        /**
         * Dialog box shown to user. Will be cleared if the message box is dismissed without
         * a button being clicked. If a message box button is clicked messageBoxClick() function
         * will be called.
         */
        dialog?: KnockoutObservableBase<Dialogs.Dialog>;
        /**
         * Function called when a message box button is clicked.
         *
         * @param result Contains the result of the user interaction with the dialog.
         */
        dialogClick?(result: Dialogs.DialogResult): void;
    }
    /**
     * Interface for a command that launches a URI.
     */
    interface UriCommandContract extends CommandBaseContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget?: KnockoutObservableBase<string>;
    }
    /**
     * Interface for a command that launches a URI.
     */
    interface UriCallbackCommandContract extends CommandBaseContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional callback to dynamically generate navigate uri when the command is clicked.
         * If this callback is provided, navigateUri will not be used.
         */
        navigateUriCallback?: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget?: KnockoutObservableBase<string>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
    }
    /**
     * Interface for a command that opens a dropdown menu of items.
     */
    interface ListCommandContract extends CommandBaseContract {
        /**
         * Items that will be displayed when the ListCommand is open.
         */
        listItems: KnockoutObservableArray<string>;
        /**
         * Text of the selected item. We use the text as the key.
         */
        selectedItem: KnockoutObservable<string>;
    }
    /**
     * Interface for a command that defines its type and behavior dynamically.
     */
    interface DynamicCommandContract extends CommandBaseContract {
        /**
         * The view model of the nested command.
         */
        viewModel: KnockoutObservableBase<CommandBaseContract>;
    }
    /**
     * Interface for a command that launches a file download specified by the URI.
     */
    interface FileDownloadCommandContract extends CommandBaseContract {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * A callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is set, then the targetUri property is not used.
         */
        targetUriCallback?: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Optionally specify GET or POST type for the http request. Default is GET.
         */
        httpMethod?: KnockoutObservableBase<string>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType?: KnockoutObservableBase<string>;
        /**
         * Specify set of http headers to be included in the request.
         */
        headers?: KnockoutObservableBase<StringMap<any>>;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType?: KnockoutObservableBase<FileDownloadType>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<FileDownloadStatus>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions?: DownloadProgressDialogOptions;
    }
    /**
     * Interface for a command that opens a blade.
     */
    interface OpenBladeCommandContract extends CommandBaseContract {
    }
    /**
     * Abstract base class for Commands and UriCommands.
     */
    class CommandBase implements CommandBaseContract {
        /**
         * Whether the command is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Icon object for the command.
         */
        icon: KnockoutObservableBase<FxImage>;
        /**
         * Text for the command.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Optional. Sets a label alternative used by accessibility tools.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Tooltip for the command.
         */
        tooltip: KnockoutObservableBase<string>;
    }
    /**
     * Base class for executable commands.
     */
    class Command extends CommandBase implements CommandContract {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservableBase<MsPortalFx.ViewModels.CommandStatus>;
        /**
         * Function called when command is executed.
         * @param formValid Contains the validation status of form elements contained within the command's blade or part.
         */
        execute(formValid?: boolean): void;
        /**
         * Dialog box shown to user.
         *
         * If a message box button is clicked then the 'dialogClick()' function will be called.
         *
         * If the message box is dismissed without a button being clicked, you should ensure to set your
         * CommandStatus to None and also null out this dialog instance.
         */
        dialog: KnockoutObservableBase<Dialogs.Dialog>;
        /**
         * Function called when a message box button is clicked.
         *
         * @param result Contains the result of the user interaction with the dialog.
         */
        dialogClick(result: Dialogs.DialogResult): void;
    }
    /**
     * Base class for commands which launch URIs.
     */
    class UriCommand extends CommandBase implements UriCommandContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget: KnockoutObservableBase<string>;
    }
    /**
     * Base class for commands which launch URIs.
     */
    class UriCallbackCommand extends CommandBase implements UriCallbackCommandContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional callback to dynamically generate navigate uri when the command is clicked.
         * If this callback is provided, navigateUri will not be used.
         */
        navigateUriCallback: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget: KnockoutObservableBase<string>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
    }
    /**
     * Base class for a command that opens a dropdown menu of items.
     */
    class ListCommand extends CommandBase implements ListCommandContract {
        listItems: KnockoutObservableArray<string>;
        selectedItem: KnockoutObservable<string>;
    }
    /**
     * Base class for a command that defines its type and behavior dynamically.
     */
    class DynamicCommand extends CommandBase implements DynamicCommandContract {
        viewModel: KnockoutObservableBase<CommandBaseContract>;
    }
    /**
     * File download status with http response codes.
     */
    class FileDownloadStatus {
        /**
         * Indicates the file download status category.
         * Status string will have the AJAX response status ("success", "notmodified", "error", "timeout", "abort", or "parsererror").
         */
        status: string;
        /**
         * Indicates the file download status code which are standard http response code.
         */
        statusCode: number;
        /**
         * Indicates the error message returned by the AJAX call.
         */
        errorMessage: string;
        constructor(status: string, statusCode: number, errorMessage?: string);
    }
    /**
     * Options for command that launches a file download specified by the URI.
     */
    interface FileDownloadCommandOptions {
        authorizationOptions?: FxNet.AuthorizationOptions;
    }
    /**
     * Command class for launching a file download specified by the URI.
     */
    class FileDownloadCommand extends CommandBase implements FileDownloadCommandContract {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * Optionally specify a callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is defined, then the targetUri property is not used.
         */
        targetUriCallback: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod: KnockoutObservableBase<string>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent: KnockoutObservable<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType: KnockoutObservable<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName: KnockoutObservableBase<string>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType: KnockoutObservableBase<FileDownloadType>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<FileDownloadStatus>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions: DownloadProgressDialogOptions;
        /**
         * FileDownload command constructor.
         *
         * @param container Boolean flag or authorization options to indicate if authorization token needs to be feteched and updated in authorizationToken.
         */
        constructor(addDefaultAuthorizationToken?: FileDownloadCommandOptions | boolean);
    }
    /**
     * Base class for commands that launches detail blades.
     */
    class OpenBladeCommand extends CommandBase implements OpenBladeCommandContract {
        /**
         * Initializes a new instance of a command that can launch new blades.
         *
         * @param container The view model for the UI representation of the command.
         */
        constructor(container: CommandContainerContract);
        /**
         * Creates a Selectable view model optionally initialized with a selectable value.
         *
         * @param selectedValue Optional, initial value for the 'selectedValue' property of the Selectable.
         * @return A Selectable view model instance.
         */
        static createSelectableViewModel(selectedValue?: any): Selectable<any>;
    }
    module Commands.Dynamic {
        import FxViewModels = MsPortalFx.ViewModels;
        /**
         * Interface for a command that opens a blade and is instantiated by a dynamic command.
         */
        interface OpenBladeCommandContract extends FxViewModels.OpenBladeCommandContract {
            /**
             * Defines a blade name.
             */
            bladeName: string;
            /**
             * Defines blade inputs.
             */
            bladeInputs: Object;
        }
        /**
         * Base class for commands that launches detail blades and is instantiated dynamically.
         */
        class OpenBladeCommand extends FxViewModels.OpenBladeCommand implements OpenBladeCommandContract {
            bladeName: string;
            bladeInputs: Object;
            /**
             * Initializes a new instance of a command that can launch new blades.
             *
             * @param container The view model for the UI representation of the command.
             */
            constructor(container: CommandContainerContract);
        }
        /**
         * Command class for launching a file download specified by the URI that is instantiated dynamically.
         */
        class FileDownloadCommand extends FxViewModels.FileDownloadCommand {
            constructor();
        }
        /**
         * Base class for executable dynamic commands.
         */
        class ExecutableCommand extends FxViewModels.Command {
            constructor();
        }
        /**
         * Base class for commands which launch URIs dynamically.
         */
        class UriCallbackCommand extends FxViewModels.UriCallbackCommand {
            constructor();
        }
        /**
         * Base class for commands which launch URIs dynamically.
         */
        class UriCommand extends FxViewModels.UriCommand {
            constructor();
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Container.d.ts
declare module MsPortalFx.ViewModels {
    import FxControlsNotice = MsPortalFx.ViewModels.Controls.Notice;
    import FxBase = MsPortalFx.Base;
    import FxCompositionSelectable = FxImpl.Composition.Selectable;
    /**
     * A callback that will be invoked when new inputs are available for the composition item.
     */
    interface OnInputsSetCallback {
        (inputs: any, settings?: any): MsPortalFx.Base.Promise;
    }
    /**
     * Details of an error that are displayed to customers along with extra data for support ticket.
     */
    interface ErrorOptions {
        /**
         * A user friendly message for the error that happened, either as a string or HtmlContent.
         * The message only shows on Blade, and expanded error view from Part.
         */
        message: string | HtmlContent;
        /**
         * The HTTP error code most closely associated with the error.
         */
        code?: number;
        /**
         * Free form text to provide in depth details of the error, elaborating upon the content of the friendly
         * error message. This can be things like raw error message, inner errors, etc. Keep content user readable
         * though, this isn't for cryptic system details.
         */
        details?: string | HtmlContent;
        /**
         * Additional key/value pair collection of summary items that will be visible to the portal user.
         * These items will be sent to the support ticket.
         *
         * By default, the following items will be included and populated by the framework:
         *     - Session ID
         *     - Resource ID (if applicable)
         *     - Extension Name
         *     - Part/Blade Name
         *     - Error code (if provided, with default fallback when possible for NotFound/Unauthorized calls)
         *     - Details (if provided)
         */
        summaryItems?: {
            /**
             * The label displayed for summary item.
             */
            label: string;
            /**
             * The value displayed for summary item.
             */
            value: string;
        }[];
        /**
         * Any extra metadata which the extension author wants to include in a support ticket to help investigation.
         * The object will be JSON stringified so it later can be parsed back for readability, log, and data analysis purposes.
         *
         * This metadata isn't visible on screen but is available via other mechanisms, including "copy to clipboard" and "create support ticket".
         * As such, this metadata should not contain personally identifiable information (PII). Caller is responsible to do this treatment.
         */
        metadata?: any;
    }
    /**
     * A registry of callbacks that will be invoked when new inputs are available for the composition item.
     */
    interface OnInputsSetCallbacks extends MsPortalFx.Base.Disposable {
        /**
         * Adds a callback to be invoked whenever new inputs are available.
         *
         * @param callback The callback to be invoked whenever new inputs are available.
         * @param invokeIfPreviousInputsPassed  If true and the callback is added after onInputsSet was invoked, then the callback is invoked immediately
         */
        add(callback: OnInputsSetCallback, invokeIfPreviousInputsPassed?: boolean): void;
        /**
         * Removes a callback from the registry, so it will no longer be invoked when new inputs are available.
         *
         * @param callback The callback to be removed.
         */
        remove(callback: OnInputsSetCallback): void;
        /**
         * Invokes any registered onInputsSet callbacks, returning a promise representing the
         * asynchronous completion of all the callbacks.
         *
         * @param inputs Inputs to supply to the callbacks.
         * @param settings Settings values to supply to the callbacks.
         * @return If any callbacks are registered and return a promise, returns a promise that represents their aggregate completion. Otherwise, returns null.
         */
        triggerCallbacks(inputs: any, settings: any): MsPortalFx.Base.Promise;
    }
    /**
     * The options for the notice blade.
     */
    interface NoticeOptions {
        /**
         * The header of the notice.
         */
        noticeHeader?: string;
        /**
         * The title of the notice.
         */
        noticeTitle?: string;
        /**
         * The description of the notice.
         */
        noticeDescription?: string;
        /**
         * The call to action text of the notice.
         */
        noticeCallToActionText?: string;
        /**
         * The call to action uri of the notice.
         */
        noticeCallToActionUri?: string;
        /**
         * The image type of the notice.
         */
        noticeImageType?: FxControlsNotice.ImageType;
    }
    interface InputsCallbacksRegistrar extends FxBase.DisposableLifetimeManager {
        /**
         * A registry of callbacks that will be invoked when new inputs are available for the composition item.
         */
        onInputsSetCallbacks: OnInputsSetCallbacks;
    }
    /**
     * Methods that can be used for managing a locked blade
     */
    interface LockedBladeManagement {
        /**
         * Closes this blade
         *
         * @param data Optional value to return back to the parent blade
         * @return a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: any): Q.Promise<boolean>;
    }
    interface OpenBladeOptions {
        asSubJourney?: boolean;
    }
    interface OpenBladeAsyncOptions extends OpenBladeOptions {
        initialWidth?: MsPortalFx.Blades.BladeWidth;
    }
    interface BladeManagement {
        /**
         * Opens a child Blade.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         */
        openBlade(bladeReference: FxCompositionSelectable.BladeReference<any>, options?: OpenBladeOptions): Q.Promise<boolean>;
        /**
         * Opens a child Blade asynchronously.  While the Blade to be shown is being determined (via 'bladeReferencePromise') a loading
         * indicator will be displayed on the new child Blade.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         */
        openBladeAsync(bladeReferencePromise: Q.Promise<FxCompositionSelectable.BladeReference<any>> | Promise<FxCompositionSelectable.BladeReference<any>>, options?: OpenBladeAsyncOptions): Q.Promise<boolean>;
        /**
         * Opens a child Blade in the Context Pane.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         * @param options Options used to open the child Blade.
         */
        openContextPane(bladeReference: FxCompositionSelectable.BladeReference<any>): Q.Promise<boolean>;
        /**
         * Opens a child Blade asynchronously in the Context Pane.  While the Blade to be shown is being determined (via
         * 'bladeReferencePromise') a loading indicator will be displayed in the Context Pane.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         * @param options Options used to open the child Blade.
         */
        openContextPaneAsync(bladeReferencePromise: Q.Promise<FxCompositionSelectable.BladeReference<any>> | Promise<FxCompositionSelectable.BladeReference<any>>): Q.Promise<boolean>;
    }
    /**
     * containers for parts and template blades expose this optional functional which is enabled
     * for menu blade content
     */
    interface MenuBladeManagement {
        /**
         * This method causes the menu blade to navigate to a different item
         *
         * @param id Identifier of the item to navigate too
         */
        switchItem(id: string): void;
        /**
         * Opens a child Blade in place.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         */
        openBlade(bladeReference: FxCompositionSelectable.BladeReference<any>, options?: OpenBladeOptions): Q.Promise<boolean>;
        /**
         * Opens a child Blade asynchronously in place.  While the Blade to be shown is being determined (via 'bladeReferencePromise') a loading
         * indicator will be displayed on the new child Blade.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         */
        openBladeAsync(bladeReferencePromise: Q.Promise<FxCompositionSelectable.BladeReference<any>>, options?: OpenBladeAsyncOptions): Q.Promise<boolean>;
    }
    /**
     * All view models have a associated container view model. The container view model
     * exists to drive the chrome. This is the base interface that all container view models
     * share.
     */
    class ContainerContract {
        constructor();
    }
    /**
     * All view models have a associated container view model. The container view model
     * exists to drive the chrome. This is the base interface that all container view models
     * share.
     */
    interface ContainerContract extends InputsCallbacksRegistrar, MsPortalFx.Data.ErrorNotificationTarget {
        /**
         * The message provided to the container when not found.
         */
        notFoundMessage: KnockoutObservable<string | ErrorOptions>;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage: KnockoutObservable<string | ErrorOptions>;
        /**
         * The path to the help content file.
         */
        helpContentUri: KnockoutObservable<string>;
        /**
         * The announce API aims to provide screen reader users knowledge of certain UI updates that are otherwise difficult to advertise.
         * Announcements main purpose is to bring attention to these changes and provide feedback that is only visual otherwise.
         *
         * The message will be published at the 'polite' level, letting the screen reader queue the announcement at an appropriate time without interrupting the current read out queues.
         *
         * The API has these notable documented use cases:
         *   UI changes without focus change: If you add new UI elements through user interaction, and without moving the focus, you should announce.
         *   Confirmations: If you do operations that have completed visually, but not audibly, you should announce. Ex: upon deleting item XYZ, announce "item XYZ deleted"
         *   Loading progression: Announce at reasonable interval loading progression of specific thresholds, and the completion of loading.
         *   Custom search results: If you don't use the SearchBox control, you should announce. Ex: "3 items found".
         *
         * Keep these rules in mind when announcing:
         *   Is this something a control you use should be doing or does already? For example, the search control already has a mechanism to publish search results updates.
         *   Keep announcements short and concise as much as possible. Verbose announcements aren't usually helpful as the UI likely has the information, but the user just didn't know to look for it yet.
         *   If you push the same message multiple times in a row, screen readers are optimized to discard consecutive duplicates, including changes in space characters only. Unless a different message was pushed before, multiple callouts with the equivalent content are therefore ignored by the screen reader.
         *
         * @param message The message that will be read by the screen reader.
         */
        announce(message: string): void;
        /**
         * Moves the container into an 'error' display mode, allowing for a custom error message.
         *
         * Use this method when encountering an expected error state transition which has been
         * designed as part of the user experience and is not the indication of a product bug.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An custom error message or options customizing the error UI.
         *                As opposed to other error state transition methods, the message is non-optional.
         */
        handledError(message: string | ErrorOptions): void;
        /**
         * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An optional custom error message or options customizing the error UI.
         */
        notFound(message?: string | ErrorOptions): void;
        /**
         * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An optional custom error message or options customizing the error UI.
         */
        unauthorized(message?: string | ErrorOptions): void;
        /**
         * A registry of callbacks that will be invoked when new inputs are available for the composition item.
         */
        onInputsSetCallbacks: OnInputsSetCallbacks;
        /**
         * Renders notice as content.
         */
        enableNotice(notice: NoticeOptions): void;
    }
    /**
     * A view model for the content displayed in a portal entity (such as Blade, Part, ActionBar, Command).
     */
    interface InputsContract {
        /**
         * Invoked by the Shell when the entity's inputs change to a new,
         * complete set of values. The view model should handle this by
         * loading whatever data corresponds to the input properties.
         *
         * @param inputs The entity's current set of input property values as a name/value collection.
         * @return A promise representing a data access operation that has been initiated, or null.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
    }
    /**
     * View models which function as a selectable source implement this interface
     */
    interface SelectableSource {
        selectable: MsPortalFx.ViewModels.Selectable<any>;
    }
    module Internal {
        /**
         * ClickContext and the BladeManagement API are the same at this time
         * This may change in the future.
         */
        type ClickContext = BladeManagement;
        function createOnInputsSetCallbacks(): OnInputsSetCallbacks;
        /**
         * Debug only helper function to check all ContainerViewModels been disposed correctly.
         */
        function verifyAllContainerViewModelDisposed(): void;
        /**
         * Generic container implementation.
         */
        class ContainerViewModel implements MsPortalFx.ViewModels.ContainerContract {
            private _lifetime;
            private _id;
            private _msPortalFxAnnounce;
            private _msPortalFxNotice;
            private _msPortalFxHandledError;
            onInputsSetCallbacks: OnInputsSetCallbacks;
            helpContentUri: KnockoutObservable<string>;
            notFoundMessage: KnockoutObservable<string | ErrorOptions>;
            unauthorizedMessage: KnockoutObservable<string | ErrorOptions>;
            registerForDispose: FxBase.RegisterForDisposeFunction;
            isDisposed(): boolean;
            createChildLifetime(): FxBase.DisposableLifetimeManager;
            dispose(): void;
            announce(message: string): void;
            handledError(message: string | ErrorOptions): void;
            unauthorized(message?: string | ErrorOptions): void;
            notFound(message?: string | ErrorOptions): void;
            enableNotice(notice: NoticeOptions): void;
            constructor();
        }
        /**
         * Various flags used to configure the SDK features exposed to the view model
         */
        const enum ViewModelFlags {
            /**
             * The view model is inside a context pane
             */
            InContextPane = 1,
            /**
             * The view model is inside a locked blade
             */
            InLockedBlade = 2,
            /**
             * The view model is content that was opened by the menu blade
             */
            MenuBladeContent = 4,
            /**
             * Use dependency injection to create the view model instance
             */
            UseDi = 8
        }
        /**
         * Options that are used to configure the selectable container.
         */
        interface SelectableContainerOptions {
            /**
             * An instance of MsPortalFx.ViewModels.Selectable which controls whether this Part can be selected.
             */
            selectable?: MsPortalFx.ViewModels.Selectable<any>;
            /**
             * Various view model flags used to configure the SDK options
             */
            flags?: ViewModelFlags;
        }
        /**
         * creates a click context for the openBlade APIs.   The click context is used for ensure lightpath works correctly.
         * For example if the openBlade API is invoked inside a onRowClick callback then click context will contain sufficient
         * state to ensure the appropriate row is highlighted when the blade is opened.
         *
         * @lifetime The lifetime of the click context.   The click context has a subscription to listen for blade opening to be completed.
         * @reason The reason click context was created.
         * @openBladeShellInterface The interface that click context requests opening a blade and listens for the open blade request to be completed.
         * @containerInContextPane True if this view model exists inside a context pane.
         * @options Additional options provided from the caller used to influence how the blade is opened.
         * @selectedItem For list controls such as the grid.   This optional parameter is a reference to the selected item.
         * @controlMetadata for list controls such as the grid.   This optional parameter contains additional state associated with the open blade request.
         * @telemetryName optional name logged in telemetry.
         */
        function createClickContext(lifetime: MsPortalFx.Base.LifetimeManager, reason: OnClickReason, openBladeShellInterface: FxImpl.OpenBladeShellInterface<any>, containerInContextPane: boolean, selectedItem?: any, controlMetadata?: any, telemetryName?: string): ClickContext;
        function setClickContext(selectableContainer: SelectableContainerViewModel, clickContext: ClickContext): void;
        class SelectableContainerViewModel extends ContainerViewModel implements FxImpl.Composition.Selectable.SelectableViewModel, CommandContainerContract, BladeManagement {
            /**
             * see CommandContainerContract interface
             * This member is not initialized or exposed when this class is used for blade view models and other generic cases
             */
            selectable: MsPortalFx.ViewModels.Selectable<any>;
            /**
             * see MsPortalFx.Blades.SelectableViewModel interface
             * For open blade commands
             */
            configureSelectable: <TBladeReference extends FxImpl.Composition.Selectable.BladeReference<any>>(options: FxImpl.Composition.Selectable.Selectable2Options<FxImpl.Composition.Selectable.BladeReference<any>>) => FxImpl.Composition.Selectable.Selectable2<TBladeReference>;
            /**
             * If true then this container is inside a blade context pane
             */
            flags: Internal.ViewModelFlags;
            constructor(options: SelectableContainerOptions);
            /**
             * Opens a child Blade.
             *
             * @param bladeReference A BladeReference describing the Blade to be opened.
             * @param options Additional options for how the blade should be opened
             * @return a promise that is fulfilled when the blade is opened.
             */
            openBlade<TParameters, TOutputs>(bladeReference: FxCompositionSelectable.PdlBladeReference<TParameters, TOutputs>, options?: OpenBladeOptions): Q.Promise<boolean>;
            /**
             * Opens a child Blade asynchronously.  While the Blade to be shown is being determined (via 'bladeReferencePromise') a loading
             * indicator will be displayed on the new child Blade.
             *
             * @param bladeReferencePromise A promise that will be resolved with a BladeReference describing the Blade to be opened.
             * @param options Additional options for how the blade should be opened
             * @return A promise that is fulfilled when the blade is opened.
             */
            openBladeAsync<TParameters, TOutputs>(bladeReferencePromise: Q.Promise<FxCompositionSelectable.PdlBladeReference<TParameters, TOutputs>>, options?: OpenBladeAsyncOptions): Q.Promise<boolean>;
            /**
             * Opens a child Blade in the Context Pane.
             *
             * @param bladeReference A BladeReference describing the Blade to be opened.
             */
            openContextPane(bladeReference: FxCompositionSelectable.BladeReference<any>): Q.Promise<boolean>;
            /**
             * Opens a child Blade asynchronously in the Context Pane.  While the Blade to be shown is being determined (via
             * 'bladeReferencePromise') a loading indicator will be displayed in the Context Pane.
             *
             * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
             */
            openContextPaneAsync(bladeReferencePromise: Q.Promise<FxCompositionSelectable.BladeReference<any>>): Q.Promise<boolean>;
        }
        interface PreviewContract {
            /**
             * True if the composition is marked as being in preview.
             */
            preview: KnockoutObservableBase<boolean>;
        }
        /**
         * Marks the given container as having content that is in preview.
         *
         * @param The container to mark as preview.
         * @param isPreview Optional boolean true to mark the contain as in preview (default), false to clear the preview mark.
         */
        function markAsPreview(container: MsPortalFx.ViewModels.ContainerContract, isPreview?: boolean): void;
        const enum CloseBladeTarget {
            ThisBlade = 0,
            ChildBlade = 1,
            ContextBlade = 2
        }
        /**
         * This is the shell close blade API typing that is invoked by extensions to close a blade.
         * This API is wrapped with some SDK sugar for general consumption by extensions view models.
         */
        type ShellCloseBladeFunction = (target: CloseBladeTarget, data?: any) => boolean;
        interface ShellMenuContract {
            switchItem(id: string): void;
        }
        /**
         * Extends the public SDK Dialog type to include a type property
         */
        interface ShellDialog extends DialogOptions, Dialogs.DialogContract {
        }
        /**
         * Dialogs with this type are dialogs opened with the openDialog API
         */
        const Dlg2: Dialogs.DialogType;
        /**
         * private contract shared between the shell and the part container
         */
        interface ShellPartContainerContract {
            /**
             * A flag to request resizing at the composition level.
             */
            resize: KnockoutObservable<{
                width: number;
                height: number;
            }>;
            /**
             * Shared selectable instance for opening blades
             */
            selectables: KnockoutObservable<StringMap<FxImpl.Composition.Selectable.Selectable2<any>>>;
            /**
             * Callback for closing blades.   This member is populated by the shell after the part is created.
             *
             * This member cannot be populated by the part view model constructor because there is pooled view models which
             * at the time of creation have no context (no specific part instance they are attached too).
             */
            closeBlade: KnockoutObservable<ShellCloseBladeFunction>;
            /**
             * optional shell interface that is used to manage the menu blade
             */
            menu: KnockoutObservable<ShellMenuContract>;
            triggerValidation: KnockoutObservable<(focusOnFirstInvalid?: boolean, validateHidden?: boolean) => MsPortalFx.Base.PromiseV<boolean>>;
            suppressAlert: KnockoutObservable<boolean>;
            configureAlert: KnockoutObservable<AlertConfiguration>;
            /**
             * Shell setFocus method.   Set on an observable because getViewModel is a RPC call that does not proxy
             * the method via the PO layer.
             *
             * @param targetSelector The class selector associated with the desired focus target.
             * @return An object with a success status and an optional error message explaining rejection.
             */
            setFocus: KnockoutObservable<(targetSelector: string) => Q.Promise<{
                success: boolean;
                errorMsg?: string;
            }>>;
            /**
             * Shell openDialog method.   Set on a observable because getViewModel is a RPC call that does not
             * proxy the method via the PO layer.
             *
             * @param options - dialog options, processed by the shell
             * @param target - if target is of type FxElement it is not proxied correctly when passed as a field in unproxied object
             *   so we pass it as a separate parameter to ensure its identity is not lost.
             */
            openDialog: KnockoutObservable<(options: DialogOptions, target: string | FxElement) => Q.Promise<boolean>>;
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.ContentState.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Specifies which content state decoration should be applied to a Part.
     */
    const enum ContentState {
        /**
         * The Part / Blade does not display any content state decoration.
         */
        None = 0,
        /**
         * The Part / Blade displays a "success" content state decoration.
         */
        Success = 1,
        /**
         * The Part / Blade displays a "warning" content state decoration.
         */
        Warning = 2,
        /**
         * The Part / Blade displays an "error" content state decoration.
         */
        Error = 3,
        /**
         * The Part / Blade displays a "dirty" content state decoration.
         */
        Dirty = 4,
        /**
         * The Part / Blade displays an "info" content state decoration.
         */
        Info = 5,
        /**
         * The Part / Blade displays an "upsell" content state decoration.
         */
        Upsell = 6,
        /**
         * The Part / Blade displays an "complete" content state decoration.
         */
        Complete = 7
    }
    module Internal {
        enum InternalContentState {
            None = 0,
            Success = 1,
            Warning = 2,
            Error = 3,
            Dirty = 4,
            Info = 5,
            Upsell = 6,
            Complete = 7
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.DeleteAssetConfirmation.d.ts
declare module MsPortalFx.ViewModels.DeleteAssetConfirmation {
    import FxUI = MsPortalFx.UI;
    import NotificationManager = FxUI.NotificationManager;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    /**
     * The contract of the binding inputs data to the view model.
     */
    interface InputData {
        /**
         * The id of the asset.
         */
        assetId: any;
        /**
         * The name of the asset.
         */
        assetName: string;
        /**
         * The display name of the asset type.
         */
        assetTypeDisplayName?: string;
        /**
         * The affected items of the asset.
         */
        items?: string[];
    }
    /**
     * The options of the delete asset confirmation part view model.
     */
    interface PartViewModelOptions<TItem, TSelection> extends FxControls.DeleteAssetConfirmation.Options<TItem, TSelection> {
    }
    /**
     * The view model of the delete asset confirmation blade.
     */
    class BladeViewModel extends FxViewModels.Blade {
        /**
         * Gets the data input to the blade view model.
         */
        data: KnockoutObservable<InputData>;
        /**
         * Invoked when the inputs are set.
         * Subclass should call this method and chain the returned Promise.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Gets the title for the blade.
         * Subclass can override this method to proivde the custom title for the blade.
         *
         * @param data The asset input data.
         * @return the blade title.
         */
        _onGetTitle(data: InputData): string;
    }
    /**
     * The command view model to open the delete asset confirmation blade.
     */
    abstract class CommandViewModel extends FxViewModels.OpenBladeCommand {
        /**
         * Gets the data input to the command.
         */
        data: KnockoutObservable<InputData>;
        /**
         * Gets or sets the result of the deletion result.
         */
        result: KnockoutObservable<FxViewModels.CommandResult>;
        /**
         * Gets the container of the command.
         */
        _container: FxViewModels.CommandContainerContract;
        /**
         * Gets the type of the asset.
         */
        _assetType: string;
        private _data;
        private _selectedItems;
        private _previousUserActionId;
        /**
         * Creates the command instance.
         *
         * @param container The command container.
         * @param assetType The type of the asset.
         */
        constructor(container: FxViewModels.CommandContainerContract, assetType: string);
        /**
         * Invoked when the inputs are set.
         * Subclass should call this method and chain the returned Promise.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Deletes the asset.
         * Subclass is required to implement this method to actually delete the identified asset.
         * Based on the result of the deletion, subclass need to set the result property accordingly.
         *
         * @param data The data of the asset to be deleted.
         * @param selectedItems The items selected to be deleted.
         */
        abstract _onDelete(data: InputData, selectedItems: any[]): void;
        /**
         * Sends the error notification when deletion fails.
         * Subclass is required to implement this method to notify the shell the failure of the deletion of the asset.
         *
         * @param data The data of the asset to be deleted.
         * @param selectedItems The items selected to be deleted.
         * @return the error notification.
         */
        abstract _onSendErrorNotification(data: InputData, selectedItems: any[]): NotificationManager.Notification;
        /**
         * Validates if the command should be enabled.
         * Subclass can provide additional logic to decide if the command should be enabled based the data.
         *
         * @param data The data of the asset.
         * @return true if the command should be enabled, false otherwise.
         */
        _onValidateCommand(data: InputData): boolean;
    }
    /**
     * The viewModel of delete asset confirmation part.
     */
    abstract class PartViewModel<TItem, TSelection> extends FxControls.DeleteAssetConfirmation.ViewModel<TItem, TSelection> implements FxViewModels.InputsContract {
        /**
         * Gets the input data.
         */
        data: KnockoutObservable<InputData>;
        private _data;
        constructor(container: FxViewModels.PartContainerContract, options: PartViewModelOptions<TItem, TSelection>);
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Populates the grid when the asset is changed.
         * Subclass is required to implement this method to populate the grid.
         *
         * @param data The asset input data.
         */
        abstract _onPopulateGrid(data: InputData): void;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.DeleteCommand.d.ts
declare module MsPortalFx.ViewModels {
    import Fx = MsPortalFx;
    import NotificationManager = Fx.UI.NotificationManager;
    import FxViewModels = Fx.ViewModels;
    import Dialogs = FxViewModels.Dialogs;
    import DialogResult = Dialogs.DialogResult;
    /**
     * The result of the command execution.
     */
    const enum CommandResult {
        /**
         * The command is not executed.
         */
        None = 0,
        /**
         * The execution of the command has succeeded.
         */
        Success = 1,
        /**
         * The execution of the command has failed.
         */
        Failure = 2
    }
    /**
     * The options of the message box.
     */
    interface DeleteCommandMessageBoxOptions {
        /**
         * The title of the message box.
         */
        title: string;
        /**
         * The message of the message box.
         */
        message: string;
    }
    /**
     * The command to delete an asset.
     */
    abstract class DeleteAssetCommand extends FxViewModels.Command {
        private _assetType;
        private _confirmationDialog;
        private _errorDialog;
        private _data;
        /**
         * The asset data bound to the command.
         */
        data: KnockoutObservable<any>;
        /**
         * The result of the deletion.
         */
        result: KnockoutObservable<CommandResult>;
        /**
         * Instantiates the command.
         */
        constructor(container: FxViewModels.ContainerContract, assetType: string);
        onInputsSet(inputs: any): Fx.Base.Promise;
        execute(formValid?: boolean): void;
        dialogClick(result: DialogResult): void;
        /**
         * Deletes the asset.
         * Subclass is required to implement this method to actually delete the identified asset.
         * Based on the result of the deletion, subclass should set the result property accordingly.
         *
         * @param data The data of the asset to be deleted.
         */
        abstract _onDelete(data: any): void;
        /**
         * Gets the id of the asset.
         * Subclass is required to implement this method to let the shell know the asset deleted.
         * For example, if data is a complex object that contains the asset id, subclass should return the asset id from this method.
         *
         * @param data The data of the asset to be deleted.
         * @return the id of the asset.
         */
        abstract _onGetAssetId(data: any): any;
        /**
         * Sends the error notification when deletion fails.
         * Subclass is required to implement this method to notify the shell the failure of the deletion of the asset.
         * If subclass really does not want to send error notification, it can return null/undefined from this method to cancel it.
         *
         * @param data The data of the asset to be deleted.
         * @return the error notification.
         */
        abstract _onSendErrorNotification(data: any): NotificationManager.Notification;
        /**
         * Configures the confirmation message box to display.
         * Subclass can override the method to customize the confirmation message box.
         *
         * @param data The data of the asset to be deleted.
         * @return the options of the confirmation message box.
         */
        _onShowConfirmation(data: any): DeleteCommandMessageBoxOptions;
        /**
         * Configures the error message box to display.
         * Subclass can override the method to customize the error message box.
         *
         * @param data The data of the asset to be deleted.
         * @return the options of the error message box.
         */
        _onShowError(data: any): DeleteCommandMessageBoxOptions;
        /**
         * Validates if the command should be enabled.
         * Subclass can provide additional logic to decide if the command should be enabled based the data.
         *
         * @param data The data of the asset.
         * @return true if the command should be enabled, false otherwise.
         */
        _onValidateCommand(data: any): boolean;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Dialogs.d.ts
declare module FxImpl.Dialogs {
    /**
     * The internal contract that allows to control a dialog instance. Used by DialogRef instances to communicate between the extension view model and the framework.
     */
    interface DialogContract {
        /**
         * Controls the internal details of closing an instance of a dialog.
         */
        closeCallback: KnockoutObservable<Action1<{
            button: MsPortalFx.ViewModels.Dialogs.DialogResult;
        }>>;
    }
}
declare module MsPortalFx.ViewModels.Dialogs {
    const enum DialogType {
        /**
         * Invalid value for a dialog type. Used on base class types that are not meant to be passed to the framework.
         * Derived types will assign valid dialog types.
         */
        Invalid = 0,
        /**
         * Dialog is a message box.
         */
        MessageBox = 1,
        /**
         * Dialog is a progress box.
         */
        ProgressBox = 2,
        /**
         * Dialog is a form.
         */
        Form = 3,
        /**
         * Dialog for selecting one item out of a list.
         */
        List = 4
    }
    /**
     * Defines the options to configure dialog.
     */
    interface DialogContract {
        /**
         * The type of dialog to display.
         */
        type: DialogType;
        /**
         * Title shown at the top of the dialog.
         *
         * If hideTitle is set true
         * the title value will only be used for the dialog's aria label (an accessibility requirement).
         */
        title: string;
        /**
         * Indicator to hide the dialog title.
         */
        hideTitle?: boolean;
    }
    class Dialog implements DialogContract {
        type: DialogType;
        title: string;
        hideTitle: boolean;
        /**
         * Do not use. Dialog is an abstract class and should not
         * be instantiated directly.
         */
        constructor(title: string);
    }
    /**
     * Button identifiers.
     */
    const enum DialogResult {
        /**
         * The abort button.
         */
        Abort = 0,
        /**
         * The cancel button.
         */
        Cancel = 1,
        /**
         * The ignore button.
         */
        Ignore = 2,
        /**
         * The no button.
         */
        No = 3,
        /**
         * The ok button.
         */
        Ok = 4,
        /**
         * The retry button.
         */
        Retry = 5,
        /**
         * The yes button.
         */
        Yes = 6
    }
    interface DialogResultCallback {
        (result: MsPortalFx.ViewModels.Dialogs.DialogResult): void;
    }
    /**
     * Standard button sets that can be displayed in a dialog.
     */
    const enum MessageBoxButtons {
        /**
         * The message box contains Abort, Retry and Ignore buttons.
         */
        AbortRetryIgnore = 0,
        /**
         * The message box contains an OK button.
         */
        OK = 1,
        /**
         * The message box contains OK and Cancel buttons.
         */
        OKCancel = 2,
        /**
         * The message box contains Retry and Cancel buttons.
         */
        RetryCancel = 3,
        /**
         * The message box contains Yes and No buttons.
         */
        YesNo = 4,
        /**
         * The message box contains Yes, No and Cancel buttons.
         */
        YesNoCancel = 5
    }
    /**
     * The options required by a message box.
     */
    class MessageBox extends Dialog {
        text: string;
        buttons: MessageBoxButtons;
        /**
         * Gets or sets if a confirmation is required before users can press default button.
         */
        confirmationRequired: boolean;
        /**
         * The text of the confirmation message.
         */
        confirmationMessage: string;
        /**
         * Creates a new instance of a MessageBox.
         *
         * @param title Title shown at the top of the message box.
         * @param text Text of the message box.
         * @param buttons The button set to be displayed on the message box.
         */
        constructor(title: string, text: string, buttons: MessageBoxButtons);
    }
    /**
     * The options required by a progress box.
     */
    class ProgressBox extends Dialog {
        text: KnockoutObservable<string>;
        /**
         * The completion progress of the command, in percentage.
         * Values range from 0-100 or -1 for indefinite progress.
         * Defaults to indefinite progress if not specified.
         */
        completionPercentage: KnockoutObservable<number>;
        /**
         * Creates a new instance of a ProgressBox.
         *
         * @param title Title shown at the top of the progress dailog.
         * @param text Text of the progress dailog.
         * @param completionPercentage Optional number that initializes the current completion progress of the command.
         */
        constructor(title: string, text: string, completionPercentage?: number);
    }
    /**
     * The options required by the form dialog.
     */
    class FormDialog extends Dialog {
        description: KnockoutObservable<string>;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row1column1: any;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row1column2: any;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row2column1: any;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row2column2: any;
        /**
         * Creates the options for a form dialog.
         *
         * @param title The title for the dialog.
         */
        constructor(title: string);
    }
    /**
     * The options required by the list popup.
     */
    class ListPopup extends Dialog {
        listItems: KnockoutObservableBase<string[]>;
        selectedItem: KnockoutObservable<string>;
        /**
         * Creates the options for a list dialog.
         */
        constructor();
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.ExtensibleViewModel.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model whose behavior can be customized or expanded with logic supplied by another extension.
     * The additional logic is supplied by the other extension as an inner view model configured into this view model.
     */
    interface ExtensibleViewModel<T> {
        /**
         * The view model supplied by another extension.
         */
        extenderViewModel: KnockoutObservable<T>;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Part.d.ts
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxImplComposition = FxImpl.Composition;
    import NetDiagnostics = FxImpl.NetDiagnostics;
    import FxImplExtension = FxImpl.Extension;
    import FxCompositionConfiguration = MsPortalFx.Composition.Configuration;
    import FxViewModelsInternal = FxViewModels.Internal;
    import ImplViewModels = FxImpl.ViewModels;
    import CompositionViewModelContract = ImplViewModels.CompositionViewModelContract;
    import CompositionViewModelBase = ImplViewModels.CompositionViewModelBase;
    import FrameworkPartViewModelContract = ImplViewModels.FrameworkPartViewModelContract;
    import Rpc = FxImpl.Rpc;
    import FxClickContext = FxImplComposition.Selectable;
    import ViewModelType = FxImplExtension.ViewModelType;
    /**
     * The PartContainer information that can be saved from an earlier rendering of this part.
     * Used when rehydration of the part fails and we want to show some information to the user.
     */
    interface PartContainerSerializableStateOptions {
        /**
         * The title text displayed for this part. Typically this specifies what kind of information
         * appears inside the part, e.g., "Deployment history", or if that is not applicable then the
         * type of the asset that the part relates to, e.g., "Website".
         */
        partTitle?: string;
        /**
         * The asset name text displayed for this part, e.g., "Freezing Fog".
         */
        assetName?: string;
    }
    /**
     * Options used when constructing a PartContainer view model.
     */
    interface PartContainerOptions extends PartContainerSerializableStateOptions, MsPortalFx.ViewModels.Internal.SelectableContainerOptions {
        /**
         * An instance of MsPortalFx.ViewModels.ClickableLink which controls whether this Part opens a link when clicked.
         */
        clickableLink?: ClickableLink;
        /**
         * The Part's location.
         */
        location?: PartLocation;
        /**
         * The type of the part's view model.
         */
        viewModelType?: ViewModelType;
    }
    /**
     * Interface for an unprovisioned part that uses an edit scope to collect form data.
     */
    interface ProvisioningPartContentContract {
        /**
         * Edit scope id to be used by the unprovisioned part and it's children.
         */
        editScopeId: KnockoutObservable<string>;
    }
    const enum OnClickReason {
        Click = 1,
        FxClick = 2,
        RowClick = 3
    }
    /**
     * Interface for a part.
     */
    interface PartContract<T> extends CompositionViewModelContract<PartContainer, T, FrameworkPartViewModelContract> {
        /**
         * Updates a part when it becomes unauthorized.
         */
        updatePartForUnauthorized(): void;
        /**
         * Invokes extension onClick and onRowClick callbacks with click context
         */
        invokeClickHandler<TSelectedItem>(reason: OnClickReason, thisPtr: any, onClick: FxClickContext.OnClickHandler | FxClickContext.OnListClickHandler<TSelectedItem>, referenceSetter: FxImpl.OpenBladeShellInterface<any>, target?: FxElement, selectedItem?: TSelectedItem, controlMetadata?: any, telemetryName?: string): void;
    }
    interface MutateInfo {
        /**
         * Part to mutate into. Can be omitted for provisioning parts in which case
         * the new part locator will be looked up from extension definition.
         */
        partName?: string;
        /**
         * Extension that defines the specified part in its parts catalog.
         */
        extensionName?: string;
        /**
         * Input bindings for the new part. Parts in blades must not specify a new
         * container model. Their context will be the blade.
         */
        containerModel?: any;
        /**
         * Whether to prevent activation of the new part.
         */
        preventActivation?: boolean;
    }
    /**
     * Options for the for the registerSelectable API
     */
    interface RegisterSelectableOptions {
        /**
         * parameter collector is optional.
         * provide a parameter collector associated with the selectable here if the blade
         * is a a parameter provider.
         */
        parameterCollector?: ParameterCollector<any>;
        /**
         * If set to true AND the blade is a contextblade, will open in a contextpane.
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    /**
     * A reference to a DOM element in the portal
     */
    interface FxElement {
        _fxSignature: void;
    }
    /**
     * Information describing a event generated by a mouse action
     */
    interface FxMouseEvent {
        /**
         * A reference to the DOM element that was clicked
         */
        readonly target: FxElement;
    }
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    interface HtmlContent {
        /**
         * The HTML template to display
         */
        htmlTemplate: string;
        /**
         * The object to bind to the template.
         */
        viewModel?: any;
    }
    /**
     * Button identifiers
     */
    export import DialogButton = Dialogs.DialogResult;
    /**
     * Standard buttons that can be displayed in a dialog.
     */
    export import DialogButtons = Dialogs.MessageBoxButtons;
    /**
     * Describes a custom button in a dialog.
     */
    interface CustomDialogButton {
        /**
         * Optional display text of the button
         * If not specified, a default display text value will be used.
         */
        displayText?: string;
        /**
         * Button identifier that is programmatically passed back.
         */
        button: DialogButton;
        /**
         * If set to the true the button is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    /**
     * The result returned after a dialog was closed.
     */
    interface DialogResult {
        /**
         * The result returned from the dialog.
         */
        button: DialogButton;
    }
    /**
     * Describes preferred strategies to position a dialog.
     */
    const enum DialogPosition {
        /**
         * The dialog will open above the reference element, aligned to its left edge.
         * The dialog pointer will be located at the bottom left pointing downward.
         */
        TopLeftEdge = 1,
        /**
         * The dialog will open to the right of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top left pointing leftward.
         */
        RightTopEdge = 2,
        /**
         * The dialog will open below the reference element, aligned to its left edge.
         * The dialog pointer will be located at the top left pointing upward.
         */
        BottomLeftEdge = 3,
        /**
         * The dialog will open to the left of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top right pointing rightward.
         */
        LeftTopEdge = 4,
        /**
         * The dialog will open above the reference element, aligned to its right edge.
         * The dialog pointer will be located at the bottom right pointing downward.
         */
        TopRightEdge = 5,
        /**
         * The dialog will open below the reference element, aligned to its right edge.
         * The dialog pointer will be located at the top right pointing upward.
         */
        BottomRightEdge = 6
    }
    /**
     * Options supplied when opening a dialog
     */
    interface BaseDialogOptions {
        /**
         * Name used in telemetry
         */
        telemetryName: string;
        /**
         * Dialog title
         *
         * If hideTitle is set the title value will still be used for the dialog's accessible name.
         */
        title: string;
        /**
         * Dialog content
         *
         * The dialog content can be a string message to display or an HTML template / view model pair.
         */
        content: string | HtmlContent;
        /**
         * Buttons can be either standard buttons provided by the framework or
         * this can be custom buttons with labels provided by the extension
         */
        buttons: DialogButtons | CustomDialogButton[];
        /**
         * Default button is the button which has focus if custom buttons was specified.
         * This property is not applicable when standard buttons are specified.
         */
        defaultButton?: DialogButton;
        /**
         * Optional callback that is invoked when the dialog is closed.
         * Dialogs are closed when the user clicks on one of the buttons or
         * clicks anywhere on the screen outside of the dialog. If the user clicks
         * somewhere else in the portal the cancel button or equivalent is passed to this callback.
         */
        onClosed?: (result: DialogResult) => void;
        /**
         * Hint to hide dialog title.
         */
        hideTitle?: boolean;
        /**
         * Makes the dialog render as modal within its context. When modal, user input is required for dismissal and user interaction is suppressed within the context of the dialog.
         *
         * Only the blade dialog context supports a modal rendering. Modal rendering isn't compatible with DialogOptions target parameter.
         */
        modal?: boolean;
        /**
         * Dialog reference populated by the runtime that offers fine control of the lifetime of the dialog.
         * This is useful for very specific scenarios, mostly where an asynchronous operation is needed before closing the dialog.
         * Doing so requires to build a fully custom dialog content.
         */
        dialogRef?: DialogRef;
    }
    /**
     * Options supplied when opening a dialog that supports targeting
     */
    interface DialogOptions extends BaseDialogOptions {
        /**
         * The target which is used to position the dialog.
         * This is a class name or a reference to a DOM element.
         */
        target?: string | FxElement;
        /**
         * Hint where to position the dialog relative to the target.
         * Defaults to BottomLeftEdge.
         */
        positionHint?: DialogPosition;
    }
    /**
     * Methods for managing dialogs
     */
    interface DialogManagement {
        /**
         * Opens a new dialog.
         *
         * @param options Describes the dialog that is too be opened.
         * @returns Promise that is resolved when the dialog is successfully opened.
         */
        openDialog(options: DialogOptions): Q.Promise<boolean>;
    }
    /**
     * Provides an interface to control a dialog reference.
     */
    interface DialogRef {
        /**
         * The dialog instance.
         */
        value: {
            /**
             * Close the dialog with the provided result.
             *
             * @param result The DialogResult that is passed to the onClosed callback and logged to telemetry.
             */
            close: (result: DialogResult) => void;
        };
    }
    /**
     * Creates a DialogRef instance to be used as a value for the dialogRef parameter in DialogOptions.
     * @returns A DialogRef instance.
     */
    function createDialogRef(): DialogRef;
    /**
     * When to show an alert to a user when the blade closes.
     */
    const enum AlertLevel {
        /**
         * Alerts when the user closes a blade and there are dirty forms on the blade
         */
        Default = 0,
        /**
         * Never alerts
         */
        None = 1
    }
    /**
     * Alert configuration for custom alerting when the blade closes.
     */
    interface AlertConfiguration {
        /**
         * Flag to indicate whether to show the alert or not.
         */
        showAlert: boolean;
        /**
         * Optional custom message for the alert if set.
         */
        message?: string;
        /**
         * Optional flag to indicate that the alert should fire if the form is dirty even if the blade is returning
         * data.
         */
        alertOnDirtyWhenReturningData?: boolean;
    }
    /**
     * Properties to track form validity, dirty state of forms on this tile/blade and methods to trigger validation and modify alert behavior
     */
    interface FormProperties {
        /**
         *  Overall valid state of the controls in this tile/blade.
         */
        validationState: KnockoutReadOnlyObservable<MsPortalFx.ViewModels.Controls.Validators.ValidationState>;
        /**
         * Overall dirty state of the controls in this tile/blade.
         */
        dirty: KnockoutReadOnlyObservable<boolean>;
        /**
         * Triggers validation on all form controls in this tile/blade.
         * @returns a promise for the validation result.
         */
        triggerValidation(focusOnFirstInvalid?: boolean, validateHidden?: boolean): Q.Promise<boolean>;
        /**
         * Configures the behavior of the alert when the blade is closed.
         * @param configuration A computed that returns whether or not to show the alert and what message to show the user
         */
        configureAlertOnClose(configuration: KnockoutObservableBase<AlertConfiguration>): void;
        /**
         * Configures the behavior of the alert when the blade is closed.
         * @param alertLevel when to show the alert.
         */
        configureAlertOnClose(alertLevel: AlertLevel): void;
    }
    /**
     * Interface for managing dashboards.
     */
    interface DashboardManagement {
        /**
         * Navigates to the specified dashboard.
         *
         * @param dashboardId The id of the dashboard to navigate to.
         */
        navigateToDashboard(dashboardId?: string): void;
    }
    interface PartContainerContract extends MsPortalFx.ViewModels.ContainerContract, FxImpl.Composition.Selectable.SelectableViewModel, BladeManagement, DialogManagement {
        /**
         * The title text displayed for this part. Typically this specifies what kind of information
         * appears inside the part, e.g., "Deployment history", or if that is not applicable then the
         * type of the asset that the part relates to, e.g., "Website".
         */
        partTitle: KnockoutObservableBase<string>;
        /**
         * The label read by assistive devices on this part. If not set, will default to the part title set.
         * Override if you desire the label to be more specific than the default title of the part.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * The asset name text displayed for this part, e.g., "Freezing Fog".
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * If isSelectable is true then the part is selectable.  This value always is true by default.
         * If this setting is false then the state of selectable is ignored and the part is not selectable.
         */
        isSelectable: KnockoutObservableBase<boolean>;
        /**
         * View model reflecting the selection state of the Part. The value is null if the part is not selectable.
         */
        selectable: Selectable<any>;
        /**
         * View model reflecting whether the Part will open a link when clicked. The value is null if the part is not a link.
         */
        clickableLink: ClickableLink;
        /**
         * Tracks the list of asynchronous operations being performed by the Part.
         */
        operations: PartOperationList;
        /**
         * Specifies which content state decoration is applied to the Part.
         */
        contentState: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        /**
         * Reflects the load state of the Part.
         */
        partState: KnockoutObservableBase<MsPortalFx.Parts.PartState>;
        /**
         * The error message displayed by the Part when it has failed.
         */
        failureMessage: KnockoutObservable<string | ErrorOptions>;
        /**
         * The message displayed by the Part when it has no data to display.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * Member used to mutate the part.
         */
        mutate: KnockoutObservable<MutateInfo>;
        /**
         * The height of the part in pixels without padding.
         * Note: The height value will be not useful for part size FullWidthFitHeight, HeroWideFitHeight and FitToContainer.
         */
        height: KnockoutObservableBase<number>;
        /**
         * The width of the part in pixels without padding.
         */
        width: KnockoutObservableBase<number>;
        /**
         * Detailed size information for the Part.
         */
        size: KnockoutObservableBase<PartSizeInfo>;
        /**
         * The width and height of the content area, in pixels.
         */
        contentSize: KnockoutReadOnlyObservableBase<{
            height: number;
            width: number;
        }>;
        /**
         * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An optional custom error message or options customizing the error UI.
         */
        fail(message?: string | ErrorOptions): void;
        /**
         * Indicates the location of this Part (on a Dashboard, on a Blade, etc.).
         */
        location: PartLocation;
        /**
         * Removes any 'failed' error message and brings the part back to 'ready' state.
         * If the part was not already in a 'failed' state, this method does nothing.
         */
        recover(): void;
        /**
         * If allowed by ResizeMode, will adjust the size of the part to the size specified, clamped to the grid constraints.
         *
         * @param width The desired width, in grid steps, valid in range from 1 to 25.
         * @param height The desired height, in grid steps, valid in range from 1 to 25.
         */
        resizeTo(width: number, height: number): void;
        /**
         * Causes the part's content to be revealed immediately, regardless of any onInputsSet promise that
         * might not yet have completed. This removes the opaque 'loading' spinner and makes the part interactive,
         * so you must also disable or hide any UI elements that the user should not be able to see or interact with
         * until data is fully loaded.
         */
        revealContent(): void;
        /**
         * Asynchronously moves the focus to the first focusable element on or within the specified target if the container currently
         * owns the focus. If multiple targetSelector elements are found, only the first one will be inspected. If nothing is focusable,
         * the focus will not move and this method will return false.
         *
         * @param targetSelector A class selector that identifies a target to focus on or within.
         * @return An object with a success status and an optional error message explaining rejection.
         */
        setFocus(targetSelector: string): Q.Promise<{
            success: boolean;
            errorMsg?: string;
        }>;
        /**
         * Registers a selectable to open blades using dynamic blade selection.
         *
         * @param lifetime Reflects the lifetime of the selectable.  When the lifetime is disposed, the selectable will be implicitly unregistered.
         * @param identity Required, this is used as the key for persisting the selection state
         * @param selectable Required, the selectable that will be used to open blades.   This must be a Selectable or SelectableSet type only.
         * @param options Optional, additional options to configure
         */
        registerSelectable(lifetime: FxBase.LifetimeManager, identity: string, selectable: Selectable<any> | SelectableSet<any, any>, options?: RegisterSelectableOptions): void;
        /**
         * Activates this Part's 'Configuration', which is an API that enables the Part to manage parameter and settings overrides/inheritance via
         * configuration UI (typically via a Context Blade).  See the MsPortalFx.Composition.Configuration.Contract interface for details.
         *
         * @param options Options used to initialize the Configuration API for this Part
         * @return The Configuration API for this Part
         */
        activateConfiguration<TParameters, TSettings>(options?: FxCompositionConfiguration.Part.Options<TParameters, TSettings>): FxCompositionConfiguration.Part.Contract<TParameters, TSettings>;
        /**
         * Closes the child blade that is currently open
         *
         * @return a promise that resolves to true if the child blade is successfully closed.
         */
        closeChildBlade(): Q.Promise<boolean>;
        /**
         * Closes the context blade that was opened by this part
         *
         * @returns a promise that resolves to true if the context blade is successfully closed.
         */
        closeContextBlade(): Q.Promise<boolean>;
        /**
         * Optional property that provides functionality for parts that are on locked blades.
         */
        onLockedBlade?: LockedBladeManagement;
        /**
         * Properties to track form validity, dirty state of forms on this tile and methods to trigger validation and modify alert behavior
         */
        form: FormProperties;
        /**
         * This is the interface for managing the host menu blade.  If this part is not hosted in a menu blade this then property is null.
         */
        menu: MenuBladeManagement;
        /**
         * API collection that facilitates dashboard interactions.
         */
        dashboard: DashboardManagement;
    }
    /**
     * Detailed Part size information.
     */
    interface PartSizeInfo {
        /**
         * One of the defined Part sizes, including 'Custom' if the Part is configured to support arbitrary sizing.
         */
        partSize: MsPortalFx.Parts.PartSize;
        /**
         * The width/height of the Part in terms of pixels.
         */
        dimensions: {
            width: number;
            height: number;
        };
    }
    /**
     * The location of a Blade.
     */
    const enum BladeLocation {
        /**
         * Default case. The blade is neither in the content area of a MenuBlade nor in the Context Pane.
         */
        Standalone = 0,
        /**
         * The Blade is in the content area of a Menu Blade.
         */
        MenuContent = 1,
        /**
         * The Blade is in the context pane.
         */
        ContextPane = 2
    }
    /**
     * The location of a Part.
     */
    const enum PartLocation {
        /**
         * For testing purposes only.  The Part is neither on a Dashboard nor on a Blade.
         */
        _Internal_None = 0,
        /**
         * The Part is on a Dashboard.
         */
        Dashboard = 1,
        /**
         * The Part is on a Blade.
         */
        Blade = 2
    }
    /**
     * A view model for a Part.
     */
    class Part extends CompositionViewModelBase<PartContainer, any, FrameworkPartViewModelContract> implements PartContract<any> {
        private _initLoadingDefer;
        /**
         * A promise that will automatically be "superseded" (removed from the
         * operations list) the next time onInputsSet is called.
         */
        private _onInputsSetQ;
        /**
         * If true, we know that all subsequent onInputsSet promises should not block the UI, because if
         * all necessary data was known at construction (i.e., the part called 'revealContent' from inside
         * its constructor) then it can't depend on any asynchronously-loaded data.
         */
        private _hadRevealedContentAtConstruction;
        /**
         * Defines the instance of the logger to use.
         */
        private _logArea;
        /**
         * Promise from onInputsSet, if that was called shortly after the view model was created.
         * Undefined otherwise.
         */
        onInputsSetPromise?: Q.Promise<any>;
        /**
         * Constructs a Part view model instance.
         *
         * @param internal Internal view model used for extension/shell sharing of internal state
         * @param containerViewModel View model for the container of the Part.
         * @param contentViewModel View model for the content of the Part.
         * @param initialViewModelState View model state which was restored from a previous journey
         * @param contentFactory Extension view model factory, only required for noPDL view models
         */
        constructor(internal: FrameworkPartViewModelContract, containerViewModel: PartContainer, contentViewModel: any, initialViewModelState: any, logArea: string, role: FxImpl.Extension.ViewModelType, contentFactory?: () => any);
        /**
         * Creates a Selectable view model that is initialized with the Part's saved state.
         *
         * @param initialState Optional, saved selection state for the Part.
         * @param selectedValue Optional, initial value for the 'selectedValue' property of the Selectable.
         * @return A Selectable view model instance.
         */
        static createSelectableViewModel(initialState?: any, selectedValue?: any): FxViewModels.Selectable<any>;
        static createClickableLinkViewModel(observableUri: KnockoutObservable<string>, observableTarget?: KnockoutObservable<string>): FxViewModels.ClickableLink;
        /**
         * Supplies updated input binding values to the part.
         *
         * @param inputs The inputs to the part.
         * @param partSettings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * @param inputsMetadata Metadata describing the current configuration state of the Part's inputs (used by its Configuration API).
         * @param dontCallOnInputsSet If true, indicates that 'onInputsSet' should not be called (for situations where the extension called
         * 'configuration.updateValues(...)' and reacts locally to the parameters/settings changes.
         * @param filters A StringMap from filter id to filter model for the currently applied Dashboard and Part-level filters.
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, partSettings?: any, traceOptions?: ImplViewModels.CompositionViewModelTraceOptions, viewModelName?: string, inputsMetadata?: FxImplExtension.InputsMetadata, dontCallOnInputsSet?: boolean, filters?: ImplViewModels.AllFilterModels): Q.Promise<NetDiagnostics.NetworkActivityRecording>;
        private _removePromiseFromOps;
        /**
         * Updates a part when it becomes unauthorized.
         */
        updatePartForUnauthorized(): void;
        /**
         * Invokes onClick and onRowClick calls on the extension view model in the context of the extension IFrame
         */
        invokeClickHandler<TSelectedItem>(reason: OnClickReason, thisPtr: any, onClick: FxClickContext.OnClickHandler | FxClickContext.OnListClickHandler<TSelectedItem>, openBladeShellContract: FxImpl.OpenBladeShellInterface<any>, target?: FxElement, selectedItem?: TSelectedItem, controlMetadata?: any, telemetryName?: string): void;
        private _onRevealContent;
    }
    const navigateToDashboardEndPoint: Rpc.FuncEndPointDefinition<string[], void>;
    /**
     * A view model for the Part itself, that is, the container around the Part's content.
     */
    class PartContainer extends FxViewModelsInternal.SelectableContainerViewModel implements PartContainerContract {
        partTitle: KnockoutObservableBase<string>;
        ariaLabel: KnockoutObservableBase<string>;
        assetName: KnockoutObservableBase<string>;
        isSelectable: KnockoutObservable<boolean>;
        clickableLink: ClickableLink;
        operations: PartOperationList;
        contentState: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        partState: KnockoutObservableBase<MsPortalFx.Parts.PartState>;
        failureMessage: KnockoutObservable<string | FxViewModels.ErrorOptions>;
        noDataMessage: KnockoutObservable<string>;
        height: KnockoutObservable<number>;
        width: KnockoutObservable<number>;
        size: KnockoutObservable<FxViewModels.PartSizeInfo>;
        contentSize: KnockoutObservable<{
            height: number;
            width: number;
        }>;
        mutate: KnockoutObservable<MutateInfo>;
        location: PartLocation;
        /**
         * When this Part is the virtual Part that implements a Blade, this is the location where the Blade was opened/rendered.
         */
        bladeLocation: BladeLocation;
        /**
         * Optional property that provides functionality for parts that are on locked blades.
         */
        onLockedBlade: LockedBladeManagement;
        /**
         * Properties to track form validity, dirty state of forms on this tile and methods to trigger validation and modify alert behavior
         */
        form: FormProperties;
        /**
         * Interface for managing the host menu blade. If this part is not hosted in a menu blade then this property is null.
         */
        menu: MenuBladeManagement;
        dashboard: DashboardManagement;
        private _partState;
        /**
         * selectables that are dynamically registered
         */
        private _registeredSelectables;
        /**
         * Options for dynamically registered selectables
         */
        private _registeredSelectableOptions;
        /**
         * A private viewmodel used for interactions between the part, its container, and the Shell.
         */
        private _internalViewModel;
        /**
         * This Part's Configuration API, optionally activated via 'container.activateConfiguration()'.
         */
        private _config;
        /**
         * Constructs a PartContainer view model instance.
         *
         * @param internal Required internal framework view model. The container API manipulates this internal view model.
         * @param options Options used to construct this view model. Optional.
         */
        constructor(internal: FrameworkPartViewModelContract, options?: PartContainerOptions);
        private autoSize;
        resizeTo(width: number, height: number): void;
        setFocus(targetClass: string): Q.Promise<{
            success: boolean;
            errorMsg?: string;
        }>;
        fail(message?: string | FxViewModels.ErrorOptions): void;
        recover(): void;
        revealContent(): void;
        enableNotice(notice: NoticeOptions): void;
        registerSelectable(lifetime: FxBase.LifetimeManager, identity: string, selectable: Selectable<any> | SelectableSet<any, any>, options?: RegisterSelectableOptions): void;
        activateConfiguration<TParameters, TSettings>(options?: FxCompositionConfiguration.Part.Options<TParameters, TSettings>): FxCompositionConfiguration.Part.Contract<TParameters, TSettings>;
        closeCurrentBlade(data?: any): Q.Promise<boolean>;
        closeChildBlade(): Q.Promise<boolean>;
        closeContextBlade(): Q.Promise<boolean>;
        openDialog(options: DialogOptions): Q.Promise<boolean>;
    }
    /**
     * The part container.
     */
    class PartContainerContract {
        constructor();
    }
    module Parts.Frame {
        /**
         * The contract for the view model of a frame part.
         */
        interface Contract {
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Toolbar.d.ts
declare module MsPortalFx.ViewModels.Toolbars {
    import FxViewModels = MsPortalFx.ViewModels;
    import FileDownload = FxViewModels.FileDownload;
    /**
     * The type of the toolbar item.
     *
     * These must match the corresponding enum in 'FxInternal/Controls/Toolbar'
     */
    const enum ToolbarItemType {
        /**
         * Not a valid type.
         */
        None = 0,
        /**
         * An items that visually groups other toolbar items.
         */
        Group = 1,
        /**
         * A toolbar button that opens a link.
         */
        OpenLinkButton = 2,
        /**
         * A toolbar button that opens a blade.
         */
        OpenBladeButton = 3,
        /**
         * A toolbar button that is associated to a command.
         */
        CommandButton = 4,
        /**
         * A toolbar button that opens a dialog before executing a command.
         */
        DialogButton = 5,
        /**
         * A toolbar button and can be toggled (between ON and OFF states).
         */
        ToggleButton = 6,
        /**
         * A toolbar button which initiates a file download
         */
        FileDownloadButton = 7,
        /**
         * A toolbar button which initiates a file upload
         */
        FileUploadButton = 8,
        /**
         * A toolbar button which acts like OAuth button
         */
        OAuthButton = 9,
        /**
         * A toolbar button that opens a blade using selectable 2
         */
        OpenBladeButton2 = 10,
        /**
         * A toolbar button that allows moving resources across resource groups/subscriptions
         */
        MoveResourceButton = 11,
        /**
         * A toolbar item separator to add a line UX separator between the toolbar buttons
         */
        Separator = 12,
        /**
         * An adapter for PDL command groups.
         */
        PdlCommandGroup = 13
    }
    interface BaseToolbarItemContract {
        /**
         * The type of the toolbar item.
         */
        type?: ToolbarItemType;
    }
    /**
     * Defines a toolbar item separator to add a line UX separator between the toolbar buttons
     */
    interface ToolbarItemSeparatorContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
    }
    /**
     * Defines an item in the toolbar.
     */
    interface ToolbarItemContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
        /**
         * A value indicating whether or not the toolbar item is disabled.
         */
        disabled: KnockoutObservableBase<boolean | string>;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage: KnockoutObservable<string>;
        /**
         * Signals the toolbar item is in unauthorized mode and provides an optional custom error message,
         * or an optional boolean value indicating whether or not the toolbar item is unauthorized.
         *
         * @param message A custom error message or value indicating whether or not the toolbar item is unauthorized.
         */
        unauthorized(message?: string | boolean): void;
        /**
         * Optional. The aria label to use instead of the visual text label.
         */
        ariaLabel?: KnockoutObservableBase<string>;
        /**
         * The name of the toolbar item.
         */
        name?: string;
        /**
         * The regular tooltip of the toolbar item
         */
        tooltip?: KnockoutObservableBase<string>;
    }
    /**
     * Options for an item in the toolbar
     */
    interface ToolbarItemOptions {
        /**
         * The type of the toolbar item.
         */
        type?: ToolbarItemType;
        /**
         * A value indicating whether or not the toolbar item is disabled.
         */
        disabled?: KnockoutObservableBase<boolean | string> | boolean | string;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage?: KnockoutObservable<string> | string;
        /**
         * Optional. The aria label to use instead of the default text label.
         */
        ariaLabel?: KnockoutObservableBase<string> | string;
        /**
         * The name of the toolbar item.
         */
        name?: string;
        /**
         * The regular tooltip of the toolbar item
         */
        tooltip?: KnockoutObservableBase<string> | string;
    }
    class ToolbarItem implements ToolbarItemContract {
        type: ToolbarItemType;
        disabled: KnockoutObservableBase<boolean | string>;
        unauthorizedMessage: KnockoutObservable<string>;
        ariaLabel: KnockoutObservableBase<string>;
        name: string;
        tooltip: KnockoutObservableBase<string>;
        /**
         * Creates a toolbar item.
         *
         * @param type The type of the toolbar item.
         */
        constructor(type: ToolbarItemType, options?: ToolbarItemOptions);
        unauthorized(message?: string | boolean): void;
    }
    /**
     * Defines a toolbar.
     */
    interface ToolbarContract extends FxViewModels.Controls.Loadable.Contract {
        /**
         * Sets the ordered list of items (buttons, separators, groups) that will be shown in the toolbar
         */
        setItems(items: BaseToolbarItemContract[]): void;
        /**
         * A value indicating whether or not to show item labels.
         */
        showLabels: KnockoutObservable<boolean>;
    }
    /**
     * Options for a Toolbar
     */
    interface ToolbarOptions extends FxViewModels.Controls.Loadable.Options {
        showLabels?: KnockoutObservable<boolean> | boolean;
    }
    /**
     * Defines a button in the toolbar.
     */
    interface ToolbarButtonContract extends ToolbarItemContract {
        /**
         * The command label.
         */
        label: KnockoutObservableBase<string>;
        /**
         * The icon for the command.
         */
        icon: KnockoutObservableBase<Base.Image>;
    }
    /**
     * Options for a button in toolbar.
     */
    interface ToolbarButtonOptions extends ToolbarItemOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
    }
    /**
     * Defines a toolbar.
     */
    class Toolbar extends Controls.Loadable.ViewModel implements ToolbarContract {
        /**
         * A value indicating whether or not to show item labels.
         */
        showLabels: KnockoutObservable<boolean>;
        /**
         * The list of items to show in the toolbar.
         * Does not start with '_' so that it gets proxied over to the shell.
         */
        private items;
        /**
         * Sets the ordered list of items (buttons, separators, groups) that will be shown in the toolbar
         */
        setItems(items: (BaseToolbarItemContract)[]): void;
        /**
         * Creates a toolbar.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: ToolbarOptions);
    }
    /**
     * Toolbar item seprator to add a line UX separator between the toolbar buttons
     */
    class Separator implements ToolbarItemSeparatorContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
    }
    class ToolbarButton extends ToolbarItem implements ToolbarButtonContract {
        label: KnockoutObservableBase<string>;
        icon: KnockoutObservableBase<Base.Image>;
        /**
         * Creates a toolbar button.
         *
         * @param type The type of the button.
         * @param options, the options of button, see ToolbarButtonOptions
         */
        constructor(type: ToolbarItemType, options?: ToolbarButtonOptions);
    }
    /**
     * Defines a group in the toolbar.
     */
    interface ToolbarGroupContract extends ToolbarItemContract {
        /**
         * The items in the group.
         */
        items: ToolbarItemContract[];
    }
    class ToolbarGroup extends ToolbarItem implements ToolbarGroupContract {
        items: ToolbarItemContract[];
        /**
         * Creates a toolbar group.
         *
         * @param items The items in the group.
         */
        constructor(items: ToolbarItemContract[]);
    }
    /**
     * Defines a button that can execute the associated command.
     */
    interface ExecutableButtonBaseContract<T> extends ToolbarButtonContract {
        /**
         * The command associated to the toolbar item.
         */
        command: Commands.Command<T>;
    }
    /**
     * Options for a ExecutableButtonBase
     */
    interface ExecutableButtonBaseOptions<T> extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<T>;
    }
    class ExecutableButtonBase<T> extends ToolbarButton implements ExecutableButtonBaseContract<T> {
        command: Commands.Command<T>;
        /**
         * Creates an executable button.
         *
         * @param type The type of the button.
         * @param options The options of the button, see ExecutableButtonBaseOptions
         */
        constructor(type: ToolbarItemType, options?: ExecutableButtonBaseOptions<T>);
    }
    /**
     * Defines a button that can execute the associated command.
     */
    interface CommandButtonContract<T> extends ExecutableButtonBaseContract<T> {
        /**
         * The context to pass on to the command.
         */
        commandContext: KnockoutObservableBase<T>;
    }
    /**
     * Options for a CommandButton
     */
    interface CommandButtonOptions<T> extends ExecutableButtonBaseOptions<T> {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<T>;
        /**
         * The context to pass on to the command.
         */
        commandContext?: KnockoutObservableBase<T>;
    }
    class CommandButton<T> extends ExecutableButtonBase<T> implements CommandButtonContract<T> {
        type: ToolbarItemType.CommandButton;
        commandContext: KnockoutObservableBase<T>;
        /**
         * Creates an executable button.
         *
         * @param options The options of the button, see CommandButtonOptions
         */
        constructor(options?: CommandButtonOptions<T>);
    }
    interface ToggleButtonContext<T> {
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked: boolean;
        /**
         * The context defined by the consumer of the toggle button.
         */
        context: T;
    }
    /**
     * This type of button provides an ON-OFF functionality that allows the user to toggle between
     * the ON and OFF states on every click.
     */
    interface ToggleButtonContract<T> extends ExecutableButtonBase<ToggleButtonContext<T>> {
        /**
         * The option group that the toggle button belongs to.
         */
        optionGroupName: string;
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked: KnockoutObservable<boolean>;
        /**
         * The context to pass on to the command.
         */
        commandContext: KnockoutObservableBase<T>;
    }
    /**
     * Options for a ToggleButton
     */
    interface ToggleButtonOptions<T> extends ExecutableButtonBaseOptions<ToggleButtonContext<T>> {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<ToggleButtonContext<T>>;
        /**
         * The option group that the toggle button belongs to.
         */
        optionGroupName?: string;
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked?: KnockoutObservable<boolean> | boolean;
        /**
         * The context to pass on to the command.
         */
        commandContext?: KnockoutObservableBase<T>;
    }
    class ToggleButton<T> extends ExecutableButtonBase<ToggleButtonContext<T>> implements ToggleButtonContract<T> {
        optionGroupName: string;
        checked: KnockoutObservable<boolean>;
        commandContext: KnockoutObservableBase<T>;
        /**
         * Creates a toggle button.
         *
         * @param groupNameOrOptions, implement overloads for both optionGroupName & options. if optionGroupName, The option group that the toggle button belongs to. if options, The options of the button, see ToggleButtonOptions
         */
        constructor(groupNameOrOptions?: string | ToggleButtonOptions<T>);
    }
    /**
     * Defines a button that shows a dialog before executing a command using the dialog result as context.
     */
    interface DialogButtonContract extends ExecutableButtonBaseContract<Dialogs.DialogResult> {
        /**
         * Options required for showing the dialog.
         */
        dialogOptions: Dialogs.DialogContract;
    }
    /**
     * Options for a DialogButton
     */
    interface DialogButtonOptions extends ExecutableButtonBaseOptions<Dialogs.DialogResult> {
        /**
         * The tyoe of Dialog Button
         */
        type?: ToolbarItemType;
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<Dialogs.DialogResult>;
        /**
         * Options required for showing the dialog.
         */
        dialogOptions?: Dialogs.DialogContract;
    }
    class DialogButton extends ExecutableButtonBase<Dialogs.DialogResult> implements DialogButtonContract {
        dialogOptions: Dialogs.DialogContract;
        /**
         * Creates a dialog button.
         *
         * @param typeOrOptions, implement overloads for both type & options. if type, The type of the button; if options, The options of the button, see DialogButtonOptions
         */
        constructor(typeOrOptions?: ToolbarItemType | DialogButtonOptions);
    }
    /**
     * Defines a toolbar command button that can upload a file from local disk.
     */
    interface FileUploadButtonContract extends ToolbarButtonContract, FxViewModels.FileUpload.UploadContract {
    }
    /**
     * Options for a FileUploadButton
     */
    interface FileUploadButtonOptions extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept?: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext?: KnockoutObservableBase<FxViewModels.FileUpload.UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads?: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection?: KnockoutObservableBase<boolean>;
    }
    class FileUploadButton extends ToolbarButton implements FileUploadButtonContract {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<FxViewModels.FileUpload.UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection: KnockoutObservableBase<boolean>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress and content.
         * FileUploadTask is used to initiate the file upload, resume steaming uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutObservableArray<FxViewModels.FileUpload.UploadTaskContract>;
        /**
         * Creates the file upload toolbar button.
         *
         * @param options, options of the button, see FileUploadButtonOptions
         */
        constructor(options?: FileUploadButtonOptions);
    }
    /**
     * Defines a toolbar command button that can download a file.
     */
    interface FileDownloadButtonContract extends ToolbarButtonContract {
        /**
         * The file download context of the button
         */
        context: KnockoutObservableBase<FileDownload.Context>;
    }
    /**
     * Options for a FileDownload Button
     */
    interface FileDownloadButtonOptions extends FileDownload.Options, ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
    }
    class FileDownloadButton extends ToolbarButton implements FileDownloadButtonContract {
        /**
         * The file download context of the button
         */
        context: KnockoutObservableBase<FileDownload.Context>;
        /**
         * Creates the file download toolbar button.
         *
         * @param options, options of the button, see FileDownloadButtonOptions
         */
        constructor(options: FileDownloadButtonOptions);
    }
    /**
     * Options for a OAuthButton Button
     */
    interface OAuthButtonOptions extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl?: KnockoutObservable<string> | string;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth?: KnockoutObservable<number> | number;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight?: KnockoutObservable<number> | number;
        /**
         * Token
         */
        value?: KnockoutObservable<string> | string;
    }
    class OAuthButton extends ToolbarButton implements ToolbarButtonContract {
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl: KnockoutObservable<string>;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth: KnockoutObservable<number>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight: KnockoutObservable<number>;
        /**
         * Token
         */
        value: KnockoutObservable<string>;
        /**
         * Creates the OAuth toolbar button.
         *
         * @param options, options of the button, see OAuthButtonOptions
         */
        constructor(options?: OAuthButtonOptions);
    }
    /**
     * Defines a button that can open a blade.
     */
    interface OpenBladeButtonContract<T> extends ToolbarButtonContract {
        /**
         * The selectable for the command.
         */
        selectable: FxViewModels.Selectable<T>;
    }
    /**
     * Options for a OpenBlade Button
     */
    interface OpenBladeButtonOptions<T> extends SelectableOptions<T>, ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * The selectable for the command.
         */
        selectable?: FxViewModels.Selectable<T>;
    }
    class OpenBladeButton<T> extends ToolbarButton implements OpenBladeButtonContract<T> {
        selectable: FxViewModels.Selectable<T>;
        /**
         * Creates the selectable toolbar button.
         *
         * @param options, options of the button, see OpenBladeButtonOptions
         */
        constructor(options?: OpenBladeButtonOptions<T>);
    }
    /**
     * Defines a button that can open a blade.
     */
    interface OpenBladeButtonContract2<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends ToolbarButtonContract {
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id: string;
        /**
         * The selectable for the command.
         */
        selectable: FxImpl.Composition.Selectable.Selectable2<T>;
    }
    interface OpenBladeButton2Options<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends FxImpl.Composition.Selectable.Selectable2Options<T>, ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id?: string;
        /**
         * The selectable for the command.
         */
        selectable?: FxImpl.Composition.Selectable.Selectable2<T>;
    }
    class OpenBladeButton2<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends ToolbarButton implements OpenBladeButtonContract2<T> {
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id: string;
        selectable: FxImpl.Composition.Selectable.Selectable2<T>;
        /**
         * Creates the selectable toolbar button.
         *
         * @param options, options of the button, see OpenBladeButton2Options
         */
        constructor(options?: OpenBladeButton2Options<T>);
    }
    /**
     * Defines a button that can open a new link.
     */
    interface OpenLinkButtonContract extends ToolbarButtonContract {
        /**
         * An instance of MsPortalFx.ViewModels.ClickableLink which controls whether this Part
         * opens a link when clicked.
         */
        clickableLink: FxViewModels.ClickableLink;
    }
    /**
     * Options for a OpenLinkButton
     */
    interface OpenLinkButtonOptions extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * An instance of MsPortalFx.ViewModels.ClickableLink which controls whether this Part
         * opens a link when clicked.
         */
        uri: string;
        /**
         * where to open the new link .
         */
        target?: string;
    }
    class OpenLinkButton extends ToolbarButton implements OpenLinkButtonContract {
        clickableLink: ClickableLink;
        /**
         * Creates the selectable toolbar button.
         *
         * @param uriOrOptions, if uri, The URI that will be opened when target is clicked; if options, the options of the button, see OpenLinkButtonOptions
         * @param target The target window to open the URI in.
         */
        constructor(uriOrOptions: string | OpenLinkButtonOptions, target?: string);
    }
}
