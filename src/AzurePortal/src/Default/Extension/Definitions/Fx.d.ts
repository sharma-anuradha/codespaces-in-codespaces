// Compiled with TypeScript 3.9

// FILE: Fx.d.ts
declare module "Fx" {
    export = Main;
    module Main {
        export import forEachKey = MsPortalFx.forEachKey;
        export import getEnvironmentValue = MsPortalFx.getEnvironmentValue;
        export import getUniqueId = MsPortalFx.getUniqueId;
        export import isDevelopmentMode = MsPortalFx.isDevelopmentMode;
        export import isFeatureEnabled = MsPortalFx.isFeatureEnabled;
        export import require = MsPortalFx.require;
        export import startTimer = MsPortalFx.startTimer;
    }
}

// FILE: Fx\Ajax.d.ts
declare module "Fx/Ajax" {
    import FxBase = MsPortalFx.Base;
    import Net2 = FxBase.Net2;
    export import HttpStatusCode = Net2.HttpStatusCode;
    interface HttpMethods extends Common.Ajax.BatchHttpMethods {
        TRACE: void;
        OPTIONS: void;
    }
    /**
     * Http methods for ajax calls
     */
    export type HttpMethod = keyof HttpMethods;
    /**
     * Http methods for batch ajax calls
     */
    export type BatchHttpMethod = Common.Ajax.BatchHttpMethod;
    /**
     * The contract of settings input into ajax calls.
     */
    export type NetAjaxSettings<T> = Net2.NetAjaxSettings<T>;
    /**
     * Endpoints used by most extensions.
     */
    export type Endpoints = Common.Ajax.Endpoints;
    /**
     * The settings for the batch call.
     */
    export type BatchSettings = Common.Ajax.BatchSettings;
    /**
     * The contract for the batch settings.
     */
    export type BatchMultipleSettings = Common.Ajax.BatchMultipleSettings;
    /**
     * Response for a request within a batch.
     */
    export type BatchResponseItem<T> = Common.Ajax.BatchResponseItem<T>;
    /**
     * Batch response.
     */
    export type BatchResponse = Common.Ajax.BatchResponse;
    /**
     * Individual batch request.
     */
    export type BatchRequest = Common.Ajax.BatchRequest;
    /**
     * The request options.
     */
    export const enum RequestOptions {
        /**
         * Default behavior.
         *    - Defaults to foreground request
         *    - Calls are batched to ARM every 100 ms
         *    - Any ServerTimeout (503) failures for foreground GET requests
         *      are automatically retried by calling the API directly wihtout batch
         *    - Responses are not cached
         */
        None = 0,
        /**
         * Make the batch call on the next tick.
         * DebounceNextTick takes precedence over Debounce100Ms.
         */
        DebounceNextTick = 1,
        /**
         * Include the request in a batch call that is made after a 100ms delay.
         * Debounce100Ms takes precedence over DebounceOneMinute
         */
        Debounce100ms = 2,
        /**
         * Sets this request to run in the background.
         * Background requests are batched every 60 seconds.
         */
        DebounceOneMinute = 4,
        /**
         * Forces a retry for any failure returned (statusCode >= 400) regardless of the HTTP method.
         */
        RetryForce = 8,
        /**
         * Skips the default retry.
         * SkipRetry takes precedence over ForceRetry if both are set.
         */
        RetrySkip = 16,
        /**
         * Caches the response for GET requests for 10 seconds.
         */
        ResponseCacheEnabled = 32,
        /**
         * Skips caching the response for GET requests.
         */
        ResponseCacheSkip = 64,
        /**
         * Skips retry when a forbidden gateway error is received.
         */
        RetrySkipOnForbidden = 128
    }
    /**
     * Performs an ajax request with the appropriate headers set.
     *
     * @param settings The settings that are to be passed to the ajax call.
     * @return A promise for the ajax call.
     */
    export function postJSON<T>(settings: NetAjaxSettings<T>, data: any): Q.Promise<T>;
    /**
     * Performs an ajax request using caching with the appropriate headers set.
     *
     * @param settings The settings that are to be passed to the ajax call.
     * @return A promise for the ajax call.
     */
    export function ajax<T>(settings: NetAjaxSettings<T>): Q.Promise<T>;
    /**
     * Performs an ajax request using caching with the appropriate headers set and returns the XML Http response.
     *
     * @param settings The settings that are to be passed to the ajax call.
     * @return A promise for the ajax call.
     */
    export function ajaxExtended<T>(settings: NetAjaxSettings<T>): Q.Promise<Net2.Response<T>>;
    /**
     * Sets the default options that will be used for all requests unless other settings are specified.
     * @param options Request option flags.
     */
    export function initialize(options: {
        requestOptions: RequestOptions.ResponseCacheEnabled | RequestOptions.RetrySkip;
    }): void;
    /**
     * Retrieves commonly-used endpoints.
     * @returns The collection of commonly-used endpoints.
     */
    export function getEndpoints(): Endpoints;
    /**
     * The ARM endpoint in lower case form.
     *
     * @deprecated FxAjax.armEndpointLowerCase will be removed from the SDK soon, please use the getEndpoints() function instead. See https://aka.ms/portalfx/breaking for details.
     */
    export const armEndpointLowerCase: Obsolete;
    /**
     * Calls the API by batching multiple requests together.
     * Use this API if you have a single AJAX request but there is potential for batching this
     * with other requests.
     *
     * There are a couple of limitations when using this:
     *   - Requests can use absolute or relative ARM endpoint
     *   - Supports tenant level operations (/subscriptions, /resources, /locations, /providers, /tenants)
     *
     * @param settings The settings to use to call batch.
     * @return A promise for the batch call.
     */
    export function batch<T>(settings: BatchSettings): Q.Promise<BatchResponseItem<T>>;
    /**
     * Performs a batch ajax request using the given set of URIs.
     * This API is recommended if you have a set of URIs that can be called concurrently using batch.
     *
     * @param settings The settings that are to be passed to the batch call.
     * @return A promise for the batch call.
     */
    export function batchMultiple(settings: BatchMultipleSettings): Q.Promise<BatchResponse>;
    export const DEV: {
        resetAsyncBatchEnabled: () => void;
        resetArmEndpointLower: () => void;
        setArmEndpointLower: (endpoint: string) => void;
    };
    export {};
}

// FILE: Fx\Assets\AssetTypes.d.ts
declare module "Fx/Assets/AssetTypes" {
    /**
     * The asset type metadata including the resource type metadata.
     */
    export type AssetType = MsPortalFx.Assets.ResourceTypeAssetTypeInformation;
    /**
     * Gets all the asset types defined across all portal extension.
     * Official exported function to retrieve the metadata for all the asset types.
     *
     * @return A promise that resolves to an array with metadata for each asset type.
     */
    export function getAllAssetTypes(): Q.Promise<AssetType[]>;
}

// FILE: Fx\Assets\Assets.d.ts
declare module "Fx/Assets/Assets" {
    import FxAssets = MsPortalFx.Assets;
    /**
     * Finds the asset type information for the given resource type from the collection of asset types.
     * NOTE: The asset types must come from the API MsPortalFx.Assets.getResourceTypeAssetTypeInformation().
     *
     * @deprecated 04/30/2020 - No longer supported. This is being removed, use the following code in your
     * code (limited use).
     *
     * @param resourceType The resource type to find.
     * @param assetTypes The array of asset type information from the getResourceTypeAssetTypeInformation API.
     * @returns The result asset type information if found, otherwise undefined.
     */
    export function findAssetTypeInformation<T extends FxAssets.ResourceTypeAssetTypeInformation>(resourceType: string, assetTypes: T[]): Obsolete;
    /**
     * Finds the asset type information for the given resource ID from the collection of asset types.
     * NOTE: The asset types must come from the API MsPortalFx.Assets.getResourceTypeAssetTypeInformation().
     *
     * @deprecated 04/30/2020 - No longer supported. This is being removed, use the following code in your
     * code (limited use).
     *
     * @param resourceID The resource ID for the resource type to find.
     * @param assetTypes The array of asset type information from the getResourceTypeAssetTypeInformation API.
     * @returns The result asset type information if found, otherwise undefined.
     */
    export function findAssetTypeInformationFromResourceId<T extends FxAssets.ResourceTypeAssetTypeInformation>(resourceId: string, assetTypes: T[]): Obsolete;
}

// FILE: Fx\Assets\Decorators.d.ts
declare module "Fx/Assets/Decorators" {
    import { SvgType } from "Fx/Images";
    export = MsPortalFxForAsset;
    module MsPortalFxForAsset {
        module ForAsset {
            module Commands {
                /**
                 * Command kinds.
                 */
                const enum CommandKind {
                    /**
                     * Kind for the open blade commands.
                     */
                    OpenBladeCommand = 0,
                    /**
                     * Kind for the menu command.
                     */
                    MenuCommand = 1
                }
                /**
                 * Selection Command kinds.
                 */
                const enum SelectionCommandKind {
                    /**
                     * Kind for the open blade commands that require selection.
                     */
                    OpenBladeSelectionCommand = 0,
                    /**
                     * Kind for the ARM commands.
                     */
                    ArmCommand = 1,
                    /**
                     * Kind for the selection based menu command.
                     */
                    MenuSelectionCommand = 2
                }
                /**
                 * Defines the options that are passed to the command decorator.
                 */
                interface CommandOptions {
                    /**
                     * The asset type that the commands are associated with.
                     */
                    readonly assetType: string;
                    /**
                     * The list of commands which do no require resource selection.
                     */
                    readonly commands?: ReadonlyArray<Command>;
                    /**
                     * The list of commands which require selection.
                     */
                    readonly selectionCommands?: ReadonlyArray<SelectionCommand>;
                }
                /**
                 * Constrains the @ForAsset.Commands decorator so that it can be applied only to classes implementing 'Contract'.
                 */
                interface Contract {
                }
                /**
                 * Constrains the @Commands decorator so that it can be applied only to classes implementing 'Contract'.
                 */
                interface CommandsClass {
                    new (...args: any[]): Contract;
                }
                /**
                 * Decorator for Asset commands
                 * @param options command options
                 */
                function Decorator(options?: CommandOptions): (commandsClass: CommandsClass) => void;
                /**
                 * The blade reference options for open blade command.
                 */
                interface BladeReference {
                    /**
                     * The blade name.
                     */
                    readonly blade: string;
                    /**
                     * The extension name for the blade
                     */
                    readonly extension?: string;
                    /**
                     * The flag indicating whether blade needs to be opened as a context pane.
                     * Defaults to false.
                     */
                    readonly inContextPane?: boolean;
                    /**
                     * The blade parameters.
                     *
                     * NOTE: Blades that require list of resourceIds in the parameters, should specify {resourceIds} as the parameter value.
                     * Fx will replace the {resourceIds} value with currently selected resource Ids at runtime.
                     */
                    readonly parameters?: ReadonlyStringMap<any>;
                }
                /**
                 * The marketplace blade reference
                 */
                interface MarketplaceBladeReference {
                    /**
                     * The marketplaceItemId to open a create flow.
                     */
                    readonly marketplaceItemId?: string;
                }
                /**
                 * Interface for Open blade commands.
                 */
                interface OpenBladeCommand extends CommonCommandBase<CommandKind.OpenBladeCommand> {
                    /**
                     * The blade reference.
                     * Either a reference to the blade or the marketpkace item id which opens the create flow needs to be specified.
                     */
                    readonly bladeReference: BladeReference | MarketplaceBladeReference;
                }
                /**
                 * The interface for resource selection for commands.
                 */
                interface RequiresSelection {
                    /**
                     * The resource selection for commands.
                     * Default selection is max allowed selection supported by browse grid.
                     */
                    readonly selection?: Selection;
                }
                /**
                 * The interface for command execution confirmation options.
                 */
                interface ConfirmationOptions {
                    /**
                     * The confirmation dialog title to show before execution of the command.
                     */
                    readonly title: string;
                    /**
                     * The confirmation dialog message to show before execution of the bulk command.
                     */
                    readonly message: string;
                    /**
                     * The confirmation text input.
                     * User needs to enter this text in order to confirm command execution.
                     */
                    readonly explicitConfirmationText?: string;
                }
                /**
                 * The interface for commands that require user confirmation.
                 */
                interface ConfirmationCommandBase {
                    /**
                     * The command execution confirmation options.
                     */
                    readonly confirmation: ConfirmationOptions;
                }
                /**
                 * The interface for ARM command definition.
                 */
                interface ArmCommandDefinition {
                    /**
                     * Http method POST/DELETE/PATCH etc. By default POST will be used.
                     */
                    readonly httpMethodType?: string;
                    /**
                     * ARM uri for the command operation.
                     * Uri should be a relative uri with the fixed format - {resourceid}/optionalOperationName?api-version.
                     * Example: "{resourceid}?api-version=2018-09-01-preview
                     */
                    readonly uri: string;
                    /**
                     * ARM command operation can be long running operation. asyncOperation property specifies how to poll the status for completion of long running operation.
                     */
                    readonly asyncOperation?: AsyncOperationOptions;
                    /**
                     * Optional list of resource-specific ARM error codes that should be retried for HttpStatusCode.BadRequest(400).
                     *
                     * By default, Fx retries below codes:
                     *     Retry for transient errors with Http status codes: HttpStatusCode.InternalServerError(500), HttpStatusCode.BadGateway(502), HttpStatusCode.ServiceUnavailable(503), HttpStatusCode.GatewayTimeout(504)
                     *     Retry for ARM conflict/throttle errors with status codes: HttpStatusCode.TooManyRequests(409), HttpStatusCode.Conflict(429)
                     * In addition to these, there could be resource-specific errors that need to be retried for HttpStatusCode.BadRequest(400).
                     * If this list is specified, Fx will parse ARM error codes for HttpStatusCode.BadRequest(400) requests and retry in addition to above retries.
                     *
                     * Example: ["PublicIpAddressCannotBeDeleted", "InuseNetworkSecurityGroupCannotBeDeleted"]
                     */
                    readonly retryableArmCodes?: ReadonlyArray<string>;
                    /**
                     * Optional list of resource-specific ARM error codes that shouldn't be retried.
                     * This helps optimize network calls and improve bulk operation performance.
                     *
                     * By default, Fx won't issue retry for below code regardless of HTTP status code:
                     *    "ScopeLocked"
                     * In addition to this Arm error code, there could be resource-specific error codes that shouldn't be retried.
                     * If this list is specified, Fx will ignore the above mentioned list and only honor this list of Arm codes that shouldn't be retried.
                     *
                     * Example: ["ScopeLocked"]
                     */
                    readonly nonRetryableArmCodes?: ReadonlyArray<string>;
                }
                /**
                 * Optional Arm command configs to describe how long running ARM operations needs to be polled and results processed.
                 */
                interface AsyncOperationOptions {
                    /**
                     * By default when http Accepted (202) status code is received, the Location header will be looked up for polling uri to get the status of long running operation.
                     * A different response header can be specified with the pollingHeaderOverride value.
                     */
                    readonly pollingHeaderOverride?: string;
                    /**
                     * A property path to look for status in the response body.
                     * By default 'status' property will be looked up to see if it has "Succeeded", "Failed", "InProgress" or "Canceled".
                     */
                    readonly statusPath?: string;
                }
                /**
                 * The interface for ARM commands.
                 * These commands honor default selection which is FullPage.
                 */
                interface ArmCommand extends CommonCommandBase<SelectionCommandKind.ArmCommand>, ConfirmationCommandBase {
                    /**
                     * The map of ARM bulk command definitions per resource type.
                     *
                     * NOTE: A command may delete multiple types of resources e.g. browse for merged resource types.
                     * In such cases, ARM command definition can be specified for each resource type.
                     */
                    readonly definitions: ReadonlyStringMap<ArmCommandDefinition>;
                    /**
                     * The flag indicating whether to launch Fx bulk delete confirmation blade for delete operations.
                     */
                    readonly isDelete?: boolean;
                }
                /**
                 * The interface for open blade commands that require resource selection.
                 */
                interface OpenBladeSelectionCommand extends CommonCommandBase<SelectionCommandKind.OpenBladeSelectionCommand>, RequiresSelection {
                    /**
                     * The blade reference.
                     */
                    readonly bladeReference: BladeReference;
                }
                /**
                 * The interface for selection based menu command.
                 */
                interface MenuSelectionCommand extends CommonCommandBase<SelectionCommandKind.MenuSelectionCommand>, RequiresSelection {
                    /**
                     * The list of commands.
                     */
                    readonly commands: ReadonlyArray<OpenBladeSelectionCommand | ArmCommand>;
                }
                /**
                 * The interface for menu command.
                 */
                interface MenuCommand extends CommonCommandBase<CommandKind.MenuCommand> {
                    /**
                     * The list of commands.
                     */
                    readonly commands: ReadonlyArray<OpenBladeCommand>;
                }
                /**
                 * The interface for commands that require resource selection.
                 */
                type SelectionCommand = OpenBladeSelectionCommand | ArmCommand | MenuSelectionCommand;
                /**
                 * The interface for command.
                 */
                type Command = OpenBladeCommand | MenuCommand;
                /**
                 * The interface for command selection.
                 */
                interface Selection {
                    /**
                     * The max number of selected resources supported by the command operation.
                     */
                    readonly maxSelectedItems?: number;
                    /**
                     * The message shown when user tries to select more than supported items by the command operation.
                     */
                    readonly disabledMessage?: string;
                }
                /**
                 * The interface for common command properties.
                 */
                interface CommonCommandBase<TKind extends CommandKind | SelectionCommandKind> {
                    /**
                     * The command kind.
                     */
                    readonly kind: TKind;
                    /**
                     * The command Id.
                     */
                    readonly id: string;
                    /**
                     * The command label.
                     */
                    readonly label: string;
                    /**
                     * The command icon.
                     */
                    readonly icon: ({
                        /**
                         * URI to the image element.
                         */
                        path: string;
                    } | {
                        /**
                         * References a built-in SVG element.
                         */
                        image: SvgType;
                    });
                    /**
                     * The command tooltip.
                     */
                    readonly tooltip?: string;
                    /**
                     * The command aria label.
                     */
                    readonly ariaLabel?: string;
                }
            }
        }
    }
}

// FILE: Fx\ClientIp.d.ts
declare module "Fx/ClientIp" {
    const _default: () => Q.Promise<string>;
    /**
     * Gets the IPv4 address of the client.
     *
     * @return The promise for the IP address.
     */
    export = _default;
}

// FILE: Fx\Composition.d.ts
declare module "Fx/Composition" {
    import FxSelectable2 = FxImpl.Composition.Selectable;
    export import PdlBladeCallbacks = FxSelectable2.PdlBladeCallbacks;
    export import BladeReference = FxSelectable2.BladeReference;
    export import PartReference = MsPortalFx.Composition.PartReference;
    export import BladeClosedReason = FxImpl.CompositionCore.BladeClosedReason;
    export import BladeClosedHandler = FxImpl.CompositionCore.BladeClosedHandler;
    export import BladeClosedWithDataHandler = FxImpl.CompositionCore.BladeClosedWithDataHandler;
    export import ClickableLink = FxImpl.CompositionCore.ClickableLink;
    export import OperationOptions = FxImpl.CompositionCore.OperationOptions;
    export import ShieldType = FxImpl.CompositionCore.ShieldType;
    export import OperationList = FxImpl.CompositionCore.OperationList;
    export import BladeLink = FxImpl.CompositionCore.BladeLink;
    export import ResourceLink = FxImpl.CompositionCore.ResourceLink;
    /**
     * Provides access to all the Blade reference factories that are exported by a given extension.
     */
    export interface ImportedBladeReferenceFactoriesRegistry<TExtensionName extends keyof ImportedBladeReferenceFactories> {
        /**
         * Gets the Blade reference factory for a blade in the specified extension.
         */
        forBlade<TBladeName extends keyof ImportedBladeReferenceFactories[TExtensionName]>(bladeName: TBladeName): ImportedBladeReferenceFactories[TExtensionName][TBladeName];
    }
    /**
     * Provides access to all blade reference factories.
     */
    export interface BladeReferenceFactoriesRegistry {
        /**
         * Gets the Blade reference factory for a blade in the current extension.
         */
        forBlade<TBladeName extends keyof BladeReferenceFactories>(blade: TBladeName): BladeReferenceFactories[TBladeName];
        /**
         * Gets the Blade reference factory for a nopdl blade referenced by a marketplace package.
         */
        forMarketplace(): MarketplaceBladeReferenceFactory;
        /**
         * Gets all the Blade reference factories that are exported by a given extension.
         * The list of available extensions is enhanced by referencing the different definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         * Importing definition files just extends the list of types available for TypeScript compiler (and hence available in the IntelliSense).
         */
        forExtension<TExtensionName extends keyof ImportedBladeReferenceFactories>(extensionName: TExtensionName): ImportedBladeReferenceFactoriesRegistry<TExtensionName>;
    }
    /**
     * Represents a factory for a blade reference.
     */
    interface MarketplaceBladeReferenceFactory {
        /**
         * Creates a reference to a Blade.
         * @param options Options for configuring the blade reference.
         * @returns A reference to a Blade.
         */
        createReference(options: {
            /**
             * Parameters to pass to the child blade.
             */
            parameters?: any;
            /**
             * Callback that is invoked when the blade is closed.
             */
            onClosed?: BladeClosedWithDataHandler<any>;
            /**
             * The marketplace id of the provisioning Blade.
             */
            marketplaceId: string;
        }): BladeReference<any>;
    }
    /**
     * Provides access to all blade reference factories.
     */
    export const BladeReferences: BladeReferenceFactoriesRegistry;
    /**
     * Provides access to all the Part reference factories that are exported by a given extension.
     */
    export interface ImportedPartReferenceFactoriesRegistry<TExtensionName extends keyof ImportedPartReferenceFactories> {
        /**
         * Gets the Part reference factory for a part in the specified extension.
         */
        forPart<TPartName extends keyof ImportedPartReferenceFactories[TExtensionName]>(partName: TPartName): ImportedPartReferenceFactories[TExtensionName][TPartName];
    }
    /**
     * Provides access to all part reference factories.
     */
    export interface PartReferenceFactoriesRegistry {
        /**
         * Gets the Part reference factory for a part in the current extension.
         */
        forPart<TPartName extends keyof PartReferenceFactories>(part: TPartName): PartReferenceFactories[TPartName];
        /**
         * Gets all the Part reference factories that are exported by a given extension.
         * The list of available extensions is enhanced by referencing the different definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         * Importing definition files just extends the list of types available for TypeScript compiler (and hence available in the IntelliSense).
         */
        forExtension<TExtensionName extends keyof ImportedPartReferenceFactories>(extensionName: TExtensionName): ImportedPartReferenceFactoriesRegistry<TExtensionName>;
    }
    /**
     * Provides access to all part reference factories.
     */
    export const PartReferences: PartReferenceFactoriesRegistry;
    global {
        /**
         * Describes the list of blades that exist in the current extension.
         */
        interface BladeReferenceFactories {
        }
        /**
         * Describes the list of blades that are exported by the different extensions.
         * This list is enhanced by referencing the definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         */
        interface ImportedBladeReferenceFactories {
        }
        /**
         * Describes the list of parts that exist in the current extension.
         */
        interface PartReferenceFactories {
        }
        /**
         * Describes the list of parts that are exported by the different extensions.
         * This list is enhanced by referencing the definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         */
        interface ImportedPartReferenceFactories {
        }
    }
    export {};
}

// FILE: Fx\Composition\Blade.d.ts
declare module "Fx/Composition/Blade" {
    import * as FxComposition from "Fx/Composition";
    import { DialogManagement } from "Fx/Composition/Dialog";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as Provisioning from "Fx/ResourceManagement/Provisioning";
    import { PostProvisioningOptions, PostProvisioningContent } from "Fx/ResourceManagement/Deployments";
    export = MsPortalFxBlade;
    module MsPortalFxBlade {
        import PartReference = MsPortalFx.Composition.PartReference;
        /**
         * The @Blade decorator.  Identifies a class within the extension as a Blade view model class.
         *
         * @options Metadata describing the Blade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (bladeClass: BladeClass) => void;
        /**
         * Constrains the @Blade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface BladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @Blade decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this Blade.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             */
            viewModel: any;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' method.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a Blade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the Blade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a Blade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' method.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the Blade.
             */
            container: Container;
        }
        /**
         * Describes if/when to display an alert when the blade closes.
         */
        export import AlertLevel = FxBladeBase.AlertLevel;
        /**
         * Options supplied to the @Blade decorator.  Includes metadata describing the Blade and how it will be treated by
         * the FX.
         */
        interface Options extends FxBladeBase.Options, FxViewModelBase.AcceptsStyleSheetsOptions, FxBladeBase.ShrinkOnOpenChildBladeOptions, FxBladeBase.ReflowReadyOption {
        }
        /**
         * Represents a container object that can be used to control the chrome of the Blade.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the Blade.
         */
        interface Container extends FxBladeBase.Container, FxBladeBase.CanHaveCommandBarContainer, FxBladeBase.ExposesContentSize, DialogManagement {
            /**
             * The location where the Blade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the Blade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * The path to the help content file.
             */
            helpContentUri: KnockoutObservable<string>;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the Blade view model such that it implements an 'onRebind' method that will be
             * called when the Blade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the Blade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its persisted 'settings' values.  The 'settings'
             * values are made available in the view model's 'context', for use in the view model's 'onInitialize' and optional 'onRebind'
             * methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Blade's settings.
             */
            type Options = FxBladeBase.Configurable.Options;
            /**
             * Metadata describing one setting of the Blade's persisted settings.
             */
            type SettingMetadata = FxBladeBase.Configurable.SettingMetadata;
            /**
             * The scope at which the Blade's settings are persisted.
             */
            export import SettingsScope = FxBladeBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Blade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Blade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include 'configuration' (the Blade's configuration
                 * API) as well as 'settings' (the Blade's persisted settings values).
                 */
                context: Context<TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the Blade's configuration API),
             * the 'parameters' of the Blade, as well as its persisted 'settings' values.
             */
            interface Context<TSettings> extends FxBladeBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its settings.
                 */
                configuration: Configuration<TSettings>;
            }
            /**
             * The Blade's configuration API returned from 'context.configuration'.
             */
            type Configuration<TSettings> = FxBladeBase.Configurable.Configuration<TSettings>;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * Blade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the Blade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        module Pinnable {
            /**
             * The @Pinnable decorator.  Requires that the Blade implement an 'onPin' method that determines what Part
             * to pin when the user pins the Blade.
             */
            function Decorator(): (pinnableClass: PinnableClass) => void;
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface PinnableClass {
                new (...args: any[]): Contract;
            }
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract {
                /**
                 * A callback that will be called when the user pins the Blade.  Returns a PartReference to the Part that will be pinned to the
                 * user's Dashboard.
                 */
                onPin(): PartReference<any>;
            }
        }
        module DoesProvisioning {
            /**
             * The @DoesProvisioning decorator. Adds a strongly-typed 'context.provisioning' to the TemplateBlade.
             * This provisioning API allows the view model to perform provisioning operations, including support
             * for telemetry around provisioning.
             *
             * @param options Options used to configure the @DoesProvisioning decorator.
             */
            function Decorator<TOptions extends Options>(options?: TOptions): (doesProvisioningClass: TOptions["supportsPostProvisioning"] extends true ? DoesProvisioningAndPostProvisioningClass : DoesProvisioningClass) => void;
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningClass {
                new (...args: any[]): Contract;
                _fx?: {
                    doesProvisioning?: boolean;
                };
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningAndPostProvisioningClass extends DoesProvisioningClass {
                /**
                 * A static function which returns a viewmodel used to customize the content on the blade launched after submitting a provisioning request.
                 * @param lifetime The lifetime of the content returned.
                 * @param options The options for fetching content relevant to the provisioning request.
                 */
                createPostProvisioningContent(lifetime: MsPortalFx.Base.LifetimeManager, options: PostProvisioningOptions): Q.Promise<PostProvisioningContent> | Promise<PostProvisioningContent>;
            }
            /**
             * Options supplied to the @DoesProvisioning decorator.
             */
            interface Options {
                /**
                 * A flag indicating whether the caller is required to supply a Marketplace item id
                 * when instantiating a BladeReference to this TemplateBlade. Defaults to true.
                 */
                requiresMarketplaceId?: boolean;
                /**
                 * A flag indicating that the create blade's class exposes the createPostProvisioningContent function.
                 */
                supportsPostProvisioning?: true;
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes
             * implementing 'Contract'.
             */
            interface Contract {
                /**
                 * Context injected by the FX into the view model. This context should be used within
                 * the view model's 'onInitialize' and optional 'onRebind' methods.
                 */
                context: Context<any>;
            }
            /**
             * Context injected by the FX into the view model. This context should be used within the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             */
            interface Context<TUIMetadata = void> {
                /**
                 * The view model's provisioning API, with which the view model can
                 * perform provisioning operations, including support for telemetry
                 * around provisioning.
                 */
                provisioning: FxBladeBase.DoesProvisioning.Provisioning<TUIMetadata>;
            }
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTemplateOptions = Provisioning.DeployTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeploySubscriptionLevelTemplateOptions = Provisioning.DeploySubscriptionLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployManagementGroupLevelTemplateOptions = Provisioning.DeployManagementGroupLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTenantLevelTemplateOptions = Provisioning.DeployTenantLevelTemplateOptions;
            /**
             * Options for the DeployCustom method on provisioning context
             */
            export import DeployCustomOptions = Provisioning.DeployCustomOptions;
            /**
             * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
             */
            export import TemplateDeploymentMode = Provisioning.TemplateDeploymentMode;
            /**
             * Parameters passed to the arm errors blade. See 'getArmErrorsBladeReference'.
             */
            export import ArmErrorsBladeParameters = FxBladeBase.DoesProvisioning.ArmErrorsBladeParameters;
            /**
             * Troubleshooting links for the arm errors blade
             */
            export import TroubleshootingLinks = FxBladeBase.DoesProvisioning.TroubleshootingLinks;
        }
        module LegacyFeatures {
            /**
             * The @LegacyFeatures decorator.  Used to access legacy features for Blades, like defining an explicit Blade width.
             *
             * @param options Options used to configure the @LegacyFeatures decorator.
             */
            function Decorator(options: Options): (bladeClass: BladeClass) => void;
            /**
             * Options supplied to the @LegacyFeatures decorator.
             */
            interface Options {
                /**
                 * The width for this Blade.
                 */
                width?: Width;
            }
            /**
             * The available widths for the Blade.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        module ForContextPane {
            /**
             * The @ForContextPane decorator.  Used to configure the behavior of the Blade when it is opened in the ContextPane.
             *
             * @param options Options used to configure the @ForContextPane decorator.
             */
            function Decorator(options: Options): (bladeClass: BladeClass) => void;
            /**
             * Options supplied to the @ForContextPane decorator.
             */
            interface Options {
                /**
                 * The width of the Blade when it is opened in the ContextPane.
                 */
                width?: Width;
            }
            /**
             * The available widths for the ContextPane.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        /**
         * A decorator used to specify a Blade that will be replaced by this Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: BladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a Blade class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the Blade's view."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
    }
}

// FILE: Fx\Composition\BladeBase.d.ts
declare module "Fx/Composition/BladeBase" {
    import { ClickableLink } from "Fx/Composition";
    import { ItemType } from "Fx/Composition/ItemType";
    import { Container as PdlBladeContainer } from "Fx/Composition/Pdl/Blade";
    import { Context as MarketplaceContext } from "Fx/ResourceManagement/Marketplace";
    import { InitialValues, DeployTemplateOptions, AllDeployTemplateOptions, DeployCustomOptions, DeployTemplateResults } from "Fx/ResourceManagement/Provisioning";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import { PdlBladeReference } from "Fx/Composition/Selectable";
    import * as Toolbar from "Fx/Controls/Toolbar";
    export = Main;
    module Main {
        import FxConfiguration = MsPortalFx.Composition.Configuration;
        import FxToolbars = MsPortalFx.ViewModels.Toolbars;
        /**
         * The class type to which the various Blade decorators can be applied.
         */
        interface BladeClass extends FxViewModelBase.ViewModelClass<any> {
            _fx?: {
                itemType?: ItemType;
                options?: Options;
                ownsEditScope?: boolean;
                rebindable?: boolean;
                parameterProvider?: boolean;
                doesProvisioning?: boolean;
                configurableOptions?: FxViewModelBase.Configurable.Options;
            };
        }
        /**
         * A common interface type for various Blade view model classes.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxViewModelBase.Contract<TParameters, TModel> {
            /**
             * The displayed title of the Blade.
             * Supply 'null' if no title is desired for the Blade.
             */
            title: string | KnockoutObservableBase<string>;
            /**
             * The displayed subtitle of the Blade.
             * Supply 'null' if no subtitle is desired for the Blade.
             */
            subtitle: string | KnockoutObservableBase<string>;
        }
        /**
         * Status bar for a Blade.
         */
        interface StatusBar {
            /**
             * The text to display in the Blade's status bar.
             */
            text: string;
            /**
             * Optional callback called by the FX when the status bar is clicked.
             */
            onClick?: (() => void) | ClickableLink;
        }
        /**
         * Specifies which content state decoration should be applied to a Blade.
         */
        export import ContentState = MsPortalFx.ViewModels.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxViewModelBase.Context<TParameters, TModel> {
            /**
             * An API a Blade can use to interact with its host MenuBlade (if applicable).
             */
            menu: MenuBladeManagement;
            /**
             * An API a Blade can use to interact with the Form Fields on the Blade.
             */
            form: FormManagement;
        }
        /**
         * Represents a container object that can be used to control the chrome of the Blade.
         */
        interface Container extends FxViewModelBase.Container {
            /**
             * Supplies the Blade's icon.
             * Any non-null value supplied here will override the image inferred from this Blade's 'forAsset' option (if supplied).
             */
            icon: KnockoutObservable<MsPortalFx.Base.Image>;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = MsPortalFx.ViewModels.BladeLocation;
        /**
         * Represents a container object that can be used to specify the CommandBar of the Blade.
         */
        interface CanHaveCommandBarContainer {
            /**
             * The command bar of the Blade.  If required, must be set before 'container.revealContent' is called and before the
             * Promise returned from 'onInitialized' is resolved.
             */
            commandBar: FxToolbars.Toolbar | Toolbar.Contract;
        }
        /**
         * Represents a container object that exposes an observable size of the content area.
         */
        interface ExposesContentSize {
            /**
             * The width and height of the content area of the blade, in pixels.
             */
            contentSize: KnockoutObservable<{
                height: number;
                width: number;
            }>;
        }
        /**
         * Options passed to the various Blade decorators.
         */
        interface Options extends FxViewModelBase.Options {
            /**
             * Specifies whether the Blade is pinnable.  Defaults to 'true'.
             */
            isPinnable?: boolean;
        }
        /**
         * Shared by decorator options of @Blade/@TemplateBlade/@FrameBlade
         */
        interface ShrinkOnOpenChildBladeOptions {
            /**
             * Specifies whether the Blade shrinks to the small width on open child blade.
             */
            shrinkOnOpenChildBlade?: boolean;
        }
        interface ReflowReadyOption {
            /**
             * Specifies whether the content is compliant with {@link https://www.w3.org/WAI/WCAG21/Understanding/reflow.html WCAG2.1 criterion 1.4.10 Reflow}
             * Compliant content is designed to be responsive and can be rendered in a resolution as low as 320px width by 256px height in the portal.
             */
            reflowReady?: boolean;
        }
        module Rebindable {
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxViewModelBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Blade's settings.
             */
            type Options = FxViewModelBase.Configurable.Options;
            /**
             * Metadata describing one setting of the Blade's persisted settings.
             */
            type SettingMetadata = FxViewModelBase.Configurable.SettingMetadata;
            /**
             * The scope at which the Blade's settings are persisted.
             */
            export import SettingsScope = FxViewModelBase.Configurable.SettingsScope;
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the Blades's
             * configuration API) as well as 'settings' (the Blade's persisted settings values).
             */
            type Context<TSettings> = FxViewModelBase.Configurable.Context<TSettings>;
            /**
             * The Blade's configuration API returned from 'context.configuration'.
             */
            type Configuration<TSettings> = FxConfiguration.Blade.Contract<TSettings>;
        }
        module ReturnsData {
            /**
             * Represents a container object that can be used to control the chrome of the Blade.
             */
            interface Container<TData> {
                /**
                 * Closes the Blade, returning 'data' to the parent Blade/Part.
                 *
                 * @param data The data to return to the parent Blade/Part.
                 * @return A promise indicating if the Blade was successfully closed.
                 */
                closeCurrentBlade(data: TData): Q.Promise<boolean>;
            }
        }
        module DoesProvisioning {
            /**
             * Troubleshooting links for the arm errors blade
             */
            export import TroubleshootingLinks = Common.Provisioning.TroubleshootingLinks;
            /**
             * The input parameters for the arm errors blade.
             */
            export import ArmErrorsBladeParameters = Common.Provisioning.ArmErrorsBladeParameters;
            /**
             * The view model's provisioning API, with which the view model can provision async
             * operations, such as creates and deployments, (and logs the necessary telemetry).
             */
            interface Provisioning<TUIMetadata> extends MarketplaceContext<TUIMetadata> {
                /**
                 * Initial values for form initialization. Use those values to initialize the subscription,
                 * resource group, and location drop down controls.
                 */
                readonly initialValues: InitialValues;
                /**
                 * Validates an ARM template and returns a promise for the validation result.
                 * @param options Template deployment options
                 */
                validateTemplate<TOptions extends AllDeployTemplateOptions = DeployTemplateOptions>(options: TOptions): Q.Promise<TOptions>;
                /**
                 * Deploy a template to ARM and receive a promise for a deployment result
                 * @param options Template deployment options
                 */
                deployTemplate<TOptions extends AllDeployTemplateOptions = DeployTemplateOptions>(options: TOptions): Q.Promise<DeployTemplateResults<TOptions>>;
                /**
                 * Get a blade reference to the template viewer blade
                 * @param options Template deployment options
                 */
                getAutomationBladeReference<TOptions extends AllDeployTemplateOptions = DeployTemplateOptions>(options: TOptions): PdlBladeReference<any, void>;
                /**
                 * Get a blade reference to the Arm Errors blade
                 * @param bladeParameters Parameters passed to the arm errors blade
                 */
                getArmErrorsBladeReference(bladeParameters: ArmErrorsBladeParameters): PdlBladeReference<any, void>;
                /**
                 * Deploy a template to ARM and receive a promise for a deployment result
                 * @param options Custom deployment options
                 */
                deployCustom<TResult>(options: DeployCustomOptions<TResult>): Q.Promise<TResult>;
            }
        }
        /**
         * An API available as 'context.form' that a Blade can use to interact with the Form Fields on the Blade.
         */
        type FormManagement = MsPortalFx.ViewModels.FormProperties;
        /**
         * Describes if/when to display an alert when the blade closes.
         */
        export import AlertLevel = MsPortalFx.ViewModels.AlertLevel;
        /**
         * An API available as 'context.menu' that a Blade can use to interact with its host MenuBlade (if applicable).
         */
        interface MenuBladeManagement extends MsPortalFx.ViewModels.MenuBladeManagement {
            /**
             * A suffix applied to the title of the MenuBlade.
             */
            titleSuffix: KnockoutObservable<string>;
            /**
             * A suffix applied to the subtitle of the MenuBlade.
             */
            subtitleSuffix: KnockoutObservable<string>;
        }
        /**.
         * The blade 'Container' API for all variations of blades. It's through this API that extensions
         * can interact with the blade's chrome UI.
         */
        type AnyBladeContainer = Container | PdlBladeContainer;
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            interface Options {
                /**
                 * The old blade that is to be replaced
                 */
                replacedBlade: string;
                /**
                 * The extension which the old blade belongs to
                 */
                extension?: string;
            }
        }
    }
}

// FILE: Fx\Composition\ButtonPart.d.ts
declare module "Fx/Composition/ButtonPart" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as FxPartBase from "Fx/Composition/PartBase";
    export = MsPortalFxButtonPart;
    module MsPortalFxButtonPart {
        /**
         * The @ButtonPart decorator.  Identifies a class within the extension as a ButtonPart view model class.
         *
         * @options Metadata describing the ButtonPart and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (partClass: ButtonPartClass) => void;
        /**
         * Constrains the @ButtonPart decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface ButtonPartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @ButtonPart decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> {
            /**
             * The title of the part.
             */
            title: string | KnockoutObservableBase<string>;
            /**
             * A shorter title of the part (for size: mini).
             */
            shortTitle: string | KnockoutObservableBase<string>;
            /**
             * The displayed subtitle for this Part, typically the Asset name for the asset/resource associated with this Part.
             * Supply 'null' if no subtitle is desired for the Part.
             */
            subtitle: string | KnockoutObservableBase<string>;
            /**
             * A description for the part.
             */
            description: string | KnockoutObservableBase<string>;
            /**
             * An icon for the the part.
             */
            icon: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
            /**
             * Called by the FX to initialize this ButtonPart.
             *
             * @return A promise that should be resolved by the ButtonPart when: (1) all the data is loaded for this view model and (2) the
             * ButtonPart state is updated to reflect the loaded data.
             */
            onInitialize(): Q.Promise<any> | Promise<any>;
            /**
             * Describes the behavior of the ButtonPart when it is clicked by the user.
             * Supply 'null' if the Part is not clickable.
             */
            onClick: (() => void) | FxComposition.ClickableLink;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the ButtonPart.
             */
            container: Container;
        }
        /**
         * Represents a container object that can be used to control the chrome of the ButtonPart.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the ButtonPart.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed ButtonPart size information.
             * The ButtonPart class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this ButtonPart (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed ButtonPart size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined ButtonPart sizes, including 'Custom' if the ButtonPart is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this ButtonPart (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @ButtonPart decorator.  Includes metadata describing the ButtonPart and how it will be treated by
         * the FX.
         */
        interface Options extends FxViewModelBase.Options {
            /**
             * The initial size with which the ButtonPart will be rendered.
             */
            initialSize?: Size.Mini | Size.Small | Size.Normal | Size.Wide;
            /**
             * Metadata describing the parameters passed to this Part.
             */
            parameterMetadata?: {
                [key: string]: ParameterMetadata;
            };
            /**
             * Metadata that describes this Part in the Part Gallery.
             */
            galleryMetadata?: FxPartBase.GalleryMetadata;
            /**
             * Ensure the Part's 'onClick' method is always called when such a Part is clicked.
             * This overrides intrinsic FX behavior for Parts pinned from MenuBlades, where 'onClick' is not called and, rather,
             * a deep link is utilized to open the MenuBlade.
             */
            ignorePinnedDeepLink?: boolean;
        }
        /**
         * The available sizes for the ButtonPart.
         */
        export import Size = FxPartBase.Size;
        /**
         * Metadata describing a parameter passed to this ButtonPart.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the ButtonPart view model such that it implements an 'onRebind' method that will be
             * called when the ButtonPart's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the ButtonPart is bound.
             *
             * When this decorator is not used, whenever parameters change value, the ButtonPart view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * ButtonPart replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: ButtonPartClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\DashboardFilters.d.ts
declare module "Fx/Composition/DashboardFilters" {
    export = MsPortalFxDashboardFilters;
    module MsPortalFxDashboardFilters {
        namespace TimeRangeFilter {
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             */
            interface FilterModel {
                /**
                 * An absolute time range.
                 */
                absolute?: {
                    /**
                     * The start of the time range.
                     */
                    fromDate: Date;
                    /**
                     * The end of the time range.
                     */
                    toDate: Date;
                };
                /**
                 * A relative time range.
                 */
                relative?: {
                    /**
                     * The duration for the relative time range.
                     */
                    duration: number;
                    /**
                     * The time unit for the duration of the relative time range.
                     */
                    timeUnit: TimeUnit;
                };
                /**
                 * The time standard for the provided time range.
                 */
                format?: DateTimeKind;
                /**
                 * The time granularity for the provided time range.
                 */
                granularity?: TimeGranularity;
            }
            /**
             * Values represent units of time.  Used in FilterModel above.
             */
            const enum TimeUnit {
                Minute = 0,
                Hour = 1,
                Day = 2,
                Week = 3
            }
            /**
             * Values represent time zone formats.  Used in FilterModel above.
             */
            const enum DateTimeKind {
                UTC = 0,
                Local = 1
            }
            /**
             * Values represent time granularity units.  Used in FilterModel above.
             */
            const enum TimeGranularity {
                Automatic = 0,
                OneMinute = 1,
                FiveMinutes = 2,
                FifteenMinutes = 3,
                ThirtyMinutes = 4,
                OneHour = 5,
                SixHours = 6,
                TwelveHours = 7,
                OneDay = 8,
                OneWeek = 9,
                OneMonth = 10
            }
            /**
             * The filter id of the TimeRange filter.
             */
            const filterId = "MsPortalFx_TimeRange";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_TimeRange: FilterModel;
            }
        }
        /**
         * An abstract class representing an extension-defined filter, one supported by a particular Part.
         * Each supported FX filter variant will have a 'createDefinition' factory function that returns a FilterDefinition.
         * A Part returns FilterDefinitions covering its supported filters from its 'getFilterDefinitions' and 'getDynamicFilterDefinitions'
         * methods.
         */
        class FilterDefinition {
        }
        /**
         * Identifies a specific localizable filter value.
         */
        interface LocalizableFilterValue {
            /**
             * Identifies a specific localizable filter value.  Part's return localized display text for such a value by implementing
             * a 'getLocalizedFilterValues' method.
             */
            valueId: string;
        }
        /**
         * A discrete value the user can pick in the filter UI.
         */
        type FilterValue = string | LocalizableFilterValue;
        namespace EqualityFilter {
            /**
             * Operators supported by the equality filter.
             */
            const enum Operator {
                Equals = 0,
                NotEquals = 1,
                Contains = 2,
                NotContains = 3,
                StartsWith = 4,
                NotStartsWith = 5,
                EndsWith = 6,
                NotEndsWith = 7
            }
            /**
             * Type alias for equality operators.
             */
            type EqualityOperator = Operator.Equals | Operator.NotEquals;
            /**
             * Type alias for substring operators.
             */
            type SubstringOperator = Operator.Contains | Operator.NotContains | Operator.StartsWith | Operator.NotStartsWith | Operator.EndsWith | Operator.NotEndsWith;
            /**
             * A discrete value the user can pick in the equality filter UI.
             */
            type FilterValue = MsPortalFxDashboardFilters.FilterValue;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of filter values selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                values?: FilterValue[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityOperator;
                values: FilterValue[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), identifying and configuring an extension-declared equality filter.
             */
            interface Options {
                /**
                 * The id of the extension-declared filter.  For extensions to jointly participate in a filter (for instance, to each supply
                 * distinct filter values), this id must be the same across the extensions.
                 */
                filterId: string;
                /**
                 * Display text for this filter.
                 */
                displayText: string;
                /**
                 * A callback called when the user changes the filter text in the equality filter UI.  In response, the Part should
                 * return a set of filter values, where each value matches 'filterText'.
                 *
                 * @param filterText User input from the equality filter text box.
                 * @return An array or Promise resolving with an array of filter values, where each value matches 'filterText'.
                 */
                getFilterValues(filterText: string): FilterValue[] | Q.Promise<FilterValue[]>;
                /**
                 * The filter's supported operators.
                 * If not provided, Equals and NotEquals operators will be supported by default.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates an equality filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @return The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
        }
        /**
         * A type describing any filter model.  The filter's kind or id should be used to choose a corresponding filter model type to which to cast.
         */
        type AnyFilterModel = EqualityFilter.FilterModel | TimeRangeFilter.FilterModel | SubscriptionFilter.FilterModel | LocationFilter.FilterModel | ResourceGroupFilter.FilterModel | ResourceTypeFilter.FilterModel;
        /**
         * Part 'TFilterModels' interface types will inherit this interface type when they support dynamic filters (those filters not known at
         * compile-time).  In the Part's 'onInitialize' and 'onRebind' methods, it will reason over filter models for dynamic filters
         * according to this interface type.
         */
        interface DynamicFilterModels {
            /**
             * The filter {id, model}-pairs for dynamic filters.
             */
            [dynamicFilterId: string]: AnyFilterModel;
        }
        /**
         * A localized filter value returned from a Part's 'getLocalizedFilterValues' method.
         */
        interface LocalizedFilterValue {
            /**
             * The value id.
             */
            valueId: string;
            /**
             * The localized filter value.
             */
            value: string;
        }
        /**
         * A dynamic filter definition returned from a Part's 'getDynamicFilterDefinitions'.
         */
        interface DynamicFilterDefinition {
            /**
             * The filter definition.
             */
            definition: FilterDefinition;
            /**
             * Specifies whether telemetry should be logged for this filter.  Defaults to 'false' if not supplied.
             * Telemetry should only be logged if the filter (its filter id, for instance) doesn't include any sensitive user information.
             */
            logTelemetry?: boolean;
        }
        namespace SubscriptionFilter {
            /**
             * Operators supported by the subscription filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of subscription ids selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                subscriptionIds?: string[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                subscriptionIds: string[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard subscription filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of subscriptions from which the user can pick, reflecting those subscriptions supported
                 * by the associated Part.
                 *
                 * @return An array or Promise resolving with an array of supported subscription ids.
                 */
                getSubscriptionIds(): string[] | Q.Promise<string[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a subscription filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @return The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the subscription filter.
             */
            const filterId = "MsPortalFx_Subscription";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_Subscription: FilterModel;
            }
        }
        namespace LocationFilter {
            /**
             * Operators supported by the location filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * A location known to the Portal/ARM for which locale-specific text can be mapped to by the FX.
             */
            interface KnownLocation {
                /**
                 * The non-localized location name.
                 */
                name: string;
            }
            /**
             * A discrete location value the user can pick in the location filter UI.
             */
            type Location = KnownLocation | MsPortalFxDashboardFilters.FilterValue;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of locations selected by the user from a list.  Supplied only when 'operator' is Operator.Equals and Operator.NotEquals.
                 */
                locations?: Location[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                locations: Location[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard location filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of locations from which the user can pick, reflecting those locations supported
                 * by the associated Part.
                 *
                 * @param filterText User input from the location filter text box.
                 * @return An array or Promise resolving with an array of supported locations ids.
                 */
                getLocations(filterText: string): Location[] | Q.Promise<Location[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a location filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @return The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the location filter.
             */
            const filterId = "MsPortalFx_Location";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_Location: FilterModel;
            }
        }
        namespace ResourceGroupFilter {
            /**
             * Operators supported by the resource groups filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of resource group ids selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                resourceGroupIds?: string[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                resourceGroupIds: string[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard resource groups filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of resource groups from which the user can pick, reflecting those resource groups supported
                 * by the associated Part.
                 *
                 * @return An array or Promise resolving with an array of supported resource group ids.
                 */
                getResourceGroupIds(): string[] | Q.Promise<string[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a resource groups filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @return The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the resource groups filter.
             */
            const filterId = "MsPortalFx_ResourceGroup";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_ResourceGroup: FilterModel;
            }
        }
        namespace ResourceTypeFilter {
            /**
             * Operators supported by the resource types filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * A discrete resource type value the user can pick in the resource types filter UI.
             */
            interface ResourceType {
                /**
                 * The name of the resource type, used to locate <ResourceType> metadata defined on some <AssetType>.
                 */
                resourceType: string;
                /**
                 * An optional resource kind, used to locate <ResourceKind> metadata around the <ResourceType> named by 'resourceType'.
                 */
                resourceKind?: string;
            }
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of resource types selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                resourceTypes?: ResourceType[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                resourceTypes: ResourceType[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard resource types filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of resource types from which the user can pick, reflecting those resource types supported
                 * by the associated Part.
                 *
                 * @return An array or Promise resolving with an array of supported resource types.
                 */
                getResourceTypes(): ResourceType[] | Q.Promise<ResourceType[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a resource types filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @return The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the resource types filter.
             */
            const filterId = "MsPortalFx_ResourceType";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_ResourceType: FilterModel;
            }
        }
    }
}

// FILE: Fx\Composition\DataContext.d.ts
declare module "Fx/Composition/DataContext" {
    export = MsPortalFxDataContext;
    module MsPortalFxDataContext {
        /**
         * The @DataContext decorator.  Identifies a class within the extension as the DataContext class for a certain extension area.
         * The DataContext class loads and caches data for the area's contained Blades and Parts.
         *
         * @options Options supplied to the decorator, including the area for which the DataContext loads/caches data.
         */
        function Decorator(options?: Options): (dataContextClass: Function) => void;
        /**
         * Options supplied to the @DataContext decorator.
         */
        interface Options {
            /**
             * The extension area for which the DataContext loads and caches data for the area's contained Blades and Parts.
             */
            area: string;
        }
    }
}

// FILE: Fx\Composition\Dialog.d.ts
declare module "Fx/Composition/Dialog" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { FxElement } from "Fx/Events";
    /**
     * Standard button sets that can be displayed in a dialog.
     */
    export const enum DialogButtons {
        /**
         * The message box contains Abort, Retry and Ignore buttons.
         */
        AbortRetryIgnore = 0,
        /**
         * The message box contains an OK button.
         */
        OK = 1,
        Ok = 1,
        /**
         * The message box contains OK and Cancel buttons.
         */
        OKCancel = 2,
        /**
         * The message box contains Retry and Cancel buttons.
         */
        RetryCancel = 3,
        /**
         * The message box contains Yes and No buttons.
         */
        YesNo = 4,
        /**
         * The message box contains Yes, No and Cancel buttons.
         */
        YesNoCancel = 5
    }
    /**
     * Button identifiers.
     */
    export const enum DialogButton {
        /**
         * The abort button.
         */
        Abort = 0,
        /**
         * The cancel button.
         */
        Cancel = 1,
        /**
         * The ignore button.
         */
        Ignore = 2,
        /**
         * The no button.
         */
        No = 3,
        /**
         * The ok button.
         */
        Ok = 4,
        /**
         * The retry button.
         */
        Retry = 5,
        /**
         * The yes button.
         */
        Yes = 6
    }
    /**
     * Describes a custom button in a dialog.
     */
    export interface CustomDialogButton {
        /**
         * Optional display text of the button
         * If not specified, a default display text value will be used.
         */
        displayText?: string;
        /**
         * Button identifier that is programatically passed back.
         */
        button: DialogButton;
        /**
         * If set to the true the button is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    /**
     * The result returned after a dialog was closed.
     */
    export interface DialogResult {
        /**
         * The result returned from the dialog.
         */
        button: DialogButton;
    }
    /**
     * Describes preferred strategies to position a dialog.
     */
    export const enum DialogPosition {
        /**
         * The dialog will open above the reference element, aligned to its left edge.
         * The dialog pointer will be located at the bottom left pointing downward.
         */
        TopLeftEdge = 1,
        /**
         * The dialog will open to the right of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top left pointing leftward.
         */
        RightTopEdge = 2,
        /**
         * The dialog will open below the reference element, aligned to its left edge.
         * The dialog pointer will be located at the top left pointing upward.
         */
        BottomLeftEdge = 3,
        /**
         * The dialog will open to the left of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top right pointing rightward.
         */
        LeftTopEdge = 4,
        /**
         * The dialog will open above the reference element, aligned to its right edge.
         * The dialog pointer will be located at the bottom right pointing downward.
         */
        TopRightEdge = 5,
        /**
         * The dialog will open below the reference element, aligned to its right edge.
         * The dialog pointer will be located at the top right pointing upward.
         */
        BottomRightEdge = 6
    }
    /**
     * Options supplied when opening a dialog
     */
    export interface BaseDialogOptions {
        /**
         * Name used in telemetry
         */
        telemetryName: string;
        /**
         * Dialog title
         *
         * If hideTitle is set the title value will still be used for the dialog's accessible name.
         */
        title: string;
        /**
         * Dialog content
         *
         * The dialog content can be a string message to display or an HTML template / view model pair.
         */
        content: string | HtmlContent;
        /**
         * Buttons can be either standard buttons provided by the framework or
         * this can be custom buttons with labels provided by the extension
         */
        buttons: DialogButtons | CustomDialogButton[];
        /**
         * Default button is the button which has focus if custom buttons was specified.
         * This property is not applicable when standard buttons are specified.
         */
        defaultButton?: DialogButton;
        /**
         * Optional callback that is invoked when the dialog is closed.
         * Dialogs are closed when the user clicks on one of the buttons or
         * clicks anywhere on the screen outside of the dialog. If the user clicks
         * somewhere else in the portal the cancel button or equivalent is passed to this callback.
         */
        onClosed?: (result: DialogResult) => void;
        /**
         * Indicator to hide dialog title.
         */
        hideTitle?: boolean;
        /**
         * Makes the dialog render as modal within its context. When modal, user input is required for dismissal and user interaction is suppressed within the context of the dialog.
         *
         * Only the blade dialog context supports a modal rendering. Modal rendering isn't compatible with DialogOptions target parameter.
         */
        modal?: boolean;
        /**
         * Dialog reference populated by the runtime that offers fine control of the lifetime of the dialog.
         * This is useful for very specific scenarios, mostly where an asynchronous operation is needed before closing the dialog.
         * Doing so requires to build a fully custom dialog content.
         */
        dialogRef?: DialogRef;
    }
    /**
     * Options supplied when opening a dialog that supports targeting
     */
    export interface DialogOptions extends BaseDialogOptions {
        /**
         * The target which is used to position the dialog.
         * This is a class name or a reference to a DOM element.
         */
        target?: string | FxElement;
        /**
         * Hint where to position the dialog relative to the target.
         * Defaults to BottomLeftEdge.
         */
        positionHint?: DialogPosition;
    }
    /**
     * Methods for managing dialogs which don't support targeting
     */
    export interface BaseDialogManagement {
        /**
         * Opens a new dialog.
         *
         * @param options Describes the dialog that is to be opened.
         * @returns Promise that is resolved when the dialog is successfully opened.
         */
        openDialog(options: BaseDialogOptions): Q.Promise<boolean>;
    }
    /**
     * Methods for managing dialogs
     */
    export interface DialogManagement {
        /**
         * Opens a new dialog.
         *
         * @param options Describes the dialog that is to be opened.
         * @returns Promise that is resolved when the dialog is successfully opened.
         */
        openDialog(options: DialogOptions): Q.Promise<boolean>;
    }
    /**
     * Provides an interface to control a dialog reference.
     */
    export interface DialogRef {
        /**
         * The dialog instance.
         */
        value: {
            /**
             * Close the dialog with the provided result.
             *
             * @param result The DialogResult that is passed to the onClosed callback and logged to telemetry.
             */
            close: (result: DialogResult) => void;
        };
    }
    /**
     * Creates a DialogRef instance to be used as a value for the dialogRef parameter in DialogOptions.
     * @returns A DialogRef instance.
     */
    export function createDialogRef(): DialogRef;
}

// FILE: Fx\Composition\FrameBlade.d.ts
declare module "Fx/Composition/FrameBlade" {
    import * as FxComposition from "Fx/Composition";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import { BaseDialogManagement } from "Fx/Composition/Dialog";
    import * as FxFramePart from "Fx/Composition/FramePart";
    import * as Provisioning from "Fx/ResourceManagement/Provisioning";
    import { PostProvisioningOptions, PostProvisioningContent } from "Fx/ResourceManagement/Deployments";
    export = MsPortalFxFrameBlade;
    module MsPortalFxFrameBlade {
        import PartReference = MsPortalFx.Composition.PartReference;
        /**
         * The @FrameBlade decorator.  Identifies a class within the extension as a FrameBlade view model class.
         *
         * @options Metadata describing the FrameBlade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (bladeClass: FrameBladeClass) => void;
        /**
         * Constrains the @FrameBlade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface FrameBladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @FrameBlade decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * The FrameBlade view model.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             *
             * ViewModelV2Contract is preferred since this API is consistent across FrameBlade, FramePart and FrameControl.
             */
            viewModel: ViewModel | ViewModelV2Contract;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a FrameBlade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the FrameBlade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a FrameBlade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the FrameBlade.
             */
            container: Container;
        }
        /**
         * Options supplied to the @FrameBlade decorator.  Includes metadata describing the FrameBlade and how it will be treated by
         * the FX.
         */
        interface Options extends FxBladeBase.Options, FxBladeBase.ShrinkOnOpenChildBladeOptions, FxBladeBase.ReflowReadyOption {
        }
        /**
         * Represents a container object that can be used to control the chrome of the FrameBlade.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the FrameBlade.
         */
        interface Container extends FxBladeBase.Container, FxBladeBase.CanHaveCommandBarContainer, FxBladeBase.ExposesContentSize, BaseDialogManagement {
            /**
             * The location where the FrameBlade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the FrameBlade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the FrameBlade view model such that it implements an 'onRebind' method that will be
             * called when the FrameBlade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the FrameBlade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its persisted 'settings' values.  The 'settings'
             * values are made available in the view model's 'context', for use in the view model's 'onInitialize' and optional 'onRebind'
             * methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the FrameBlade's settings.
             */
            type Options = FxBladeBase.Configurable.Options;
            /**
             * Metadata describing one setting of the FrameBlade's persisted settings.
             */
            type SettingMetadata = FxBladeBase.Configurable.SettingMetadata;
            /**
             * The scope at which the FrameBlade's settings are persisted.
             */
            export import SettingsScope = FxBladeBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FrameBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FrameBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include 'configuration' (the FrameBlade's configuration
                 * API) as well as 'settings' (the FrameBlade's persisted settings values).
                 */
                context: Context<TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the FrameBlade's configuration API),
             * the 'parameters' of the FrameBlade, as well as its persisted 'settings' values.
             */
            interface Context<TSettings> extends FxBladeBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its settings.
                 */
                configuration: Configuration<TSettings>;
            }
            /**
             * The FrameBlade's configuration API returned from 'context.configuration'.
             */
            type Configuration<TSettings> = FxBladeBase.Configurable.Configuration<TSettings>;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * FrameBlade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the FrameBlade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        module Pinnable {
            /**
             * The @Pinnable decorator.  Requires that the FrameBlade implement an 'onPin' method that determines what Part
             * to pin when the user pins the FrameBlade.
             */
            function Decorator(): (pinnableClass: PinnableClass) => void;
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface PinnableClass {
                new (...args: any[]): Contract;
            }
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract {
                /**
                 * A callback that will be called when the user pins the FrameBlade.  Returns a PartReference to the Part that will be pinned to the
                 * user's Dashboard.
                 */
                onPin(): PartReference<any>;
            }
        }
        module DoesProvisioning {
            /**
             * The @DoesProvisioning decorator. Adds a strongly-typed 'context.provisioning' to the TemplateBlade.
             * This provisioning API allows the view model to perform provisioning operations, including support
             * for telemetry around provisioning.
             *
             * @param options Options used to configure the @DoesProvisioning decorator.
             */
            function Decorator<TOptions extends Options>(options?: TOptions): (doesProvisioningClass: TOptions["supportsPostProvisioning"] extends true ? DoesProvisioningAndPostProvisioningClass : DoesProvisioningClass) => void;
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningClass {
                new (...args: any[]): Contract;
                _fx?: {
                    doesProvisioning?: boolean;
                };
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningAndPostProvisioningClass extends DoesProvisioningClass {
                /**
                 * A static function which returns a viewmodel used to customize the content on the blade launched after submitting a provisioning request.
                 * @param lifetime The lifetime of the content returned.
                 * @param options The options for fetching content relevant to the provisioning request.
                 */
                createPostProvisioningContent(lifetime: MsPortalFx.Base.LifetimeManager, options: PostProvisioningOptions): Q.Promise<PostProvisioningContent> | Promise<PostProvisioningContent>;
            }
            /**
             * Options supplied to the @DoesProvisioning decorator.
             */
            interface Options {
                /**
                 * A flag indicating whether the caller is required to supply a Marketplace item id
                 * when instantiating a BladeReference to this TemplateBlade. Defaults to true.
                 */
                requiresMarketplaceId?: boolean;
                /**
                 * A flag indicating that the create blade's class exposes the createPostProvisioningContent function.
                 */
                supportsPostProvisioning?: true;
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes
             * implementing 'Contract'.
             */
            interface Contract {
                /**
                 * Context injected by the FX into the view model. This context should be used within
                 * the view model's 'onInitialize' and optional 'onRebind' methods.
                 */
                context: Context<any>;
            }
            /**
             * Context injected by the FX into the view model. This context should be used within the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             */
            interface Context<TUIMetadata = void> {
                /**
                 * The view model's provisioning API, with which the view model can
                 * perform provisioning operations, including support for telemetry
                 * around provisioning.
                 */
                provisioning: FxBladeBase.DoesProvisioning.Provisioning<TUIMetadata>;
            }
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTemplateOptions = Provisioning.DeployTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeploySubscriptionLevelTemplateOptions = Provisioning.DeploySubscriptionLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployManagementGroupLevelTemplateOptions = Provisioning.DeployManagementGroupLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTenantLevelTemplateOptions = Provisioning.DeployTenantLevelTemplateOptions;
            /**
             * Options for the DeployCustom method on provisioning context
             */
            export import DeployCustomOptions = Provisioning.DeployCustomOptions;
            /**
             * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
             */
            export import TemplateDeploymentMode = Provisioning.TemplateDeploymentMode;
            /**
             * Parameters passed to the arm errors blade. See 'getArmErrorsBladeReference'.
             */
            export import ArmErrorsBladeParameters = FxBladeBase.DoesProvisioning.ArmErrorsBladeParameters;
            /**
             * Troubleshooting links for the arm errors blade
             */
            export import TroubleshootingLinks = FxBladeBase.DoesProvisioning.TroubleshootingLinks;
        }
        module LegacyFeatures {
            /**
             * The @LegacyFeatures decorator.  Used to access legacy features for FrameBlades, like defining an explicit FrameBlade width.
             *
             * @param options Options used to configure the @LegacyFeatures decorator.
             */
            function Decorator(options: Options): (bladeClass: FrameBladeClass) => void;
            /**
             * Options supplied to the @LegacyFeatures decorator.
             */
            interface Options {
                /**
                 * The width for this FrameBlade.
                 */
                width?: Width;
            }
            /**
             * The available widths for the FrameBlade.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        module ForContextPane {
            /**
             * The @ForContextPane decorator.  Used to configure the behavior of the FrameBlade when it is opened in the ContextPane.
             *
             * @param options Options used to configure the @ForContextPane decorator.
             */
            function Decorator(options: Options): (bladeClass: FrameBladeClass) => void;
            /**
             * Options supplied to the @ForContextPane decorator.
             */
            interface Options {
                /**
                 * The width of the FrameBlade when it is opened in the ContextPane.
                 */
                width?: Width;
            }
            /**
             * The available widths for the ContextPane.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        /**
         * Options used to configure the FrameBlade view model.
         */
        export import ViewModelOptions = FxFramePart.ViewModelOptions;
        /**
         * V2 options used to configure the FrameBlade view model.
         */
        export import ViewModelV2Options = FxFramePart.ViewModelV2Options;
        /**
         * ViewModelV2Contract is the latest frame API where messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
         */
        export import ViewModelV2Contract = FxFramePart.ViewModelV2Contract;
        /**
         * Defines the signature for a message handler.
         */
        export import MessageHandler = FxFramePart.MessageHandler;
        /**
         * The view model of the FrameBlade.
         */
        class ViewModel extends FxFramePart.ViewModel {
            /**
             * Creates the view model for a FrameBlade
             *
             * @param container The container for this FrameBlade.
             * @param options Options for the FrameBlade view model.
             */
            constructor(container: Container, options: ViewModelOptions);
        }
        /**
         * Creates the V2 view model for a FrameBlade.
         * With V2 view model, messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
         *
         * @param container The container for this FrameBlade.
         * @param options V2 options for the FrameBlade view model.
         */
        function createViewModel(container: Container, options: ViewModelV2Options): ViewModelV2Contract;
        /**
         * A decorator used to specify a Blade that will be replaced by this Frame Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: FrameBladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\FramePart.d.ts
declare module "Fx/Composition/FramePart" {
    import * as FxComposition from "Fx/Composition";
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    import * as FxPartBase from "Fx/Composition/PartBase";
    export = MsPortalFxFramePart;
    module MsPortalFxFramePart {
        /**
         * The @FramePart decorator.  Identifies a class within the extension as a FramePart view model class.
         *
         * @options Metadata describing the FramePart and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (partClass: FramePartClass) => void;
        /**
         * Constrains the @FramePart decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface FramePartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @FramePart decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxPartBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this FramePart.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             *
             * ViewModelV2Contract is preferred since this API is consistent across FrameBlade, FramePart and FrameControl.
             */
            viewModel: ViewModel | ViewModelV2Contract;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the FramePart.
             */
            container: Container;
        }
        /**
         * Represents a container object that can be used to control the chrome of the FramePart.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the FramePart.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed Part size information.
             * The FramePart class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this FramePart (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed Part size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined Part sizes, including 'Custom' if the FramePart is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this FramePart (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @FramePart decorator.  Includes metadata describing the FramePart and how it will be treated by
         * the FX.
         */
        interface Options extends FxPartBase.Options {
            /**
             * The sizes supported by this FramePart.
             */
            supportedSizes?: Size[];
            /**
             * The initial size with which the FramePart will be rendered.  Must be one of the 'supportedSizes'.
             */
            initialSize?: Size;
            /**
             * The resize mode for the FramePart.  If not supplied, the default value of 'Fixed' will be used.
             */
            resizeMode?: ResizeMode;
        }
        /**
         * The available sizes for the FramePart.
         */
        export import Size = FxPartBase.Size;
        /**
         * The available resize modes for the FramePart.
         */
        export import ResizeMode = FxPartBase.ResizeMode;
        /**
         * Metadata describing a parameter passed to this FramePart.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the FramePart view model such that it implements an 'onRebind' method that will be
             * called when the FramePart's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the FramePart is bound.
             *
             * When this decorator is not used, whenever parameters change value, the FramePart view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its 'parameters' and persisted 'settings'
             * values.  A new 'settings' property is added to the view model's 'context' which -- along with 'parameters' -- are used in the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the FramePart's settings.
             */
            type Options = FxPartBase.Configurable.Options;
            /**
             * Metadata describing one setting of the FramePart's persisted settings.
             */
            type SettingMetadata = FxPartBase.Configurable.SettingMetadata;
            /**
             * The scope at which the FramePart's settings are persisted.
             */
            export import SettingsScope = FxPartBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FramePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any, any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FramePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TParameters, TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include a 'configuration' (the FramePart's
                 * configuration API), as well as 'parameters' and 'settings' (the FramePart's persisted settings values).
                 */
                context: Context<TParameters, TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the FramePart's configuration
             * API), the 'parameters' of the FramePart, as well as its persisted 'settings' values.
             */
            interface Context<TParameters, TSettings> extends FxPartBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its parameters and settings.
                 */
                configuration: Configuration<TParameters, TSettings>;
            }
            /**
             * The FramePart's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxPartBase.Configurable.Configuration<TParameters, TSettings>;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * FramePart replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: FramePartClass) => void;
        }
        /**
         * The signature of messages used by the FramePart.
         */
        const signature = "FxFramePart";
        /**
         * The kind of message indicating that content can be revealed.
         */
        const revealContentMessageKind = "revealcontent";
        /**
         * The kind of message indicating that initialization has completed.
         */
        const initializationCompleteMessageKind = "initializationcomplete";
        module Internal {
            interface Data<T> {
                /**
                 * Data passed from the shell to the control.
                 */
                postMessage: KnockoutObservable<Message<T>>;
                /**
                 * Data passed from the control to the shell.
                 */
                receiveMessage: KnockoutObservable<Message<T>>;
                /**
                 * Indicates whether the iframe control has initialized.
                 */
                isFrameReady: KnockoutObservable<boolean>;
                /**
                 * The signature to be used for messages routed to/from the IFrame.
                 */
                signature: string;
                /**
                 * isV2Options flag indicates if iframe messages are exchanged via the latest V2 frame APIs.
                 * With V2 frame APIs, messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
                 */
                isV2Options: boolean;
            }
            interface ViewModelOptions extends MsPortalFxFramePart.ViewModelOptions {
                /**
                 * The signature of messages used by the FramePart.
                 */
                signature: string;
            }
        }
        /**
         * Defines the signature for a message handler.
         */
        type MessageHandler = (data: any) => void;
        /**
         * Defines a message sent between a frame part's view model and the frame.
         */
        interface Message<T> {
            /**
             * The message signature.
             */
            signature: string;
            /**
             * The message kind.
             */
            kind: string;
            /**
             * The message data.
             */
            data: T;
        }
        interface ViewModelOptions {
            /**
             * The URL of the page to load in the frame.
             */
            src: string;
        }
        interface ViewModelV2Options {
            /**
             * The URL of the page to embed in an iframe.
             */
            readonly src: string;
            /**
             * Callback to handle messages posted from iframe to the FramePart.
             * FramePart defines the shape of the message received from iframe.
             *
             * @param message Message received from iframe.
             */
            readonly onReceiveMessage: (message: unknown) => void;
        }
        interface ViewModelV2Contract {
            /**
             * Method to post message from FramePart to iframe.
             * FramePart defines the shape for the message posted to iframe.
             *
             * @param message Message posted from FramePart to iframe.
             */
            readonly postMessage: (message: unknown) => void;
        }
        /**
         * Creates an instance of iframe viewmodel with V2 contract.
         * V2 view model is the latest frame API where messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
         *
         * @param container Container of the part.
         * @param options Options for creating V2 view model.
         *
         * @returns a V2 iframe viewmodel
         */
        function createViewModel(container: Container, options: ViewModelV2Options): ViewModelV2Contract;
        class ViewModelBase {
            private readonly _handlers;
            private readonly _readyPromise;
            /**
             * Data passed to/from the shell and the control.
             */
            private readonly _msPortalFxData;
            /**
             * Posts a message to the frame.
             *
             * @param kind The message kind.
             * @param data The data associated to the message.
             */
            protected _postMessage: <T>(kind: string, data?: T) => void;
            /**
             * The URL of the page to embed.
             */
            readonly src: string;
            /**
             * Creates the view model for a frame part.
             *
             * @param container Container of the part.
             * @param options Options for this view model.
             */
            constructor(container: MsPortalFx.ViewModels.PartContainerContract | Container, options: ViewModelOptions);
            constructor(container: MsPortalFx.ViewModels.PartContainerContract | Container, options: ViewModelV2Options);
            /**
             * Helper method to wait till frame initialization is complete.
             *
             * @return A promise when resolved will indicate iframe has been fully initialized.
             */
            waitForFrameReady(): Q.Promise<void>;
            /**
             * Attaches an event handler function for message events of the specified kind.
             *
             * @param kind The kind of message to listen to.
             * @param handler A function to execute when a message of the specified kind is received.
             */
            on(kind: string, handler: MessageHandler): void;
            /**
             * Removes an event handler.
             *
             * @param kind The kind of message.
             * @param handler A function previously attached to message events of the specified kind.
             */
            off(kind: string, handler: MessageHandler): void;
        }
        class ViewModel extends ViewModelBase {
            /**
             * Creates the view model for a frame part.
             *
             * @param container Container of the part.
             * @param options Options for this view model.
             */
            constructor(container: MsPortalFx.ViewModels.PartContainerContract | Container, options: ViewModelOptions);
            /**
             * Posts a message to the frame.
             *
             * @param kind The message kind.
             * @param data The data associated to the message.
             */
            postMessage<T>(kind: string, data?: T): void;
        }
        namespace Filterable {
            /**
             * The @Filterable decorator.  FrameParts that carry this decorator will receive the state of the those filters currently
             * applied to the containing Dashboard.  They'll receive a "filter model" for each applied filter that the FramePart supports.
             * (see the 'FramePart.Filterable.Context' type and its 'filterModels' property, injected into the FramePart as its 'context' member).
             * FrameParts will make use of the current "filter models":
             * - in their 'onInitialize' method, to render the FramePart
             * - in their 'onRebind' method, to update the rendered FramePart to reflect user changes to Dashboard filters
             */
            function Decorator(): (filterableClass: FilterableClass) => void;
            interface FilterableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    filterable?: boolean;
                };
            }
            /**
             * The interface type implemented by any class that carries the '@FramePart.Filterable.Decorator' decorator.
             */
            interface Contract<TFilterModels> {
                /**
                 * Context injected by the FX into the FramePart class.  This context should be used within the FramePart's 'onInitialize'
                 * and 'onRebind' methods.
                 */
                context: Context<TFilterModels>;
                /**
                 * As with the 'onRebind' method required when using the @FramePart.Rebindable.Decorator decorator,
                 * this method will be called by the FX whenever the filters for the current Dashboard are updated by the user.
                 *
                 * @param changes An indication of the filter ids whose corresponding filters have been added/removed/updated.
                 * @return A Promise reflecting the time spent loading updated FramePart data and making corresponding
                 * changes to the FramePart's view.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known statically.  These static filters are those known
                 * at development time (and not those derived from mutable backend schema, for instance).  Such extension-defined
                 * filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic filters like TimeRangeFilter).
                 * This method should return a filter definition for each extension-defined filters declared on the FramePart's
                 * 'TFilterModels' type included in 'public context: FramePart.Filterable.Context<TFilterModels>'.
                 *
                 * This method will be called by the FX some time after the FX calls this FramePart's 'onInitialize' (to not compete
                 * with the initiation of FramePart data-loading).  When called, this method should not assume that the FramePart is
                 * fully initialized.
                 *
                 * @return An array of filter definitions for each extension-defined filter declared on the FramePart's 'TFilterModels' type.
                 */
                getFilterDefinitions?(): FxFilters.FilterDefinition[];
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known only dynamically (for instance, derived from
                 * mutable backend schema).  Such extension-defined filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic
                 * filters like TimeRangeFilter).
                 *
                 * This method will be called by the FX some time after the FX calls this FramePart's 'onInitialize' (to not compete
                 * with the initiation of FramePart data-loading).  When called, this method should not assume that the FramePart is
                 * fully initialized.
                 *
                 * @return An array of filter definitions for each extension-defined filter only known dynamically.
                 */
                getDynamicFilterDefinitions?(): Q.Promise<FxFilters.DynamicFilterDefinition[]> | Promise<FxFilters.DynamicFilterDefinition[]>;
                /**
                 * Required only if any filter definition 'getValues' callbacks returns a localizable filter value.
                 * In such cases, this method will be called to map one or more such localizable filter values to display text in the Portal
                 * user's locale.
                 *
                 * @param filterId The filter id for the filter definition whose 'getValues' callback returned a localizable value.
                 * @param valueIds One or more ids of localizable values.
                 * @return A Promise resolving with corresponding display text for each localizable value, according to the user's locale.
                 */
                getLocalizedFilterValues?(filterId: string, valueIds: string[]): Q.Promise<FxFilters.LocalizedFilterValue[]> | Promise<FxFilters.LocalizedFilterValue[]>;
            }
            /**
             * A description of filter changes (adds/removes/updates) that triggered a call to the FramePart's 'onRebind' method,
             * to reflect user modification to Dashboard filters.
             */
            interface Changes {
                /**
                 * An array of filter ids covering the added/removed/updated Dashboard filters.
                 */
                filterIds: string[];
            }
            /**
             * Context injected by the FX into the FramePart class, including extra APIs supporting the
             * '@FramePart.Filterable.Decorator' decorator.
             */
            interface Context<TFilterModels> {
                /**
                 * FX APIs related to Dashboards.
                 */
                dashboard: {
                    /**
                     * FX APIs related to Dashboard filtering.
                     */
                    filtering: {
                        /**
                         * For those filters supported by this FramePart, these are the filter models for those filters currently applied
                         * to the active Dashboard and those that are applied locally at the Part level.  The supported filters are those static filters declared in this FramePart's
                         * 'TFilterModels' type and those dynamic filters returned from 'getDynamicFilterDefinitions'.
                         */
                        effectiveFilterModels: TFilterModels;
                        /**
                         * A description of all filters applied, broken down into those filters applied to the active Dashboard and those filters applied locally
                         * at the Part level.
                         *
                         * These values do not take precedence into consideration, and should not be used as a source of truth for a filter's final
                         * effective value. For that refer back to the effectiveFilterModels.
                         *
                         */
                        allFilterModels: {
                            /**
                             * All filters applied at the dashboard level.
                             */
                            dashboard: TFilterModels;
                            /**
                             * All filters applied at the part level.
                             */
                            part: TFilterModels;
                        };
                        /**
                         * If this FramePart includes UX to update filters that apply to the Part, the FramePart can include an option for
                         * the user to update filters at the Dashboard level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'dashboardFilters' here passed here.
                         *
                         * @param dashboardFilters Updated dashboard filter models
                         * @return A Promise reflecting the updating of the Dashboard filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(dashboardFilters: Partial<TFilterModels>): Q.Promise<void>;
                        /**
                         * If this FramePart includes UX to update filters that apply to the Part, the FramePart can include an option for
                         * the user to update filters at the Dashboard level and/or part level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'filters' here passed here.
                         *
                         * @param filters Updated dashboard and/or part-level filter models
                         * @return A Promise reflecting the updating of the Dashboard and/or Part-level filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(filters: {
                            dashboard?: Partial<TFilterModels>;
                            part?: Partial<TFilterModels>;
                        }): Q.Promise<void>;
                    };
                };
            }
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\ItemType.d.ts
declare module "Fx/Composition/ItemType" {
    /**
     * These are the composition items that have TypeScript decorator support.
     */
    export const enum ItemType {
        Blade = 0,
        FrameBlade = 1,
        MenuBlade = 2,
        TemplateBlade = 3,
        ButtonPart = 4,
        FramePart = 5,
        Part = 6,
        TemplatePart = 7,
        ReactView = 10,
        AssetCommands = 11
    }
}

// FILE: Fx\Composition\MenuBlade.d.ts
declare module "Fx/Composition/MenuBlade" {
    import * as FxComposition from "Fx/Composition";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import * as Menu from "Fx/Controls/Menu";
    export = MsPortalFxMenuBlade;
    module MsPortalFxMenuBlade {
        /**
         * The @MenuBlade decorator.  Identifies a class within the extension as a MenuBlade view model class.
         *
         * @options Metadata describing the MenuBlade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (bladeClass: MenuBladeClass) => void;
        /**
         * Constrains the @MenuBlade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface MenuBladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @MenuBlade decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this MenuBlade.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             */
            viewModel: ViewModel2;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a MenuBlade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the MenuBlade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a MenuBlade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the MenuBlade.
             */
            container: Container;
        }
        /**
         * Options supplied to the @MenuBlade decorator.  Includes metadata describing the MenuBlade and how it will be treated by
         * the FX.
         */
        type Options = FxBladeBase.Options;
        /**
         * Represents a container object that can be used to control the chrome of the MenuBlade.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the MenuBlade.
         */
        interface Container extends FxBladeBase.Container {
            /**
             * The location where the MenuBlade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the MenuBlade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the MenuBlade view model such that it implements an 'onRebind' method that will be
             * called when the MenuBlade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the MenuBlade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * MenuBlade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the MenuBlade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        /**
         * The sort order used for groups in the menu.
         */
        export import SortOrder = Menu.SortOrder;
        /**
         * The sort function used to order groups in the menu.
         */
        export import SortFunction = Menu.SortFunction;
        namespace Internal {
            /**
             * Options supplied to the ViewModel constructor.
             */
            interface ViewModelOptions extends Menu.Options {
                /**
                 * The groups of menu items.
                 */
                groups: MenuGroup[] | KnockoutReadOnlyObservableBase<MenuGroup[]>;
                /**
                 * Specifies the sort order used for groups in the menu.
                 */
                groupSortOrder?: SortOrder;
                /**
                 * Specifies the sort function used to order groups in the menu.
                 */
                groupSortFunction?: SortFunction;
                /**
                 * A value indicating whether or not to show the search box.
                 */
                showSearch?: boolean;
            }
        }
        /**
         * Defines the view model for a menu blade.
         */
        class ViewModel2 {
            private _msPortalFxMenu;
            /**
             * Creates the view model for a menu blade.
             *
             * @param container The container for the view model.
             * @param options Options for the view model.
             * @return The view model.
             */
            static create<T extends Internal.ViewModelOptions>(container: Container, options: T): ViewModel2 & T;
            private _initialize;
        }
        /**
         * Defines an item in a group of the menu.
         */
        interface MenuItem extends Menu.MenuItem {
        }
        /**
         * Defines a group in the menu.
         */
        interface MenuGroup extends Menu.MenuGroup {
        }
        /**
         * A decorator used to specify a Blade that will be replaced by this Menu Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: MenuBladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\Part.d.ts
declare module "Fx/Composition/Part" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as FxPartBase from "Fx/Composition/PartBase";
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    export = MsPortalFxPart;
    module MsPortalFxPart {
        /**
         * The @Part decorator.  Identifies a class within the extension as a Part view model class.
         *
         * @options Metadata describing the Part and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (partClass: PartClass) => void;
        /**
         * Constrains the @Part decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface PartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @Part decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxPartBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this Part.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             */
            viewModel: any;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the Part.
             */
            container: Container;
        }
        /**
         * Represents a container object that can be used to control the chrome of the Part.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the Part.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed Part size information.
             * The Part class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this Part (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed Part size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined Part sizes, including 'Custom' if the Part is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this Part (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @Part decorator.  Includes metadata describing the Part and how it will be treated by
         * the FX.
         */
        interface Options extends FxPartBase.Options, FxViewModelBase.AcceptsStyleSheetsOptions {
            /**
             * The sizes supported by this Part.
             */
            supportedSizes?: Size[];
            /**
             * The initial size with which the Part will be rendered.  Must be one of the 'supportedSizes'.
             */
            initialSize?: Size;
            /**
             * The resize mode for the Part.  If not supplied, the default value of 'Fixed' will be used.
             */
            resizeMode?: ResizeMode;
        }
        /**
         * The available sizes for the Part.
         */
        export import Size = FxPartBase.Size;
        /**
         * The available resize modes for the Part.
         */
        export import ResizeMode = FxPartBase.ResizeMode;
        /**
         * Metadata describing a parameter passed to this Part.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the Part view model such that it implements an 'onRebind' method that will be
             * called when the Part's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the Part is bound.
             *
             * When this decorator is not used, whenever parameters change value, the Part view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its 'parameters' and persisted 'settings'
             * values.  A new 'settings' property is added to the view model's 'context' which -- along with 'parameters' -- are used in the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Part's settings.
             */
            type Options = FxPartBase.Configurable.Options;
            /**
             * Metadata describing one setting of the Part's persisted settings.
             */
            type SettingMetadata = FxPartBase.Configurable.SettingMetadata;
            /**
             * The scope at which the Part's settings are persisted.
             */
            export import SettingsScope = FxPartBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Part's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any, any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Part's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TParameters, TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include a 'configuration' (the Part's
                 * configuration API), as well as 'parameters' and 'settings' (the Part's persisted settings values).
                 */
                context: Context<TParameters, TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the Part's configuration
             * API), the 'parameters' of the Part, as well as its persisted 'settings' values.
             */
            interface Context<TParameters, TSettings> extends FxPartBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its parameters and settings.
                 */
                configuration: Configuration<TParameters, TSettings>;
            }
            /**
             * The Part's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxPartBase.Configurable.Configuration<TParameters, TSettings>;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * Part replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: PartClass) => void;
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a Part class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the Part's view."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
        namespace Filterable {
            /**
             * The @Filterable decorator.  Parts that carry this decorator will receive the state of the those filters currently
             * applied to the containing Dashboard.  They'll receive a "filter model" for each applied filter that the Part supports.
             * (see the 'Part.Filterable.Context' type and its 'filterModels' property, injected into the Part as its 'context' member).
             * Parts will make use of the current "filter models":
             * - in their 'onInitialize' method, to render the Part
             * - in their 'onRebind' method, to update the rendered Part to reflect user changes to Dashboard filters
             */
            function Decorator(): (filterableClass: FilterableClass) => void;
            interface FilterableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    filterable?: boolean;
                };
            }
            /**
             * The interface type implemented by any class that carries the '@Part.Filterable.Decorator' decorator.
             */
            interface Contract<TFilterModels> {
                /**
                 * Context injected by the FX into the Part class.  This context should be used within the Part's 'onInitialize'
                 * and 'onRebind' methods.
                 */
                context: Context<TFilterModels>;
                /**
                 * As with the 'onRebind' method required when using the @Part.Rebindable.Decorator decorator,
                 * this method will be called by the FX whenever the filters for the current Dashboard are updated by the user.
                 *
                 * @param changes An indication of the filter ids whose corresponding filters have been added/removed/updated.
                 * @return A Promise reflecting the time spent loading updated Part data and making corresponding
                 * changes to the Part's view.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known statically.  These static filters are those known
                 * at development time (and not those derived from mutable backend schema, for instance).  Such extension-defined
                 * filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic filters like TimeRangeFilter).
                 * This method should return a filter definition for each extension-defined filters declared on the Part's
                 * 'TFilterModels' type included in 'public context: Part.Filterable.Context<TFilterModels>'.
                 *
                 * This method will be called by the FX some time after the FX calls this Part's 'onInitialize' (to not compete
                 * with the initiation of Part data-loading).  When called, this method should not assume that the Part is
                 * fully initialized.
                 *
                 * @return An array of filter definitions for each extension-defined filter declared on the Part's 'TFilterModels' type.
                 */
                getFilterDefinitions?(): FxFilters.FilterDefinition[];
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known only dynamically (for instance, derived from
                 * mutable backend schema).  Such extension-defined filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic
                 * filters like TimeRangeFilter).
                 *
                 * This method will be called by the FX some time after the FX calls this Part's 'onInitialize' (to not compete
                 * with the initiation of Part data-loading).  When called, this method should not assume that the Part is
                 * fully initialized.
                 *
                 * @return An array of filter definitions for each extension-defined filter only known dynamically.
                 */
                getDynamicFilterDefinitions?(): Q.Promise<FxFilters.DynamicFilterDefinition[]> | Promise<FxFilters.DynamicFilterDefinition[]>;
                /**
                 * Required only if any filter definition 'getValues' callbacks returns a localizable filter value.
                 * In such cases, this method will be called to map one or more such localizable filter values to display text in the Portal
                 * user's locale.
                 *
                 * @param filterId The filter id for the filter definition whose 'getValues' callback returned a localizable value.
                 * @param valueIds One or more ids of localizable values.
                 * @return A Promise resolving with corresponding display text for each localizable value, according to the user's locale.
                 */
                getLocalizedFilterValues?(filterId: string, valueIds: string[]): Q.Promise<FxFilters.LocalizedFilterValue[]> | Promise<FxFilters.LocalizedFilterValue[]>;
            }
            /**
             * A description of filter changes (adds/removes/updates) that triggered a call to the Part's 'onRebind' method,
             * to reflect user modification to Dashboard filters.
             */
            interface Changes {
                /**
                 * An array of filter ids covering the added/removed/updated Dashboard filters.
                 */
                filterIds: string[];
            }
            /**
             * Context injected by the FX into the Part class, including extra APIs supporting the
             * '@Part.Filterable.Decorator' decorator.
             */
            interface Context<TFilterModels> {
                /**
                 * FX APIs related to Dashboards.
                 */
                dashboard: {
                    /**
                     * FX APIs related to Dashboard filtering.
                     */
                    filtering: {
                        /**
                         * For those filters supported by this Part, these are the filter models for those filters currently applied
                         * to the active Dashboard and those that are applied locally at the Part level.  The supported filters are those static filters declared in this Part's
                         * 'TFilterModels' type and those dynamic filters returned from 'getDynamicFilterDefinitions'.
                         */
                        effectiveFilterModels: TFilterModels;
                        /**
                         * A description of all filters applied, broken down into those filters applied to the active Dashboard and those filters applied locally
                         * at the Part level.
                         *
                         * These values do not take precedence into consideration, and should not be used as a source of truth for a filter's final
                         * effective value. For that refer back to the effectiveFilterModels.
                         *
                         */
                        allFilterModels: {
                            /**
                             * All filters applied at the dashboard level.
                             */
                            dashboard: TFilterModels;
                            /**
                             * All filters applied at the part level.
                             */
                            part: TFilterModels;
                        };
                        /**
                         * If this Part includes UX to update filters that apply to the Part, the Part can include an option for
                         * the user to update filters at the Dashboard level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'dashboardFilters' here passed here.
                         *
                         * @param dashboardFilters Updated dashboard filter models
                         * @return A Promise reflecting the updating of the Dashboard filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(dashboardFilters: Partial<TFilterModels>): Q.Promise<void>;
                        /**
                         * If this Part includes UX to update filters that apply to the Part, the Part can include an option for
                         * the user to update filters at the Dashboard level and/or part level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'filters' here passed here.
                         *
                         * @param filters Updated dashboard and/or part-level filter models
                         * @return A Promise reflecting the updating of the Dashboard and/or Part-level filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(filters: {
                            dashboard?: Partial<TFilterModels>;
                            part?: Partial<TFilterModels>;
                        }): Q.Promise<void>;
                    };
                };
            }
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\PartBase.d.ts
declare module "Fx/Composition/PartBase" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import { ItemType } from "Fx/Composition/ItemType";
    import { SvgType } from "Fx/Images";
    import { DialogManagement } from "Fx/Composition/Dialog";
    export = Main;
    module Main {
        import FxConfiguration = MsPortalFx.Composition.Configuration;
        import FxParts = MsPortalFx.Parts;
        /**
         * The class type to which the various Part decorators can be applied.
         */
        interface PartClass extends FxViewModelBase.ViewModelClass<any> {
            _fx?: {
                itemType?: ItemType;
                options?: Options;
                ownsEditScope?: boolean;
                rebindable?: boolean;
                parameterProvider?: void;
                configurableOptions?: FxViewModelBase.Configurable.Options;
                filterable?: boolean;
            };
        }
        /**
         * A common interface type for the various Part view model classes.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxViewModelBase.Contract<TParameters, TModel> {
            /**
             * The title text displayed for this part. Typically this specifies what kind of information
             * appears inside the part, e.g., "Deployment history", or if that is not applicable then the
             * type of the asset that the part relates to, e.g., "Website".
             * Supply 'null' if no title is desired for the Part.
             */
            title: string | KnockoutObservableBase<string>;
            /**
             * The displayed subtitle for this Part, typically the Asset name for the asset/resource associated with this Part.
             * Supply 'null' if no subtitle is desired for the Part.
             */
            subtitle: string | KnockoutObservableBase<string>;
            /**
             * Describes the behavior of the Part when it is clicked by the user.
             * Supply 'null' if the Part is not clickable.
             */
            onClick: (() => void) | FxComposition.ClickableLink;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        type Context<TParameters, TModel = void> = FxViewModelBase.Context<TParameters, TModel>;
        /**
         * Represents a container object that can be used to control the chrome of the Part.
         */
        interface Container extends FxViewModelBase.Container, DialogManagement {
            /**
             * If allowed by ResizeMode, will adjust the size of the part to the size specified, clamped to the grid constraints.
             *
             * @param width The desired width, in grid steps, valid in range from 1 to 25.
             * @param height The desired height, in grid steps, valid in range from 1 to 25.
             */
            resizeTo(width: number, height: number): void;
        }
        /**
         * Detailed Part size information.
         */
        interface SizeInfo {
            /**
             * The width/height of the Part in terms of pixels.
             */
            dimensions: {
                width: number;
                height: number;
            };
        }
        /**
         * The location of a Part.
         */
        export import Location = MsPortalFx.ViewModels.PartLocation;
        /**
         * Options supplied to the specific Part decorator.  Includes metadata describing the Part and how it will be
         * treated by the FX.
         */
        interface Options extends FxViewModelBase.Options {
            /**
             * The initial height with which the Part will be rendered.
             * Is applicable only when the 'initialSize' doesn't include a fixed height.
             */
            initialHeight?: number;
            /**
             * The initial width with which the Part will be rendered.
             * Is applicable only when the 'initialSize' doesn't include a fixed width.
             */
            initialWidth?: number;
            /**
             * Metadata describing the parameters passed to this Part.
             */
            parameterMetadata?: {
                [key: string]: ParameterMetadata;
            };
            /**
             * Metadata that describes this Part in the Part Gallery.
             */
            galleryMetadata?: GalleryMetadata;
            /**
             * Ensure the Part's 'onClick' method is always called when such a Part is clicked.
             * This overrides intrinsic FX behavior for Parts pinned from MenuBlades, where 'onClick' is not called and, rather,
             * a deep link is utilized to open the MenuBlade.
             */
            ignorePinnedDeepLink?: boolean;
        }
        /**
         * The available sizes for the Part.
         */
        export import Size = FxParts.PartSize;
        /**
         * The available resize modes for the Part.
         */
        export import ResizeMode = FxParts.ResizeMode;
        /**
         * Metadata describing a parameter passed to this Part.
         */
        interface ParameterMetadata {
            /**
             * When a Part is added to a Dashboard, this type is used to determine compatible Dashboard values to which the
             * associated parameter can be bound.
             */
            valueType: FxConfiguration.ValueType;
        }
        /**
         * Metadata describing the parameters passed to this Part.
         */
        interface GalleryMetadata {
            /**
             * The title of the Part shown in the Part Gallery.
             */
            title: string;
            /**
             * The description of the Part shown in the Part Gallery.
             */
            description?: string;
            /**
             * The category to which the Part belongs.
             */
            category?: string;
            /**
             * A reference to an SVG element to be used as the the thumbnail that is shown for the Part's entry in the Part Gallery.
             */
            thumbnail?: ({
                /**
                 * URI to the image element.
                 */
                path: string;
            } | {
                /**
                 * References a built-in SVG element.
                 */
                image: SvgType;
            });
            /**
             * The feature name used to hide this Part in the Part Gallery.
             */
            feature?: string;
        }
        module Rebindable {
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxViewModelBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Part's settings.
             */
            type Options = FxViewModelBase.Configurable.Options;
            /**
             * Metadata describing one setting of the Part's persisted settings.
             */
            type SettingMetadata = FxViewModelBase.Configurable.SettingMetadata;
            /**
             * The scope at which the Part's settings are persisted.
             */
            export import SettingsScope = FxViewModelBase.Configurable.SettingsScope;
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the Part's configuration
             * API) as well as 'parameters' and 'settings' (the Part's persisted settings values).
             */
            type Context<TSettings> = FxViewModelBase.Configurable.Context<TSettings>;
            /**
             * The Part's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxConfiguration.Part.Contract<TParameters, TSettings>;
        }
        module ReplacesOldPart {
            /**
             * Identifies a part on a blade that is to have its pinned instances replaced
             */
            interface ReplacedPartIdentifer {
                /**
                 * Name of the part that is to be replaced
                 */
                part: string;
                /**
                 * The lens which contains the part that is to be replaced
                 */
                lens: string;
                /**
                 * The blade which contains the part that is to be replaced
                 */
                blade: string;
            }
            /**
             * Options supplied to the ReplacesOldPart decorator.
             */
            interface Options {
                /**
                 * The old part that is to be replaced
                 */
                replacedPart: string | ReplacedPartIdentifer;
                /**
                 * The extension which the old part belongs to
                 */
                extension?: string;
            }
        }
        /**.
         * The Part 'Container' API for all variations of Parts. It's through this API that extensions
         * can interact with the Part's chrome UI.
         */
        type AnyPartContainer = Container | MsPortalFx.ViewModels.PartContainerContract;
    }
}

// FILE: Fx\Composition\PartReferences.d.ts
declare module "Fx/Composition/PartReferences" {
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    export = PartReferences;
    module PartReferences {
        interface PartReferenceOptions extends MsPortalFx.Composition.PartReferenceOptions {
            /**
             * The part-level filters to use when displaying data, if applicable.
             */
            filters?: StringMap<FxFilters.AnyFilterModel>;
        }
        /**
         * Identifies the part that is referenced. This type is not intended to be used directly, but instead
         * code generation defines sub-classes of this base type to create a strongly typed reference per Part.
         */
        class PartReference<TParameters> extends MsPortalFx.Composition.PartReference<TParameters> {
            /**
             * Options to create the target part
             */
            options: PartReferenceOptions;
            /**
             * PartReference constructor
             *
             * @param partName partName of the referenced part
             * @param parameters parameters that are passed to the target part
             * @param options options that are used to create the target part
             */
            constructor(partName: string, parameters: TParameters, options?: PartReferenceOptions);
        }
    }
}

// FILE: Fx\Composition\Pdl\Blade.d.ts
declare module "Fx/Composition/Pdl/Blade" {
    import * as FxComposition from "Fx/Composition";
    import { ExposesContentSize } from "Fx/Composition/BladeBase";
    import FxConfiguration = MsPortalFx.Composition.Configuration;
    import BladeLocation = MsPortalFx.ViewModels.BladeLocation;
    export interface Container extends MsPortalFx.ViewModels.ContainerContract, MsPortalFx.ViewModels.BladeManagement, MsPortalFx.ViewModels.DialogManagement, ExposesContentSize {
        /**
         * Activates this Blade's 'Configuration', which is an API that enables the Blade to manage parameter and settings overrides/inheritance via
         * configuration UI (typically via a Context Blade).  See the MsPortalFx.Composition.Configuration.Contract interface for details.
         *
         * @param options Options used to initialize the Configuration API for this Part
         * @return The Configuration API for this Part
         */
        activateConfiguration<TSettings>(options?: FxConfiguration.Blade.Options<TSettings>): FxConfiguration.Blade.Contract<TSettings>;
        /**
         * Tracks the list of asynchronous operations being performed by the Blade.
         */
        operations: FxComposition.OperationList;
        /**
         * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An optional custom error message or options customizing the error UI.
         */
        fail(message?: string | ErrorOptions): void;
        /**
         * Moves the container into an 'error' display mode, allowing for a custom error message.
         *
         * Use this method when encountering an expected error state transition which has been
         * designed as part of the user experience and is not the indication of a product bug.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An custom error message or options customizing the error UI.
         *                As opposed to other error state transition methods, the message is non-optional.
         */
        handledError(message: string | ErrorOptions): void;
        /**
         * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An optional custom error message or options customizing the error UI.
         */
        notFound(message?: string | ErrorOptions): void;
        /**
         * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         *
         * @param message An optional custom error message or options customizing the error UI.
         */
        unauthorized(message?: string | ErrorOptions): void;
        /**
         * Used to put a failed Blade/Part back into an operational state.
         */
        recover(): void;
        /**
         * Causes the blade's content to be revealed immediately, regardless of any onInputsSet promise that
         * might not yet have completed. This removes the opaque 'loading' spinner and makes the blade interactive,
         * so you must also disable or hide any UI elements that the user should not be able to see or interact with
         * until data is fully loaded.
         */
        revealContent(): void;
        /**
         * The message displayed by the Part when it has no data to display.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * Closes this blade
         *
         * @param data Optional value to return back to the parent blade
         * @return a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: any): Q.Promise<boolean>;
        /**
         * Closes the child blade that is currently open
         *
         * @return a promise that resolves to true if the child blade is successfully closed.
         */
        closeChildBlade(): Q.Promise<boolean>;
        /**
         * Closes the context blade that was opened by this part
         *
         * @returns a promise that resolves to true if the context blade is successfully closed.
         */
        closeContextBlade(): Q.Promise<boolean>;
        /**
         * Properties to track form validity, dirty state of forms on this blade and methods to trigger validation and modify alert behavior
         */
        form: MsPortalFx.ViewModels.FormProperties;
        /**
         * Interface for managing menu blade.   This property is null if the blade is not a opened by a menu blade.
         */
        menu: MsPortalFx.ViewModels.MenuBladeManagement;
        /**
         * The path to the help content file.
         */
        helpContentUri: KnockoutObservable<string>;
        /**
         * API collection that facilitates dashboard interactions.
         */
        dashboard: MsPortalFx.ViewModels.DashboardManagement;
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        bladeLocation: BladeLocation;
    }
    /**
     * The options for the notice blade.
     */
    export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
    /**
     * The options for the error details.
     */
    export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
    export class Container {
        constructor();
    }
}

// FILE: Fx\Composition\Pdl\MenuBlade.d.ts
declare module "Fx/Composition/Pdl/MenuBlade" {
    import * as Menu from "Fx/Controls/Menu";
    export = Main;
    module Main {
        /**
         * The options for the menu.
         */
        interface Options extends Menu.Options {
        }
        /**
         * The sort functions used to sort groups in the menu.
         */
        const SortFunction: typeof Menu.SortFunction;
        /**
         * Defines the view model for a menu blade.
         */
        class ViewModel extends MsPortalFx.ViewModels.Blade {
            menu: Menu.ViewModel;
            /**
             * Creates the view model for a menu blade.
             *
             * @param container The container for the view model.
             */
            constructor(container: MsPortalFx.ViewModels.ContainerContract);
        }
        /**
         * The sort order used for groups in the menu.
         */
        export import SortOrder = Menu.SortOrder;
        /**
         * Defines an item in a group of the menu.
         */
        interface MenuItem extends Menu.MenuItem {
        }
        /**
         * Defines a group in the menu.
         */
        interface MenuGroup extends Menu.MenuGroup {
        }
    }
}

// FILE: Fx\Composition\Permissions.d.ts
declare module "Fx/Composition/Permissions" {
    /**
     * Permissions that will be evaluated before rendering a Blade/Part.
     */
    export type Permissions = (Permission | PermissionSet)[];
    /**
     * A permission that will be evaluated for a resource before the associated Blade/Part UI will be shown/enabled.
     */
    export interface Permission {
        /**
         * The 'action' name for this permission ('read', 'write', etc.).
         */
        action: string;
        /**
         * An optional target of the permissions check.  If this is not supplied, then the target resource of this
         * permissions check is the asset associated with this Blade/Part.  To associate a Blade/Part with an asset,
         * use the 'Options.forAsset' property supplied to the Blade/Part decorator.
         */
        targetResource?: ResourceIdSource;
    }
    /**
     * A set of permissions that will be evaluated for a resource before the associated Blade/Part UI will be
     * shown/enabled.
     */
    export interface PermissionSet {
        /**
         * The set of permissions and/or permission references.
         */
        permissions: Permission[];
        /**
         * Indicates how the result from each of the N permission checks will be considered before allowing the
         * associated Blade/Part UI to be shown/enabled.
         */
        requirement: SetRequirement;
    }
    /**
     * Specifies the target asset for a permission or permission reference.
     */
    export interface ResourceIdSource {
        /**
         * A reference to an asset type definition that defines the resource that is the target of some permission or
         * permission reference.
         * If not supplied, then the asset type definition used here is that which is associated with the Blade/Part
         * (using the 'Options.forAsset' property supplied to the Blade/Part decorator).
         */
        assetType?: {
            /**
             * The name of the asset type definition.
             */
            assetType: string;
            /**
             * The name of the extension in which the asset type is defined.  When this is not supplied, this defaults
             * to the current extension.
             */
            extensionName?: string;
        };
        /**
         * If supplied, this indicates that a "property provider service" associated with the asset type definition is
         * to be used to determine the resource id that is the target of a permission / permission reference.
         * When supplied, this value contains the 'key' and 'property' parameters passed to the "property provider
         * service".
         *
         * If this is not supplied, then it is assumed that the associated permission or permission reference will be
         * evaluated against the resource associated with the Blade/Part via the 'Options.forAsset' property passed to
         * the Blade/Part decorator.
         */
        providerParameters?: {
            /**
             * The 'key' parameter passed to the "property provider service".
             */
            key: string;
            /**
             * The 'property' parameter passed to the "property provider service".  This is the view model property
             * where the resource id is to be published.
             */
            property: string;
        };
    }
    /**
     * Indicates how the result from each of the N permission checks will be considered before allowing the associated
     * Blade/Part UI to be shown/enabled.
     */
    export type SetRequirement = MsPortalFx.Extension.SetRequirement;
}

// FILE: Fx\Composition\TemplateBlade.d.ts
declare module "Fx/Composition/TemplateBlade" {
    import * as FxComposition from "Fx/Composition";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import { DialogManagement } from "Fx/Composition/Dialog";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as Provisioning from "Fx/ResourceManagement/Provisioning";
    import { PostProvisioningOptions, PostProvisioningContent } from "Fx/ResourceManagement/Deployments";
    export = MsPortalFxTemplateBlade;
    module MsPortalFxTemplateBlade {
        import PartReference = MsPortalFx.Composition.PartReference;
        /**
         * The @TemplateBlade decorator.  Identifies a class within the extension as a TemplateBlade view model class.
         *
         * @options Metadata describing the TemplateBlade and how it will be treated by the FX.
         */
        function Decorator(options: Options): (templateBladeClass: TemplateBladeClass) => void;
        /**
         * Constrains the @TemplateBlade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface TemplateBladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @TemplateBlade decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a TemplateBlade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the TemplateBlade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a TemplateBlade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the TemplateBlade.
             */
            container: Container;
        }
        /**
         * Describes if/when to display an alert when the blade closes.
         */
        export import AlertLevel = FxBladeBase.AlertLevel;
        /**
         * Options supplied to the @TemplateBlade decorator.  Includes metadata describing the TemplateBlade and how it will be treated by
         * the FX.
         */
        interface Options extends FxBladeBase.Options, FxViewModelBase.RequiresHtmlTemplateOptions, FxViewModelBase.AcceptsStyleSheetsOptions, FxBladeBase.ShrinkOnOpenChildBladeOptions, FxBladeBase.ReflowReadyOption {
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplateBlade.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplateBlade.
         */
        interface Container extends FxBladeBase.Container, FxBladeBase.CanHaveCommandBarContainer, FxBladeBase.ExposesContentSize, DialogManagement {
            /**
             * The location where the TempleteBlade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the TemplateBlade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the TemplateBlade view model such that it implements an 'onRebind' method that will be
             * called when the TemplateBlade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the TemplateBlade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its persisted 'settings' values.  The 'settings'
             * values are made available in the view model's 'context', for use in the view model's 'onInitialize' and optional 'onRebind'
             * methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the TemplateBlade's settings.
             */
            type Options = FxBladeBase.Configurable.Options;
            /**
             * Metadata describing one setting of the TemplateBlade's persisted settings.
             */
            type SettingMetadata = FxBladeBase.Configurable.SettingMetadata;
            /**
             * The scope at which the TemplateBlade's settings are persisted.
             */
            export import SettingsScope = FxBladeBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplateBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplateBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include 'configuration' (the TemplateBlade's configuration
                 * API) as well as 'settings' (the TemplateBlade's persisted settings values).
                 */
                context: Context<TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the TemplateBlade's configuration API),
             * the 'parameters' of the TemplateBlade, as well as its persisted 'settings' values.
             */
            interface Context<TSettings> extends FxBladeBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its settings.
                 */
                configuration: Configuration<TSettings>;
            }
            /**
             * The TemplateBlade's configuration API returned from 'context.configuration'.
             */
            type Configuration<TSettings> = FxBladeBase.Configurable.Configuration<TSettings>;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * TemplateBlade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the TemplateBlade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        module Pinnable {
            /**
             * The @Pinnable decorator.  Requires that the TemplateBlade implement an 'onPin' method that determines what Part
             * to pin when the user pins the TemplateBlade.
             */
            function Decorator(): (pinnableClass: PinnableClass) => void;
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface PinnableClass {
                new (...args: any[]): Contract;
            }
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract {
                /**
                 * A callback that will be called when the user pins the TemplateBlade.  Returns a PartReference to the Part that will be pinned to the
                 * user's Dashboard.
                 */
                onPin(): PartReference<any>;
            }
        }
        module DoesProvisioning {
            /**
             * The @DoesProvisioning decorator. Adds a strongly-typed 'context.provisioning' to the TemplateBlade.
             * This provisioning API allows the view model to perform provisioning operations, including support
             * for telemetry around provisioning.
             *
             * @param options Options used to configure the @DoesProvisioning decorator.
             */
            function Decorator<TOptions extends Options>(options?: TOptions): (doesProvisioningClass: TOptions["supportsPostProvisioning"] extends true ? DoesProvisioningAndPostProvisioningClass : DoesProvisioningClass) => void;
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningClass {
                new (...args: any[]): Contract;
                _fx?: {
                    doesProvisioning?: boolean;
                };
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningAndPostProvisioningClass extends DoesProvisioningClass {
                /**
                 * A static function which returns a viewmodel used to customize the content on the blade launched after submitting a provisioning request.
                 * @param lifetime The lifetime of the content returned.
                 * @param options The options for fetching content relevant to the provisioning request.
                 */
                createPostProvisioningContent(lifetime: MsPortalFx.Base.LifetimeManager, options: PostProvisioningOptions): Q.Promise<PostProvisioningContent> | Promise<PostProvisioningContent>;
            }
            /**
             * Options supplied to the @DoesProvisioning decorator.
             */
            interface Options {
                /**
                 * A flag indicating whether the caller is required to supply a Marketplace item id
                 * when instantiating a BladeReference to this TemplateBlade. Defaults to true.
                 */
                requiresMarketplaceId?: boolean;
                /**
                 * A flag indicating that the create blade's class exposes the createPostProvisioningContent function.
                 * Defaults to false.
                 */
                supportsPostProvisioning?: boolean;
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes
             * implementing 'Contract'.
             */
            interface Contract {
                /**
                 * Context injected by the FX into the view model. This context should be used within
                 * the view model's 'onInitialize' and optional 'onRebind' methods.
                 */
                context: Context<any>;
            }
            /**
             * Context injected by the FX into the view model. This context should be used within the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             */
            interface Context<TUIMetadata = void> {
                /**
                 * The view model's provisioning API, with which the view model can
                 * perform provisioning operations, including support for telemetry
                 * around provisioning.
                 */
                provisioning: FxBladeBase.DoesProvisioning.Provisioning<TUIMetadata>;
            }
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTemplateOptions = Provisioning.DeployTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeploySubscriptionLevelTemplateOptions = Provisioning.DeploySubscriptionLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployManagementGroupLevelTemplateOptions = Provisioning.DeployManagementGroupLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTenantLevelTemplateOptions = Provisioning.DeployTenantLevelTemplateOptions;
            /**
             * Options for the DeployCustom method on provisioning context
             */
            export import DeployCustomOptions = Provisioning.DeployCustomOptions;
            /**
             * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
             */
            export import TemplateDeploymentMode = Provisioning.TemplateDeploymentMode;
            /**
             * Parameters passed to the arm errors blade. See 'getArmErrorsBladeReference'.
             */
            export import ArmErrorsBladeParameters = FxBladeBase.DoesProvisioning.ArmErrorsBladeParameters;
            /**
             * Troubleshooting links for the arm errors blade
             */
            export import TroubleshootingLinks = FxBladeBase.DoesProvisioning.TroubleshootingLinks;
        }
        module LegacyFeatures {
            /**
             * The @LegacyFeatures decorator.  Used to access legacy features for TemplateBlades, like defining an explicit TemplateBlade width.
             *
             * @param options Options used to configure the @LegacyFeatures decorator.
             */
            function Decorator(options: Options): (bladeClass: TemplateBladeClass) => void;
            /**
             * Options supplied to the @LegacyFeatures decorator.
             */
            interface Options {
                /**
                 * The width for this TemplateBlade.
                 */
                width?: Width;
            }
            /**
             * The available widths for the TemplateBlade.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        module ForContextPane {
            /**
             * The @ForContextPane decorator.  Used to configure the behavior of the TemplateBlade when it is opened in the ContextPane.
             *
             * @param options Options used to configure the @ForContextPane decorator.
             */
            function Decorator(options: Options): (bladeClass: TemplateBladeClass) => void;
            /**
             * Options supplied to the @ForContextPane decorator.
             */
            interface Options {
                /**
                 * The width of the TemplateBlade when it is opened in the ContextPane.
                 */
                width?: Width;
            }
            /**
             * The available widths for the ContextPane.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a TemplateBlade class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the TemplateBlade's HTML template."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
        /**
         * A decorator used to specify a Blade that will be replaced by this Template Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: TemplateBladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\TemplatePart.d.ts
declare module "Fx/Composition/TemplatePart" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as FxPartBase from "Fx/Composition/PartBase";
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    export = MsPortalFxTemplatePart;
    module MsPortalFxTemplatePart {
        /**
         * The @TemplatePart decorator.  Identifies a class within the extension as a TemplatePart view model class.
         *
         * @options Metadata describing the TemplatePart and how it will be treated by the FX.
         */
        function Decorator(options: Options): (partClass: TemplatePartClass) => void;
        /**
         * Constrains the @TemplatePart decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface TemplatePartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @TemplatePart decorator so that it can be applied only to classes implementing 'Contract'.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxPartBase.Contract<TParameters, TModel> {
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the TemplatePart.
             */
            container: Container;
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplatePart.
         */
        class Container {
            constructor();
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplatePart.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed TemplatePart size information.
             * The TemplatePart class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this TemplatePart (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             *
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed TemplatePart size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined TemplatePart sizes, including 'Custom' if the TemplatePart is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this TemplatePart (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @TemplatePart decorator.  Includes metadata describing the TemplatePart and how it will be treated by
         * the FX.
         */
        interface Options extends FxPartBase.Options, FxViewModelBase.RequiresHtmlTemplateOptions, FxViewModelBase.AcceptsStyleSheetsOptions {
            /**
             * The sizes supported by this TemplatePart.
             */
            supportedSizes?: Size[];
            /**
             * The initial size with which the TemplatePart will be rendered.  Must be one of the 'supportedSizes'.
             */
            initialSize?: Size;
            /**
             * The resize mode for the TemplatePart.  If not supplied, the default value of 'Fixed' will be used.
             */
            resizeMode?: ResizeMode;
        }
        /**
         * The available sizes for the TemplatePart.
         */
        export import Size = FxPartBase.Size;
        /**
         * The available resize modes for the TemplatePart.
         */
        export import ResizeMode = FxPartBase.ResizeMode;
        /**
         * Metadata describing a parameter passed to this TemplatePart.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the TemplatePart view model such that it implements an 'onRebind' method that will be
             * called when the TemplatePart's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the TemplatePart is bound.
             *
             * When this decorator is not used, whenever parameters change value, the TemplatePart view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @return A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its 'parameters' and persisted 'settings'
             * values.  A new 'settings' property is added to the view model's 'context' which -- along with 'parameters' -- are used in the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the TemplatePart's settings.
             */
            type Options = FxPartBase.Configurable.Options;
            /**
             * Metadata describing one setting of the TemplatePart's persisted settings.
             */
            type SettingMetadata = FxPartBase.Configurable.SettingMetadata;
            /**
             * The scope at which the TemplatePart's settings are persisted.
             */
            export import SettingsScope = FxPartBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplatePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any, any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplatePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TParameters, TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include a 'configuration' (the TemplatePart's
                 * configuration API), as well as 'parameters' and 'settings' (the TemplatePart's persisted settings values).
                 */
                context: Context<TParameters, TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the TemplatePart's configuration
             * API), the 'parameters' of the TemplatePart, as well as its persisted 'settings' values.
             */
            interface Context<TParameters, TSettings> extends FxPartBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its parameters and settings.
                 */
                configuration: Configuration<TParameters, TSettings>;
            }
            /**
             * The TemplatePart's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxPartBase.Configurable.Configuration<TParameters, TSettings>;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * TemplatePart replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: TemplatePartClass) => void;
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a TemplatePart class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the TemplatePart's HTML template."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
        namespace Filterable {
            /**
             * The @Filterable decorator.  TemplateParts that carry this decorator will receive the state of the those filters currently
             * applied to the containing Dashboard.  They'll receive a "filter model" for each applied filter that the TemplatePart supports.
             * (see the 'TemplatePart.Filterable.Context' type and its 'filterModels' property, injected into the TemplatePart as its 'context' member).
             * TemplateParts will make use of the current "filter models":
             * - in their 'onInitialize' method, to render the TemplatePart
             * - in their 'onRebind' method, to update the rendered TemplatePart to reflect user changes to Dashboard filters
             */
            function Decorator(): (filterableClass: FilterableClass) => void;
            interface FilterableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    filterable?: boolean;
                };
            }
            /**
             * The interface type implemented by any class that carries the '@TemplatePart.Filterable.Decorator' decorator.
             */
            interface Contract<TFilterModels> {
                /**
                 * Context injected by the FX into the TemplatePart class.  This context should be used within the TemplatePart's 'onInitialize'
                 * and 'onRebind' methods.
                 */
                context: Context<TFilterModels>;
                /**
                 * As with the 'onRebind' method required when using the @TemplatePart.Rebindable.Decorator decorator,
                 * this method will be called by the FX whenever the filters for the current Dashboard are updated by the user.
                 *
                 * @param changes An indication of the filter ids whose corresponding filters have been added/removed/updated.
                 * @return A Promise reflecting the time spent loading updated TemplatePart data and making corresponding
                 * changes to the TemplatePart's view.
                 */
                onRebind(changes: Changes): Q.Promise<any> | Promise<any>;
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known statically.  These static filters are those known
                 * at development time (and not those derived from mutable backend schema, for instance).  Such extension-defined
                 * filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic filters like TimeRangeFilter).
                 * This method should return a filter definition for each extension-defined filters declared on the TemplatePart's
                 * 'TFilterModels' type included in 'public context: TemplatePart.Filterable.Context<TFilterModels>'.
                 *
                 * This method will be called by the FX some time after the FX calls this TemplatePart's 'onInitialize' (to not compete
                 * with the initiation of TemplatePart data-loading).  When called, this method should not assume that the TemplatePart is
                 * fully initialized.
                 *
                 * @return An array of filter definitions for each extension-defined filter declared on the TemplatePart's 'TFilterModels' type.
                 */
                getFilterDefinitions?(): FxFilters.FilterDefinition[];
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known only dynamically (for instance, derived from
                 * mutable backend schema).  Such extension-defined filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic
                 * filters like TimeRangeFilter).
                 *
                 * This method will be called by the FX some time after the FX calls this TemplatePart's 'onInitialize' (to not compete
                 * with the initiation of TemplatePart data-loading).  When called, this method should not assume that the TemplatePart is
                 * fully initialized.
                 *
                 * @return An array of filter definitions for each extension-defined filter only known dynamically.
                 */
                getDynamicFilterDefinitions?(): Q.Promise<FxFilters.DynamicFilterDefinition[]> | Promise<FxFilters.DynamicFilterDefinition[]>;
                /**
                 * Required only if any filter definition 'getValues' callbacks returns a localizable filter value.
                 * In such cases, this method will be called to map one or more such localizable filter values to display text in the Portal
                 * user's locale.
                 *
                 * @param filterId The filter id for the filter definition whose 'getValues' callback returned a localizable value.
                 * @param valueIds One or more ids of localizable values.
                 * @return A Promise resolving with corresponding display text for each localizable value, according to the user's locale.
                 */
                getLocalizedFilterValues?(filterId: string, valueIds: string[]): Q.Promise<FxFilters.LocalizedFilterValue[]> | Promise<FxFilters.LocalizedFilterValue[]>;
            }
            /**
             * A description of filter changes (adds/removes/updates) that triggered a call to the TemplatePart's 'onRebind' method,
             * to reflect user modification to Dashboard filters.
             */
            interface Changes {
                /**
                 * An array of filter ids covering the added/removed/updated Dashboard filters.
                 */
                filterIds: string[];
            }
            /**
             * Context injected by the FX into the TemplatePart class, including extra APIs supporting the
             * '@TemplatePart.Filterable.Decorator' decorator.
             */
            interface Context<TFilterModels> {
                /**
                 * FX APIs related to Dashboards.
                 */
                dashboard: {
                    /**
                     * FX APIs related to Dashboard filtering.
                     */
                    filtering: {
                        /**
                         * For those filters supported by this TemplatePart, these are the filter models for those filters currently applied
                         * to the active Dashboard and those that are applied locally at the Part level.  The supported filters are those static filters declared in this TemplatePart's
                         * 'TFilterModels' type and those dynamic filters returned from 'getDynamicFilterDefinitions'.
                         */
                        effectiveFilterModels: TFilterModels;
                        /**
                         * A description of all filters applied, broken down into those filters applied to the active Dashboard and those filters applied locally
                         * at the Part level.
                         *
                         * These values do not take precedence into consideration, and should not be used as a source of truth for a filter's final
                         * effective value. For that refer back to the effectiveFilterModels.
                         *
                         */
                        allFilterModels: {
                            /**
                             * All filters applied at the dashboard level.
                             */
                            dashboard: TFilterModels;
                            /**
                             * All filters applied at the part level.
                             */
                            part: TFilterModels;
                        };
                        /**
                         * If this TemplatePart includes UX to update filters that apply to the Part, the TemplatePart can include an option for
                         * the user to update filters at the Dashboard level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'dashboardFilters' here passed here.
                         *
                         * @param dashboardFilters Updated dashboard filter models
                         * @return A Promise reflecting the updating of the Dashboard filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(dashboardFilters: Partial<TFilterModels>): Q.Promise<void>;
                        /**
                         * If this TemplatePart includes UX to update filters that apply to the Part, the TemplatePart can include an option for
                         * the user to update filters at the Dashboard level and/or part level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'filters' here passed here.
                         *
                         * @param filters Updated dashboard and/or part-level filter models
                         * @return A Promise reflecting the updating of the Dashboard and/or Part-level filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(filters: {
                            dashboard?: Partial<TFilterModels>;
                            part?: Partial<TFilterModels>;
                        }): Q.Promise<void>;
                    };
                };
            }
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\ViewModelBase.d.ts
declare module "Fx/Composition/ViewModelBase" {
    import * as BladeBase from "Fx/Composition/BladeBase";
    import * as FxComposition from "Fx/Composition";
    import * as FxPermissions from "Fx/Composition/Permissions";
    import * as PartBase from "Fx/Composition/PartBase";
    export = Main;
    module Main {
        import FxBase = MsPortalFx.Base;
        import FxViewModels = MsPortalFx.ViewModels;
        /**
         * Options that are common to various Blade/Part decorators.  Includes metadata describing the Blade/Part and how it will be treated by
         * the FX.
         */
        interface Options {
            /**
             * Specifies whether this Blade/Part should exported from this extension,
             * so it can be imported/reused by other extensions.  The default is 'false'.
             */
            forExport?: boolean;
            /**
             * Used to associate this Blade/Part with a defined AssetType.  This allows the FX to:
             * - When an asset is deleted, give special UX treatment to associated Parts/Blades (close Blades, disable Parts)
             * - Store per-asset Part/Blade settings
             */
            forAsset?: {
                /**
                 * Names a single Blade/Part parameter that the FX will treat as the 'id' of the associated asset.
                 */
                assetIdParameter: string;
                /**
                 * Names an AssetType definition.  Values here should be one of the string constant generated by the PDL compiler from
                 * <AssetType>.
                 */
                assetType: string;
            };
            /**
             * Permissions that will be evaluated against the resource associated with this Blade/Part (see 'forAsset' above) before the
             * Blade/Part UI is shown/enabled.
             */
            permissions?: FxPermissions.Permissions;
        }
        /**
         * A common class type for Blade/Part view model classes.
         */
        interface ViewModelClass<TModel = void> {
            new (...args: any[]): Contract<any, TModel>;
        }
        /**
         * A common interface type for Blade/Part view model classes.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> {
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
            /**
             * Called by the FX to initialize this view model.
             *
             * @return A promise that should be resolved by the view model when: (1) all the data is loaded for this view model and (2) the
             * view model is updated to reflect the loaded data.
             */
            onInitialize(): Q.Promise<any> | Promise<any>;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> {
            /**
             * The container used by this view model.
             */
            container: Container;
            /**
             * The model used by this view model.
             */
            model?: TModel;
            /**
             * Parameters supplied by the caller of this Blade/Part.
             */
            parameters: TParameters;
            /**
             * API collection that facilitates dashboard interactions.
             */
            dashboard: MsPortalFx.ViewModels.DashboardManagement;
        }
        /**
         * Represents a container object that can be used to control the chrome of the Blade/Part.
         */
        interface Container extends FxBase.LifetimeManager, FxViewModels.BladeManagement {
            /**
             * Removes the blocking loading indicator from the Blade/Part.
             */
            revealContent(): void;
            /**
             * The announce API aims to provide screen reader users knowledge of certain UI updates that are otherwise difficult to advertise.
             * Announcements main purpose is to bring attention to these changes and provide feedback that is only visual otherwise.
             *
             * The message will be published at the 'polite' level, letting the screen reader queue the announcement at an appropriate time without interrupting the current read out queues.
             *
             * The API has these notable documented use cases:
             *   UI changes without focus change: If you add new UI elements through user interaction, and without moving the focus, you should announce.
             *   Confirmations: If you do operations that have completed visually, but not audibly, you should announce. Ex: upon deleting item XYZ, announce "item XYZ deleted"
             *   Loading progression: Announce at reasonable interval loading progression of specific thresholds, and the completion of loading.
             *   Custom search results: If you don't use the SearchBox control, you should announce. Ex: "3 items found".
             *
             * Keep these rules in mind when announcing:
             *   Is this something a control you use should be doing or does already? For example, the search control already has a mechanism to publish search results updates.
             *   Keep announcements short and concise as much as possible. Verbose announcements aren't usually helpful as the UI likely has the information, but the user just didn't know to look for it yet.
             *   If you push the same message multiple times in a row, screen readers are optimized to discard consecutive duplicates, including changes in space characters only. Unless a different message was pushed before, multiple callouts with the equivalent content are therefore ignored by the screen reader.
             *
             * @param message The message that will be read by the screen reader.
             */
            announce(message: string): void;
            /**
             * Asynchronously moves the focus to the first focusable element on or within the specified target if the container currently
             * owns the focus. If multiple targetSelector elements are found, only the first one will be inspected. If nothing is focusable,
             * the focus will not move and this method will return false.
             *
             * @param targetSelector A class selector that identifies a target to focus on or within.
             * @return An object with a success status and an optional error message explaining rejection.
             */
            setFocus(targetSelector: string): Q.Promise<{
                success: boolean;
                errorMsg?: string;
            }>;
            /**
             * Closes this blade.
             *
             * @param data Use the @ReturnsData<TData> decorator to supply TData-typed 'data' here. This 'data' will be returned to the
             * BladeReference with which this Blade was opened, via the BladeReference's 'onClosed' callback.
             * @return a promise that resolves to true if the this blade is successfully closed.
             */
            closeCurrentBlade(data?: void): Q.Promise<boolean>;
            /**
             * Closes the child blade that is currently open.
             *
             * @return a promise that resolves to true if the child blade is successfully closed.
             */
            closeChildBlade(): Q.Promise<boolean>;
            /**
             * Closes the context blade that was opened by this part
             *
             * @returns a promise that resolves to true if the context blade is sucessfully closed.
             */
            closeContextBlade(): Q.Promise<boolean>;
            /**
             * Tracks the list of asynchronous operations being performed by the Part.
             */
            operations: FxComposition.OperationList;
            /**
             * An observable whose value determines the message displayed when there is no data to be displayed in the
             * Blade/Part.
             * This message will be displayed if it is non-null, non-empty.
             */
            noDataMessage: KnockoutObservable<string>;
            /**
             * Used to put a failed Blade/Part back into an operational state.
             */
            recover(): void;
        }
        /**
         * Shared by the decorator options of @TemplateBlade/@TemplatePart.  Requires that the extension supply an HTML template to which the
         * view model will be bound.
         */
        interface RequiresHtmlTemplateOptions {
            /**
             * The HTML template to which the associated view model will be bound.  This can be either an HTML string or an HTML filename.
             */
            htmlTemplate: string;
        }
        /**
         * Shared by decorator options that accept a 'styleSheets' option.
         */
        interface AcceptsStyleSheetsOptions {
            /**
             * The CSS style sheets containing styles used by HTML templates of this Blade/Part.
             */
            styleSheets?: string[];
        }
        module Rebindable {
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            interface Changes {
                /**
                 * The keys of those view model parameters whose values have changed.
                 */
                parameterKeys: string[];
            }
        }
        module Configurable {
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Blade/Part's settings.
             */
            interface Options {
                /**
                 * Metadata describing the settings that will be persisted for this Blade/Part.
                 */
                settings?: {
                    /**
                     * The scope at which the settings will be persisted.  If not supplied, a default value of 'PerPartOrBladeType' will be
                     * used.
                     */
                    scope?: SettingsScope;
                    /**
                     * A StringMap of metadata describing individual settings that will be persisted.
                     */
                    metadata?: {
                        [key: string]: SettingMetadata;
                    };
                };
            }
            /**
             * Metadata describing one setting of the Blade/Part's persisted settings.
             */
            interface SettingMetadata {
                /**
                 * Specifies whether this setting is one that can be shared across different Part and Blade types (that is, isn't used by a
                 * single Part or Blade type).  If not supplied, a default value of 'false' will be used.
                 */
                isSharedAcrossPartAndBladeTypes?: boolean;
                /**
                 * When 'isSharedAcrossPartAndBladeTypes' is 'true', this is the key under which the setting will be saved.  This key will
                 * be used in the different Parts and Blades that share the setting value.
                 */
                sharedKey?: string;
            }
            /**
             * The scope at which the Blade/Part's settings are persisted.
             */
            const enum SettingsScope {
                /**
                 * The settings are saved under a single key for all instances of the associated Blade/Part.
                 */
                PerPartOrBladeType = 0,
                /**
                 * The settings are saved under a discrete key for each 'id' with which the associated Blade/Part
                 * is rendered.  For instance, the 'Freezing Fog' website would have different settings values than those of the
                 * 'Jasmine Dancer' website on the 'WebsiteDetails' Blade.
                 */
                PerId = 1
            }
            /**
             * Context injected by the FX into the view model.  This context will include a 'configuration' (the
             * Blade/Part's configuration API) as well as 'parameters' and 'settings' (the
             * Blade/Part's persisted settings values).
             */
            interface Context<TSettings> {
                /**
                 * The persisted settings values.
                 */
                settings: TSettings;
            }
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a Blade/Part class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the Blade/Part's view."
         */
        function ProxiedMember(target: Object, key: string): void;
        /**.
         * The Part 'Container' API for all variations of Parts. It's through this API that extensions
         * can interact with the Part's chrome UI.
         */
        type AnyContainer = BladeBase.AnyBladeContainer | PartBase.AnyPartContainer;
    }
}

// FILE: Fx\Controls\Accordion.d.ts
declare module "Fx/Controls/Accordion" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring an accordion control
     */
    export interface Options {
        /**
         * Specifies whether the user can open multiple sections or not.
         * Set to false by default.
         * If canExpandMultipleSections = false and > 1 sections are initialized with `expanded = true`, only the 1st section will be expanded
         */
        canExpandMultipleSections?: boolean;
        /**
         * Specifies whether the user can make all the sections be closed at once. Allows collapsing the active section.
         * Set to false by default.
         * If canCollapseAllSections = false and no section is initialized with `expanded = true`, will expand the 1st section.
         *
         * 'canExpandMultipleSections' and 'canCollapseAllSections' used together exhibit the following behavior:
         * canExpandMultipleSections = true ; canCollapseAllSections = true ;  =>  Expand / collapse with no limitations.
         * canExpandMultipleSections = true ; canCollapseAllSections = false;  =>  At least one section expanded, can have more than one sections expanded.
         * canExpandMultipleSections = false; canCollapseAllSections = true ;  =>  At most one section expanded, can have all sections collapsed.
         * canExpandMultipleSections = false; canCollapseAllSections = false;  =>  Always have exact one section expanded.
         */
        canCollapseAllSections?: boolean;
        /**
         * Disabled state
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Visibility of the control
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Styling for the control
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * No border style for Accordion. Set to false by default.
         */
        noFxPadding?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sections for your accordion control.
         */
        sections: Section[] | KnockoutObservableArray<Section>;
    }
    /**
     * The interface that defines the viewmodel that respresents an Accordion.
     */
    export interface Contract extends Control {
        /**
         * Disabled state
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Visibility of the control
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Styling for the control
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Aria label for control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * No border style for Accordion. Set to false by default.
         */
        readonly noFxPadding: KnockoutObservableBase<boolean>;
        /**
         * Sections for your accordion control.
         */
        readonly sections: KnockoutObservableArray<Section>;
    }
    /**
     * Creates an Accordion control viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the accordion.
     *
     * @returns an Accordion viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    /**
     * Options for a Section in Accordion control
     */
    export interface SectionOptions {
        /**
         * The open / collapse status of the section, Default is false.
         */
        expanded?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Header title for your section.
         * Can be a HTML template.
         */
        title: string | Control | HtmlContent | KnockoutObservableBase<string | Control | HtmlContent>;
        /**
         * Content for your section.
         * Can also be a HTML template.
         * Can be a Q.Promise.
         */
        content: string | Control | HtmlContent | KnockoutObservableBase<string | Control | HtmlContent> | Q.Promise<string | HtmlContent>;
    }
    /**
     * The interface that defines the viewmodel that respresents a Section.
     */
    export interface Section {
        /**
         * The open / collapse status of the section
         */
        readonly expanded: KnockoutObservableBase<boolean>;
        /**
         * Header title for your section.
         */
        readonly title: KnockoutObservableBase<string | Control | HtmlContent>;
        /**
         * Content for your section.
         */
        readonly content: KnockoutObservableBase<string | Control | HtmlContent>;
    }
    /**
     * Creates a Section viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the Section.
     *
     * @returns a Section viewmodel
     */
    export function createSection(lifetime: MsPortalFx.Base.LifetimeManager, options: SectionOptions): Section;
}

// FILE: Fx\Controls\AreaChart.d.ts
declare module "Fx/Controls/AreaChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export import ChartEvents = ChartBase.ChartEvents;
    export import ConditionOperator = ChartBase.ConditionOperator;
    export import Interpolation = ChartBase.Interpolation;
    export import RenderingCondition = ChartBase.RenderingCondition;
    export { FxChartColorClass };
    /**
     * Supported area chart types.
     */
    export const enum AreaChartType {
        /**
         * Overlapping area chart
         */
        Overlapped = 0,
        /**
         * Stacked area chart.
         */
        Stacked = 1
    }
    /**
     * Display options for showing the line and data points for stacked area charts.
     */
    export const enum LineState {
        /**
         * Display stacked area chart line with coordinate points.
         */
        ShowLineWithPoints = 0,
        /**
         * Hide stacked area chart line.
         */
        HideLine = 1,
        /**
         * Display stacked area chart line with the point nearest to x slider only.
         */
        ShowLineWithXHoverPoint = 2
    }
    /**
     * View options to customize how series should be displayed.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Defines the hatching pattern type for the series.
         * Default is solid color without any hatch patterns.
         */
        readonly areaHatchingPattern?: Pattern;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        readonly renderingConditions?: RenderingCondition[];
        /**
         * Indicates if the series is selectable.
         * By default, the area is selectable and selectable styling is shown. To disallow selecting the area, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the area is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Defines the interpolation type for the series.
         * By default the interpolation is Linear and the data points will be connected by straight lines.
         */
        readonly interpolation?: Interpolation;
        /**
         * Indicates if the series is hidden from the legend.
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Options for configuring a AreaChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis properties of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis properties of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * Specify if area chart should be stacked or overlapped.
         */
        readonly areaChartType?: AreaChartType | KnockoutObservableBase<AreaChartType>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking area charts.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Whether to show lines for the StackedArea charts.
         */
        readonly lineState?: LineState | KnockoutObservableBase<LineState>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the area chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * AreaChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Specify if area chart should be stacked or overlapped.
         */
        readonly areaChartType: KnockoutObservableBase<AreaChartType>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking area charts.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries: KnockoutObservableBase<boolean>;
        /**
         * Whether to show lines for the StackedArea charts.
         */
        readonly lineState: KnockoutObservableBase<LineState>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the area chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @return A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Q.Promise;
    }
    /**
     * Creates a AreaChart control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a AreaChart control viewmodel
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\ArmErrorList.d.ts
declare module "Fx/Controls/ArmErrorList" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The data contract for errors coming from ARM.
     */
    export interface ArmError {
        /**
         * The error code.
         */
        code?: string;
        /**
         * The error message.
         */
        message?: string;
        /**
         * The target of the error. Typically, this is a ARM resource name.
         */
        target?: string;
        /**
         * The nested ARM errors.
         */
        details?: ArmError[];
        /**
         * The additional information.
         */
        additionalInfo?: ErrorDetails[];
        /**
         * Optional custom HTML view for the error. If supplied, the control will display the view as it is for the error.
         * This is useful when the extension needs to show the error formatted in a custom way.
         */
        customHtml?: HtmlContent;
        /**
         * The recommended action.
         * This property is not defined in ARM error contract, but some errors contain this.
         */
        recommendedAction?: string;
    }
    /**
     * The error type and information.
     */
    export interface ErrorDetails {
        /**
         * The error type.
         */
        type: string;
        /**
         * The details of error type.
         */
        info?: any;
    }
    /**
     * Error specific options.
     */
    export interface ErrorOptions {
        /**
         * Options for policy error.
         */
        readonly policyError: PolicyErrorOptions;
    }
    /**
     * Options for policy error.
     */
    export interface PolicyErrorOptions {
        /**
         * Main error target. Used to deduplicate policy errors when errors have multiple targets.
         */
        readonly mainTarget?: string;
        /**
         * Callback when the link to policy assignment is clicked.
         */
        readonly onViewPolicyAssignmentClick?: (policyAssignmentId: string) => void;
    }
    /**
     * Options for configuring a ArmErrorList control.
     */
    export interface Options {
        /**
         * The ARM error.
         */
        readonly error: ArmError | KnockoutReadOnlyObservable<ArmError>;
        /**
         * Error specific options.
         */
        readonly errorOptions?: ErrorOptions;
        /**
         * The value indicating whether the root error needs to be hidden or not. The root error is the top error in the given error object.
         * The default value is false.
         */
        readonly hideRootError?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the copy button needs to be hidden or not.
         * The default value is false.
         */
        readonly hideCopyButton?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the feedback area needs to be hidden or not.
         * The default value is false.
         */
        readonly hideFeedback?: boolean;
        /**
         * The value indicating whether the error details need to show only leaf errors or not.
         * The default value is false.
         */
        readonly showLeafErrorsOnly?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ArmErrorList control view model.
     */
    export interface Contract extends Control {
        /**
         * The ARM  error.
         * This property is read-only. To mutate, change the value of the error property provided in the ArmErrorList options.
         */
        readonly error: KnockoutReadOnlyObservable<ArmError>;
        /**
         * The value indicating whether the root error needs to be hidden or not. The root error is the top error in the given error object.
         * The default value is false.
         */
        readonly hideRootError: KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the copy button needs to be hidden or not.
         * The default value is false.
         */
        readonly hideCopyButton: KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the error details need to show only leaf errors or not.
         * The default value is false.
         */
        readonly showLeafErrorsOnly: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a ArmErrorList control.
     *
     * @param lifetime The lifetime manager for the ArmErrorList control.
     * @param options The options for creating the ArmErrorList control.
     * @returns The created ArmErrorList control.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\BarChart.d.ts
declare module "Fx/Controls/BarChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export { FxChartColorClass };
    /**
     * Supported bar chart types.
     */
    export const enum BarChartType {
        /**
         * The data series will be rendered as stacked bars for each x value.
         */
        Stacked = 0,
        /**
         * The data series will be rendered as grouped bars for each x value.
         */
        Grouped = 1
    }
    /**
     * Defines the date span used for spacing the bars.
     */
    export interface DateSpanOptions {
        /**
         * The number of years in the span.
         */
        readonly years?: number;
        /**
         * The number of months in the span.
         */
        readonly months?: number;
        /**
         * The number of days in the span.
         */
        readonly days?: number;
        /**
         * The number of hours in the span.
         */
        readonly hours?: number;
        /**
         * The number of minutes in the span.
         */
        readonly minutes?: number;
        /**
         * The number of seconds in the span.
         */
        readonly seconds?: number;
        /**
         * The number of milliseconds in the span.
         */
        readonly milliseconds?: number;
    }
    /**
     * This base interface defines the how a series should be rendered on the chart.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Indicates if the series is selectable.
         * By default, the bar is selectable and selectable styling is shown. To disallow selecting the bar, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the bar is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Indicates if the series is hidden from the legend
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Users can optionally provide event handler callbacks for all or subset of events.
     */
    export interface ChartEvents<TX, TY> {
        /**
         * Event handler for mouse click on the plot area.
         *
         * Event callback.
         * @param x The pixel value of x coordinate
         * @param y The pixel value of y coordinate.
         * @param xValue The x axis value at the x coordinate.
         * @param yValue The y axis value at the y coordinate.
         */
        readonly plotAreaClick?: (x: number, y: number, xValue: TX, yValue: TY) => void;
        /**
         * Event handler for click on a point.
         *
         * Event callback.
         * @param data EventData with clicked seriesName and the x, y value to the clicked point.
         */
        readonly pointClick?: (data: EventData<TX, TY>) => void;
    }
    /**
     * Options for configuring a BarChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A padding ratio which is relative to bar size. The ratio will be used to specify padding between two bars and the bar width.
         */
        readonly barPaddingRatio?: number | KnockoutObservableBase<number>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        readonly barChartType?: BarChartType | KnockoutObservableBase<BarChartType>;
        /**
         * The span for the x-axis. For bar chart with close data points, bars may over lap. A granular span can be specified to avoid bar overlaps.
         */
        readonly xAxisSpan?: DateSpanOptions | KnockoutObservableBase<DateSpanOptions>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the bar chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * BarChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries: KnockoutObservableBase<boolean>;
        /**
         * A padding ratio which is relative to bar size. The ratio will be used to specify padding between two bars and the bar width.
         */
        readonly barPaddingRatio: KnockoutObservableBase<number>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        readonly barChartType: KnockoutObservableBase<BarChartType>;
        /**
         * The span for the x-axis. For bar chart with close data points, bars may over lap. A granular span can be specified to avoid bar overlaps.
         */
        readonly xAxisSpan: KnockoutObservableBase<DateSpanOptions>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the bar chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @return A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Q.Promise;
    }
    /**
     * Creates a BarChart control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a BarChart control viewmodel.
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\BaseResourceDropDown.d.ts
declare module "Fx/Controls/BaseResourceDropDown" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { CustomV, Required, ValidationResult } from "Fx/Controls/Validations";
    import { Item as MarketplaceItem } from "Fx/ResourceManagement/Marketplace";
    import { Location as ArmLocation, ResourceGroup as ArmResourceGroup } from "Fx/ResourceManagement";
    export = Main;
    module Main {
        import FxAzure = MsPortalFx.Azure;
        /**
         * The validations accepted by the resource dropdowns.
         */
        type Validation<TValue> = CustomV<TValue> | Required;
        /**
         * Interface for grouping with text group headers.
         */
        interface Group<TValue, THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> {
            /**
             * A function which takes an item and returns the display name of the group it will belong to.
             * @param item An object of the type for this dropdown.
             * @returns The display name for the group it belongs to. If empty, item will be on top level of the dropdown.
             */
            map: (item: TValue) => THtmlKeyMap extends StringMap<HtmlContent> ? keyof THtmlKeyMap : string;
            /**
             * A comparator to display the groups in the order desired (does not sort values within groups).
             */
            sort?: Comparator<THtmlKeyMap extends StringMap<HtmlContent> ? keyof THtmlKeyMap : string>;
            /**
             * A StringMap used to look up HtmlContent object for each of the groups returned from the map function.
             */
            mapToHtml?: THtmlKeyMap;
        }
        /**
         * The options accepted by all resource dropdowns.
         */
        interface Options<TValue, THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> {
            /**
             * A custom css class to apply to the control.
             */
            cssClass?: string | KnockoutObservableBase<string>;
            /**
             * The label of the control.
             */
            label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
            /**
             * Aria label for group.
             */
            ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * Turn filtering on/off. Default is on.
             */
            filter?: boolean;
            /**
             * Sets the filter TextBoxs placeholder text.
             * Default is blank.
             */
            filterPlaceholder?: string;
            /**
             * Sets the DropDowns placeholder text.
             * This is the placeholder if `filter` is set to false.
             * Default is blank.
             */
            placeholder?: string;
            /**
             * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
             */
            suppressDirtyBehavior?: boolean;
            /**
             * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
             */
            value?: TValue | KnockoutObservableBase<TValue>;
            /**
             * Validations on the control.
             */
            validations?: Validation<TValue>[] | KnockoutObservableBase<Validation<TValue>[]>;
            /**
             * Sanitized html string shown in the info balloon popup.
             */
            infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
            /**
             * Aria label for the info balloon anchor.
             */
            infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
            /**
             * An object which will hide values.
             */
            hiding?: {
                /**
                 * A callback for to determine if an item is hidden.
                 * @param item An object of the type for this dropdown.
                 * @returns A flag for if the item should be hidden.
                 */
                hide(item: TValue): boolean;
                /**
                 * A message explaining why values are hidden.
                 */
                reason: string;
            };
            /**
             * An object which will map values to groups and sort the groups.
             */
            grouping?: Group<TValue, THtmlKeyMap>;
            /**
             * A callback which will disable an item if a reason is returned to disable it.
             * Values will be grouped by the reason the item is disabled.
             * @param item An object of the type for this dropdown.
             * @return The reason this item is disabled. If empty the item will be enabled.
             */
            disable?(item: TValue): string;
            /**
             * A comparator to display the values in the order desired (does not sort groups if you have any, will sort within groups).
             */
            sort?: Comparator<TValue>;
            /**
             * A function called which will be passed a readonly array of values when fetched.
             */
            onFetchedValues?: (fetchedValues: TValue[]) => void;
        }
        /**
         * The contract all resource dropdowns fulfill
         */
        interface Contract<TValue> extends Control {
            /**
             * A custom css class to apply to the control.
             */
            readonly cssClass: KnockoutObservableBase<string>;
            /**
             * The dirty state of the control. This will only change when the user performs an action to change the value, or the dirty state is set explicitly by the extension.
             */
            readonly dirty: KnockoutObservableBase<boolean>;
            /**
             * The validation state of the control.
             */
            readonly valid: KnockoutReadOnlyObservableBase<boolean>;
            /**
             * The label of the control.
             */
            readonly label: KnockoutObservableBase<string | HtmlContent>;
            /**
             * validations on the control.
             */
            readonly validations: KnockoutObservableArray<Validation<TValue>>;
            /**
             * Latest validation results.
             */
            readonly validationResults: KnockoutReadOnlyObservableArray<ValidationResult>;
            /**
             * The disabled state of the control.
             */
            readonly disabled: KnockoutObservableBase<boolean>;
            /**
             * Triggers validation on this control when called.  Returns a promise that resolves once validation on this control has completed.
             */
            readonly triggerValidation: () => Q.Promise<boolean>;
            /**
             * the value of the control.
             */
            readonly value: KnockoutObservableBase<TValue>;
            /**
             * The available values for the control.
             */
            readonly fetchedValues: KnockoutReadOnlyObservableArray<TValue>;
            /**
             * Indicates that the control is in a loading state.  When in the loading state, the control will be disabled and have the text "Loading..." shown.
             */
            readonly loading: KnockoutReadOnlyObservable<boolean>;
        }
        /**
         * Subscription dropdown interfaces.
         */
        module Subscription {
            import FxGalleryItem = MsPortalFx.Services.Gallery.GalleryItem;
            import ResourceManager = FxAzure.ResourceManager;
            import RequiredPermissions = FxAzure.RequiredPermissions;
            import Subscription = FxAzure.Subscription;
            /**
             * Options for the legacy dropdown which doesn't have the property initialSubscriptionId.
             */
            interface BaseOptions<THtmlKeyMap extends StringMap<HtmlContent>> extends Main.Options<Subscription, THtmlKeyMap> {
                /**
                 * The gallery item to validate against.
                 */
                filterByGalleryItem?: FxGalleryItem | ResourceManager.GalleryItemExtract | MarketplaceItem<any> | KnockoutObservableBase<FxGalleryItem | ResourceManager.GalleryItemExtract | MarketplaceItem<any>>;
                /**
                 * The list of required permissions the subscription must have. (If you need to check.
                 * for resource provider registration permissions, use the 'resourceProviders' option.
                 * instead.)
                 */
                requiredPermissions?: RequiredPermissions | KnockoutObservableBase<RequiredPermissions>;
                /**
                 * A list of resource providers that the
                 * subscription needs to be registered with. Providing the list will NOT register
                 * the subscription with the resource provider, but will only check if the user has
                 * the necessary permissions to register them (only if they aren't registered already).
                 */
                resourceProviders?: string[] | KnockoutObservableBase<string[]>;
            }
            /**
             * Options for the subscription dropdown.
             */
            interface Options<THtmlKeyMap extends StringMap<HtmlContent>> extends BaseOptions<THtmlKeyMap> {
                /**
                 * The initial subscription id to be set as a default value for the dropdown if it's a member of the values fetched from ARM.
                 * Create Blades will receive this value on the blades context e.g. `this.context.provisioning.initialValues.subscriptionIds`.
                 * If an array is passed here, the first item in the array which is is a member of the values fetched from ARM will be used.
                 */
                initialSubscriptionId: string | string[] | KnockoutObservableBase<string | string[]>;
                /**
                 * A custom fetch callback to replace the network call for loading items into the dropdown.
                 */
                customFetch?(): Q.Promise<Subscription[]>;
            }
            /**
             * This is the contract for the subscription dropdown.
             */
            interface Contract extends Main.Contract<Subscription> {
            }
        }
        /**
         * Location dropdown interfaces module.
         */
        module Location {
            import Subscription = FxAzure.Subscription;
            /**
             * Options for the legacy dropdown which doesn't have properties initialLocationName and subscriptionId
             */
            type BaseOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = Main.Options<ArmLocation, THtmlKeyMap>;
            /**
             * Options for the location dropdown.
             */
            interface Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends BaseOptions<THtmlKeyMap> {
                /**
                 * The initial location name to be set as a default value for the dropdown if it's a member of the values fetched from ARM.
                 * Create Blades will receive this value on the blades context e.g. `this.context.provisioning.initialValues.locationNames`.
                 * If an array is passed here, the first item in the array which is is a member of the values fetched from ARM will be used.
                 */
                initialLocationName: string | string[] | KnockoutObservableBase<string | string[]>;
                /**
                 * The subscription used to look up available locations if provided.
                 * Otherwise, defaults to locations available to the current tenant.
                 */
                subscriptionId?: KnockoutObservableBase<string | Subscription>;
                /**
                 * The scope used to look up available locations if subscriptionId is not provided.
                 * Defaults to locations available to the current tenant.
                 */
                scope?: KnockoutObservableBase<string>;
                /**
                 * Optional. The observable that holds the list of resource types used to filter locations.
                 */
                resourceTypes?: string[] | KnockoutObservableBase<string[]>;
                /**
                 * A custom fetch callback to replace the network call for loading items into the dropdown.
                 */
                customFetch?(): Q.Promise<ArmLocation[]>;
            }
            /**
             * Options for the location dropdown with additional locations.
             */
            interface CustomOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends Options<THtmlKeyMap> {
                /**
                 * A callback to customize which locations are in the dropdown.
                 * @param locs The locations retrieved from ARM.
                 * @return A list of locations to be displayed in the dropdown.
                 */
                customizeItems?: (locs: ArmLocation[]) => ArmLocation[];
            }
            /**
             * This is the contract for the location dropdown.
             */
            interface Contract extends Main.Contract<ArmLocation> {
            }
        }
        /**
         * ResourceGroup dropdown interfaces module.
         */
        module ResourceGroup {
            import RequiredPermissions = FxAzure.RequiredPermissions;
            import Subscription = FxAzure.Subscription;
            /**
             * The modes possible for the dropdown.
             */
            const enum Mode {
                UseExisting = 0,
                CreateNew = 1,
                Both = 2
            }
            /**
             * The mode of the value returned by the control
             */
            type SelectedMode = Mode.CreateNew | Mode.UseExisting;
            /**
             * The ARM resource group value.
             */
            type ResourceGroup = ArmResourceGroup;
            /**
             * The value of the resource group dropdown.
             */
            interface Value {
                /**
                 * The mode of the dropdown, create new or use existing.
                 */
                mode: SelectedMode;
                /**
                 * The ARM value for the resource group.
                 */
                value: ResourceGroup;
            }
            /**
             * Options for the resource group dropdown.
             */
            interface Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends BaseOptions<THtmlKeyMap> {
                /**
                 * The initial resourceGroupId to be set as a default value for the dropdown if it's an existing resource group in the dropdown.
                 * Create Blades will receive this value on the blades context e.g. `this.context.provisioning.initialValues.resourceGroupNames`.
                 * If an array is passed, will select the first available in the list.
                 */
                initialResourceGroupName?: string | string[] | KnockoutObservableBase<string | string[]>;
                /**
                 * The subscription used to look up available resource groups.
                 */
                subscriptionId: KnockoutObservableBase<string | Subscription>;
                /**
                 * A custom fetch callback to replace the network call for loading items into the dropdown.
                 */
                customFetch?(): Q.Promise<ResourceGroup[]>;
                /**
                 * If true, the control will shift to the right with a line indicating a parent/child relationship with the item above it. Defaults to false.
                 * This option overrides any class provided in the cssClass option.
                 */
                nested?: boolean;
            }
            /**
             * Options for the legacy dropdown (which doesn't have 'initialResourceGroupName' and 'subscriptionId' properties).
             */
            interface BaseOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends Main.Options<Value, THtmlKeyMap> {
                /**
                 * The list of required permissions the subscription must have.
                 */
                requiredPermissions?: RequiredPermissions | KnockoutObservableBase<RequiredPermissions>;
                /**
                 * The mode allowed for the resource group dropdown.
                 */
                allowedMode?: Mode | KnockoutObservableBase<Mode>;
                /**
                 * Sets the placeholder.
                 * Default is blank.
                 */
                createNewPlaceholder?: string | KnockoutObservableBase<string>;
            }
            /**
             * This is the contract for the resource group dropdown.
             */
            interface Contract extends Main.Contract<Value> {
                /**
                 * Set which mode the dropdown is in, create or use existing.
                 */
                switchMode(mode?: SelectedMode): void;
            }
        }
    }
}

// FILE: Fx\Controls\Batch\HeatMap.d.ts
declare module "Fx/Controls/Batch/HeatMap" {
    /**
     * Represent an item in the heatMap
     */
    export interface Item {
        /**
         * Id of an item in the heatmap. This NEED to be unique.
         */
        id: string;
        /**
         * State of the item
         */
        state: string;
        /**
         * Optional setting to make the item less opaque on the heatmap.
         * Default: 1
         */
        opacity?: number;
    }
    /**
     * Possible position of the legend relative to the heatmap.
     * i.e. LegendLocation.Left means the legend will be on the left of the heatmap.
     *
     * LegendLocation.None will not show the legend
     */
    export enum LegendLocation {
        None = 0,
        Top = 1,
        Right = 2,
        Bottom = 3,
        Left = 4
    }
    /**
     * Represent a possible state an item can have
     */
    export interface State {
        /**
         * State id, Item added to the Heatmap should have their state match this id
         */
        id: string;
        /**
         * Label for the legend
         */
        label: KnockoutObservableBase<string>;
        /**
         * Color the tile with this state will have
         */
        color: MsPortalFx.ColorUtil.ColorCode;
        /**
         * Color opacity
         * @default 1
         */
        opacity?: number;
    }
    export interface Options {
        /**
         * Message to be displayed in the heatmap if the item list is empty
         */
        noItemsMessage?: KnockoutObservableBase<string>;
        /**
         * List of available states. Every state that might be used in an item later on should be here.
         */
        states?: State[];
        /**
         * When one of the item has a state not defined in the lis_t above it will use this color
         */
        unknownStateColor?: MsPortalFx.ColorUtil.ColorCode;
        /**
         * Enable selection on the heatmap
         * @default true
         */
        isSelectable?: boolean;
        /**
         * If the heatmap control should expand automatically if the number of items don't fit in the initial window
         * @default false
         */
        isExpandable?: boolean;
        /**
         * Minimum number of pixel a tile side can be in the heatmap
         * Cannot be less that 1
         * @default 10
         */
        minTileSize?: number;
        /**
         * Maximum number of pixel a tile side can be in the heatmap
         * @default 100
         */
        maxTileSize?: number;
        /**
         * Legend location relative to the heatmap.
         * None will not show the legend.
         * @default Right
         */
        legendLocation?: KnockoutObservableBase<LegendLocation>;
    }
    export interface ItemListDiff {
        added: Item[];
        updated: Item[];
        removed: Item[];
    }
    export class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel {
        states: State[];
        unknownStateColor: MsPortalFx.ColorUtil.ColorCode;
        noItemsMessage: KnockoutObservableBase<string>;
        errorMessage: string;
        minTileSize: number;
        maxTileSize: number;
        /**
         * Enable selection on the heatmap
         * @default true
         */
        isSelectable: boolean;
        /**
         * If the heatmap control should expand automatically if the number of items don't fit in the initial window
         * @default false
         */
        isExpandable: boolean;
        /**
         * Cache of the items used to compute the edits
         */
        private itemMap;
        /**
         * Legend location relative to the heatmap.
         * None will not show the legend.
         * @default Right
         * @see LegendOptions
         */
        legendLocation: KnockoutObservableBase<LegendLocation>;
        /**
         * Internal mapping of state by ID.
         * Used in the widget.
         */
        stateMap: StringMap<State>;
        /**
         * Internal callback that will pass the difference of items everytime setItems is called
         */
        _msPortalFxUpdateCallback: KnockoutObservable<(diffs: ItemListDiff) => void>;
        /**
         * Internal update to ask for a canvas redraw
         */
        _msPortalFxUpdateCanvas: KnockoutObservableBase<number>;
        /**
         * Observable containing the currently selected item.
         * Seleletable must be set to true in the options for this to be updated
         */
        selectedItem: KnockoutObservable<Item>;
        selectable: MsPortalFx.ViewModels.Selectable<Item>;
        /**
         * Buffer for to keep the last setItems args until the implementation set the callback
         */
        private _lastItemsBuffer;
        private defaultOptions;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        setItems(items: Item[]): void;
        /**
         * Force a render of the heatmap.
         * Use this if you have enableAutoRendering to false.
         */
        render(): void;
        private _createStateMap;
        private _createItemMap;
        private _computeDifference;
    }
}

// FILE: Fx\Controls\Button.d.ts
declare module "Fx/Controls/Button" {
    import { BladeLink, ResourceLink, ClickableLink } from "Fx/Composition";
    import * as ControlBase from "Fx/Controls/ControlsBase";
    export import Image = ControlBase.Image;
    export import IconPosition = ControlBase.IconPosition;
    export import IconAndPosition = ControlBase.IconAndPosition;
    /**
     * Styling of the button
     */
    export const enum Style {
        /**
         * Primary button style (default).
         */
        Primary = 0,
        /**
         * Secondary button style.
         */
        Secondary = 1
    }
    /**
     * Options used to dynamically configure the button.
     */
    export interface Options {
        /**
         * Describes the behavior when the button is clicked.
         *
         * For non-navigation scenarios, a callback can be supplied.
         * For navigation scenarios, a modeled description of the navigation target can be supplied.
         * For navigation scenarios, the callback option should not be used,
         * as it breaks browser 'open in new tab' and 'copy link' support.
         */
        onClick: Function | BladeLink | ResourceLink | ClickableLink;
        /**
         * The text shown on the button.
         */
        text: string | KnockoutObservableBase<string>;
        /**
         * Style of the button.
         */
        style?: Style | KnockoutObservableBase<Style>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The alternate text for screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates that the control is in a loading state.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Loading text message.
         */
        loadingText?: string | KnockoutObservableBase<string>;
        /**
         * Icon shown in the button.
         */
        icon?: IconAndPosition | KnockoutObservableBase<IconAndPosition>;
    }
    /**
     * Button control.
     */
    export interface Contract extends ControlBase.Control {
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The text shown on the button.
         */
        readonly text: KnockoutObservableBase<string>;
        /**
         * Style of the button (Primary / Secondary).
         */
        readonly style: KnockoutObservableBase<Style>;
        /**
         * Whether the form element is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The alternate text for screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Loading status.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Loading text message.
         */
        readonly loadingText: KnockoutObservableBase<string>;
        /**
         * Icon shown in the button.
         */
        readonly icon: KnockoutObservableBase<IconAndPosition>;
    }
    /**
     * Creates a button control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a button viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\ChartBase.d.ts
declare module "Fx/Controls/ChartBase" {
    import { Contract as InfoBalloonContract } from "Fx/Controls/InfoBalloon";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    /**
     * Defines hatching patterns.
     */
    export const enum HatchingPattern {
        /**
         * The area is solid.
         */
        Solid = 0,
        /**
         * The area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The area is hatched with main diagonal (\) thin lines. Alternate name aligning with new enums - CounterDiagonalThinLine.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched with horizontal think lines. Alternate name aligning with new enums - HorizontalThickLine
         */
        DottedHatching = 3,
        /**
         * The area is hatched with main diagonal (\) thin lines.
         */
        MainDiagonalThinLine = 4,
        /**
         * The area is hatched with horizontal thin lines.
         */
        HorizontalThinLine = 5,
        /**
         * The area is hatched with vertical thin lines.
         */
        VerticalThinLine = 6,
        /**
         * The area is hatched with main diagonal (\) thick lines.
         */
        MainDiagonalThickLine = 7,
        /**
         * The area is hatched with counter diagonal (/) thick lines.
         */
        CounterDiagonalThickLine = 8,
        /**
         * The area is hatched with vertical thick lines.
         */
        VerticalThickLine = 9,
        /**
         * The area is hatched with main diagonal (\) lines in a smoothed out pattern.
         */
        MainDiagonalSmoothLine = 10,
        /**
         * The area is hatched with counter diagonal (/) lines in a smoothed out pattern.
         */
        CounterDiagonalSmoothLine = 11,
        /**
         * The area is hatched with horizontal lines in a smoothed out pattern.
         */
        HorizontalSmoothLine = 12,
        /**
         * The area is hatched with vertical lines in a smoothed out pattern.
         */
        VerticalSmoothLine = 13,
        /**
         * The area has square pattern.
         */
        Square = 14,
        /**
         * The area has diagonal square pattern.
         */
        DiagonalSquare = 15,
        /**
         * The area has circle pattern.
         */
        Circle = 16,
        /**
         * The area has quarter circle(quadrant) pattern.
         */
        Quadrant = 17
    }
    /**
     * Specifies the scale used on the axis.
     */
    export const enum Scale {
        /**
         * Specify this scale for discrete values where the values will be mapped 1:1 on the axis.
         */
        Ordinal = 0,
        /**
         * Specify this scale for continuous values like numeric values in the series which may or may not be sorted.
         */
        Linear = 1,
        /**
         * Specify this scale for date / time values in the series which may or may not be sorted.
         */
        Time = 2,
        /**
         * Logarithmic scale for numeric values
         */
        Log = 3
    }
    /**
     * Specifies conditions checked on rendering a series view.
     */
    export const enum ConditionOperator {
        /**
         * The view should be rendered for series segments exceeding the argument of the condition.
         */
        GreaterThan = 0,
        /**
         * The view should be rendered for series segments not exceeding the argument of the condition.
         */
        LessThan = 1
    }
    /**
     * Defines interpolation of lines of the line chart.
     */
    export const enum Interpolation {
        /**
         * The series interpolation when data points are connected by straight lines.
         */
        Linear = 0,
        /**
         * The series interpolation when data points are connected by smooth curves. The monotone is a mode of D3 interpolation style.
         */
        Monotone = 1,
        /**
         * The series interpolation when series are connected by two lines: the first one (from the left side) is horizontal and the second one is vertical.
         */
        StepAfter = 2
    }
    /**
     * Specifies the aggregation type of a metric rule.
     */
    export const enum MetricRuleAggregationType {
        /**
         * X-value of the point selected.
         */
        CurrentXValue = 0,
        /**
         * Y-value of the point selected.
         */
        CurrentYValue = 1,
        /**
         * Min of y-value of points selected.
         */
        MinY = 2,
        /**
         * Max of y-value of points selected.
         */
        MaxY = 3,
        /**
         * Average of y-value of points selected.
         */
        AverageY = 4,
        /**
         * Sum of y-value of points selected.
         */
        SumY = 5,
        /**
         * Count of points selected.
         */
        Count = 6,
        /**
         * Custom value.
         */
        CustomValue = 7
    }
    /**
     * Specifies the aggregation scope of a metric rule.
     */
    export const enum MetricRuleAggregationScope {
        /**
         * All selected series should be aggregated into a common metric.
         */
        AllTogether = 0,
        /**
         * All selected series should be aggregated with separate metrics.
         */
        AllSeparately = 1,
        /**
         * A metric should be aggregated over a single series.
         */
        SingleSeries = 2
    }
    /**
     * Specifies the scope of metrics rules.
     */
    export const enum MetricRuleScope {
        /**
         * The default scope if other rules are not specified.
         */
        Default = 0,
        /**
         * A single data point is in the scope.
         */
        Point = 2,
        /**
         * Multiple data points from the same series are in the scope.
         */
        MultiplePointsSingleSeries = 3,
        /**
         * Multiple data points from multiple series are in the scope.
         */
        MultiplePointsMultipleSeries = 4
    }
    /**
     * Specifies the display options for a single metric.
     */
    export interface Metric {
        /**
         * Specifies the aggregation scope of the rule.
         */
        readonly aggregationScope: MetricRuleAggregationScope;
        /**
         * Specifies the aggregation of the rule.
         */
        readonly aggregationType: MetricRuleAggregationType;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        readonly aggregationSeriesName?: string;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        readonly showBarColor?: boolean;
        /**
         * Specifies the color css for the metric bar. If nothing is specified, the color css from the current aggregation series will be used.
         */
        readonly colorCode?: string | FxChartColorClass;
        /**
         * Specifies the hatching pattern for the metric bar. If nothing is specified, the hatching pattern from the current aggregation series will be used.
         */
        readonly hatchingPattern?: HatchingPattern;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values if DateFormatOptions is not specified a built-in multi-formatter for dates will be used.
         * For number values if NumberFormatOptions is not specified a built-in format option with a min fraction 0 and max fraction 2 is used.
         */
        readonly formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions;
        /**
         * Specifies the metric title of the rule.
         */
        readonly title?: string;
        /**
         * Specifies the metric unit of the rule.
         */
        readonly unit?: string;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        readonly customValue?: KnockoutObservableBase<string>;
        /**
         * The default info balloon of the metric rule.
         */
        readonly defaultInfoBalloon?: InfoBalloonContract;
    }
    /**
     * Specifies options for defining a metric rule.
     */
    export interface MetricRule {
        /**
         * Specifies the scope of the rule.
         */
        readonly scope: MetricRuleScope;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        readonly scopeSeriesName?: string;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        readonly metrics: KnockoutObservableArray<Metric>;
    }
    export interface AxisOptions<T> {
        /**
         * Defines the type of the axis label.
         */
        readonly scale?: Scale | KnockoutObservableBase<Scale>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        readonly tickMarksCount?: number | KnockoutObservableBase<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        readonly showAxis?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        readonly showAxisLine?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        readonly showTickMarks?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        readonly showGridLines?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        readonly rotateLabel?: number | KnockoutObservableBase<number>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly xSliderFormatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly displayLabelFormatter?: string | KnockoutObservableBase<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly xSliderCalloutDisplayFormatter?: string | KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        readonly min?: T | KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        readonly max?: T | KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        readonly unit?: MsPortalFx.UnitConversion.Unit | KnockoutObservableBase<MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        readonly displaySIUnit?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        readonly autoScaleUnit?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the padding size for axis labels.
         */
        readonly labelPadding?: number | KnockoutObservableBase<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        readonly customAxisPadding?: number | KnockoutObservableBase<number>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        readonly reverseDomain?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If true, all the axis labels except the current slider value will be hidden.
         */
        readonly hideAxisLabelsOnXSliderHover?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Axis<T> {
        /**
         * Defines the type of the axis label.
         */
        readonly scale: KnockoutObservableBase<Scale>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        readonly tickMarksCount: KnockoutObservableBase<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        readonly showAxis: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        readonly showAxisLine: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        readonly showTickMarks: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        readonly showGridLines: KnockoutObservableBase<boolean>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        readonly rotateLabel: KnockoutObservableBase<number>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly displayLabelFormatter: KnockoutObservableBase<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        readonly min: KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        readonly max: KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        readonly unit: KnockoutObservableBase<MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        readonly displaySIUnit: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        readonly autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Defines the padding size for axis labels.
         */
        readonly labelPadding: KnockoutObservableBase<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        readonly customAxisPadding: KnockoutObservableBase<number>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        readonly reverseDomain: KnockoutObservableBase<boolean>;
        /**
         * If true, all the axis labels except the current slider value will be hidden.
         */
        readonly hideAxisLabelsOnXSliderHover: KnockoutObservableBase<boolean>;
    }
    /**
     * This interface defines a single data point for the chart.
     */
    export interface ChartItem<TX, TY> {
        /**
         * The X value for an item.
         */
        readonly xValue: TX;
        /**
         * The Y values for an item.
         */
        readonly yValue: TY;
    }
    /**
     * Specifies the condition used on rendering a series view.
     */
    export interface RenderingCondition {
        /**
         * The name of the series to be compared with.
         */
        readonly seriesName: string;
        /**
         * The condition operator.
         */
        readonly conditionOperator: ConditionOperator;
        /**
         * The interpolation for the series.
         */
        readonly interpolation: Interpolation;
    }
    /**
     * Specifies a array of selected chart items with in a series.
     */
    export interface SeriesSelection<TX, TY> {
        /**
         * Name of the series.
         */
        readonly seriesName: string;
        /**
         * The value of the selected chart item.
         */
        readonly values: ChartItem<TX, TY>[];
    }
    /**
     * Defines the event data associated with chart event notifications.
     */
    export interface EventData<TX, TY> {
        /**
         * Name of the series.
         */
        readonly seriesName: string;
        /**
         * The value of the current target element.
         */
        readonly value: ChartItem<TX, TY>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Users can optionally provide event handler callbacks for all or subset of events.
     */
    export interface ChartEvents<TX, TY> {
        /**
         * Event handler for mouse click on the plot area.
         *
         * Event callback.
         * @param x The pixel value of x coordinate
         * @param y The pixel value of y coordinate.
         * @param xValue The x axis value at the x coordinate.
         * @param yValue The y axis value at the y coordinate.
         */
        readonly plotAreaClick?: (x: number, y: number, xValue: TX, yValue: TY) => void;
        /**
         * Event handler for click on a point.
         *
         * Event callback.
         * @param data EventData with clicked seriesName and the x, y value to the clicked point.
         */
        readonly pointClick?: (data: EventData<TX, TY>) => void;
        /**
         * Event handler for click on a series.
         *
         * Event callback.
         * @param data EventData with clicked seriesName and optionally provides the x, y value if series was clicked on specific point.
         */
        readonly seriesClick?: (data: EventData<TX, TY>) => void;
    }
}

// FILE: Fx\Controls\ChartColor.d.ts
declare module "Fx/Controls/ChartColor" {
    /**
     * Supported chart color classes which represets color sequences with accessible contrast ratios.
     */
    export const enum FxChartColorClass {
        /**
         * Light theme: #0078d4
         * Dark theme: #0078d4
         */
        Color0 = "msportalfx-chart-color-0",
        /**
         * Light theme: #ef6950
         * Dark theme: #cb4936
         */
        Color1 = "msportalfx-chart-color-1",
        /**
         * Light theme: #00188f
         * Dark theme: #bedfff
         */
        Color2 = "msportalfx-chart-color-2",
        /**
         * Light theme: #00a2ad
         * Dark theme: #038387
         */
        Color3 = "msportalfx-chart-color-3",
        /**
         * Light theme: #4b003f
         * Dark theme:  #f6c0ff
         */
        Color4 = "msportalfx-chart-color-4",
        /**
         * Light theme: #e3008c
         * Dark theme: #d60084
         */
        Color5 = "msportalfx-chart-color-5",
        /**
         * Light theme: #022f22
         * Dark theme: #a4e1d2
         */
        Color6 = "msportalfx-chart-color-6",
        /**
         * Light theme: #917edb
         * Dark theme: #6e5db7
         */
        Color7 = "msportalfx-chart-color-7",
        /**
         * Light theme: #001d3f
         * Dark theme: #c7d3ff
         */
        Color8 = "msportalfx-chart-color-8",
        /**
         * Light theme: #502006
         * Dark theme: #ffca8a
         */
        Color9 = "msportalfx-chart-color-9",
        /**
         * Light theme: #00439b
         * Dark theme: #62b2ee
         */
        Color10 = "msportalfx-chart-color-10",
        /**
         * Light theme: #a32d21
         * Dark theme: #e89387
         */
        Color11 = "msportalfx-chart-color-11",
        /**
         * Light theme: #5a6bbc
         * Dark theme: #5493ba
         */
        Color12 = "msportalfx-chart-color-12",
        /**
         * Light theme: #006875
         * Dark theme: #61b9bc
         */
        Color13 = "msportalfx-chart-color-13",
        /**
         * Light theme: #895682
         * Dark theme: #aa72b3
         */
        Color14 = "msportalfx-chart-color-14",
        /**
         * Light theme: #a00055
         * Dark theme: #ed68ba
         */
        Color15 = "msportalfx-chart-color-15",
        /**
         * Light theme: #527c70
         * Dark theme: #439686
         */
        Color16 = "msportalfx-chart-color-16",
        /**
         * Light theme: #50419e
         * Dark theme: #aba0dc
         */
        Color17 = "msportalfx-chart-color-17",
        /**
         * Light theme: #667c97
         * Dark theme: #7188ba
         */
        Color18 = "msportalfx-chart-color-18",
        /**
         * Light theme: #936952
         * Dark theme: #af7f33
         */
        Color19 = "msportalfx-chart-color-19",
        /**
         * Light theme: #005eb8
         * Dark theme: #3195e1
         */
        Color20 = "msportalfx-chart-color-20",
        /**
         * Light theme: #c64d3d
         * Dark theme: #da6e5e
         */
        Color21 = "msportalfx-chart-color-21",
        /**
         * Light theme: #3449aa
         * Dark theme: #89b9dc
         */
        Color22 = "msportalfx-chart-color-22",
        /**
         * Light theme: #008792
         * Dark theme: #329ea2
         */
        Color23 = "msportalfx-chart-color-23",
        /**
         * Light theme: #733569
         * Dark theme: #d099d9
         */
        Color24 = "msportalfx-chart-color-24",
        /**
         * Light theme: #c10070
         * Dark theme: #e1349f
         */
        Color25 = "msportalfx-chart-color-25",
        /**
         * Light theme: #335c50
         * Dark theme: #73bcac
         */
        Color26 = "msportalfx-chart-color-26",
        /**
         * Light theme: #7160bc
         * Dark theme: #8c7fc9
         */
        Color27 = "msportalfx-chart-color-27",
        /**
         * Light theme: #334d6b
         * Dark theme: #9caddc
         */
        Color28 = "msportalfx-chart-color-28",
        /**
         * Light theme: #784e37
         * Dark theme: #d7a45f
         */
        Color29 = "msportalfx-chart-color-29",
        /**
         * Light theme: #01297f
         * Dark theme: #93cffb
         */
        Color30 = "msportalfx-chart-color-30",
        /**
         * Light theme: #810c06
         * Dark theme: #f7b8af
         */
        Color31 = "msportalfx-chart-color-31",
        /**
         * Light theme: #7e8fd7
         * Dark theme: #1f6c97
         */
        Color32 = "msportalfx-chart-color-32",
        /**
         * Light theme: #004a57
         * Dark theme: #90d4d7
         */
        Color33 = "msportalfx-chart-color-33",
        /**
         * Light theme: #b384ad
         * Dark theme: #893b8e
         */
        Color34 = "msportalfx-chart-color-34",
        /**
         * Light theme: #7e0039
         * Dark theme: #f89cd5
         */
        Color35 = "msportalfx-chart-color-35",
        /**
         * Light theme: #729d86
         * Dark theme: #127160
         */
        Color36 = "msportalfx-chart-color-36",
        /**
         * Light theme: #30237f
         * Dark theme: #c9c2ee
         */
        Color37 = "msportalfx-chart-color-37",
        /**
         * Light theme: #7e95b4
         * Dark theme: #466297
         */
        Color38 = "msportalfx-chart-color-38",
        /**
         * Light theme: #b18b72
         * Dark theme: #875908
         */
        Color39 = "msportalfx-chart-color-39",
        /** Color index sequence ends: Max chart color count = 40 */
        /**
         * Light theme: #015cda
         * Dark theme: #015cda
         */
        Info = "msportalfx-chart-color-info",
        /**
         * Light theme: #57a300
         * Dark theme: #57a300
         */
        Success = "msportalfx-chart-color-success",
        /**
         * Light theme: #db7500
         * Dark theme: #db7500
         */
        Warning = "msportalfx-chart-color-warning",
        /**
         * Light theme: #e00b1c
         * Dark theme: #e00b1c
         */
        Error = "msportalfx-chart-color-error",
        /**
         * Light theme: #8a8886
         * Dark theme: #8a8886
         */
        Disabled = "msportalfx-chart-color-disabled"
    }
}

// FILE: Fx\Controls\CheckBox.d.ts
declare module "Fx/Controls/CheckBox" {
    import { HtmlContent, OverflowMode } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Overflow Mode for text overflow
     */
    export { OverflowMode };
    /**
     * Options for configuring a checkbox control.
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria-label on the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * if set to true, the label will be placed to the right of the control
         */
        labelOnRight?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        overflowMode?: OverflowMode | KnockoutObservableBase<OverflowMode>;
    }
    /**
     * CheckBox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<boolean>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        readonly overflowMode: KnockoutObservableBase<OverflowMode>;
    }
    /**
     * Creates a checkbox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a checkbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\ComboBox.d.ts
declare module "Fx/Controls/ComboBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { BaseOptions, BaseContract, Item, Group } from "Fx/Controls/DropDown";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Describes an Item used for items in the ComboBox.
     */
    export { Item };
    /**
     * Describes a Group used for items in the ComboBox.
     */
    export { Group };
    /**
     * ComboBox control options.
     */
    export interface Options<TValue> extends BaseOptions<TValue> {
        /**
         * Callback when the user types into the ComboBox.
         * The extension is responsible for populating the ComboBox content based on the user inputted string.
         *
         * While pending we add a loading icon into the ComboBox.
         */
        onFilter?: (value: string) => Q.Promise<void>;
    }
    /**
     * ComboBox control view model.
     */
    export interface Contract<TValue> extends BaseContract<TValue> {
    }
    /**
     * Creates a ComboBox control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param items The items shown in the ComboBox.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a ComboBox control viewmodel.
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\Console.d.ts
declare module "Fx/Controls/Console" {
    import { Control } from "Fx/Controls/ControlsBase";
    import { LogItem, LogItemType } from "Fx/Controls/LogStream";
    export { LogItem, LogItemType };
    export interface Options {
        /**
         * Alternate text for screen reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Provides the text used for the CLI prompt.
         */
        prompt?: string | KnockoutObservableBase<string>;
        /**
         * callback called when the user enters input
         * console is the instance of the console created with these options, userInput is the string entered by the user
         */
        processCommand: (console: Contract, userInput: string) => void;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Contract extends Control {
        /**
         * Alternate text for screen reader, label for this log-stream
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Provides the text used for the CLI prompt.
         */
        readonly prompt: KnockoutObservableBase<string>;
        /**
         * Clears the console.
         */
        reset(): void;
        /**
         * Writes an entry to the console
         * @param entry The text to show in the control.  Passing in a LogItem or array of LogItems allows you to control the level of entry (error, warning, etc.)
         */
        log(entry: string | string[] | LogItem | LogItem[]): void;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a Console control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a Console control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\ControlsBase.d.ts
declare module "Fx/Controls/ControlsBase" {
    /**
     * Enum that defines the type of the control.
     */
    export import ControlType = MsPortalFx.ViewModels.ControlType;
    /**
     * Contract identifying a control as something that can be created via the pcControl binding.
     */
    export interface Control {
        /**
         * Enum that defines the type of the control.
         */
        readonly controlType: ControlType;
    }
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export interface HtmlContent {
        /**
         * The HTML template to display
         */
        htmlTemplate: string;
        /**
         * The object to bind to the template.
         */
        viewModel?: any;
    }
    /**
     * Overflow Mode for text overflow
     */
    export const enum OverflowMode {
        /**
         * Wrapping the overflow text
         */
        Wrap = 0,
        /**
         * Show Ellipsis for the overflow text
         */
        Ellipsis = 1
    }
    /**
     * Image interface
     */
    export import Image = MsPortalFx.Base.Image;
    export import IconPosition = MsPortalFx.ViewModels.Controls.SimpleButton.IconPosition;
    export import IconAndPosition = MsPortalFx.ViewModels.Controls.SimpleButton.IconAndPosition;
}

// FILE: Fx\Controls\CopyableLabel.d.ts
declare module "Fx/Controls/CopyableLabel" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Options {
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The readOnly property of the control.
         */
        readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Hides the textbox.  Used in scenarios where the copied text is not shown to the user.
         */
        hideTextbox?: boolean;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The number of lines in the textbox.
         */
        rows?: number;
        /**
         * The sub label of the control.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The value of the TextBox.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Contract extends Control {
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The readOnly property of the control.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * The label of the control.
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sub label of the control.
         */
        readonly subLabel: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The value of the TextBox.
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a copyableLabel control viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\CustomHtml.d.ts
declare module "Fx/Controls/CustomHtml" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for creating a custom html form control
     */
    export interface Options {
        /**
         * The html template to display as the body of the form.
         */
        htmlTemplate: string;
        /**
         * The object to bind to the template.
         */
        innerViewModel?: any;
        /**
         * Uses a new binding context for the template such that $root is innerViewModel instead of the blade/part view model.
         * Defaults to true.
         */
        isolated?: boolean;
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sub label of the control.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * Custom html control viewmodel
     */
    export interface Contract extends Control {
        /**
         * The label of the control.
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sub label of the control.
         */
        readonly subLabel: KnockoutObservableBase<string | HtmlContent>;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
    }
    /**
     * Creates a custom html control viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\DataGrid.d.ts
declare module "Fx/Controls/DataGrid" {
    import { Control, HtmlContent } from "Fx/Controls/ControlsBase";
    import { SelectionMode, SortDirection } from "Fx/Controls/GridBase";
    import * as ToolbarControl from "Fx/Controls/Toolbar";
    import { BladeReference } from "Fx/Composition/Selectable";
    import ToolbarItemContract = ToolbarControl.ToolbarItems.ToolbarItemContract;
    import { FxElement } from "Fx/Events";
    export { 
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    HtmlContent, 
    /**
     * DataGrid selection mode.
     */
    SelectionMode, 
    /**
     * DataGrid sort direction.
     */
    SortDirection, };
    /**
     * DataGrid column sort order.
     */
    export interface SortOrder {
        /**
         * The column id.
         */
        id: string;
        /**
         * The sort direction.
         */
        direction: SortDirection;
    }
    /**
     * DataGrid cell definition.
     */
    export interface CellDefinitionBase<TItem> {
        /**
         * The accessibility label for the cell.
         */
        ariaLabel?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
    }
    /**
     * Text cell definition.
     */
    export interface TextCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies the text to display in the cell.
         *
         * @param item The data item,
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A string or a value that is convertible to string or an observable containing the value.
         */
        text: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * Text column definition.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinition<TItem> extends TextColumnDefinitionOptions<TItem> {
        /**
         * Text column definition type.
         * A column that displays text in each cell.
         */
        type: "Text";
    }
    /**
     * Text column definition options.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A Text cell definition.
         */
        cell: TextCellDefinition<TItem>;
    }
    /**
     * Template cell definition.
     */
    export interface TemplateCellDefinition<TItem, TViewModel = any> extends CellDefinitionBase<TItem> {
        /**
         * The template used for all cells in the column.
         */
        template: string;
        /**
         * Supplies a viewmodel to bind with the template.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @param grid The grid.
         * @returns A view model or an observable containing the view model.
         */
        viewModel: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => TViewModel | KnockoutReadOnlyObservableBase<TViewModel>;
    }
    /**
     * Template column definition.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinition<TItem> extends TemplateColumnDefinitionOptions<TItem, any> {
        /**
         * Template column definition type.
         * A column that binds a view model to an HTML template in each cell.
         */
        type: "Template";
    }
    /**
     * Template column definition options.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinitionOptions<TItem, TViewModel = any> extends ColumnDefinitionBase<TItem> {
        /**
         * A Template cell definition.
         */
        cell: TemplateCellDefinition<TItem, TViewModel>;
    }
    /**
     * UriLink definition.
     */
    export interface UriLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the uri.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The link target.
         */
        target?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The link text.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
        /**
         * The URI to navigate to when the link is clicked.
         * A non-null URI will render a clickable link.
         * A null URI will render plain text that is not clickable.
         */
        uri: string | KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * UriLink cell definition.
     */
    export interface UriLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a UriLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A UriLink definition.
         */
        uriLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => UriLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * UriLink column definition.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinition<TItem> extends UriLinkColumnDefinitionOptions<TItem> {
        /**
         * UriLink column definition type.
         * A column that displays a URI link in each cell.
         */
        type: "UriLink";
    }
    /**
     * UriLink column definition options.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A UriLink cell definition.
         */
        cell: UriLinkCellDefinition<TItem>;
    }
    /**
     * BladeLink definition.
     */
    export interface BladeLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the bladeReference.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The blade reference for the link.
         * A non-null blade reference will render a clickable link.
         * A null blade reference will render plain text that is not clickable.
         * A blade reference that uses object-typed blade parameters or is too long will result in an href of "#" instead of a deep link.
         */
        bladeReference: BladeReference<unknown> | KnockoutReadOnlyObservableBase<BladeReference<unknown>>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * Text to display with link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * BladeLink cell definition.
     */
    export interface BladeLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a BladeLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A BladeLink definition.
         */
        bladeLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => BladeLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * BladeLink column definition.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinition<TItem> extends BladeLinkColumnDefinitionOptions<TItem> {
        /**
         * BladeLink column definition type.
         * A column that displays a link that opens a blade in each cell.
         */
        type: "BladeLink";
    }
    /**
     * BladeLink column definition options.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A BladeLink cell definition.
         */
        cell: BladeLinkCellDefinition<TItem>;
    }
    /**
     * ResourceLink definition.
     */
    export interface ResourceLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the resourceId.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The resource id to link to.
         * A non-null resource id will render a clickable link.
         * A null resource id will render plain text that is not clickable.
         */
        resourceId: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The resource kind to link to.
         */
        resourceKind?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * Overrides the default text determined from the resource id.
         *
         * You can use the getDisplayName utility function to generate a name that utilizes a hidden-title tag.
         *
         * text: ResourceName.getDisplayName({
         *     id: getResourceId(item),
         *     tags: getResourceTags(item),
         * }),
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * ResourceLink cell definition.
     */
    export interface ResourceLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a resource link definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A resource link definition.
         */
        resourceLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => ResourceLink;
        /**
         * Indicates to display the resource icon in the link.
         * Defaults to true.
         */
        showIcon?: boolean;
        /**
         * Indicates to display the preview badge on the resource icon in the link.
         * Defaults to true.
         * For preview blades you may set this to false if you find it too noisy to show these on every icon.
         * If you do hide the badging for a preview blade make sure the blade itself indicates it is preview.
         */
        showPreview?: boolean;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * ResourceLink column definition.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinition<TItem> extends ResourceLinkColumnDefinitionOptions<TItem> {
        /**
         * ResourceLink column definition type.
         * A column that displays a link that opens a resource in each cell.
         */
        type: "ResourceLink";
    }
    /**
     * ResourceLink column definition options.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A ResourceLink cell definition.
         */
        cell: ResourceLinkCellDefinition<TItem>;
    }
    /**
     * CustomLink definition.
     */
    export interface CustomLink {
        /**
         * Indicates if the link can be clicked.
         * The default is true.
         * Set to false to display the link as text that is not clickable.
         */
        canClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link use canClick.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The text to display in the link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * CustomLink cell definition.
     */
    export interface CustomLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a CustomLink definition to display a custom link in a cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A CustomLink definition.
         */
        customLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => CustomLink;
        /**
         * Callback to provide custom behavior for clicking on the link.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         *
         * @param item The data item.
         * @param row The row containing the data item.
         * @param target The framework element that was clicked on.
         */
        onClick?: (item: TItem, row: Row<TItem>, target: FxElement) => void;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * CustomLink column definition.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinition<TItem> extends CustomLinkColumnDefinitionOptions<TItem> {
        /**
         * CustomLink column definition type.
         * A column that displays a custom link in each cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         */
        type: "CustomLink";
    }
    /**
     * CustomLink column definition options.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A CustomLink cell definition.
         */
        cell: CustomLinkCellDefinition<TItem>;
    }
    /**
     * TagList cell definition.
     */
    export interface TagListCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Notification when an item tag has been clicked.
         *
         * @param item The item being clicked.
         * @param tagIndex The index of the tag being clicked.
         */
        onClick?: (item: TItem, tagIndex: number) => void;
        /**
         * Supplies the tags to display in a cell.
         *
         * @param lifetime The cell lifetime.
         * @param item The item to get tags for.
         * @param row The row containing the cell.
         * @returns The tags or an observable containing the tags.
         */
        tags: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string[] | KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * TagList column definition.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinition<TItem> extends TagListColumnDefinitionOptions<TItem> {
        /**
         * TagList column definition type.
         * A TagList column displays a list of strings as bubbled text in a cell.
         */
        type: "TagList";
    }
    /**
     * TagList column definition options.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A TagList cell definition.
         */
        cell: TagListCellDefinition<TItem>;
    }
    /**
     * DataGrid data node.
     */
    export interface DataNode<TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The unique id.
         * If the object identity of your items is changing this is required to allow
         * the grid to preserve selection and other UI state across refreshes.
         * Can be set to null if you do not have an identifier or do not care about preserving UI state.
         */
        id: TId;
        /**
         * The data item.
         */
        item: TItem;
        /**
         * The child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the child nodes when the children property is not set.
         * Allows for delayed loading of child items.
         *
         * @param parentNode The parent node.
         * @returns The child nodes or a promise for the child nodes.
         */
        getChildren?: (parentNode: DataNode<TItem, TId>) => DataNode<TItem, TId>[] | Q.Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * DataGrid group data node.
     * A group node is a parent node for all the children in the group.
     * A group node creates a group row with a single cell spanning the row to contains the group header.
     */
    export interface GroupNode<TGroup, TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The group unique id.
         */
        id: TId;
        /**
         * The group data item.
         */
        group: TGroup;
        /**
         * The group child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the group child nodes when the children property is not set.
         * Allows for asynchronous loading of group items.
         *
         * @param parentNode The parent node.
         * @returns The group child nodes or a promise for the group child nodes.
         */
        getChildren?: (parentNode: GroupNode<TGroup, TItem, TId>) => DataNode<TItem, TId>[] | Q.Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * Query parameters for the callback data source.
     */
    export interface CallbackDataSourceParams<TParams = any> {
        /**
         * Custom query parameters for the datasource.
         */
        params: TParams;
        /**
         * Indicates if the data source has been reset.
         * The data source may return uncached data in this case.
         */
        reset: boolean;
        /**
         * The requested sort order to return the data in.
         */
        sortOrder: SortOrder[];
    }
    /**
     * Result to return from the callback data source.
     */
    export type CallbackDataSourceResult<TItem, TGroup = any> = DataNode<TItem>[] | GroupNode<TGroup, TItem, any>[];
    /**
     * DataGrid callback data source.
     */
    export interface CallbackDataSource<TItem, TGroup = any, TParams = any> {
        /**
         * Callback to get the data items.
         *
         * @param queryParams Query parameters such as sort order for making the correct query.
         * @returns The data result or a promise for the result.
         */
        (queryParams: CallbackDataSourceParams<TParams>): CallbackDataSourceResult<TItem, TGroup> | Q.Promise<CallbackDataSourceResult<TItem, TGroup>>;
    }
    /**
     * Refresh options.
     */
    export interface RefreshOptions<TParams = any> {
        /**
         * Message to display while refreshing.
         */
        message?: string;
        /**
         * Custom query parameters to pass to the dataSource.
         */
        params?: TParams;
        /**
         * Indicates if the refresh should fully reset the grid data.
         * Typically used with a refresh command in the UI.
         * When reset the grid will clear selection and other UI state that may not apply with new data.
         * The data source should use this option to determine if cached data should be returned or not.
         * The default is false.
         */
        reset?: boolean;
    }
    /**
     * DataGrid column header definition.
     * The ColumnHeaderDefinition contains properties that are used to create a ColumnHeader
     * when constructing the grid or adding dynamic columns via grid.columnDefinitions.
     */
    export interface ColumnHeaderDefinition {
        /**
         * Aria label for the header.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column header text will be bold.
         * The default is determined by portal styling which can change.
         */
        bold?: boolean;
        /**
         * Content for the header.
         * The content can be a string, HTML content, or an observable that returns a string or HTML content.
         */
        content?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Indicates if the column header text will be in upper case.
         * The default is determined by portal styling which can change.
         */
        upperCase?: boolean;
    }
    /**
     * DataGrid column header.
     * Accessed by grid.columns()[index].header or grid.columns.get(id).header.
     */
    export interface ColumnHeader {
        /**
         * Aria label for the header.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Content for the header.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent>;
    }
    /**
     * DataGrid column definition.
     * The ColumnDefinition contains properties that are used to create a Column.
     */
    export type ColumnDefinition<TItem> = BladeLinkColumnDefinition<TItem> | CustomLinkColumnDefinition<TItem> | ResourceLinkColumnDefinition<TItem> | TagListColumnDefinition<TItem> | TemplateColumnDefinition<TItem> | TextColumnDefinition<TItem> | UriLinkColumnDefinition<TItem>;
    /**
     * DataGrid column definition common properties.
     */
    export interface ColumnDefinitionBase<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         * Defaults to true.
         */
        canResize?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         * Defaults to false.
         * When set to true the dataSource must implement sorting for it to work.
         */
        canSort?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The column header definition or text content.
         * For simple cases this can be a string.
         * To set additional column header properties provide a column header definition.
         */
        header?: string | ColumnHeaderDefinition;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        id?: string;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * Sort direction of the column.
         * Defaults to unsorted.
         */
        sortDirection?: SortDirection | KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        width?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         * Default is true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid column.
     * Part of the DataGrid object model.
     * Accessed by grid.columns.
     */
    export interface Column<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         */
        readonly canResize: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         */
        readonly canSort: KnockoutObservableBase<boolean>;
        /**
         * The column header.
         */
        readonly header: ColumnHeader;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        readonly id: string;
        /**
         * Sort direction of the column.
         */
        readonly sortDirection: KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        readonly width: KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid column collection.
     */
    export interface ColumnCollection<TItem> extends KnockoutReadOnlyObservableArray<Column<TItem>> {
        /**
         * Adds columns to the grid.
         * The columns are created from the supplied column definitions and inserted.
         *
         * @param columnDefinitions Array of column definitions create columns from.
         * @param index The index to insert the new columns in the columns collection.  If not specified the columns are added to the end.
         */
        add(columsDefinitions: ColumnDefinition<TItem>[], index?: number): void;
        /**
         * Gets a column by column id.
         * @param columnId The id of the column.
         * @returns The indicated column.
         */
        get(columnId: string): Column<TItem>;
        /**
         * Removes columns from the grid.
         *
         * @param ids The column ids of the columns to remove from the grid.
         * @returns The original column definitions used to create the columns.
         */
        remove(ids: string[]): ColumnDefinition<TItem>[];
        /**
         * Removes all columns from the grid.
         *
         * @returns The original column definitions used to create the columns.
         */
        removeAll(): ColumnDefinition<TItem>[];
    }
    /**
     * DataGrid cell.
     * Part of the DataGrid object model.
     * Accessed by row.cells()[index] or row.cells.get(columnId).
     */
    export interface Cell<TItem> {
        /**
         * Indicates if the cell is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The aria label for the cell.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The cell column.
         */
        readonly column: Column<TItem>;
    }
    /**
     * DataGrid row options.
     * Used to initialize new rows.
     */
    export interface RowDefinition<TItem> {
        /**
         * Supplies the accessibility label for the row.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The accessibility label.
         */
        ariaLabel?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the row disabled state.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The disabled state.
         */
        disabled?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => boolean | KnockoutObservableBase<boolean>;
        /**
         * The row height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
    }
    /**
     * DataGrid cell collection.
     */
    export interface CellCollection<TItem> extends KnockoutReadOnlyObservableArray<Cell<TItem>> {
        /**
         * Gets a cell by column id.
         * @param columnId The column id.
         * @returns The requested cell.
         */
        get(columnId: string): Cell<TItem>;
    }
    /**
     * DataGrid row.
     * Part of the DataGrid object model.
     */
    export interface Row<TItem> {
        /**
         * Indicates if the row is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The row accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The row cells.
         * A particular cell can be retrieved by column id cells.get(columnId).
         */
        readonly cells: CellCollection<TItem>;
        /**
         * Child rows.
         */
        readonly children: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The row disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is expanded.
         */
        readonly expanded: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * The data id.
         */
        readonly id: any;
        /**
         * The data item.
         */
        readonly item: TItem;
        /**
         * Indicates if the row is selected.
         */
        readonly selected: KnockoutReadOnlyObservable<boolean>;
    }
    /**
     * DataGrid row group definition.
     * Used to initialize new row groups.
     */
    export interface RowGroupDefinition<TGroup> {
        /**
         * Supplies the accessibility label for the row group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The accessibility label.
         */
        ariaLabel?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the content for the group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The row group content label.
         */
        content?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | HtmlContent | KnockoutObservableBase<string>;
    }
    /**
     * DataGrid header definition.
     */
    export interface HeaderDefinition {
        /**
         * The header height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Indicates if the header should be visible.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid header.
     * Part of the DataGrid object model.
     * Accessed by grid.header.
     */
    export interface Header {
        /**
         * Determines if the header is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid focus options.
     */
    export interface FocusOptions<TItem, TGroup = any> {
        /**
         * Event handler for CellEnter event.
         *
         * @param cell The cell being entered.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onEnterCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowEnter event.
         *
         * @param row The row being entered.
         * @param grid The grid.
         */
        onEnterRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for CellExit event.
         *
         * @param cell The cell being exited.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onExitCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowExit event.
         *
         * @param row The row being exited.
         * @param grid The grid.
         */
        onExitRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * DataGrid focus contract.
     */
    export interface FocusContract<TItem> {
        /**
         * The current cell.
         * This cell is the focused cell when the grid has focus.
         * When focus leaves the grid the current cell remains.
         * The current cell will be null when no cell contains the focus.
         */
        readonly currentCell: KnockoutReadOnlyObservable<Cell<TItem>>;
        /**
         * The current row.
         * This row is the focused row when the grid has focus.
         * When focus leaves the grid the current row remains.
         */
        readonly currentRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * Moves the focus from the current row to the row below it if possible.
         *
         * @returns Indicates if the focus moved down.
         */
        moveDown(): boolean;
        /**
         * Moves the focus from the current row to the first row if possible.
         *
         * @returns Indicates if the focus moved to the first row.
         */
        moveFirst(): boolean;
        /**
         * Moves the focus from the current row to the last row if possible.
         *
         * @returns Indicates if the focus moved to the last row.
         */
        moveLast(): boolean;
        /**
         * Moves the focus from the current row to the specified row.
         * Makes the specified row the current row.
         * Focus will not change unless the grid already has focus.
         *
         * @param row The row to move to.
         * @returns Indicates if the focus moved.
         */
        moveToRow(row: Row<TItem>): boolean;
        /**
         * Moves the focus from the current row to the row above it if possible.
         *
         * @returns Indicates if the focus moved up.
         */
        moveUp(): boolean;
    }
    /**
     * DataGrid selection options.
     */
    export interface SelectionOptions<TItem, TGroup = any> {
        /**
         * Determines if all items can be selected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be selected at once.
         */
        canSelectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be selected.
         *
         * @param item The item to select.
         * @param grid The grid.
         * @returns Indicates if the item can be selected.
         */
        canSelectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if all items can be unselected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be unselected at once.
         */
        canUnselectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be unselected.
         *
         * @param item The item to unselect.
         * @param grid The grid.
         * @returns Indicates if the item can be unselected.
         */
        canUnselectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Disables Ctrl+A or the select all checkbox from selecting all rows at once in multiple selection mode.
         */
        selectAllDisabled?: boolean;
        /**
         * Selection mode (defaults to Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid selection state.
     */
    export interface SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
    }
    /**
     * DataGrid selection contract.
     */
    export interface SelectionContract<TItem> extends SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Indicates if all items can be selected.
         */
        readonly canSelectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be selected.
         *
         * @item The item to select.
         * @return Indicates if an item can be selected.
         */
        canSelectItem(item: TItem): boolean;
        /**
         * Indicates if all items can be unselected.
         */
        readonly canUnselectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be unselected.
         *
         * @item The item to unselect.
         * @return Indicates if an item can be unselected.
         */
        canUnselectItem(item: TItem): boolean;
        /**
         * Selects all items.
         *
         * @return Indicates if all items were selected.
         */
        selectAllItems(): boolean;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * Selects an item.
         *
         * @item The item to select.
         * @return Indicates if the item was selected.
         */
        selectItem(item: TItem): boolean;
        /**
         * Selects an item by id.
         *
         * @id The item's id to select.
         * @return Indicates if the item was selected.
         */
        selectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Unselects all items.
         *
         * @return Indicates if all items were unselected.
         */
        unselectAllItems(): boolean;
        /**
         * Unselects an item.
         *
         * @item The item to unselect.
         * @return Indicates if the item was unselected.
         */
        unselectItem(item: TItem): boolean;
        /**
         * Unselects an item by id.
         *
         * @id The item's id to unselect.
         * @return Indicates if the item was unselected.
         */
        unselectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         */
        visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid activation contract.
     * Activation occurs when a child blade is opened from a grid cell using a BladeLinkColumn,
     * CustomLinkColumn, ResourceLinkColumn, or fxClick in an HTML template.
     */
    export interface ActivationContract<TItem> {
        /**
         * Activated column id.
         */
        readonly activatedColumnId: KnockoutReadOnlyObservableBase<string>;
        /**
         * Activated item.
         */
        readonly activatedItem: KnockoutReadOnlyObservableBase<TItem>;
    }
    /**
     * DataGrid context menu options.
     */
    export interface ContextMenuOptions<TItem, TGroup = any> {
        /**
         * Determines if the row supports context menu.
         * This is true by default and only needs to be implemented to opt specific rows out.
         * This controls if the context menu shortcut is displayed in the row.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param row The row to show menus for.
         * @param grid The grid.
         * @returns Indicates if the row can show a context menu.
         */
        canShowMenu?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines the maximum buttons commands to display directly in the row.
         * The default is one.
         * Command buttons will be displayed in the row until the count of commands exceeds this max.
         * When the max is exceeded the ellipsis will be displayed indicating more commands and providing a way to open the menu.
         * If zero only the ellipsis will ever be shown.
         */
        maxButtonCommands?: number;
        /**
         * Supplies command buttons to be displayed in the row margin.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyButtonCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Q.Promise<ToolbarItemContract[]>;
        /**
         * Supplies bulk commands to be displayed for the rows in a context menu.
         * This is called only when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionState<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Q.Promise<ToolbarItemContract[]>;
        /**
         * Supplies commands to be displayed in the row context menu.
         * This is not called when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Q.Promise<ToolbarItemContract[]>;
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid context menu contract.
     */
    export interface ContextMenuContract<TItem> {
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid hierarchy options.
     */
    export interface HierarchyOptions<TItem, TGroup = any> {
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @param grid The grid.
         * @returns Indicates if the row can be collapsed.
         */
        canCollapseRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @param grid The grid.
         * @returns Indicates if the row can be expanded.
         */
        canExpandRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Customize the initial expanded state of a hierarchical parent row.
         * The grid will call this when a new row is being created to determine if it should be expanded or not.
         * The grid will only call if the item has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded The default expanded state which is expanded for root items and collapsed for all child item.
         * @param level The item level in the hierarchy 1 is top level.
         * @param item The row item.
         * @return The expanded state the grid will use.
         */
        supplyInitialExpansionForItem?: (cachedExpanded: boolean, defaultExpanded: boolean, level: number, item: TItem) => boolean;
        /**
         * Customize the initial expanded state of a row group.
         * The grid will call this when a new row group is being created to determine if it should be expanded or not.
         * The grid will only call if the group has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded  The default expanded state which is expanded for row groups.
         * @param group The row group.
         * @return The expanded state the grid will use.
         */
        supplyInitialExpansionForGroup?: (cachedExpanded: boolean, defaultExpanded: boolean, group: TGroup) => boolean;
    }
    /**
     * DataGrid hierarchy contract.
     */
    export interface HierarchyContract<TItem> {
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @return Indicates if a row can be collapsed.
         */
        canCollapseRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @return Indicates if a row can be expanded.
         */
        canExpandRow(row: Row<TItem>): boolean;
        /**
         * Collapses a row.
         *
         * @param row The row to collapse.
         * @return Indicates if the row was collapsed.
         */
        collapseRow(row: Row<TItem>): Q.Promise<boolean>;
        /**
         * Expands a row.
         *
         * @param row The row to expand.
         * @return Indicates if the row was expanded.
         */
        expandRow(row: Row<TItem>): Q.Promise<boolean>;
    }
    /**
     * DataGrid resizing options.
     */
    export interface ResizingOptions<TItem, TGroup = any> {
        /**
         * Notification when columns have been resized by the user.
         *
         * @param columns The columns that changed widths.
         * @param grid The grid.
         */
        onColumnsResized?: (columns: Column<TItem>[], grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * DataGrid scrolling options.
     */
    export interface ScrollingOptions {
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (% or fr units) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * By default vertical scrolling is automatically enabled when the grid UI is created and the element
         * the grid is bound into has a height.
         * By default vertical scrolling is automatically disabled when the grid UI is created and the element
         * the grid is bound into does not have a height.
         * When set to true the grid will enable vertical scrolling and skip the auto detection based on height.
         * However, you will still need to ensure the element the grid is bound to has a height.
         * When set to false the grid will disable vertical scrolling and skip the auto detection based on height.
         */
        vertical?: boolean;
    }
    /**
     * DataGrid sorting options.
     */
    export interface SortingOptions<TItem, TGroup = any> {
        /**
         * Determines whether additional sorted columns can be added to the current sort order.
         * This can be used to limit the number of columns that can be sorted at the same time.
         * The default is to allow all the sortable columns to be sorted at the same time.
         *
         * @param sortOrder All columns with their column ids and sort directions.
         * @param grid The grid.
         * @returns A boolean that indicates if additional columns can be added to the current sort order.
         */
        canSortAdditionalColumns?: (sortOrder: SortOrder[], grid: Contract<TItem, TGroup>) => boolean;
    }
    /**
     * DataGrid options.
     */
    export interface Options<TItem, TGroup = any> {
        /**
         * The accessibility label for the grid.
         */
        ariaLabel: string | KnockoutObservableBase<string>;
        /**
         * The column definitions.
         * This is required because it is expected that the existing columns will be known or obtained before creating the grid.
         */
        columns: ColumnDefinition<TItem>[];
        /**
         * Context menu options.
         */
        contextMenu?: ContextMenuOptions<TItem, TGroup>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The data source.
         */
        dataSource: CallbackDataSource<TItem, TGroup>;
        /**
         * Disabled state.
         */
        disabled?: boolean;
        /**
         * Focus options.
         * Focus is enabled by default.
         * Focus can not be disabled by omitting the focus options or setting to null.
         */
        focus?: FocusOptions<TItem, TGroup>;
        /**
         * Header definition.
         * Initializes the grid header.
         */
        header?: HeaderDefinition;
        /**
         * Hierarchy options.
         * Heirarchy is enabled by default.
         * The hierarchy is determined by the node structure returned from the data source.
         */
        hierarchy?: HierarchyOptions<TItem, TGroup>;
        /**
         * Content to display when the grid has no data.
         */
        noDataMessage?: string | HtmlContent;
        /**
         * Resizing options.
         * Resizing is enabled by default.
         * Resizing can be disabled by setting to null.
         */
        resizing?: ResizingOptions<TItem, TGroup>;
        /**
         * Row initialization options.
         */
        row?: RowDefinition<TItem>;
        /**
         * Row group options.
         */
        rowGroup?: RowGroupDefinition<TGroup>;
        /**
         * Scrolling options.
         * By default horizontal scrolling is enabled and vertical scrolling is auto-detected.
         * Setting to null will disable all in-grid scrolling.
         */
        scrolling?: ScrollingOptions;
        /**
         * Selection options.
         * Selection is not enabled by default.
         * Selection is enabled by providing selection options.
         */
        selection?: SelectionOptions<TItem, TGroup>;
        /**
         * Sorting options.
         * Sorting is enabled by default.
         * Sorting can be disabled by setting to null.
         * To sort you must set canSort to true on a column and implement sorting in the dataSource.
         */
        sorting?: SortingOptions<TItem, TGroup>;
        /**
         * Hides or shows the grid.
         */
        visible?: boolean;
    }
    /**
     * DataGrid contract.
     */
    export interface Contract<TItem, TGroup = any> extends Control {
        /**
         * DataGrid activation properties and methods.
         */
        readonly activation: ActivationContract<TItem>;
        /**
         * The accessibility label for the grid.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The columns of the grid.
         */
        readonly columns: ColumnCollection<TItem>;
        /**
         * Context menu properties and methods.
         */
        readonly contextMenu: ContextMenuContract<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Displays a loading message until the supplied promise is resolved or rejected.
         * if called multiple times the promises are queued and the grid remains in a loading state until all loading tasks are completed.
         *
         * @param completion Promise for completion.
         * @param message Optional message to display.
         */
        displayLoadingMessage(completion: Q.Promise<any>, message?: string): void;
        /**
         * DataGrid focus properties and methods.
         */
        readonly focus: FocusContract<TItem>;
        /**
         * The grid header.
         */
        readonly header: Header;
        /**
         * Hierarchy properties and methods.
         */
        readonly hierarchy: HierarchyContract<TItem>;
        /**
         * Indicates when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() method.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() method.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * Indicates when the grid has no data to display.
         */
        readonly noData: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid has no data.
         */
        readonly noDataMessage: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Refreshes the grid data.
         * @param options Refresh options.
         * @returns A promise for completion.
         */
        refresh<TParams>(options?: RefreshOptions<TParams>): Q.Promise<any>;
        /**
         * The grid rows.
         */
        readonly rows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * DataGrid selection properties and methods.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * Hides or shows the DataGrid.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a DataGrid control.
     *
     * @param lifetime The lifetime manager for the grid.
     * @param options The options for creating the grid.
     * @returns The created grid.
     */
    export function create<TItem, TGroup = any>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<TItem, TGroup>): Contract<TItem, TGroup>;
    /**
     * Creates a BladeLink column definition that displays a link to a blade in each cell.
     *
     * @param options The BladeLink column definition options.
     * @returns A BladeLink column definition.
     */
    export function createBladeLinkColumn<TItem>(options: BladeLinkColumnDefinitionOptions<TItem>): BladeLinkColumnDefinition<TItem>;
    /**
     * Creates a CustomLink column definition that displays a custom link in each cell.
     * Only use for exceptional cases where you do not require browser behaviors like
     * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
     * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
     *
     * @param options The CustomLink column definition options.
     * @returns A CustomLink column definition.
     */
    export function createCustomLinkColumn<TItem>(options: CustomLinkColumnDefinitionOptions<TItem>): CustomLinkColumnDefinition<TItem>;
    /**
     * Creates a ResourceLink column definition that displays a link to a resource in each cell.
     *
     * @param options The ResourceLink column definition options.
     * @returns A ResourceLink column definition.
     */
    export function createResourceLinkColumn<TItem>(options: ResourceLinkColumnDefinitionOptions<TItem>): ResourceLinkColumnDefinition<TItem>;
    /**
     * Creates a TagList column definition that displays a list of tags as bubbled text in each cell.
     *
     * @param options The TagList column definition options.
     * @returns A TagList column definition.
     */
    export function createTagListColumn<TItem>(options: TagListColumnDefinitionOptions<TItem>): TagListColumnDefinition<TItem>;
    /**
     * Creates a template column definition that displays an HTML template bound to a view model in each cell.
     *
     * @param options The template column definition options.
     * @returns A Template column definition.
     */
    export function createTemplateColumn<TItem, TViewModel = any>(options: TemplateColumnDefinitionOptions<TItem, TViewModel>): TemplateColumnDefinition<TItem>;
    /**
     * Creates a text column definition that displays text in each cell.
     *
     * @param options The text column definition options.
     * @returns A Text column definition.
     */
    export function createTextColumn<TItem>(options: TextColumnDefinitionOptions<TItem>): TextColumnDefinition<TItem>;
    /**
     * Creates a UriLink column definition that displays a URI link in each cell.
     *
     * @param options The UriLink column definition options.
     * @returns A UriLink column definition.
     */
    export function createUriLinkColumn<TItem>(options: UriLinkColumnDefinitionOptions<TItem>): UriLinkColumnDefinition<TItem>;
}

// FILE: Fx\Controls\DatePicker.d.ts
declare module "Fx/Controls/DatePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a date picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DatePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange> | DateTimeRange[] | KnockoutObservableArray<DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Date | KnockoutObservableBase<Date>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DatePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Date>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        readonly enabledDateTimeRange: KnockoutObservableBase<DateTimeRange> | KnockoutObservableArray<DateTimeRange>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
    }
    /**
     * Creates a date picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a date picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DateTimePicker.d.ts
declare module "Fx/Controls/DateTimePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import * as TimeZones from "Fx/TimeZones";
    export import TimeZoneId = TimeZones.TimeZoneId;
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a date time picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DateTimePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange> | DateTimeRange[] | KnockoutObservableArray<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        timezoneId?: TimeZoneId | KnockoutObservableBase<TimeZoneId>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * Empty value text for date.
         */
        placeHolderTextForDate?: string | KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        placeHolderTextForTime?: string | KnockoutObservableBase<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Date | KnockoutObservableBase<Date>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DateTimePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Date>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        readonly enabledDateTimeRange: KnockoutObservableBase<DateTimeRange> | KnockoutObservableArray<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        readonly showTimezoneDropdown: KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        readonly timezoneId: KnockoutObservableBase<TimeZoneId>;
        /**
         * Empty value text for date.
         */
        readonly placeHolderTextForDate: KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        readonly placeHolderTextForTime: KnockoutObservableBase<string>;
    }
    /**
     * Creates a date/time picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a date time picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DateTimeRangePicker.d.ts
declare module "Fx/Controls/DateTimeRangePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import * as TimeZones from "Fx/TimeZones";
    export import TimeZoneId = TimeZones.TimeZoneId;
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a date time range picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DateTimeRangePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Enabled range for start date/time
         */
        startDateTimeEnabledRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange>;
        /**
         * Enabled range for end date/time
         */
        endDateTimeEnabledRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        timezoneId?: TimeZoneId | KnockoutObservableBase<TimeZoneId>;
        /**
         * Empty value text for date.
         */
        placeHolderTextForDate?: string | KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        placeHolderTextForTime?: string | KnockoutObservableBase<string>;
        /**
         * Display start/end date/time fields inline (false by default).
         */
        displayFieldsInline?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: DateTimeRange | KnockoutObservableBase<DateTimeRange>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DateTimeRangePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<DateTimeRange>;
        /**
         * Enabled range for start date/time
         */
        readonly startDateTimeEnabledRange: KnockoutObservableBase<DateTimeRange>;
        /**
         * Enabled range for end date/time
         */
        readonly endDateTimeEnabledRange: KnockoutObservableBase<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        readonly showTimezoneDropdown: KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        readonly timezoneId: KnockoutObservableBase<TimeZoneId>;
        /**
         * Empty value text for date.
         */
        readonly placeHolderTextForDate: KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        readonly placeHolderTextForTime: KnockoutObservableBase<string>;
    }
    /**
     * Creates a date/time range picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a date time range picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DayPicker.d.ts
declare module "Fx/Controls/DayPicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a day picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DayPicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number[] | KnockoutObservableBase<number[]>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DayPicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number[]>;
    }
    /**
     * Creates a day picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a day picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DiffEditor.d.ts
declare module "Fx/Controls/DiffEditor" {
    import * as Base from "Fx/Controls/ControlsBase";
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    import { ContentType, Marker, Range, CustomConfig, CursorPosition, TypeScriptExtraLib, TypeScriptCompilerOptions, JSONSchema } from "Fx/Controls/Editor";
    export { ContentType, Marker, Range, CustomConfig, CursorPosition, TypeScriptExtraLib, TypeScriptCompilerOptions, JSONSchema, };
    /**
     * Options for creating a diff editor control
     */
    export interface Options {
        /**
         * The original document contents.
         */
        readonly oldContent: string | KnockoutObservableBase<string>;
        /**
         * The new document contents.
         */
        readonly newContent: string | KnockoutObservableBase<string>;
        /**
         * Enables splitter between the content panes
         */
        readonly enableSplitViewResizing?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Render the differences in two side-by-side editors.
         * Defaults to true.
         */
        readonly renderSideBySide?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers?: Marker[] | KnockoutObservableBase<Marker[]>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize?: number | KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn?: number | KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines?: number | KnockoutObservableBase<number>;
        /**
         * Defines an auto save delay in millisenconds when it expires the editor changes are saved.
         * The delay is set each time the user changes the text and if there where no changes until the time expires the changes are saved
         * Zero -or- null means auto save is disabled.
         * Defaults to 500 milliseconds.
         */
        readonly autoSaveDelay?: number;
    }
    /**
     * Options for creating an editor control
     */
    export interface EditorOptions extends Options {
        /**
         * The type of editor content.
         */
        readonly contentType?: ContentType | KnockoutObservableBase<ContentType>;
    }
    /**
     * Options for creating an editor control
     */
    export interface JSONEditorOptions extends Options {
        /**
         * JSON schemas.
         */
        readonly schemas: JSONSchema[];
    }
    /**
     * Options for creating an editor control
     */
    export interface TypeScriptEditorOptions extends Options {
        /**
         * Additional source files to the language service. Use this
         * for typescript (definition) files that won't be loaded as editor
         * document, like `jquery.d.ts`.
         */
        readonly extraLibs?: TypeScriptExtraLib[];
        /**
         * Compiler options for compiling the typescript.
         */
        readonly compilerOptions: TypeScriptCompilerOptions;
    }
    /**
     * Options for creating a custom editor control
     */
    export interface CustomEditorOptions extends Options {
        /**
         * Custom language configruation.
         */
        readonly customConfig: CustomConfig;
    }
    /**
     * Editor contract.
     */
    export interface EditorContract extends Contract {
        /**
         * The type of the editor content.
         */
        readonly contentType: KnockoutObservableBase<ContentType>;
    }
    /**
     * Custom editor contract.
     */
    export interface CustomEditorContract extends Contract {
        /**
         * Custom language configruation.
         */
        readonly customConfig: KnockoutObservableBase<CustomConfig>;
    }
    /**
     * JSON editor contract.
     */
    export interface JSONEditorContract extends Contract {
    }
    /**
     * TypeScript editor contract.
     */
    export interface TypeScriptEditorContract extends Contract {
        /**
         * The typescript compiler output.
         * Updated on each save.
         * This is the transpiled javascript content.
         */
        readonly typescriptOutput: KnockoutObservableBase<string>;
    }
    /**
     * Base DiffEditor contract.
     */
    export interface Contract extends Base.Control {
        /**
         * The original document contents.
         */
        readonly oldContent: KnockoutObservableBase<string>;
        /**
         * The new document contents.
         */
        readonly newContent: KnockoutObservableBase<string>;
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The currently selected content of the editor content.
         */
        readonly selectedContent: KnockoutReadOnlyObservableBase<string>;
        /**
         * The currently selected range in the editor content.
         */
        readonly selectedRange: KnockoutObservableBase<Range>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers: KnockoutObservableBase<Marker[]>;
        /**
         *  Current position of the cursor in the editor content.
         */
        readonly cursorPosition: KnockoutObservableBase<CursorPosition>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar: KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize: KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn: KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines: KnockoutObservableBase<number>;
        /**
         * Indicates if the contents have been modified but not yet saved.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor is displayed.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Refreshes the editor view.
         */
        refresh(): Q.Promise<void>;
        /**
         * Saves the content of the editor.
         */
        save(): Q.Promise<void>;
    }
    /**
     * Creates an editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createEditor(lifetime: LifetimeManager, options: EditorOptions): EditorContract;
    /**
     * Creates a custom editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createCustomEditor(lifetime: LifetimeManager, options: CustomEditorOptions): CustomEditorContract;
    /**
     * Creates a JSON editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createJSONEditor(lifetime: LifetimeManager, options: JSONEditorOptions): JSONEditorContract;
    /**
     * Creates a TypeScript editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createTypeScriptEditor(lifetime: LifetimeManager, options: TypeScriptEditorOptions): TypeScriptEditorContract;
}

// FILE: Fx\Controls\DocsControl.d.ts
declare module "Fx/Controls/DocsControl" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * DocsControl's supported blade actions.
     *
     * @deprecated DocsControl.ActionType - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export enum ActionType {
        /**
         * Blade action is not supported by DocsControl.
         */
        NotSupported = 0,
        /**
         * Open a blade from #blade deeplink.
         */
        OpenBlade = 1,
        /**
         * Open a create flow from #create deeplink.
         */
        Create = 2,
        /**
         * Open a blade in context pane.
         */
        OpenContextPane = 3
    }
    /**
     * Action completed args to indicate if the blade action was performed successfully by the DocsControl.
     *
     * @deprecated DocsControl.ActionCompletedArgs - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export interface ActionCompletedArgs {
        /**
         * One of the supported blade action type.
         */
        actionType: ActionType;
        /**
         * Blade action data embeeded in docs.
         */
        data: string;
        /**
         * Azure documentation source uri.
         */
        src: string;
        /**
         * Flag to indicate if blade action succeeded or failed.
         */
        success?: boolean;
        /**
         * Error message if the blade action failed.
         */
        errorMessage?: string;
    }
    /**
     * Options for configuring a DocsControl control.
     *
     * @deprecated DocsControl.Options - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export interface Options {
        /**
         * Source uri where docs are hosted.
         */
        readonly src: string | KnockoutObservableBase<string>;
        /**
         * Action completion callback for the extension to know if the blade action succeed or not.
         * Extension can add any telemtry related to the blade action in the callback.
         *
         * @param args Action completed args indicating success or failure of the blade action.
         */
        readonly onActionCompleted?: (args: ActionCompletedArgs) => void;
    }
    /**
     * DocsControl view model contract.
     *
     * @deprecated DocsControl.Contract - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export interface Contract extends Control {
        /**
         * Source uri where docs are hosted.
         */
        readonly src: KnockoutObservableBase<string>;
    }
    /**
     * Creates a DocsControl viewmodel.
     *
     * Chromeless doc service will not be supported going forward.
     * As first step, DocsControl is getting deprecated and DocsControl will be removed from SDK in near future.
     * Extension should find alternate solutions to surface doc content via direct links.
     * The current deprecation will raise tslint errors if extension is using any DocsControl type/APIs.
     * Extension can temporarily add // tslint:disable:deprecation to bypass the tslint rule.
     *
     * @deprecated DocsControl.create - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a DocsControl viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Donut.d.ts
declare module "Fx/Controls/Donut" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Built-in sizes for Donut control.
     */
    export const enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determined by Min(width, hight).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyLarge = 3,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 4,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 5,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 6,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 7
    }
    /**
     * GroupInfo is the ViewModel for a particular <optGroup>
     */
    export interface GroupInfo {
        /**
         * Id for mapping from Item GroupID column to this user friendly GroupInfo.
         */
        key: string;
        /**
         * User friendly label for the grouping.
         */
        text: string | KnockoutObservableBase<string>;
        /**
         * Disable state of this group.
         */
        disable: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ItemSetting defines the properties required to build donut items.
     * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of donut slices.
     */
    export interface ItemSetting {
        /**
         * Data key used to identify the color.  This is optional, if not provided, it will use default color wheel.
         */
        colorKey?: string;
        /**
         * Data key used to identify the donut slice.  Data have to be string, we use it on the object map to quickly identify item's element.
         */
        rowIdKey?: string;
        /**
         * Data key used to label the row for display purpose.  Data have to be string, we use to show center caption for quick indication of the item.
         */
        labelKey?: string;
        /**
         * Property used for display item. If it is not set, it uses items[index] to display.
         */
        textKey?: string;
        /**
         * Property used for Value of an item. If it is not set, it uses items[index] as Value.
         */
        valueKey?: string;
        /**
         * Property used for disable state of an item. If it is not set, default to false.
         */
        disableKey?: string;
        /**
         * Property used for select state of an item. If it is not set, default to false.
         */
        selectedKey?: string;
        /**
         * Property used for grouping of an item. If it is not set, there is no grouping for the items.
         */
        groupIdKey?: string;
        /**
         * Data key of the hatching pattern.
         */
        hatchingKey?: string;
    }
    /**
     * Options for configuring a Donut control.
     */
    export interface Options<T> {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates that the control is in a loading state.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        gaugeSize?: GaugeSize | KnockoutObservableBase<GaugeSize>;
        /**
         * Group definitions.
         */
        groupInfos?: GroupInfo[] | KnockoutObservableArray<GroupInfo>;
        /**
         * ItemSetting defines the properties required to build donut items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of donut slices.
         */
        itemSetting?: ItemSetting | KnockoutObservableBase<ItemSetting>;
        /**
         * Items displayed in the donut based on the ItemSetting definitions.
         */
        items?: T[] | KnockoutObservableArray<T>;
        /**
         * total value. The total value of all item values.
         */
        total?: number | KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset?: number | KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}". The following formatter arguments will be substituted with respective values when displaying center text,
         * {0}: current value.
         * {1}: maximum value.
         */
        totalFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        unitFormat?: string | MsPortalFx.UnitConversion.Unit | KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space constraints in the center of the Donut.
         */
        numberFormatOptions?: MsPortalFx.Intl.NumberFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        infoFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text. The following formatter arguments will be substituted with respective values when displaying center hover text,
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        hoverInfoFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * The following formatter arguments will be substituted with respective values when displaying center selected text,
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        selectedInfoFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentage.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        hoveredUnit?: string | MsPortalFx.UnitConversion.Unit | KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * RowId of current hovered slice in donut.
         */
        hoveredIndex?: KnockoutObservableBase<string>;
        /**
         * Disable selected change on click.
         */
        disableSelectOnClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show center content.
         */
        showCenter?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Title of the Donut control, a short description, will be utilized by screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the Donut control, will be utilized by screen-reader.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * Donut control view model contract.
     */
    export interface Contract<T> extends Control {
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        readonly gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * Group definitions.
         */
        readonly groupInfos: KnockoutObservableArray<GroupInfo>;
        /**
         * ItemSetting defines the properties required to build donut items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of donut slices.
         */
        readonly itemSetting: KnockoutObservableBase<ItemSetting>;
        /**
         * Items displayed in the donut based on the ItemSetting definitions.
         */
        readonly items: KnockoutObservableArray<T>;
        /**
         * total value. The total value of all item values.
         */
        readonly total: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        readonly startOffset: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}". The following formatter arguments will be substituted with respective values when displaying center text,
         * {0}: current value.
         * {1}: maximum value.
         */
        readonly totalFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        readonly unitFormat: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space constraints in the center of the Donut.
         */
        readonly numberFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        readonly infoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text. The following formatter arguments will be substituted with respective values when displaying center hover text,
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        readonly hoverInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * The following formatter arguments will be substituted with respective values when displaying center selected text,
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        readonly selectedInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentage.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        readonly hoveredUnit: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * RowId of current hovered slice in donut.
         */
        readonly hoveredIndex: KnockoutObservableBase<string>;
        /**
         * Disable selected change on click.
         */
        readonly disableSelectOnClick: KnockoutObservableBase<boolean>;
        /**
         * Show center content.
         */
        readonly showCenter: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Title of the Donut control, a short description, will be utilized by screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Donut control, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        render: () => void;
    }
    /**
     * Creates a Donut control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a Donut control viewmodel
     */
    export function create<T>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<T>): Contract<T>;
}

// FILE: Fx\Controls\DropDown.d.ts
declare module "Fx/Controls/DropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { Validation } from "Fx/Controls/Validations";
    import { Contract as FormContract } from "Fx/Controls/FormBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Describes an Item used for items in the DropDown.
     */
    export interface Item<TValue> {
        /**
         * Content to render for the item.
         * If you use HtmlContent, use `ariaLabel` for screen reader support.
         */
        text: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Overrides what is shown in the selected state. Allows you to display different content then what is shown in the DropDown.
         * This is especially useful when using filtering and items with html.
         */
        selectedItemOverride?: string | KnockoutObservableBase<string>;
        /**
         * Value of the item.
         */
        value: TValue;
        /**
         * Disabled state of the item.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria label for item.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Describes an Group used for items in the DropDown.
     */
    export interface Group<TValue> {
        /**
         * Content to render for the item.
         * If you use HtmlContent, use `ariaLabel` for screen reader support.
         */
        text?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Items to render under this group.
         */
        children?: Array<Item<TValue> | Group<TValue>> | KnockoutObservableBase<Array<Item<TValue> | Group<TValue>>>;
        /**
         * Disabled state of group.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria label for group.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface BaseOptions<TValue> {
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * String/HtmlContent shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Items to render in the DropDown.
         */
        items?: Array<Item<TValue> | Group<TValue>> | KnockoutObservableArray<Item<TValue> | Group<TValue>>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        placeholder?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Indicates that the control is in a loading state.  When in the loading state, the control will be disabled and have the text "Loading..." shown. Default is false.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The disabled state of the control. Default is false.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: TValue | Array<TValue> | KnockoutObservableBase<TValue | Array<TValue>>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Message shown at bottom of dropdown when no items are remain after filtering (by default).
         * You can set an empty string if you don't want to show any message.
         *
         * Optionally, manipulate visibility  with 'showStatusMessage' for use in other applications.
         */
        statusMessage?: HtmlContent | KnockoutObservableBase<HtmlContent>;
        /**
         * Manipulate visibility of 'statusMessage'.
         * Leave as is or set to undefined to have the default filtering behavior.
         */
        showStatusMessage?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show the search icon in the filter textbox. Default is false.
         */
        showSearchIcon?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Telemetry identifier.
         */
        telemetryName?: string;
        /**
         * Popup state of the DropDown.
         */
        isPopUpOpen?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Base DropDown control view model.
     */
    export interface BaseContract<TValue> extends FormContract {
        /**
         * Popup state of the DropDown.
         */
        readonly isPopUpOpen: KnockoutObservableBase<boolean>;
        /**
         * Current value of the filter TextBox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         */
        readonly filterPlaceholder: KnockoutObservableBase<string>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        readonly placeholder: KnockoutObservableBase<string>;
        /**
         * Items to render in the DropDown.
         */
        readonly items: KnockoutObservableArray<Item<TValue> | Group<TValue>>;
        /**
         * Indicates that the control is in a loading state.  When in the loading state, the control will be disabled and have the text "Loading..." shown. Default is false.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText: KnockoutObservableBase<string>;
        /**
         * Stops the selected item from updating, if items are changed.
         * This is useful while changing items via 'filterString' or a 'customFilter'.
         */
        readonly suppressSelectedUpdate: KnockoutObservableBase<boolean>;
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<TValue> & KnockoutObservableBase<Array<TValue>>;
        /**
         * Message shown at bottom of dropdown when no items are remain after filtering (by default).
         * You can set an empty string if you don't want to show any message.
         *
         * Optionally, manipulate visibility  with 'showStatusMessage' for use in other applications.
         */
        readonly statusMessage: KnockoutObservableBase<HtmlContent>;
        /**
         * Manipulate visibility of 'statusMessage'.
         * Leave as is or set to undefined to have the default filtering behavior.
         */
        readonly showStatusMessage: KnockoutObservableBase<boolean>;
        /**
         * Show the search icon in the filter textbox. Default is false.
         */
        readonly showSearchIcon: KnockoutObservableBase<boolean>;
        /**
         * Telemetry identifier.
         */
        readonly telemetryName: string;
    }
    /**
     * DropDown control options.
     */
    export interface Options<TValue> extends BaseOptions<TValue> {
        /**
         * Enable filtering. Default is false.
         *
         * When filtering, the control does a substring match over the item's text property (if a string).
         * If the text property is HtmlContent, the control does a substring match on the rendered content text.
         *
         * If the HtmlContent content has data-bound content, the control does not consider the item for filtering.
         * For this scenario, the 'customFilter' option should be used.
         */
        filter?: boolean;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         */
        filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Callback which will override the default substring filtering.
         * Return list of items (by item value) you wish to show.
         * Only enabled when filter is set to true.
         */
        customFilter?: (value: string) => MsPortalFx.Base.PromiseV<TValue[]>;
        /**
         * Enable multiselect. Default is false.
         */
        multiselect?: boolean;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected".
         */
        multiItemDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * Enables 'select all' for multiselect. Default is false.
         */
        selectAll?: boolean;
        /**
         * Callback which will override the default 'select all' functionality.
         * Allows you to select any items you wish, we don't do any selecting when you provide this override.
         */
        selectAllOverride?: () => MsPortalFx.Base.PromiseV<any>;
    }
    /**
     * DropDown control view model.
     */
    export interface Contract<TValue> extends BaseContract<TValue> {
        /**
         * Current value of the filter TextBox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         */
        readonly filterPlaceholder: KnockoutObservableBase<string>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText: KnockoutObservableBase<string>;
        /**
         * Stops the selected item from updating, if items are changed.
         * This is useful while changing items via 'filterString' or a 'customFilter'.
         */
        readonly suppressSelectedUpdate: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a DropDown control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param items The items shown in the DropDown.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a DropDown control viewmodel.
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
    /**
     * @deprecated DropDown.ObsoleteOptions - Options used in old construction pattern.  For new controls, please use the new create pattern.
     * No new features or fixes are added here.
     */
    export interface ObsoleteOptions<T> {
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Items to render in the DropDown.
         */
        items?: KnockoutObservableArray<Item<T> | Group<T>>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        placeholder?: string | KnockoutObservableBase<string>;
        /**
         * Enable filtering. Default is false.
         *
         * When filtering, the control does a substring match over the item's text property (if a string).
         * If the text property is HtmlContent, the control does a substring match on the rendered content text.
         *
         * If the HtmlContent content has data-bound content, the control does not consider the item for filtering.
         * For this scenario, the 'customFilter' option should be used.
         */
        filter?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         */
        filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Callback which will override the default simple substring filtering.
         * Return list of items (by item value) you wish to show.
         * Only works when filter is set to true.
         */
        customFilter?: (value: string) => MsPortalFx.Base.PromiseV<T[]>;
        /**
         * Toggle multiselect on.
         */
        multiselect?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Enables select all for multiselect.
         */
        selectAll?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override the default selectAll functionality.
         * Allows you to select any items you wish, we don't do any selecting when you provide this override.
         */
        selectAllOverride?: () => MsPortalFx.Base.PromiseV<any>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Show validation error message below the control.
         */
        showValidationMessagesBelowControl?: boolean;
        /**
         * Aria label for DropDown.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Display text format for multiselect.
         * By default the format string is "{0} selected".
         */
        multiItemDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * Old construction pattern.  Instead of creating instances of this class, please use the create methods in this module instead.
     * No new features or fixes are added here.
     */
    export class ViewModel<TValue> extends MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<TValue> {
        /**
         * Items to render in the DropDown.
         */
        items: KnockoutObservableArray<Item<TValue> | Group<TValue>>;
        /**
         * Turn filtering on/off.
         */
        filter: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         */
        filterPlaceholder: string | KnockoutObservableBase<string>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an <input> tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        placeholder: string | KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Callback which will override the default simple substring filtering.
         * Return list of items (by item value) you wish to show.
         * Only works when filter is set to true.
         */
        customFilter: (value: string) => MsPortalFx.Base.PromiseV<TValue[]>;
        /**
         * Turn multiselect on/off.
         */
        multiselect: boolean | KnockoutObservableBase<boolean>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        multiItemDisplayText: string | KnockoutObservableBase<string>;
        /**
         * Turn multiselect on/off.
         */
        selectAll: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override the default selectAll functionality.
         */
        selectAllOverride: () => MsPortalFx.Base.PromiseV<any>;
        /**
         * Stops the selected from updating, if items are changed.
         */
        suppressSelectedUpdate: KnockoutObservableBase<boolean>;
        /**
         * Value is of type T or Array<TValue> depending on whether multiselect is set;
         */
        value: KnockoutObservableBase<TValue> & KnockoutObservableBase<Array<TValue>>;
        /**
         * Aria label for DropDown.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Popup state of of the DropDown.
         */
        readonly isPopUpOpen: KnockoutObservableBase<boolean>;
        /**
         * This is an old construction pattern.  Please use the create method in this module instead.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DropDown control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: ObsoleteOptions<TValue> & MsPortalFx.ViewModels.Forms.Base.Input.Options<TValue>);
        /**
         * This is an old construction pattern.  Please use the create method in this module instead.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DropDown is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DropDown control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, observablePath: string, options?: ObsoleteOptions<TValue> & MsPortalFx.ViewModels.Forms.Base.Input.Options<TValue>);
        /**
         * This is an old construction pattern.  Please use the create method in this module instead.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DropDown is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DropDown control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<any>, options?: ObsoleteOptions<TValue> & MsPortalFx.ViewModels.Forms.Base.Input.Options<TValue>);
    }
}

// FILE: Fx\Controls\DurationPicker.d.ts
declare module "Fx/Controls/DurationPicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a duration picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number | KnockoutObservableBase<number>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DurationPicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number>;
    }
    /**
     * Creates a duration picker control viewmodel.
     * Note: The only options that you will be able to dynamically update are the ones that are passed in as observables.
     * ie: if you pass in { label: ko.observable("myLabel") }, the label property on your viewmodel will be observable, but the sublabel property will not be.
     * similarly, if you pass in { label: "myLabel" } as your options, and you will not be able to update your label dynamically.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a duration picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\EditableGrid.d.ts
declare module "Fx/Controls/EditableGrid" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { SelectionMode } from "Fx/Controls/GridBase";
    import * as ToolbarControl from "Fx/Controls/Toolbar";
    import ToolbarItemContract = ToolbarControl.ToolbarItems.ToolbarItemContract;
    /**
     * EditableGrid selection mode.
     */
    export { SelectionMode };
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * EditableGrid column header definition.
     * The ColumnHeaderDefinition contains properties that are used to create a ColumnHeader
     * when constructing the grid or adding dynamic columns via grid.columnDefinitions.
     */
    export interface ColumnHeaderDefinition {
        /**
         * Aria label for the header.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column header text will be bold.
         * The default is determined by portal styling which can change.
         */
        bold?: boolean;
        /**
         * Content for the header.
         * The content can be a string, a control, or an observable that returns a string or control.
         */
        content?: string | HtmlContent | Control | KnockoutObservableBase<string | HtmlContent | Control>;
        /**
         * Indicates if the column header text will be in upper case.
         * The default is determined by portal styling which can change.
         */
        upperCase?: boolean;
    }
    /**
     * EditableGrid column header.
     * Accessed by grid.columns()[index].header or grid.columns.get(id).header.
     */
    export interface ColumnHeader {
        /**
         * Aria label for the header.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Content for the header.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent | Control>;
    }
    /**
     * EditableGrid column definition.
     * The ColumnDefinition contains properties that are used to create a Column.
     */
    export interface ColumnDefinition<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         * Defaults to true.
         */
        canResize?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Creates an input control such as TextBox, DropDown, or NumericTextBox that
         * enables the user to edit the cell value.
         *
         *     createCellEditor: (editorLifetime, item) => {
         *         return TextBox.create(editorLifetime, {
         *             value: item.valueProperty // Bind the item property to the text box for editing
         *         });
         *     })
         *
         * @param editorLifetime The lifetime manager for the cell editor control.
         * @param item The data item for the row.
         * @param row The containing row.
         * @returns The input control used for editing the cell value.
         */
        createCellEditor?: (editorLifetime: MsPortalFx.Base.LifetimeManager, item: TItem, row: Row<TItem>) => Control | KnockoutReadOnlyObservableBase<Control>;
        /**
         * Callback to define cell properties.
         *
         * @param cellLifetime The cell lifetime manager.
         * @param item The item to create the cell for.
         * @param row The containing row.
         * @returns The cell definition or the cell display content as a string or control.
         */
        defineCell: (cellLifetime: MsPortalFx.Base.LifetimeManager, item: TItem, row: Row<TItem>) => DefineCellDefinition | string | HtmlContent | Control | KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
        /**
         * The column header definition or text content.
         * For simple cases this can be a string.
         * If need to set additional column header properties provide a column header definition.
         */
        header?: ColumnHeaderDefinition | string | HtmlContent | Control | KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        id?: string;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        width?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         * Default is true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid column.
     * Part of the EditableGrid object model.
     * Accessed by grid.columns.
     */
    export interface Column<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         */
        readonly canResize: KnockoutObservableBase<boolean>;
        /**
         * The column header.
         */
        readonly header: ColumnHeader;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        readonly id: string;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        readonly width: KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Editable grid column collection.
     */
    export interface ColumnCollection<TItem> extends KnockoutReadOnlyObservableArray<Column<TItem>> {
        /**
         * Adds columns to the grid.
         * The columns are created from the supplied column definitions and inserted.
         *
         * @param columnDefinitions Array of column definitions create columns from.
         * @param index The index to insert the new columns in the columns collection.  If not specified the columns are added to the end.
         */
        add(columsDefinitions: ColumnDefinition<TItem>[], index?: number): void;
        /**
         * Gets a column by column id.
         * @param columnId The id of the column.
         * @returns The indicated column.
         */
        get(columnId: string): Column<TItem>;
        /**
         * Removes columns from the grid.
         *
         * @param ids The column ids of the columns to remove from the grid.
         * @returns The original column definitions used to create the columns.
         */
        remove(ids: string[]): ColumnDefinition<TItem>[];
        /**
         * Removes all columns from the grid.
         *
         * @returns The original column definitions used to create the columns.
         */
        removeAll(): ColumnDefinition<TItem>[];
    }
    /**
     * EditableGrid cell definition.
     * The CellDefinition contains properties that are used to initialize a new Cell.
     */
    export interface DefineCellDefinition {
        /**
         * The accessibility label for the cell.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The content to display in the cell.
         * The content will usually be a string representation of a data item value.
         * For numbers and dates this may require NumberFormat and DateTimeFormat from "MsPortalFx/Globalization".
         * If the value can change and you want the cell to update use an observable or computed for the content.
         * To display images or other UI in the cell provide CustomHtml or other control for the content.
         */
        content?: string | HtmlContent | Control | KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
    }
    /**
     * EditableGrid cell.
     * Part of the EditableGrid object model.
     * Accessed by row.cells()[index] or row.cells.get(columnId).
     */
    export interface Cell<TItem> {
        /**
         * Indicates if the cell is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The aria label for the cell.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The cell column.
         */
        readonly column: Column<TItem>;
        /**
         * The content to display in the cell.
         */
        readonly content: KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
        /**
         * The cell editor control for editing cell content.
         * Will be null if cell has not been edited or is not editable.
         */
        readonly editor: KnockoutReadOnlyObservableBase<Control>;
        /**
         * Indicates if the cell editor control is dirty because the user made a change.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Triggers validation of the cell.
         */
        triggerValidation(): Q.Promise<boolean>;
        /**
         * Extension-defined cell validation errors.
         * Extensions can add custom errors to this array to flag a cell as invalid in the UI.
         * When the error condition is cleared the extension should remove the errors from this array to remove the error UI.
         */
        readonly customValidationErrors: KnockoutObservableArray<string>;
        /**
         * Validation results from the cell editor control.
         * This is a read-only collection of the validation errors extracted from the cell editor control.
         */
        readonly editorValidationErrors: KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * EditableGrid row options.
     * Used to initialize new rows.
     */
    export interface RowDefinition<TItem> {
        /**
         * The row height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Supplies the accessibility label for the row.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The accessibility label.
         */
        ariaLabel?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the row disabled state.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The disabled state.
         */
        disabled?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid cell collection.
     */
    export interface CellCollection<TItem> extends KnockoutReadOnlyObservableArray<Cell<TItem>> {
        /**
         * Gets a cell by column id.
         * @param columnId The column id.
         * @returns The requested cell.
         */
        get(columnId: string): Cell<TItem>;
    }
    /**
     * EditableGrid row.
     * Part of the EditableGrid object model.
     * Accessed by grid.rows()[index].
     */
    export interface Row<TItem> {
        /**
         * Indicates if the row is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The row accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The row cells.
         * A particular cell can be retrieved by column id cells.get(columnId).
         */
        readonly cells: CellCollection<TItem>;
        /**
         * The row disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * The data item.
         */
        readonly item: TItem;
        /**
         * Indicates if the row is selected.
         */
        readonly selected: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is being edited.
         */
        readonly editing: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is dirty because the user edited the value of one or more of the cells.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Triggers validation of the row.
         */
        triggerValidation(): Q.Promise<boolean>;
        /**
         * All cell and cell editor control validation errors for the row.
         * This is a read-only collection of all the cell validation errors within the row.
         */
        readonly validationErrors: KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * Grid header definition.
     */
    export interface HeaderDefinition {
        /**
         * The header height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Indicates if the header should be visible.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Grid header.
     * Part of the EditableGrid object model.
     * Accessed by grid.header.
     */
    export interface Header {
        /**
         * Determines if the header is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid focus options.
     */
    export interface FocusOptions<TItem> {
        /**
         * Event handler for RowEnter event.
         *
         * @param row The row being entered.
         * @param grid The grid.
         */
        onEnterRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
        /**
         * Event handler for RowExit event.
         *
         * @param row The row being exited.
         * @param grid The grid.
         */
        onExitRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
        /**
         * Event handler for CellEnter event.
         *
         * @param cell The cell being entered.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onEnterCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem>) => void;
        /**
         * Event handler for CellExit event.
         *
         * @param cell The cell being exited.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onExitCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid focus contract.
     */
    export interface FocusContract<TItem> {
        /**
         * The current row.
         * This row is the focused row when the grid has focus.
         * When focus leaves the grid the current row remains.
         */
        readonly currentRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * The current cell.
         * This cell is the focused cell when the grid has focus.
         * When focus leaves the grid the current cell remains.
         * The current cell will be null when no cell contains the focus.
         */
        readonly currentCell: KnockoutReadOnlyObservable<Cell<TItem>>;
        /**
         * Moves the focus from the current row to the specified row.
         * Makes the specified row the current row.
         * Focus will not change unless the grid already has focus.
         *
         * @param row The row to move to.
         * @returns Indicates if the focus moved.
         */
        moveToRow(row: Row<TItem>): boolean;
        /**
         * Moves the focus from the current row to the row below it if possible.
         *
         * @returns Indicates if the focus moved down.
         */
        moveDown(): boolean;
        /**
         * Moves the focus from the current row to the row above it if possible.
         *
         * @returns Indicates if the focus moved up.
         */
        moveUp(): boolean;
        /**
         * Moves the focus from the current row to the first row if possible.
         *
         * @returns Indicates if the focus moved to the first row.
         */
        moveFirst(): boolean;
        /**
         * Moves the focus from the current row to the last row if possible.
         *
         * @returns Indicates if the focus moved to the last row.
         */
        moveLast(): boolean;
    }
    /**
     * EditableGrid selection options.
     */
    export interface SelectionOptions<TItem> {
        /**
         * Selection mode (defaults to Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Disables Ctrl+A or the select all checkbox from selecting all rows at once in multiple selection mode.
         */
        selectAllDisabled?: boolean;
        /**
         * Determines if a row can be selected.
         *
         * @param row The row to select.
         * @param grid The grid.
         * @returns Indicates if the row can be selected.
         */
        canSelectRow?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if a row can be unselected.
         *
         * @param row The row to unselect.
         * @param grid The grid.
         * @returns Indicates if the row can be unselected.
         */
        canUnselectRow?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if all rows can be selected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all rows can be selected at once.
         */
        canSelectAllRows?: (grid: Contract<TItem>) => boolean;
        /**
         * Determines if all rows can be unselected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all rows can be unselected at once.
         */
        canUnselectAllRows?: (grid: Contract<TItem>) => boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid selection state.
     */
    export interface SelectionState<TItem> {
        /**
         * Indicates if all rows are selected.
         */
        readonly allRowsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected rows.
         * Commands should use the selectedOrCurrentRows property in most scenarios.
         */
        readonly selectedRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The selected rows or the current row if there are no selected rows.
         * Commands should use this property instead of selectedRows if they
         * must work on the current row when the user has not made a selection yet.
         */
        readonly selectedOrCurrentRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
    }
    /**
     * EditableGrid selection contract.
     */
    export interface SelectionContract<TItem> extends SelectionState<TItem> {
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * Indicates if all rows are selected.
         */
        readonly allRowsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected rows.
         * Commands should use the selectedOrCurrentRows property in most scenarios.
         */
        readonly selectedRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The selected rows or the current row if there are no selected rows.
         * Commands should use this property instead of selectedRows if they
         * must work on the current row when the user has not made a selection yet.
         */
        readonly selectedOrCurrentRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * Determines if a row can be selected.
         *
         * @param row The row to select.
         * @return Indicates if a row can be selected.
         */
        canSelectRow(row: Row<TItem>): boolean;
        /**
         * Selects a row.
         *
         * @param row The row to select.
         * @return Indicates if the row was selected.
         */
        selectRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row can be unselected.
         *
         * @param row The row to unselect.
         * @return Indicates if a row can be unselected.
         */
        canUnselectRow(row: Row<TItem>): boolean;
        /**
         * Unselects a row.
         *
         * @param row The row to unselect.
         * @return Indicates if the row was unselected.
         */
        unselectRow(row: Row<TItem>): boolean;
        /**
         * Indicates if all rows can be selected.
         */
        readonly canSelectAllRows: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Selects all rows.
         *
         * @return Indicates if all rows were selected.
         */
        selectAllRows(): boolean;
        /**
         * Indicates if all rows can be unselected.
         */
        readonly canUnselectAllRows: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Unselects all rows.
         *
         * @return Indicates if all rows were unselected.
         */
        unselectAllRows(): boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid activation contract.
     */
    export interface ActivationContract<TItem> {
        /**
         * Activated item.
         */
        readonly activatedItem: KnockoutReadOnlyObservableBase<TItem>;
        /**
         * Activated column id.
         */
        readonly activatedColumnId: KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * EditableGrid toolbar options.
     */
    export interface ToolbarOptions<TItem> {
        /**
         * Hides or shows the toolbar.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback to create a customized toolbar.
         * If no callback is supplied the EditableGrid will create a default toolbar.
         *
         * @param toolbarLifetime The lifetime manager for the toolbar.
         * @param grid The grid for creating built-in toolbar items like grid.deletion.createDeleteRowsCommand(toolbarLifetime, grid.selection).
         *             (BREAKING: This parameter used to be a ToolbarItems interface and is now a grid contract to be used as described above.)
         * @returns The toolbar view model that will be used within the grid header.
         */
        createToolbar?: (toolbarLifetime: MsPortalFx.Base.LifetimeManager, grid: Contract<TItem>) => ToolbarControl.Contract;
    }
    /**
     * Toolbar button creation options for grid command factory methods.
     */
    export interface ToolbarButtonOptions {
        /**
         * Telemetry identifier of the toolbar item.
         */
        telemetryName?: string;
        /**
         * The aria label to use instead of the default text label.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The regular tooltip of the toolbar item.
         */
        tooltip?: string | KnockoutObservableBase<string>;
        /**
         * The command label.
         */
        label?: string | KnockoutObservableBase<string>;
        /**
         * The icon for the command.
         */
        icon?: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The tooltip shown when the button is disabled.
         */
        disabledMessage?: string | KnockoutObservableBase<string>;
    }
    /**
     * EditableGrid toolbar contract.
     */
    export interface ToolbarContract<TItem> {
        /**
         * The toolbar view model.
         */
        readonly viewModel: ToolbarControl.Contract;
        /**
         * Controls the toolbar visibility in the grid header.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid addition options.
     */
    export interface AdditionOptions<TItem> {
        /**
         * Callback to create a new item.
         * The item will be held in the placeholder row until committed.
         *
         * @returns A newly created item.
         */
        createItem: () => TItem;
        /**
         * Determines if the user can add additional rows.
         *
         * @param grid The grid.
         * @returns Indicates if the user can add additional rows
         */
        canAddRow?: (grid: Contract<TItem>) => boolean;
        /**
         * Callback when row is added.
         *
         * @param row The added row.
         * @param grid The grid.
         */
        onAddRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid addition contract.
     */
    export interface AdditionContract<TItem> {
        /**
         * Determines if rows can be added
         */
        canAddRow: KnockoutReadOnlyObservableBase<boolean>;
    }
    /**
     * EditableGrid deletion options.
     */
    export interface DeletionOptions<TItem> {
        /**
         * Determines if rows can be deleted.
         *
         * @param rows The rows to delete.
         * @param grid The grid.
         * @returns Indicates if the rows can be deleted.
         */
        canDeleteRows?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Notifies when rows have been deleted.
         *
         * @param rows The rows that were deleted.
         * @param grid The grid.
         */
        onDeleteRows?: (rows: Row<TItem>[], grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid deletion contract.
     */
    export interface DeletionContract<TItem> {
        /**
         * Determines if rows can be deleted.
         *
         * @param rows The rows to delete.
         * @returns Indicates if the rows can be deleted.
         */
        canDeleteRows(rows: Row<TItem>[]): boolean;
        /**
         * Deletes the specified rows.
         *
         * @param rows The rows to delete.
         * @returns Indicates if the rows were deleted.
         */
        deleteRows(rows: Row<TItem>[]): boolean;
        /**
         * Creates a toolbar button for deletion using the supplied rows as the command context.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to be deleted.
         * @param options Toolbar button options for overriding defaults.
         */
        createDeleteRowsCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
    }
    /**
     * EditableGrid editing options.
     */
    export interface EditingOptions<TItem> {
        /**
         * Determines if the specified row can be edited.
         *
         * @param row The row to edit.
         * @param grid The grid.
         * @returns Indicates if the row can be edited.
         */
        canEditRow?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if the specified row can stop editing.
         *
         * @param row The row to stop editing.
         * @param grid The grid.
         * @returns Promise that indicates if the row can stop editing.
         */
        canStopEditingRow?: (row: Row<TItem>, grid: Contract<TItem>) => Q.Promise<boolean>;
    }
    /**
     * EditableGrid editing contract.
     */
    export interface EditingContract<TItem> {
        /**
         * Determines if a row can be edited.
         *
         * @param row The row to edit.
         * @returns Indicates if the row can be edited.
         */
        canEditRow(row: Row<TItem>): boolean;
        /**
         * Puts the specified row into editing mode for the user to edit it.
         *
         * @param row The row to edit.
         * @returns Indicates if the row was put into edit mode.
         */
        editRow(row: Row<TItem>): boolean;
        /**
         * Determine if the row can close all cell editors.
         *
         * @param row The row to stop editing.
         * @returns Promise that indicates if the row can stop editing.
         */
        canStopEditingRow(row: Row<TItem>): Q.Promise<boolean>;
        /**
         * Stops editing the row by closing all the cell editors of the row.
         *
         * @param row The row to stop editing.
         * @returns Promise that indicates if the row successfully stopped editing.
         */
        stopEditingRow(row: Row<TItem>): Q.Promise<boolean>;
    }
    /**
     * EditableGrid insertion options.
     */
    export interface InsertionOptions<TItem> {
        /**
         * Callback to create an new item for insertion.
         *
         * @returns A newly created item.
         */
        createItem: () => TItem;
        /**
         * Determines if a new row can be inserted before the specified row.
         *
         * @param rowBefore The row to insert a new row before.
         * @param grid The grid.
         * @returns Indicates if a new row can be inserted before the specified row.
         */
        canInsertRow?: (rowBefore: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Notifies when a row has been inserted.
         *
         * @param row The row that was inserted.
         * @param grid The grid.
         */
        onInsertRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid insertion contract.
     */
    export interface InsertionContract<TItem> {
        /**
         * Determine if a new row can be inserted before the specified row.
         *
         * @param rowBefore The row to insert a new row before.
         * @returns Indicates if a new row can be inserted before the specified row.
         */
        canInsertRow(rowBefore: Row<TItem>): boolean;
        /**
         * Inserts a new row before the specified row.
         * The grid calls the createItem callback to generate the new item that will be inserted.
         *
         * @param rowBefore The row to insert a new row before.
         * @returns Indicates if a new row was inserted.
         */
        insertRow(rowBefore: Row<TItem>): boolean;
        /**
         * Creates a toolbar button for inserting a row before the supplied row context.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The current row or rows to apply the command status to.  Will be disabled if more than one row is present.
         * @param options Toolbar button options for overriding defaults.
         */
        createInsertRowCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
    }
    /**
     * EditableGrid reordering options.
     */
    export interface ReorderingOptions<TItem> {
        /**
         * Determines if the rows can be moved to the specified row position.
         *
         * @param rows The rows to move.
         * @param to The row in the position where the rows are to be moved.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved to the specified row position.
         */
        canMoveRowsToRow?: (rows: Row<TItem>[], to: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved up.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved up.
         */
        canMoveRowsUp?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved down.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved down.
         */
        canMoveRowsDown?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved to top.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved to the top.
         */
        canMoveRowsTop?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved to bottom.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved to the bottom.
         */
        canMoveRowsBottom?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines it the reordering drag handle UI is visible.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid reordering contract.
     */
    export interface ReorderingContract<TItem> {
        /**
         * Determines if rows can be moved to the specified row position.
         *
         * @param rows The rows to move.
         * @param to The row in the position where the rows are to be moved.
         * @returns Indicates if the rows can be moved to the specified row position.
         */
        canMoveRowsToRow(rows: Row<TItem>[], to: Row<TItem>): boolean;
        /**
         * Moves rows to the specified row position.
         *
         * @param rows The rows to move.
         * @param to The row in the position where the rows are to be moved.
         * @returns Indicates if the rows were moved.
         */
        moveRowsToRow(rows: Row<TItem>[], to: Row<TItem>): boolean;
        /**
         * Determines if rows can be moved up.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved up.
         */
        canMoveRowsUp(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows up.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsUp(rows: Row<TItem>[]): boolean;
        /**
         * Determines if rows can be moved down.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved down.
         */
        canMoveRowsDown(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows down.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsDown(rows: Row<TItem>[]): boolean;
        /**
         * Determines if rows can be moved to the top.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved to the top.
         */
        canMoveRowsTop(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows to the top.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsTop(rows: Row<TItem>[]): boolean;
        /**
         * Determines if rows can be moved to the bottom.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved to the bottom.
         */
        canMoveRowsBottom(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows to the bottom.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsBottom(rows: Row<TItem>[]): boolean;
        /**
         * Creates a toolbar button for moving the supplied context rows up.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @return The command button.
         */
        createMoveRowsUpCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Creates a toolbar button for moving the supplied context rows down.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @return The command button.
         */
        createMoveRowsDownCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Creates a toolbar button for moving the supplied context rows to the top.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @return The command button.
         */
        createMoveRowsTopCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Creates a toolbar button for moving the supplied context rows to the bottom.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @return The command button.
         */
        createMoveRowsBottomCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Determines it the reordering drag handle UI is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid resizing options.
     */
    export interface ResizingOptions<TItem> {
        /**
         * Notification when columns have been resized by the user.
         *
         * @param columns The columns that changed widths.
         * @param grid The grid.
         */
        onColumnsResized?: (columns: Column<TItem>[], grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid scrolling options.
     */
    export interface ScrollingOptions {
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (% or fr units) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * By default vertical scrolling is disabled.
         * Vertical scrolling requires that the element the grid is bound to has a height.
         * Having a height allows the grid to display a vertical scrollbar and fix the header at the top.
         */
        vertical?: boolean;
    }
    /**
     * EditableGrid validation options.
     */
    export interface ValidationOptions<TItem> {
        /**
         * Custom validation call back.
         * Called to validate the grid when the form is validated.
         * Errors can be added and removed from particular cells using the cell customValidationErrors array.
         *
         * @param grid The grid.
         * @returns Indicates if the grid is valid.
         */
        validate?: (grid: Contract<TItem>) => boolean;
        /**
         * Custom async validation call back.
         * Called to validate the grid when the form is validated.
         * Errors can be added and removed from particular cells using the cell customValidationErrors array.
         *
         * @param grid The grid.
         * @returns Promise indicating if the grid is valid.
         */
        validateAsync?: (grid: Contract<TItem>) => Q.Promise<boolean>;
        /**
         * Creates a customized display of validation errors.
         *
         * @param lifetime The lifetime manager for the validation footer.
         * @param row The row to contain the footer. The validationErrors property of the row will have the errors to display.
         * @returns The control to present as the row validation footer.
         */
        createRowValidationFooter?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => HtmlContent | Control;
    }
    /**
     * EditableGrid validation contract.
     */
    export interface ValidationContract<TItem> {
        /**
         * Triggers validation of the grid.
         *
         * @returns Promise that indicates if the grid is valid.
         */
        triggerValidation(): Q.Promise<boolean>;
        /**
         * Indicates if the grid is valid.
         * This is the result of the latest validation.
         */
        readonly valid: KnockoutReadOnlyObservable<boolean>;
    }
    /**
     * EditableGrid context menu options.
     */
    export interface ContextMenuOptions<TItem> {
        /**
         * Determines if the row supports context menu.
         * This is true by default and only needs to be implemented to opt specific rows out.
         * This controls if the context menu shortcut is displayed in the row.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param row The row to show menus for.
         * @param grid The grid.
         * @returns Indicates if the row can show a context menu.
         */
        canShowMenu?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Supplies commands to be displayed in the row context menu.
         * This is not called when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => ToolbarItemContract[] | Q.Promise<ToolbarItemContract[]>;
        /**
         * Supplies bulk commands to be displayed for the rows in a context menu.
         * This is called only when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionState<TItem>, grid: Contract<TItem>) => ToolbarItemContract[] | Q.Promise<ToolbarItemContract[]>;
        /**
         * Determines the maximum buttons commands to display directly in the row.
         * The default is one.
         * Command buttons will be displayed in the row until the count of commands exceeds this max.
         * When the max is exceeded the ellipsis will be displayed indicating more commands and providing a way to open the menu.
         * If zero only the ellipsis will ever be shown.
         */
        maxButtonCommands?: number;
        /**
         * Supplies command buttons to be displayed in the row margin.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyButtonCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => ToolbarItemContract[] | Q.Promise<ToolbarItemContract[]>;
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid context menu contract.
     */
    export interface ContextMenuContract<TItem> {
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid options.
     */
    export interface Options<TItem> {
        /**
         * Addition options for adding new rows.
         * Addition is disabled by default.
         * Addition can be enabled by specifying addition options.
         */
        addition?: AdditionOptions<TItem>;
        /**
         * The accessibility label for the grid.
         */
        ariaLabel: string | KnockoutObservableBase<string>;
        /**
         * The column definitions.
         * This is required because it is expected that the existing columns will be known or obtained before creating the grid.
         */
        columns: ColumnDefinition<TItem>[] | KnockoutObservableArray<ColumnDefinition<TItem>>;
        /**
         * Context menu options.
         */
        contextMenu?: ContextMenuOptions<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Deletion options for deleting rows.
         * Deletion is disabled by default.
         * Deletion can be enabled by specifying deletion options.
         */
        deletion?: DeletionOptions<TItem>;
        /**
         * Disabled state.
         */
        disabled?: boolean;
        /**
         * Editing options for editing existing rows.
         * Editing is enabled by default.
         * Editing can not be disabled by omitting editing options or setting to null.
         * Providing a cell editor control on a column will enable editing of cells withing the column.
         * The canEditRow callback can be used to disable editing of particular rows.
         */
        editing?: EditingOptions<TItem>;
        /**
         * Focus options.
         * Focus is enabled by default.
         * Focus can not be disabled by omitting the focus options or setting to null.
         */
        focus?: FocusOptions<TItem>;
        /**
         * Header definition.
         * Initializes the grid header.
         */
        header?: HeaderDefinition;
        /**
         * Insertion options for inserting a new row.
         * Insertion is disabled by default.
         * Insertion can be enabled by specifying insertion options.
         */
        insertion?: InsertionOptions<TItem>;
        /**
         * The array of items to be edited.
         * Changes will be made directly to this array as the user makes edits.
         * This is required because it is expected that the existing data is obtained before creating the grid.
         * If you do not have existing data you can specify an empty array.
         */
        items: TItem[] | KnockoutObservableArray<TItem>;
        /**
         * Reordering options for reordering rows.
         * Reordering is disabled by default.
         * Reordering can be enabled by specifying reordering options.
         */
        reordering?: ReorderingOptions<TItem>;
        /**
         * Resizing options.
         * Resizing is enabled by default.
         * Resizing can be disabled by setting to null.
         */
        resizing?: ResizingOptions<TItem>;
        /**
         * Row initialization options
         */
        row?: RowDefinition<TItem>;
        /**
         * Scrolling options.
         * By default horizontal scrolling is enabled and vertical scrolling is disabled.
         * Setting to null will disable all in-grid scrolling.
         */
        scrolling?: ScrollingOptions;
        /**
         * Selection options.
         * Selection is enabled by default.
         * Selection can not be disabled by omitting selection options or setting to null.
         */
        selection?: SelectionOptions<TItem>;
        /**
         * Toolbar options.
         * The toolbar is disabled by default.
         * The toolbar can be enabled by providing toolbar options.
         */
        toolbar?: ToolbarOptions<TItem>;
        /**
         * Validation options.
         * Validation is enabled by default.
         * Validation can not be disabled by omitting validation options or setting to null.
         */
        validation?: ValidationOptions<TItem>;
        /**
         * Hides or shows the EditableGrid.
         */
        visible?: boolean;
    }
    /**
     * EditableGrid contract.
     */
    export interface Contract<TItem> extends Control {
        /**
         * EditableGrid activation properties and methods.
         */
        readonly activation: ActivationContract<TItem>;
        /**
         * EditableGrid grid row addition properties and methods.
         */
        readonly addition: AdditionContract<TItem>;
        /**
         * The accessibility label for the grid.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The columns of the grid.
         */
        readonly columns: ColumnCollection<TItem>;
        /**
         * Context menu properties and methods.
         */
        readonly contextMenu: ContextMenuContract<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Gets or sets the EditableGrid dirty state.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Displays a loading message until the supplied promise is resolved or rejected.
         * if called multiple times the promises are queued and the grid remains in a loading state until all loading tasks are completed.
         *
         * @param completion Promise for completion.
         * @param message Optional message to display.
         */
        displayLoadingMessage(completion: Q.Promise<any>, message?: string): void;
        /**
         * EditableGrid row deletion properties and methods.
         */
        readonly deletion: DeletionContract<TItem>;
        /**
         * EditableGrid row editing properties and methods.
         */
        readonly editing: EditingContract<TItem>;
        /**
         * EditableGrid focus properties and methods.
         */
        readonly focus: FocusContract<TItem>;
        /**
         * The grid header.
         */
        readonly header: Header;
        /**
         * Editable grid row insertion properties and methods.
         */
        readonly insertion: InsertionContract<TItem>;
        /**
         * The array of items to be edited.
         * Changes will be made directly to this array as the user makes edits.
         */
        readonly items: KnockoutObservableArray<TItem>;
        /**
         * Indicates when the grid is in a loading state.
         * Controlled by displayLoadingMessage() method.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid is in a loading state.
         * Controlled by displayLoadingMessage() method.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * EditableGrid row reordering properties and methods.
         */
        readonly reordering: ReorderingContract<TItem>;
        /**
         * The grid rows.
         */
        readonly rows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * EditableGrid selection properties and methods.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * EditableGrid toolbar properties and methods.
         */
        readonly toolbar: ToolbarContract<TItem>;
        /**
         * EditableGrid row validation properties and methods.
         */
        readonly validation: ValidationContract<TItem>;
        /**
         * Hides or shows the EditableGrid.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates an EditableGrid control.
     *
     * @param lifetime The lifetime manager for the grid.
     * @param options The options for creating the grid.
     * @returns The created grid.
     */
    export function create<TItem>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<TItem>): Contract<TItem>;
}

// FILE: Fx\Controls\Editor.d.ts
declare module "Fx/Controls/Editor" {
    import * as Base from "Fx/Controls/ControlsBase";
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    /**
     * Exposes the second part of a keyboard shortcut allowed to be mapped to the Monaco editor, if there are two keys in the shortcut.
     * Otherwise, exposes the only key bound to the shortcut.
     * The enum values are copied from Monaco Editor API(https://microsoft.github.io/monaco-editor) and should be kept in sync with it.
     */
    export const enum KeyCode {
        /**
         * Placed first to cover the 0 value of the enum.
         */
        Unknown = 0,
        Backspace = 1,
        Tab = 2,
        Enter = 3,
        Shift = 4,
        Ctrl = 5,
        Alt = 6,
        PauseBreak = 7,
        CapsLock = 8,
        Escape = 9,
        Space = 10,
        PageUp = 11,
        PageDown = 12,
        End = 13,
        Home = 14,
        LeftArrow = 15,
        UpArrow = 16,
        RightArrow = 17,
        DownArrow = 18,
        Insert = 19,
        Delete = 20,
        KEY_0 = 21,
        KEY_1 = 22,
        KEY_2 = 23,
        KEY_3 = 24,
        KEY_4 = 25,
        KEY_5 = 26,
        KEY_6 = 27,
        KEY_7 = 28,
        KEY_8 = 29,
        KEY_9 = 30,
        KEY_A = 31,
        KEY_B = 32,
        KEY_C = 33,
        KEY_D = 34,
        KEY_E = 35,
        KEY_F = 36,
        KEY_G = 37,
        KEY_H = 38,
        KEY_I = 39,
        KEY_J = 40,
        KEY_K = 41,
        KEY_L = 42,
        KEY_M = 43,
        KEY_N = 44,
        KEY_O = 45,
        KEY_P = 46,
        KEY_Q = 47,
        KEY_R = 48,
        KEY_S = 49,
        KEY_T = 50,
        KEY_U = 51,
        KEY_V = 52,
        KEY_W = 53,
        KEY_X = 54,
        KEY_Y = 55,
        KEY_Z = 56,
        Meta = 57,
        ContextMenu = 58,
        F1 = 59,
        F2 = 60,
        F3 = 61,
        F4 = 62,
        F5 = 63,
        F6 = 64,
        F7 = 65,
        F8 = 66,
        F9 = 67,
        F10 = 68,
        F11 = 69,
        F12 = 70,
        F13 = 71,
        F14 = 72,
        F15 = 73,
        F16 = 74,
        F17 = 75,
        F18 = 76,
        F19 = 77,
        NumLock = 78,
        ScrollLock = 79,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ';:' key
         */
        US_SEMICOLON = 80,
        /**
         * For any country/region, the '+' key
         * For the US standard keyboard, the '=+' key
         */
        US_EQUAL = 81,
        /**
         * For any country/region, the ',' key
         * For the US standard keyboard, the ',<' key
         */
        US_COMMA = 82,
        /**
         * For any country/region, the '-' key
         * For the US standard keyboard, the '-_' key
         */
        US_MINUS = 83,
        /**
         * For any country/region, the '.' key
         * For the US standard keyboard, the '.>' key
         */
        US_DOT = 84,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '/?' key
         */
        US_SLASH = 85,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '`~' key
         */
        US_BACKTICK = 86,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '[{' key
         */
        US_OPEN_SQUARE_BRACKET = 87,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '\|' key
         */
        US_BACKSLASH = 88,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ']}' key
         */
        US_CLOSE_SQUARE_BRACKET = 89,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ''"' key
         */
        US_QUOTE = 90,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        OEM_8 = 91,
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        OEM_102 = 92,
        NUMPAD_0 = 93,
        NUMPAD_1 = 94,
        NUMPAD_2 = 95,
        NUMPAD_3 = 96,
        NUMPAD_4 = 97,
        NUMPAD_5 = 98,
        NUMPAD_6 = 99,
        NUMPAD_7 = 100,
        NUMPAD_8 = 101,
        NUMPAD_9 = 102,
        NUMPAD_MULTIPLY = 103,
        NUMPAD_ADD = 104,
        NUMPAD_SEPARATOR = 105,
        NUMPAD_SUBTRACT = 106,
        NUMPAD_DECIMAL = 107,
        NUMPAD_DIVIDE = 108,
        /**
         * Cover all key codes when IME is processing input.
         */
        KEY_IN_COMPOSITION = 109,
        ABNT_C1 = 110,
        ABNT_C2 = 111,
        /**
         * Placed last to cover the length of the enum.
         * Please do not depend on this value!
         */
        MAX_VALUE = 112
    }
    /**
     * Exposes the first part of a keyboard shortcut allowed to be mapped to the Monaco editor, if the shortcut contains two keys.
     * The enum values are copied from Monaco Editor API(https://microsoft.github.io/monaco-editor) and should be kept in sync with it.
     */
    export const enum KeyModifier {
        CtrlCmd = 2048,
        Shift = 1024,
        Alt = 512
    }
    /**
     * Custom Keyboard shortcuts that can be bound to CallBack functions.
     */
    export interface CustomCommand {
        commandCallback: (keyCode: KeyCode, keyModifier?: KeyModifier) => void;
        keyCode: KeyCode;
        keyModifier?: KeyModifier;
    }
    /**
     * Options for creating an editor control
     */
    export interface Options {
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Custom Keyboard shortcuts that can be bound to CallBack functions.
         */
        readonly customCommands?: CustomCommand[] | KnockoutObservableArray<CustomCommand>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The content of the editor.
         */
        readonly content: string | KnockoutObservableBase<string>;
        /**
         * Content uri is used to infer the content type, if content is not given. Editor does not load the content from the Uri.
         */
        readonly contentUri?: string | KnockoutObservableBase<string>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers?: Marker[] | KnockoutObservableBase<Marker[]>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize?: number | KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn?: number | KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines?: number | KnockoutObservableBase<number>;
        /**
         * Enables highlighting of all words/tokens matching the words/tokens under the cursor position.
         * blockHighlight is not affected by this value.
         * Defaults to true.
         */
        readonly selectionHighlight?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Enables highlighting the block under the cursor position.
         * The block definition can be provided using the defineBlock callback.
         * selectionHighlight is not affected by this value.
         * Defaults to false.
         */
        readonly blockHighlight?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Block highlight definition.
         * If the callback is provided, its logic will be used to identify the block based on cursor position.
         * If the callback is not provided, the default logic is used where blank lines act as the block delimiters.
         */
        readonly defineBlock?: (cursorPosition: CursorPosition, lines: string[]) => Range;
        /**
         * Defines an auto save delay in millisenconds when it expires the editor changes are saved.
         * The delay is set each time the user changes the text and if there where no changes until the time expires the changes are saved
         * Zero -or- null means auto save is disabled.
         * Defaults to 500 milliseconds.
         */
        readonly autoSaveDelay?: number;
    }
    /**
     * Type of editor content.
     * Used to enable language specific editor features like colorization.
     */
    export const enum ContentType {
        /**
         * Text.
         * 'text/plain'
         */
        Text = 0,
        /**
         * Custom Content Type.
         */
        Custom = 1,
        /**
         * Batch Script.
         * 'text/x-bat'
         */
        Bat = 2,
        /**
         * C.
         * 'text/x-c'
         */
        C = 3,
        /**
         * Coffee Script.
         * 'text/x-coffeescript', 'text/coffeescript'
         */
        CoffeeScript = 4,
        /**
         * C++.
         * 'text/x-cpp'
         */
        Cpp = 5,
        /**
         * C#.
         * 'text/x-csharp'
         */
        CSharp = 6,
        /**
         * C# WebPages.
         * 'text/x-cshtml'
         */
        CSHtml = 7,
        /**
         * Cascading Style Sheet.
         * 'text/css'
         */
        Css = 8,
        /**
         * Dockerfile.
         * 'text/x-dockerfile'
         */
        Dockerfile = 9,
        /**
         * F#.
         * 'text/x-fsharp'
         */
        FSharp = 10,
        /**
         * Go.
         * 'text/x-go'
         */
        Go = 11,
        /**
         * Handlebars template.
         * 'text/x-handlebars-template'
         */
        Handlebars = 12,
        /**
         * Html.
         * 'text/html'
         */
        Html = 13,
        /**
         * Initialization file.
         * 'text/x-ini'
         */
        Ini = 14,
        /**
         * Pug.
         * 'pug'
         */
        Pug = 15,
        /**
         * Java.
         * 'text/x-java-source'
         */
        Java = 16,
        /**
         * JavaScript.
         * 'text/javascript'
         */
        JavaScript = 17,
        /**
         * JSHtm.
         * 'text/x-jshtm'
         */
        JSHtm = 18,
        /**
         * JSON.
         * 'application/json'
         */
        Json = 19,
        /**
         * Less.
         * 'text/x-less', 'text/less'
         */
        Less = 20,
        /**
         * Lua.
         * 'text/x-lua'
         */
        Lua = 21,
        /**
         * Mark Down.
         * 'text/x-markdown'
         */
        MarkDown = 22,
        /**
         * Objective-C
         * 'objective-c'
         */
        ObjectiveC = 23,
        /**
         * PHP.
         * 'application/x-php'
         */
        Php = 24,
        /**
         * Power Shell.
         * 'text/x-powershell'
         */
        PowerShell = 25,
        /**
         * Python.
         * 'text/x-python', 'text/python'
         */
        Python = 26,
        /**
         * R.
         * 'text/x-r'
         */
        R = 27,
        /**
         * Ruby.
         * 'text/x-ruby'
         */
        Ruby = 28,
        /**
         * SQL.
         * 'sql'
         */
        Sql = 29,
        /**
         * Swift.
         * 'swift'
         */
        Swift = 30,
        /**
         * TypeScript.
         * 'text/typescript'
         */
        TypeScript = 31,
        /**
         * Visual Basic.
         * 'text/x-vb'
         */
        VisualBasic = 32,
        /**
         * Xaml.
         * 'application/xaml+xml'
         */
        Xaml = 33,
        /**
         * Xml.
         * 'text/xml', 'application/xml'
         */
        Xml = 34,
        /**
         * MySQL.
         * 'mysql'
         */
        MySQL = 35,
        /**
         * PgSQL.
         * 'pgsql'
         */
        PgSQL = 36
    }
    /**
     * Options for creating an editor control
     */
    export interface EditorOptions extends Options {
        /**
         * The type of editor content.
         */
        readonly contentType?: ContentType | KnockoutObservableBase<ContentType>;
    }
    /**
     * Options for creating a JSON editor control
     */
    export interface JSONEditorOptions extends Options {
        /**
         * JSON schemas.
         */
        readonly schemas: JSONSchema[];
        /**
         * If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
         */
        readonly allowComments?: boolean;
    }
    /**
     * Options for creating an editor control
     */
    export interface TypeScriptEditorOptions extends Options {
        /**
         * Additional source files to the language service. Use this
         * for typescript (definition) files that won't be loaded as editor
         * document, like `jquery.d.ts`.
         */
        readonly extraLibs?: TypeScriptExtraLib[];
        /**
         * Compiler options for compiling the typescript.
         */
        readonly compilerOptions: TypeScriptCompilerOptions;
    }
    /**
     * Options for creating a custom editor control
     */
    export interface CustomEditorOptions extends Options {
        /**
         * Definition for a custom content type.
         */
        readonly customConfig: CustomConfig;
    }
    /**
     *  A cursor position in the text editor.  Same properties as a Monaco IPosition interface
     */
    export interface CursorPosition {
        /**
         * line number (1-based line number)
         */
        readonly lineNumber: number;
        /**
         * column (the first character in a line is between column 1 and column 2)
         */
        readonly column: number;
    }
    /**
     * JSON schema
     */
    export interface JSONSchema {
        /**
         * A list of filename patterns (including '*' wildcards) for files that should be associated with the schema. For example '*.schema.json', 'package.json'
         */
        readonly fileMatch: string[];
        /**
         * Indicates uri from which schema will be loaded.
         */
        readonly uri?: string;
        /**
         * Indicates to validate schema.
         */
        readonly validate?: boolean;
        /**
         * Inline schema definition.
         */
        readonly schema?: StringMap<any>;
    }
    /**
     * Defines an extra library for intellisense in the typescript editor.
     */
    export interface TypeScriptExtraLib {
        /**
         * The content of the library.
         * For example the content of a library.d.ts file.
         */
        readonly content: string;
        /**
         * The library name.
         * For instance "library.d.ts".
         */
        readonly path?: string;
    }
    /**
     * TypeScript compiler options.
     */
    export interface TypeScriptCompilerOptions {
        /**
         * The target type for compilation.
         * Defaults to ES5.
         */
        readonly target?: TypeScriptTarget;
    }
    /**
     * Definition of a custom language config.
     * See https://microsoft.github.io/monaco-editor/monarch.html
     */
    export interface CustomConfig {
        /**
         * Custom language attributes.
         * These are specific to your language definition.
         *
         * This can be an array of strings:
         *
         * keywords: ["if", "for"],
         *
         * Or this can be a regular expression:
         *
         * symbols: /[=><!~?:&|+-]+/,
         *
         * The attribute can also be a string containing a regular expression.
         */
        readonly [attribute: string]: string | string[] | RegExp | any;
        /**
         * The display name of your language.
         */
        readonly displayName?: string;
        /**
         * Ignore case when compiling regular expressions defined in 'tokenizer'.
         * Default is false.
         */
        readonly ignoreCase?: boolean;
        /**
         * An optional line comment starter.Used in the editor to insert line comments (ctrl + /).
         * Default is two forward slashes.
         */
        readonly lineComment?: string;
        /**
         * A block comment start marker. Used by the editor to insert block comments (shift+alt+A).
         * Default is forward slash asterisk.
         */
        readonly blockCommentStart?: string;
        /**
         * A block comment end marker.
         * Default is asterisk forward slash.
         */
        readonly blockCommentEnd?: string;
        /**
         * The default token returned if nothing matches in the tokenizer.
         * Default is "source".
         * It can be convenient to set this to "invalid" during development of your colorizer to easily spot what is not matched yet.
         */
        readonly defaultToken?: string;
        /**
         * This is used by the tokenizer to easily define matching braces.
         * Each bracket definition is an array of 3 elements, or object, describing the open brace, the close brace, and the token class.
         * The default definition is:
         * [ ['{','}','delimiter.curly'],
         *   ['[',']','delimiter.square'],
         *   ['(',')','delimiter.parenthesis'],
         *   ['<','>','delimiter.angle'] ]
         */
        readonly brackets?: string[][];
        /**
         * A list of auto closing character pairs, used in the editor to automatically insert the closing brace of the pair.
         * The list may end with the single string '@brackets' which automatically includes single-character close brackets defined in the brackets attribute.
         * By default the auto closing pairs are defined as: [['"','"'], ['\'','\''], ['@brackets']]
         */
        readonly autoClosingPairs?: string[][];
        /**
         * Optional postfix attached to all returned tokens.
         * By default this attaches the language name so in the CSS you can refer to your specific language.
         * For example, for the Java language, we could use .identifier.java to target all Java identifiers specifically in CSS.
         */
        readonly tokenPostfix?: string;
        /**
         * The start state of the tokenizer.
         * By default, this is the first entry in the tokenizer attribute.
         */
        readonly start?: string;
        /**
         * Optional list of token classes that are non-word tokens.
         * By default this is defined as: ['delimiter','delimiter.parenthesis','delimiter.curly','delimiter.square','delimiter.angle']
         */
        readonly nonWordTokens?: string[];
        /**
         * Optional string that defines characters that when typed could cause outdentation.
         * This attribute is only used when using advanced brace matching in combination with the bracket attribute.
         * By default it always includes the last characters of the closing brackets in the brackets list.
         * Outdentation happens when the user types a closing bracket word on an line that starts with only white space.
         * If the closing bracket matches a open bracket it is indented to the same amount of that bracket.
         * Usually, this causes the bracket to outdent. For example, in the Ruby language, the end keyword would match with an open declaration like def or class.
         * To make outdentation happen though, we would need to include the d character in the outdentTriggers attribute so it is checked when the users type end:
         *
         * outdentTriggers: 'd',
         */
        readonly outdentTriggers?: string;
        /**
         * This can be used to get autocompletion for certain constructs.
         * For example, in HTML we may want to auto complete a tag with its closing tag when the user types >.
         * A possible way to do this is to define autoComplete:
         *
         * autoComplete: [{
         *     triggers: '>',
         *     match   : '\\s<(\\w+)[^>]*>\\s$',
         *     complete: '</$1>'
         * }],
         *
         * Each matcher specifies three attributes:
         * the triggers attribute gives a string of characters where autocompletion should be checked.
         * On such character, the current input line is tested against match regular expression.
         * If it succeeds, complete is appended to the source with captured groups expanded.
         * To help with matching input, the editor first filters out all whitespace and comment tokens, and then concatenates the remaining tokens where every token is surrounded with a space.
         * The match regular expression is matched against the resulting string.
         */
        readonly autoComplete?: AutoCompleteMatcher[];
        /**
         * This can be used to specify custom auto indentation beyond what is already done for brackets and the bracket attributes.
         * Suppose for example we would like to indent for begin/end pairs.
         * The easy way to do this is off course to just specify this pair as part of the brackets attribute.
         * But for the sake of an example, here is how to do it using autoIndent:
         *
         * autoIndent: [{
         *     match     : "\\sbegin\\s(((?!\\send\\s).)*)$",
         *     matchAfter: "\\send\\s"
         * }],
         *
         * On an enter, the current line is matched against the match regular expression.
         * Note that the line is processed as described in autoComplete where each token is surrounded by a space.
         * If the match succeeds, the next line is indented.
         * If also the matchAfter regular expression matches the tokens following the line break, then an extra break is inserted that is outdented (creating a nice block structure).
         * In the example, the match regular expression matches a line where a begin keyword is present.
         * It uses (?!\\send\\s) to ensure there is no closing end after the begin.
         */
        readonly autoIndent?: AutoIndentMatcher[];
        /**
         * As described for the bracket attribute, the editor uses auto indentation for any bracket.
         * This attribute suppresses auto indentation for any brackets that match the regular expression.
         * For example, here is how to suppress auto indentation for parenthesis and angled braces:
         *
         * noindentBrackets: /[()<>]/,
         */
        readonly noindentBrackets?: RegExp;
        /**
         * Monarch custom language tokenization rules.
         *
         * The tokenizer attribute describes how lexical analysis takes place, and how the input is divided into tokens.
         * Each token is given a CSS class name which is used to render each token in the editor.
         * Standard CSS token classes include:
         *
         *     identifier         entity           constructor
         *     operators          tag              namespace
         *     keyword            info-token       type
         *     string             warn-token       predefined
         *     string.escape      error-token      invalid
         *     comment            debug-token
         *     comment.doc        regexp
         *     constant           attribute
         *
         *     delimiter .[curly,square,parenthesis,angle,array,bracket]
         *     number    .[hex,octal,binary,float]
         *     variable  .[name,value]
         *     meta      .[content]
         *
         *     A tokenizer consists of an object that defines states.
         *     The initial state of the tokenizer is the first state defined in the tokenizer.
         *     When a tokenizer is in a certain state, only the rules in that state will be applied.
         *     All rules are matched in order and when the first one matches its action is used to determine the token class.
         *     No further rules are tried.
         *     Therefore, it can be important to order the rules in a way that is most efficient, i.e. whitespace and identifiers first.
         *
         *     (Advanced) A state is interpreted as dot (.) separated sub-states.
         *     When looking up the rules for a state, the tokenizer first tries the entire state name, and then looks at its parent until it finds a definition.
         *     For example, in our example, the states "comment.block" and "comment.foo" would both be handled by the comment rules.
         *     Hierarchical state names can be used to maintain complex lexer states, as shown for example in the section on complex embeddings.
         *
         *     Each state is defined as an array of rules which are used to match the input.
         */
        readonly tokenizer: {
            [stateName: string]: TokenizationRule[];
        };
        /**
         * Code completion suggestion support for the custom language.
         */
        readonly suggestSupport?: SuggestSupport;
    }
    /**
     * Defines a tokenizer rule.
     * Rules can have the following forms:
     *
     *     {regex: regex, action: action }
     *          TokenizationRegexRule
     *
     *     { include: state }
     *         TokenizationIncludeRule
     *
     *     [regex, action]
     *         Shorthand for TokenizationRegexRule with action: { regex: regex, action: action }
     *
     *     [regex, action, next]
     *         Shorthand for TokenizationRegexRule with action having next: { regex: regex, action: action{ next: next } }
     */
    export type TokenizationRule = TokenizationRegexRule | TokenizationIncludeRule | (RegExp | string | TokenizationRuleAction)[];
    /**
     * Defines a regular expression tokenization rule.
     * When regex matches against the current input, then action is applied to set the token class.
     */
    export interface TokenizationRegexRule {
        /**
         * The regular expression for the rule.
         *
         * The regular expression regex can be either a regular expression (using /regex/), or a string representing a regular expression.
         * If it starts with a ^ character, the expression only matches at the start of a source line.
         * The $ can be used to match against the end of a source line.
         * Note that the tokenizer is not called when the end of the line is already reached, and the empty pattern /$/ will therefore never match (but see '@eos' too).
         * Inside a regular expression, you can reference a string attribute named attr as @attr, which is automatically expanded.
         * This is used in the standard example to share the regular expression for escape sequences using '@escapes' inside the regular expression for characters and strings.
         *
         * Regular expression primer: common regular expression escapes we use are \d for [0-9], \w for [a-zA-Z0-9_], and \s for [ \t\r\n].
         * The notation regex{n} stands for n occurrences of regex.
         * Also, we use (?=regex) for non-consuming `followed by regex', (?!regex) for `not followed by', and (?:regex) for a non-capturing group (i.e. cannot use $n to refer to it).
         */
        readonly regex: RegExp | string;
        /**
         * The action for the rule.
         */
        readonly action: TokenizationRuleAction[];
    }
    /**
     * Used for nice organization of your rules and expands to all the rules defined in state.
     * This is pre-expanded and has no influence on performance.
     * Many samples include the '@whitespace' state for example.
     */
    export interface TokenizationIncludeRule {
        /**
         * The state to include.
         */
        readonly include: string;
    }
    /**
     * The scalar rule actions that are allowed.
     */
    export type TokenizationRuleScalarAction = TokenizationRuleTokenAction | TokenizationRuleCasesAction | string;
    /**
     * Defines a rule action.
     * An action can have the following forms:
     *
     *     { token: tokenclass }
     *         TokenizationRuleTokenAction
     *
     *     { cases: { guard1: action1, ..., guardN: actionN } }
     *         TokenizationRuleCasesAction
     *
     *     string
     *         Shorthand for TokenizationRuleTokenAction with token only: { token: string }.
     *
     *     [action1,...,actionN]
     *         An array of N actions.
     */
    export type TokenizationRuleAction = TokenizationRuleScalarAction | TokenizationRuleScalarAction[];
    /**
     * An object that defines the token class used with CSS rendering.
     */
    export interface TokenizationRuleTokenAction {
        /**
         * The token class.
         *
         * Common token classes are for example 'keyword', 'comment' or 'identifier'.
         * You can use a dot to use hierarchical CSS names, like 'type.identifier' or 'string.escape'.
         * You can also include $ patterns that are substituted with a captured group from the matched input or the tokenizer state.
         * There are some special token classes:
         *
         * "@brackets"or "@brackets.tokenclass
         *     Signifies that brackets were tokenized.
         *     The token class for CSS is determined by the token class defined in the brackets attribute (together with tokenclass if present).
         *     Moreover, bracket attribute is set such that the editor is matches the braces (and does auto indentation).
         *     For example:
         *         [/[{}()\[\]]/, '@brackets']
         *
         * "@rematch"
         *    (Advanced) Backs up the input and re-invokes the tokenizer.
         *    This of course only works when a state change happens too (or we go into an infinite recursion), so this is usually used in combination with the next attribute.
         *    This can be used for example when you are in a certain tokenizer state and want to get out when seeing certain end markers but don't want to consume them while being in that state.
         *    See also nextEmbedded.
         */
        readonly token: string;
        /**
         * If defined it pushes the current state onto the tokenizer stack and makes state the current state.
         * This can be used for example to start tokenizing a block comment: ['/\\*', 'comment', '@comment' ]
         *
         * Note that this is a shorthand for
         *     { regex: '/\\*', action: { token: 'comment', next: '@comment' } }
         *
         * Here the matched /* is given the "comment" token class, and the tokenizer proceeds with matching the input using the rules in state @comment.
         *
         * There are a few special states that can be used for the next attribute:
         *
         *    "@pop"
         *        Pops the tokenizer stack to return to the previous state.
         *        This is used for example to return from block comment tokenizing after seeing the end marker: ['\\*<forward slash>', 'comment', '@pop']
         *
         *    "@push"
         *        Pushes the current state and continues in the current state.
         *        Nice for doing nested block comments when seeing a comment begin marker, i.e.in the @comment state, we can do: ['/\\*', 'comment', '@push']
         *
         *    "@popall"
         *        Pops everything from tokenizer stack and returns to the top state.
         *        This can be used during recovery to 'jump' back to the initial state from a deep nesting level.
         */
        readonly next?: string;
        /**
         * Switch to state without changing the stack.
         */
        readonly switchTo?: string;
        /**
         * Back up the input by number characters.
         */
        readonly goBack?: number;
        /**
         * Advanced bracket kind.
         * The kind can be either '@open' or '@close'.
         * This signifies that a token is either an open or close brace.
         * This attribute is set automatically if the token class is @brackets.
         * The editor uses the bracket information to show matching braces (where an open bracket matches with a close bracket if their token classes are the same).
         * Moreover, when a user opens a new line the editor will do auto indentation on open braces.
         * Normally, this attribute does not need to be set if you are using the brackets attribute and it is only used for complex brace matching.
         */
        readonly bracket?: string;
        /**
         * Signifies to the editor that this token is followed by code in another language specified by the mimeType, i.e. for example text/javascript.
         * Internally, our syntax highlighter keeps tokenizing the source until it finds an an ending sequence.
         * At that point, you can use nextEmbedded with a '@pop' value to pop out of the embedded mode again.
         * Usually, we need to use a next attribute too to switch to a state where we can tokenize the foreign code.
         * As an example, here is how we could support CSS fragments in our language:
         *     root: [
         *         [/<style\s*>/,   { token: 'keyword', bracket: '@open' , next: '@css_block', nextEmbedded: 'text/css' }],
         *         [/<\/style\s*>/, { token: 'keyword', bracket: '@close' }],
         *         ...
         *     ],
         *
         *     css_block: [
         *         [/[^"<]+/, ''],
         *         [/<\/style\s*>/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],
         *         [/"/, 'string', '@string' ],
         *          [/</, '']
         *     ],
         *
         * Note how we switch to the css_block state for tokenizing the CSS source.
         * Also inside the CSS we use the @string state to tokenize CSS strings such that we do not stop the CSS block when we find </style> inside a string.
         * When we find the closing tag, we also "@pop" the state to get back to normal tokenization.
         * Finally, we need to "@rematch" the token (in the root state) since the editor ignores our token classes until we actually exit the embedded mode.
         */
        readonly nextEmbedded?: string;
        /**
         * Debug logging.
         * Logs message to the console window in the browser (press F12 to see it).
         * This can be useful to see if a certain action is executing.
         * For example: [/\d+/, { token: 'number', log: 'found number $0 in state $S0' } ]
         */
        readonly log?: string;
    }
    export interface TokenizationRuleCasesAction {
        /**
         * The cases for the action.
         */
        readonly cases: ReadonlyStringMap<TokenizationRuleAction>;
    }
    /**
     * Defines suggestions for code completion in a custom language.
     */
    export interface SuggestSupport {
        /**
         * Indicates if completions should automatically be provided from the current document contents.
         */
        readonly textualCompletions?: boolean;
        /**
         * Array of characters that will trigger suggestions pop-up.
         */
        readonly triggerCharacters?: ReadonlyArray<string>;
        /**
         * Snippet definitions.
         * This is an array containing snippet definitions or simple text suggestions.
         */
        readonly snippets: ReadonlyArray<string | SuggestSupportSnippet>;
    }
    /**
     * Defines a code suggestion snippet for a custom language.
     */
    export interface SuggestSupportSnippet {
        /**
         * The type of snippet.
         */
        readonly type: string;
        /**
         * The label displayed in the suggest support pop up.
         */
        readonly label: string;
        /**
         * The snippet to insert.
         */
        readonly codeSnippet: string;
        /**
         * Documentation to display in the suggest support pop-up.
         */
        readonly documentationLabel?: string;
    }
    /**
     * Auto Complete matcher for custom content type.
     */
    export interface AutoCompleteMatcher {
        /**
         * The string of characters where autocompletion should be checked.
         */
        readonly triggers: string;
        /**
         * Regular expression that is tested against the current input line when triggred.
         */
        readonly match: string;
        /**
         * On match is appended to the source with captured groups expanded.
         */
        readonly complete: string;
    }
    /**
     * Auto indent matcher for custom content type.
     */
    export interface AutoIndentMatcher {
        /**
         * Regular expression matched against the current line on an enter to determine indentation.
         */
        readonly match: string;
        /**
         * Regular expression matched against the tokens following the line break to determing block indentation.
         */
        readonly matchAfter: string;
    }
    /**
     * The typescript script target.
     */
    export const enum TypeScriptTarget {
        /**
         * ECMAScript 3.
         */
        ES3 = 0,
        /**
         * ECMAScript 5.
         */
        ES5 = 1,
        /**
         * ECMAScript 2015.
         */
        ES2015 = 2,
        /**
         * ECMAScript 2016.
         */
        ES2016 = 3,
        /**
         * ECMAScript 2017.
         */
        ES2017 = 4,
        /**
         * ECMAScript 2018.
         */
        ES2018 = 5,
        /**
         * ECMAScript 2019.
         */
        ES2019 = 6,
        /**
         * ECMAScript 2020.
         */
        ES2020 = 7,
        /**
         * ECMAScript Next.
         */
        ESNext = 99,
        /**
         * JSON.
         */
        JSON = 100,
        /**
         * Latest.
         */
        Latest = 6
    }
    /**
     * Generic editor contract.
     */
    export interface EditorContract extends Contract {
        /**
         * The type of the editor content.
         */
        readonly contentType: KnockoutObservableBase<ContentType>;
    }
    /**
     * Custom editor contract.
     */
    export interface CustomEditorContract extends Contract {
        /**
         * Custom language configruation.
         */
        readonly customConfig: KnockoutObservableBase<CustomConfig>;
    }
    /**
     * JSON editor contract.
     */
    export interface JSONEditorContract extends Contract {
    }
    /**
     * TypeScript editor contract.
     */
    export interface TypeScriptEditorContract extends Contract {
        /**
         * The typescript compiler output.
         * Updated on each save.
         * This is the transpiled javascript content.
         */
        readonly typescriptOutput: KnockoutObservableBase<string>;
    }
    /**
     * Editor contract.
     */
    export interface Contract extends Base.Control {
        /**
         * Custom Keyboard shortcuts that can be bound to CallBack functions.
         */
        readonly customCommands: KnockoutObservableArray<CustomCommand>;
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The content of the editor content.
         */
        readonly content: KnockoutObservableBase<string>;
        /**
         * Content uri is used to infer the content type, if content is not given. Editor does not load the content from the Uri.
         */
        readonly contentUri: KnockoutObservableBase<string>;
        /**
         * The currently selected content of the editor content.
         */
        readonly selectedContent: KnockoutReadOnlyObservableBase<string>;
        /**
         * The currently selected range in the editor content.
         */
        readonly selectedRange: KnockoutObservableBase<Range>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers: KnockoutObservableBase<Marker[]>;
        /**
         *  Current position of the cursor in the editor content. Position is updated when editor saves the content.
         */
        readonly cursorPosition: KnockoutObservableBase<CursorPosition>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar: KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize: KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn: KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines: KnockoutObservableBase<number>;
        /**
         * Enables highlighting of all words/tokens matching the words/tokens under the cursor position.
         * blockHighlight is not affected by this value.
         * Defaults to true.
         */
        readonly selectionHighlight: KnockoutObservableBase<boolean>;
        /**
         * Highlights the block under the cursor position.
         * The block definition can be provided using the defineBlock callback.
         * selectionHighlight is not affected by this value.
         * Defaults to false.
         */
        readonly blockHighlight: KnockoutObservableBase<boolean>;
        /**
         * The currently block highlighted content of the editor content.
         * Will be populated when blockHighlight is set to true.
         * If the "defineBlock" callback is given, this logic will be used for selecting blocks.
         * If the "defineBlock" callback is not provided and block highlighting is enabled, the default block highlighting is used where blank lines act as the block delimiter.
         */
        readonly blockContent: KnockoutReadOnlyObservableBase<string>;
        /**
         * Indicates if the contents have been modified but not yet saved.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor is displayed.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Refreshes the editor view.
         */
        refresh(): Q.Promise<void>;
        /**
         * Saves the content of the editor.
         */
        save(): Q.Promise<void>;
    }
    /**
     *  Editor marker severity
     */
    export enum MarkerSeverity {
        /**
         * Ignored marker
         */
        Ignore = 0,
        /**
         * Hint marker
         */
        Hint = 1,
        /**
         * Information marker
         */
        Info = 2,
        /**
         * Warning marker
         */
        Warning = 3,
        /**
         * Error marker
         */
        Error = 4
    }
    /**
     *  Editor marker definition
     */
    export interface Marker {
        /**
         * The message to show in the tool tip
         */
        readonly message: string;
        /**
         * The severity of the marker
         */
        readonly severity: MarkerSeverity;
        /**
         * The text range to apply the marker to
         */
        readonly range: Range;
    }
    /**
     *  A range of text in the text editor.
     */
    export interface Range {
        /**
         * Line number on which the range starts (1-based line number).
         */
        readonly startLineNumber: number;
        /**
         * Column on which the range starts in line `startLineNumber` (1-based line number).
         */
        readonly startColumn: number;
        /**
         * Line number on which the range ends.
         */
        readonly endLineNumber: number;
        /**
         * Column on which the range ends in line `endLineNumber`.
         */
        readonly endColumn: number;
    }
    /**
     * Creates an editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createEditor(lifetime: LifetimeManager, options: EditorOptions): EditorContract;
    /**
     * Creates a custom editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createCustomEditor(lifetime: LifetimeManager, options: CustomEditorOptions): CustomEditorContract;
    /**
     * Creates a JSON editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createJSONEditor(lifetime: LifetimeManager, options: JSONEditorOptions): JSONEditorContract;
    /**
     * Creates a TypeScript editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     *
     * @returns an editor contract.
     */
    export function createTypeScriptEditor(lifetime: LifetimeManager, options: TypeScriptEditorOptions): TypeScriptEditorContract;
}

// FILE: Fx\Controls\Essentials.d.ts
declare module "Fx/Controls/Essentials" {
    import { Control, IconPosition, IconAndPosition } from "Fx/Controls/ControlsBase";
    import { ClickableLink, BladeLink, ResourceLink } from "Fx/Composition";
    import * as FxCompositionBlade from "Fx/Composition/Blade";
    import * as FxCompositionPdlBlade from "Fx/Composition/Pdl/Blade";
    import * as FxCompositionTemplateBlade from "Fx/Composition/TemplateBlade";
    export type Container = FxCompositionBlade.Container | FxCompositionPdlBlade.Container | FxCompositionTemplateBlade.Container;
    /**
     * Position of the icon
     */
    export { IconPosition };
    /**
     * Describes an icon and it's position with respect to the other content
     */
    export { IconAndPosition };
    /**
     * Built-In properties those can be obtained from resource data.
     */
    export const enum BuiltInType {
        /**
         * Built-in resource group property.  Allowed on left or right.
         */
        ResourceGroup = 1,
        /**
         * Built-in status property.  Allowed on left or right.
         */
        Status = 2,
        /**
         * Built-in location property.  Allowed on left or right.
         */
        Location = 3,
        /**
         * Built-in subscription name property.  Allowed on left or right.
         */
        SubscriptionName = 4,
        /**
         * Built-in subscription id property.  Allowed on left or right.
         */
        SubscriptionId = 5,
        /**
         * Built-in tags property.  Allowed on bottom.
         */
        Tags = 6
    }
    /**
     * The base blade close results interface provides the base for blade close results. The BuiltInType sent to the
     * onBladeClose will determine the actual shape of these results.
     */
    export interface BladeCloseResults {
    }
    /**
     * Base options.
     */
    export interface Options {
        /**
         * Expanded state of the essentials control.
         */
        expanded?: KnockoutObservableBase<boolean>;
        /**
         * This function is called when the expander is clicked.
         */
        onExpanderClick?: (isExpanded: boolean) => void;
        /**
         * Show all items without blocking them with "See More/See Less" button.
         */
        showAllItems?: boolean;
    }
    /**
     * Layout options for a resource.
     */
    export interface ResourceLayoutOptions extends Options {
        /**
         * Resource id.
         */
        resourceId: string;
        /**
         * Optional resource instance for the resource id.
         */
        resource?: HubsExtension.Azure.Resource | HubsExtension.Azure.ResourceGroup | KnockoutObservableBase<HubsExtension.Azure.Resource | HubsExtension.Azure.ResourceGroup>;
        /**
         * Flag to control whether the framework should fetch the resource info automatically if the resource instance is not provided.
         */
        skipResourceFetching?: boolean;
        /**
         * Flag to include the tags for the resource.
         */
        includeTags?: boolean;
        /**
         * List of built-in types to hide the "change" button, move resource blade opening button, right next to the built-in type label.
         */
        hiddenChangeLink?: BuiltInType[];
        /**
         * This callback function is called when the resource blade is opened.
         */
        onBladeOpen?: (type: BuiltInType) => void;
        /**
         * This callback function is called when the resource blade is closed.
         */
        onBladeClose?: (type: BuiltInType, bladeCloseResults?: BladeCloseResults) => void;
    }
    /**
     * Default layout options for a resource.
     */
    export interface DefaultResourceLayoutOptions extends ResourceLayoutOptions {
        /**
         * List of built-in types to hide.
         */
        hiddenBuiltInTypes?: BuiltInType[];
        /**
         * Additional static properties on the left besides the usual 5 items.
         */
        additionalLeft?: (Item | MultiLineItem)[];
        /**
         * Additional static properties on the right.
         */
        additionalRight: (Item | MultiLineItem)[];
    }
    /**
     * Custom layout options for a resource.
     */
    export interface CustomResourceLayoutOptions extends ResourceLayoutOptions {
        /**
         * List of items to render on the left pane.
         */
        left: (Item | MultiLineItem | BuiltInType)[];
        /**
         * List of items to render on the right pane.
         */
        right: (Item | MultiLineItem | BuiltInType)[];
    }
    /**
     * Layout options for an arbitrary object type (not a resource).
     */
    export interface NonResourceLayoutOptions extends Options {
        /**
         * List of items to render on the left pane.
         */
        left: (Item | MultiLineItem)[];
        /**
         * List of items to render on the right pane.
         */
        right: (Item | MultiLineItem)[];
    }
    /**
     * Properties of an item.
     */
    export interface ItemProperty {
        /**
         * Item value to show.
         */
        value: string | KnockoutObservableBase<string>;
        /**
         * OnClick handler for the item.
         */
        onClick?: (() => void) | ClickableLink | BladeLink | ResourceLink;
        /**
         * Displays an icon for the item.
         */
        icon?: IconAndPosition | KnockoutObservableBase<IconAndPosition>;
    }
    /**
     * Single-line item.
     */
    export interface Item extends ItemProperty {
        /**
         * Label for the item.
         */
        label: string;
    }
    /**
     * Multi-line item.
     */
    export interface MultiLineItem {
        /**
         * Label for the multi-line item.
         */
        label: string;
        /**
         * Arrays of item properties.
         * Multi-line item contains one label and multiple item properties.
         */
        lines: ItemProperty[];
    }
    /**
     * Essentials base contract.
     */
    export interface Contract extends Control {
        /**
         * Expanded state.
         */
        expanded: KnockoutObservableBase<boolean>;
        /**
         * Essentials disabled state.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * Add items dynamically to the essentials control.
         *
         * @param left An array of item to add.
         * @param right An array of item to add.
         */
        addDynamicProperties(left: (Item | MultiLineItem)[], right: (Item | MultiLineItem)[]): void;
    }
    /**
     * Essentials contract for a resource layout.
     */
    export interface ResourceLayoutContract extends Contract {
        /**
         * Resource instance.
         */
        resource: KnockoutObservableBase<HubsExtension.Azure.Resource | HubsExtension.Azure.ResourceGroup>;
        /**
         * Set "Status" property.
         *
         * @param status A string value to set the "Status" property value.
         */
        modifyStatus(status: string): void;
    }
    /**
     * Essentials contract for an arbitrary object layout.
     */
    export interface NonResourceLayoutContract extends Contract {
    }
    /**
     * Creates an Essentials control viewmodel.
     *
     * @param container A template blade container.
     * @param options The set of options to configure the essentials.
     *
     * @returns an essentials viewmodel
     */
    export function createDefaultResourceLayout(container: Container, options: DefaultResourceLayoutOptions): ResourceLayoutContract;
    /**
     * Creates an Essentials control viewmodel.
     *
     * @param container A template blade container.
     * @param options The set of options to configure the essentials.
     *
     * @returns an essentials viewmodel
     */
    export function createCustomResourceLayout(container: Container, options: CustomResourceLayoutOptions): ResourceLayoutContract;
    /**
     * Creates an Essentials control viewmodel.
     *
     * @param container A template blade container.
     * @param options The set of options to configure the essentials.
     *
     * @returns an essentials viewmodel
     */
    export function createNonResourceLayout(container: Container, options: NonResourceLayoutOptions): NonResourceLayoutContract;
}

// FILE: Fx\Controls\FileDownload.d.ts
declare module "Fx/Controls/FileDownload" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Content type for the downloaded file.
     */
    export const enum ContentType {
        /**
         * Downloaded file is a text file
         */
        Text = 1,
        /**
         * Downloaded file is a binary file
         */
        Binary = 2
    }
    /**
     * Display style options for file download
     */
    export const enum DisplayStyle {
        /**
         * Display file download as a Button.
         */
        Button = 0,
        /**
         * Display file download as a Link.
         */
        Link = 1
    }
    /**
     * Success or failure download status.
     */
    export enum Status {
        /**
         * Indicates a failure even before file download starts.
         * All required properties for file download is not provided correctly.
         */
        DownloadPreConditionFailed = 0,
        /**
         * Download is successful.
         */
        Success = 1,
        /**
         * Download encountered an error.
         */
        DownloadError = 2,
        /**
         * Download uri is not correct.
         */
        UriError = 3
    }
    /**
     * Callback contract to fetch the download context dynamically.
     * @return A promise returning one of the supported download context (where T is one of - OAuthContext, SasLikeContext, BlobUriContext or DataUriContext)
     */
    export interface DownloadContextCallback<T> {
        (): Q.Promise<T>;
    }
    /**
     * Properties needed to make an authenticated download using OAuth token.
     */
    export interface OAuthContext {
        /**
         * Uri for the file download.
         */
        readonly targetUri: string;
        /**
         * For authenticated download using OAuth an authorization token should be specified.
         * Auth token can expire anytime. So the recommendation is to provide the auth token in the DownloadContextCallback which will be
         * invoked when the download button is clicked.
         */
        readonly authorizationToken: string;
        /**
         * Specify the content type of file to download. The default content type is 'text'.
         */
        readonly contentType?: ContentType;
        /**
         * Specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        readonly targetFileName?: string;
        /**
         * Specify GET or POST type for the http request.
         * Default will be GET.
         */
        readonly httpMethod?: "GET" | "POST";
        /**
         * Specify set of http headers to be included in the request.
         */
        readonly headers?: StringMap<string>;
        /**
         * Specify a JSON request body. Valid only for POST requests.
         */
        readonly httpRequestContent?: string;
        /**
         * Specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        readonly httpRequestContentType?: string;
    }
    /**
     * Properties needed to download a file from Sas like uri.
     */
    export interface SasLikeContext {
        /**
         * Uri for the file download.
         */
        readonly targetUri: string;
    }
    /**
     * Properties needed to make a blob uri download.
     */
    export interface BlobUriContext {
        /**
         * Provide blob uri for the file download.
         */
        readonly targetUri: string;
        /**
         * Specify the target filename for the downloaded file.
         */
        readonly targetFileName?: string;
    }
    /**
     * Properties needed to make a data uri download.
     */
    export interface DataUriContext {
        /**
         * Provide data uri for the file download.
         */
        readonly targetUri: string;
        /**
         * Specify the content type of file to download. The default content type is 'text'.
         */
        readonly contentType?: ContentType;
        /**
         * Specify the target filename for the downloaded file.
         */
        readonly targetFileName?: string;
    }
    /**
     * Download status will be observable updated by providing the status and/or error messages.
     */
    export interface DownloadStatus {
        /**
         * Indicates the file download status.
         */
        readonly status: Status;
        /**
         * Indicates the error message when download fails.
         */
        readonly errorMessage: string;
    }
    /**
     * Options to customize the callback, download confirmation and progress dialogs texts.
     */
    export interface DownloadDialogOptions {
        /**
         * Specify if callback progress dialog should be shown.
         */
        readonly showCallbackProgressDialog?: boolean;
        /**
         * Callback progress title string to indicate uri callback is in progress.
         */
        readonly callbackProgressTitle?: string;
        /**
         * Callback progress description string to indicate uri callback is in progress.
         */
        readonly callbackProgressText?: string;
        /**
         * Specify if download confirmation dialog should be shown.
         * A message box dialog is shown to confirm downloading the file or cancel the download.
         */
        readonly showDownloadConfirmationDialog?: boolean;
        /**
         * Download confirmation title string to indicate if file should be downloaded or canceled.
         */
        readonly downloadConfirmationTitle?: string;
        /**
         * Download confirmation description string to indicate if file should be downloaded or canceled.
         */
        readonly downloadConfirmationText?: string;
        /**
         * Download confirmation ok button text.
         */
        readonly downloadConfirmationOKButtonText?: string;
        /**
         * Download confirmation cancel button text.
         */
        readonly downloadConfirmationCancelButtonText?: string;
        /**
         * Specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         * Progress dialog won't be shown for SAS like file downloads.
         */
        readonly showDownloadProgressDialog?: boolean;
        /**
         * ProgressBox title string to indicate download is in progress.
         */
        readonly downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate download is in progress.
         */
        readonly downloadProgressText?: string;
    }
    /**
     * Options for configuring a FileDownload control.
     */
    export interface Options {
        /**
         * Label displayed in the download button or link.
         */
        readonly label?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the file download button.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Tooltip shown on button or link hover.
         */
        readonly toolTip?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If control should be a link instead of a button
         */
        readonly displayStyle?: DisplayStyle;
        /**
         * Specify the error title when file download fails.
         * This error title will be used to send notification to the user to indicate download failure.
         */
        readonly errorTitle?: string | KnockoutObservableBase<string>;
        /**
         * Specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        readonly errorMessage?: string | KnockoutObservableBase<string>;
        /**
         * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
         */
        readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
        /**
         * Callback executed before download is initiated.
         */
        readonly onStart?: () => void;
    }
    /**
     * File download options for an authenticated download using OAuth token.
     */
    export interface OAuthDownloadOptions extends Options {
        /**
         * Provide the properties needed for making an authenticated file download using OAuth token
         * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
         */
        readonly downloadContext?: OAuthContext | DownloadContextCallback<OAuthContext>;
        /**
         * Callback executed when download is complete.
         */
        readonly onComplete?: (downloadStatus: DownloadStatus) => void;
    }
    /**
     * File download options using SAS or SAS equivalent uri.
     */
    export interface SasLikeDownloadOptions extends Options {
        /**
         * Provide the properties needed for making a file download using SAS or SAS equivalent uri
         * or provide a callback which will return the properties for file download using SAS or SAS equivalent uri
         */
        readonly downloadContext?: SasLikeContext | DownloadContextCallback<SasLikeContext>;
    }
    /**
     * File download options using blob uri.
     */
    export interface BlobUriDownloadOptions extends Options {
        /**
         * Provide the properties needed for making a file download using blob uri
         * or provide a callback which will return the properties for file download using blob uri.
         */
        readonly downloadContext?: BlobUriContext | DownloadContextCallback<BlobUriContext>;
        /**
         * Callback executed when download is complete.
         */
        readonly onComplete?: (downloadStatus: DownloadStatus) => void;
    }
    /**
     * File download options using data uri.
     */
    export interface DataUriDownloadOptions extends Options {
        /**
         * Provide the properties needed for making a file download using data uri
         * or provide a callback which will return the properties for file download using data uri.
         */
        readonly downloadContext?: DataUriContext | DownloadContextCallback<DataUriContext>;
        /**
         * Callback executed when download is complete.
         */
        readonly onComplete?: (downloadStatus: DownloadStatus) => void;
    }
    /**
     * FileDownload control view model contract.
     */
    export interface Contract extends Control {
        /**
         * Label displayed in the download button or link.
         */
        readonly label: KnockoutObservableBase<string>;
        /**
         * Aria label for the file download button.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Tooltip shown on button or link hover.
         */
        readonly toolTip: KnockoutObservableBase<string>;
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Specify the error title when file download fails.
         * This error title will be used to send notification to the user to indicate download failure.
         */
        readonly errorTitle: KnockoutObservableBase<string>;
        /**
         * Specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        readonly errorMessage: KnockoutObservableBase<string>;
        /**
         * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
         */
        readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
        /**
         * Indicates if file is download successfully or not.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         * Download status will not be updated for SasLike file downloads.
         */
        readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
    }
    /**
     * Creates a file download control viewmodel for downloads using OAuth token for authentication.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using OAuth token.
     *
     * @returns a file download view model
     */
    export function createOAuthDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: OAuthDownloadOptions): Contract;
    /**
     * Creates a file download control viewmodel for downloads using SAS or SAS equivalent uri.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using SAS or SAS equivalent uri.
     *
     * @returns a file download view model
     */
    export function createSasLikeDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: SasLikeDownloadOptions): Contract;
    /**
     * Creates a file download control viewmodel for downloads using blob uri.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using blob uri.
     *
     * @returns a file download view model
     */
    export function createBlobUriDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: BlobUriDownloadOptions): Contract;
    /**
     * Creates a file download control viewmodel for downloads using data uri.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using data uri.
     *
     * @returns a file download view model
     */
    export function createDataUriDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: DataUriDownloadOptions): Contract;
}

// FILE: Fx\Controls\FileUpload.d.ts
declare module "Fx/Controls/FileUpload" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import FxFileUpload = MsPortalFx.ViewModels.FileUpload;
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     *  Specifies how the file content should be uploaded.
     */
    export const enum UploadType {
        /**
         * Full file content will be read. Use this option only for small file sizes less than 2 MB.
         */
        Full = 0,
        /**
         * File content will be read in chunks and provided to user in chunks.
         * Use this option to read large files and if user wants control over where to post the content.
         */
        Stream = 1,
        /**
         *  File upload to block blob store.
         */
        BlockBlobStore = 2,
        /**
         *  File upload to page blob store.
         */
        PageBlobStore = 3,
        /**
         *  File upload to append blob store.
         */
        AppendBlobStore = 4,
        /**
         *  File upload to Azure file service.
         */
        FileService = 5
    }
    /**
     * Specifies how the file content should be read and encoded in memory.
     * These options mimics the html5 file reader options to read the file content.
     */
    export const enum ContentType {
        /**
         * By default, file content will be read and stored as binary data in an ArrayBuffer.
         */
        Default = 0,
        /**
         * The file content will be read as plain text.
         * By default the string is encoded in 'UTF-8' format. Use the optional encoding parameter to specify a different format.
         */
        Text = 1,
        /**
         * The file content will be available in an ArrayBuffer.
         */
        ArrayBuffer = 2,
        /**
         * The file content will be encoded in the data uri scheme. Use this option for images and if those need to be directly shown in img tag.
         */
        DataUri = 3
    }
    /**
     * File upload status.
     */
    export const enum UploadStatus {
        /**
         * Invalid.
         */
        Invalid = 0,
        /**
         * Pending.
         */
        Pending = 1,
        /**
         * Uploading.
         */
        Uploading = 2,
        /**
         * Paused.
         */
        Paused = 3,
        /**
         * Complete.
         */
        Complete = 4,
        /**
         * Canceled.
         */
        Canceled = 5,
        /**
         * Aborted.
         */
        Aborted = 6
    }
    /**
     * Access tier values for blob.
     */
    export const enum BlobAccessTier {
        /**
         * Optimized for storing data that is accessed frequently.
         */
        Hot = 0,
        /**
         * Optimized for storing data that is infrequently accessed and stored for at least 30 days.
         */
        Cool = 1,
        /**
         * Optimized for storing data that is rarely accessed and stored for at least 180 days with flexible latency requirements
         */
        Archive = 2
    }
    /**
     * Resource strings to override the default messages.
     */
    export interface ResourceStrings {
        /**
         * Override the default validation message for invalid allowed file extension.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileExtensionInvalidErrorMessage?: string;
        /**
         * Override the default validation message for file size greater than provided max file size.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         * {1} - Max file size.
         * {2} - File size.
         */
        fileSizeInvalidErrorMessage?: string;
        /**
         * Override the default message when runtime file read error occurs.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileReadAbortedErrorMessage?: string;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    export interface UploadContext {
        /**
         * Specify how/where the file should be uploaded.
         */
        type: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    export interface FullFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    export interface StreamFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning?: boolean;
    }
    /**
     * Defines SAS uri info needed for periodic SAS uri renewal.
     */
    export interface SasUriInfo {
        /**
         * Specify the SAS uri
         */
        uri: string;
        /**
         * Specify the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    export interface OauthHeaderInfo {
        /**
         * Specifies the URI including the blob.
         */
        uri: string;
        /**
         * Bearer token with permissions to write to this Storage Account.
         */
        authorizationHeader: string;
        /**
         * Specifies the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    /**
     * The type of Authorization used in making the upload call to the BlobStore.
     */
    export const enum BlobStoreAuthorizationType {
        /**
         * Authorization using an Open Authorization (Bearer token) standard.
         */
        Oauth = 0,
        /**
         * Authorization using a Shared Access Signature..
         */
        SAS = 1
    }
    /**
     * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
     */
    export interface AuthorizationContext<T> {
        /**
         * Call to fetch required credentials for the given container or storage account.
         * @param fileInfo Metadata about the current file being uploaded. This can be used to renew the correct authorization for that file.
         * @param context The context object specified by the extension to this control. This may be used to pass back specific information needed to fetch authorization in renew scenario.
         * @return A Promise with either the SASUri info or the OAUTHHeader info depending on the type of authentication this control should use.
         */
        fetchAuthorization: (fileInfo: FileInfoContract, context: T) => Q.Promise<SasUriInfo | OauthHeaderInfo>;
    }
    export interface BlobStoreFileUploadOptions<T> {
        /**
         * Specify how/where the file should be uploaded.
         */
        type?: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context?: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext?: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand?: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback?: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri?: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext?: AuthorizationContext<T>;
        /**
         * Specifies access tier for blob.
         */
        accessTier?: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders?: ReadonlyStringMap<string>;
    }
    /**
     * Holds the full file uploaded content.
     */
    export interface FullFileUploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: UploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
        /**
         * The full file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
    }
    /**
     * Holds the streamed file chunks and start/end bytes.
     */
    export interface StreamFileUploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: UploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
        /**
         * The chunked file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
        /**
         * The startbyte of the chunk.
         */
        startByte: number;
        /**
         * The endbyte of the chunk.
         */
        endByte: number;
    }
    /**
     * Each file upload task is represented by a unique key. This is used for all management operations to locate the uploads.
     */
    export interface UploadKey {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
    }
    /**
     * Resumable context needed to resume uploads across browser session.
     * This is an optional property in ResumeContext and presence of this property in ResumeContext indicates the intent to resume an upload after browser refresh/crash/close.
     */
    export interface ResumableContext {
        /**
         * Upload key of the initial upload which was stopped due to browser refresh/crash/close.
         * The upload id is used to lookup the persisted/tracked uploaded byte resumable information.
         */
        originalUploadKey: UploadKey;
    }
    /**
     * Optional context information passed to the resume API.
     * Resume is called to start a new upload, start a new upload overriding upload context, resume an in-memory paused upload and resume an upload across browser session.
     * Resume context provides adequate context to enable above resume scenarios.
     */
    export interface ResumeContext {
        /**
         * Optional upload context information to override the default upload context specified in the view model.
         * For multi-select scenarios the default context will be applied to all uploads.
         * If upload type or content type needs to be overridden for a particular upload,
         * a new upload context information can be sent as part of resume context.
         */
        uploadContext?: UploadContext;
        /**
         * For resuming the upload across browser refresh/crash/close scenario, pass in the resumableContext with the upload key for the paused upload.
         * A list of paused uploads due to browser refresh/crash/close will be made avaiable via getResumableUploadInfo API which will have all necessary information including the upload key.
         */
        resumableContext?: ResumableContext;
    }
    /**
     * Optional abort context information sent when upload is aborted.
     */
    export interface AbortContext {
        /**
         * An error message / reason for aborting the file upload.
         */
        reason?: string;
    }
    /**
     * Optional chunk context sent when fetching the next file chunk via GetNextChunk API.
     */
    export interface ChunkContext {
        /**
         * Optionally specify the start byte offset.
         */
        startByte?: number;
        /**
         * Optionally specify the chunk size otherwise the default 2 MB will be used.
         */
        chunkSize?: number;
    }
    /**
     * File information.
     */
    export interface FileInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     */
    export interface SelectedFileContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
    }
    /**
     * Upload information.
     */
    export interface UploadInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: KnockoutReadOnlyObservableBase<string>;
        /**
         * Upload category tag provided by extension.
         */
        category: KnockoutReadOnlyObservableBase<string>;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Upload type.
         */
        type: KnockoutReadOnlyObservableBase<UploadType>;
        /**
         * Upload destination like target blob store uri .
         */
        target: KnockoutReadOnlyObservableBase<string>;
        /**
         * The current status of the upload task.
         */
        status: KnockoutReadOnlyObservableBase<UploadStatus>;
        /**
         * The total bytes that have been uploaded/streamed.
         */
        uploadedBytes: KnockoutReadOnlyObservableBase<number>;
        /**
         * The percent complete of the upload task. The values will be in 0-100 range.
         */
        progressPercent: KnockoutReadOnlyObservableBase<number>;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * Async file upload task with upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     */
    export interface AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @return Promise indicating the success or failure or the operation.
         */
        resume: (context?: ResumeContext) => Q.Promise<void>;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        pause?: () => Q.Promise<void>;
        /**
         * Method to cancel the current file upload.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        cancel: () => Q.Promise<void>;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        complete: () => Q.Promise<void>;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @return Promise indicating the success or failure or the operation.
         */
        abort: (context?: AbortContext) => Q.Promise<void>;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        dispose: () => Q.Promise<void>;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk: (startByte?: number, chunkSize?: number) => Q.Promise<StreamFileUploadContent>;
    }
    /**
     * Full file upload context.
     */
    export class FullFileUploadContext implements UploadContext {
        /**
         * Full file will be read and the entire content will be available in memory.
         */
        type: UploadType;
        /**
         * File content will be stored by default in an array buffer.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding: string;
        /**
         * Specify the maximum file size that can be uploaded.
         * Recommended max file is less than 2 MB for this upload type.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded.
         * Default chunk size should be same as maxFileSize for fill file download.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings: ResourceStrings;
        constructor(options?: FullFileUploadOptions);
    }
    /**
     * Stream file upload context. File will be read in chunks and chunked content will be available in memory.
     */
    export class StreamFileUploadContext extends FullFileUploadContext {
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning: boolean;
        /**
         * Initialize default properties for stream file upload context.
         */
        constructor(options?: StreamFileUploadOptions);
    }
    /**
     * BlobStore file upload context. File will be uploaded directly to blob store specified by the SAS uri.
     */
    export class BlobStoreFileUploadContext<T> extends FullFileUploadContext {
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext: AuthorizationContext<T>;
        /**
         * Specify the access tier for blob.
         */
        accessTier: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders: ReadonlyStringMap<string>;
        /**
         * Initialize default properties for blob store file upload context.
         */
        constructor(options?: BlobStoreFileUploadOptions<T>);
    }
    /**
     * Options for configuring a file upload control.
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        accept?: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        allowedFileExtensions?: string | KnockoutObservableBase<string>;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The user selected files via browse dialog is surfaced as SelectedFile in the selectedFiles array.
         * For scenarios where selected files should automatically be associated with an UploadTask, set this value to true.
         * If this option is set to false, the extension author is responsible for explicitly adding the selectedFile to uploadTasks by invoking
         * the addUploadTasks() method on view model to create an UploadTask representation and have it available in uploadTasks array.
         * By default, this option is set to true.
         */
        autoAddUploadTasks?: boolean;
        /**
         * Enable drag and drop UX for fileupload control.
         * By default drag and drop UX is not enabled. Set this option to true to enable drag and drop UX.
         */
        enableDragAndDrop?: boolean;
        /**
         * Show or hide the default file list and status in the drag and drop UX.
         * By default the file list will be show. Set this option to true to hide the file list and
         * extension can create their own UX to show the file list.
         */
        hideDragAndDropFileList?: boolean;
        /**
         * Override default drag and drop display text.
         * Default display text in the drop area is 'Drag and drop the files'
         */
        dragAndDropDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the file upload control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Options for configuring a file upload control for full file uploads.
     */
    export interface FullUploadOptions extends Options {
        /**
         * The full upload context options.
         */
        uploadContext: FullFileUploadContext | KnockoutObservableBase<FullFileUploadContext>;
    }
    /**
     * Options for configuring a file upload control for streaming file uploads.
     */
    export interface StreamUploadOptions extends Options {
        /**
         * The stream upload context options.
         */
        uploadContext: StreamFileUploadContext | KnockoutObservableBase<StreamFileUploadContext>;
    }
    /**
     * Options for configuring a file upload control for blob store file uploads.
     */
    export interface BlobUploadOptions<T> extends Options {
        /**
         * The blob store upload context options around how/where to upload and size limits.
         */
        uploadContext: BlobStoreFileUploadContext<T> | KnockoutObservableBase<BlobStoreFileUploadContext<T>>;
    }
    /**
     * FileUpload view model contract.
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * Each time user clicks on the browse dialog, user can choose one or multiple files and each selected file is represented as SelectedFile on the extension iframe.
         * The selected files are surfaced in the selectedFiles array.
         * The array will be cleared if user chooses to click browse dialog to pick a different set of files.
         * Setting the value property null or calling resetUploadTasks() will clear the array.
         */
        readonly selectedFiles: KnockoutReadOnlyObservableArray<SelectedFileContract>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress etc.
         * UploadTask is used to initiate the file upload, pause/resume uploads, cancel and dispose the file upload.
         */
        readonly uploadTasks: KnockoutReadOnlyObservableArray<AsyncUploadTaskContract>;
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        readonly accept: KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        readonly allowedFileExtensions: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * Overrode default drag and drop display text.
         */
        readonly dragAndDropDisplayText: KnockoutObservableBase<string>;
        /**
         * Method to create an UploadTask associated with the selected file and populate that in the uploadTasks array.
         * File browse selections can be made any number of times. When autoAddUploadTaks is set to true, the selected files will be added automatically to the uploadTasks array.
         * If autoAddploadTasks is false, the selected file should be explicitly added to uploadTasks array by calling the addUploadTasks() method.
         * Extension authors will then be able to start the upload.
         *
         * @param selectedFiles User selected files to add to uploadTasks array to prepare for the file upload.
         */
        addUploadTasks: (selectedFiles: SelectedFileContract[]) => Q.Promise<void>;
        /**
         * Method to reset the uploadTasks array. This method will use the widget callback to intialize the uploadTasks array with empty array.
         * Calling this method will not dispose(abort) the uploads.
         * Uploads which have already started will continue upload in the background.
         * Uploads which have not been started will be cleaned up.
         * Invoking this method will clear the uploadTasks array, selectedFiles array and the value property.
         */
        resetUploadTasks: () => Q.Promise<void>;
    }
    /**
     * FileUpload view model contract for full file upload.
     */
    export interface FullUploadContract extends Contract {
        /**
         * The full upload context options.
         */
        readonly uploadContext: KnockoutObservableBase<FullFileUploadContext>;
    }
    /**
     * FileUpload view model contract for streaming file upload.
     */
    export interface StreamUploadContract extends Contract {
        /**
         * The stream upload context options.
         */
        readonly uploadContext: KnockoutObservableBase<StreamFileUploadContext>;
    }
    /**
     * FileUpload view model for blob store file uploads.
     */
    export interface BlobUploadContract<T> extends Contract {
        /**
         * The blob store upload context options around how/where to upload and size limits.
         */
        readonly uploadContext: KnockoutObservableBase<BlobStoreFileUploadContext<T>>;
    }
    /**
     * Creates a FileUpload control viewmodel for Full File uploads
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a file upload control viewmodel
     */
    export function createFullUpload(lifetime: MsPortalFx.Base.LifetimeManager, options: FullUploadOptions): FullUploadContract;
    /**
     * Creates a FileUpload control viewmodel for Stream File uploads.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a file upload control viewmodel
     */
    export function createStreamUpload(lifetime: MsPortalFx.Base.LifetimeManager, options: StreamUploadOptions): StreamUploadContract;
    /**
     * Creates a FileUpload control viewmodel for Blob store and Azure File Servie uploads.
     *
     * @param lifetime The lifetime of the control
     * @param options BlobUploadOptions that modify the appearance and behavior of the control.
     *
     * @returns a file upload control viewmodel
     */
    export function createBlobStoreUpload<T>(lifetime: MsPortalFx.Base.LifetimeManager, options: BlobUploadOptions<T>): BlobUploadContract<T>;
    global {
        interface EventHandlerContracts {
            "fileUploadSasUri"?: {
                renew(fileInfo: FileInfoContract, context?: unknown): Q.Promise<SasUriInfo>;
            };
            "fileUploadAuthorization"?: {
                renew(authorizationType: FxFileUpload.BlobStoreAuthorizationType, fileInfo: FileInfoContract, context?: unknown): Q.Promise<SasUriInfo | OauthHeaderInfo>;
            };
        }
    }
    export module EventHandler {
        /**
         * A decorator that is used to specify that the annotated class should be used to handle
         * FileUpload related events originating from the framework.
         *
         * @param contractName The name of the contract to be handled.
         */
        function Decorator<TContractName extends "fileUploadSasUri" | "fileUploadAuthorization">(contractName: TContractName): (target: new (...args: any[]) => EventHandlerContracts[TContractName]) => void;
    }
}

// FILE: Fx\Controls\FileUploadManagement.d.ts
declare module "Fx/Controls/FileUploadManagement" {
    import * as FileUpload from "Fx/Controls/FileUpload";
    export import SasUriInfo = FileUpload.SasUriInfo;
    /**
     * Upload action performed on upload task. This enum is used when using invokeUploadAction management API.
     */
    export const enum UploadAction {
        /**
         * No-op.
         */
        None = 0,
        /**
         * Pause the current upload task.
         */
        Pause = 1,
        /**
         * Resume the current upload task.
         */
        Resume = 2,
        /**
         * Cancel the current upload task
         */
        Cancel = 3,
        /**
         * Dispose the current upload task.
         */
        Dispose = 4,
        /**
         * Add selected file to upload task array.
         */
        AddUploadTasks = 5,
        /**
         * Reset Upload task array.
         */
        ResetUploadTasks = 6,
        /**
         * Complete the current upload task.
         * This action is used for streaming file upload to indicate the completion of the upload.
         */
        Complete = 7,
        /**
         * Abort the current upload task.
         * This action is used for aborting the current upload due to runtime errors.
         */
        Abort = 8,
        /**
         * Gets the next file chunk for streaming upload.
         * This action is used for streaming file upload to get the next file chunk.
         */
        GetNextChunk = 9
    }
    /**
     * API to get the list of upload information for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of upload information.
     */
    export function getUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: FileUpload.UploadKey[], category?: string): Q.Promise<FileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of resumable upload information.
     */
    export function getResumableUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: FileUpload.UploadKey[], category?: string): Q.Promise<FileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return Promise which contains the array of AsyncUploadTask objects.
     */
    export function getAsyncUploadTasks(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: FileUpload.UploadKey[], category?: string): Q.Promise<FileUpload.AsyncUploadTaskContract[]>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @return A promise indicating success or failure of the management operation.
     */
    export function invokeUploadAction<TResult>(uploadKey: FileUpload.UploadKey, action: UploadAction, context?: FileUpload.ResumableContext | FileUpload.AbortContext | FileUpload.ChunkContext): Q.Promise<TResult>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the start byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @return A promise indicating success or failure of the operation.
     */
    export function getNextChunk(uploadKey: FileUpload.UploadKey, startByte?: number, chunkSize?: number): Q.Promise<FileUpload.StreamFileUploadContent>;
    /**
     * API to register a SAS uri renewal callback which will be called when the SAS uri is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the
     * SAS uri renewal for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @return A promise returning the SasUriInfo on successful completion.
     */
    export function registerRenewSasUriCallback(callback: (fileInfo: FileUpload.FileInfoContract, context?: unknown) => Q.Promise<SasUriInfo>): void;
    /**
     * API to register an authorization renewal callback which will be called when the current authorization is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the OAUTH or SAS renewal
     * for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     * @param authorizationType: The type of authorization to renew.
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @return A promise returning the SasUriInfo or OauthHeaderInfor on successful completion.
     */
    export function registerRenewAuthorizationCallback(callback: (authorizationType: MsPortalFx.ViewModels.FileUpload.BlobStoreAuthorizationType, fileInfo: FileUpload.FileInfoContract, context?: unknown) => Q.Promise<FileUpload.SasUriInfo | FileUpload.OauthHeaderInfo>): void;
}

// FILE: Fx\Controls\FormBase.d.ts
declare module "Fx/Controls/FormBase" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { Validation, ValidationResult } from "Fx/Controls/Validations";
    /**
     * Base properties on all form controls
     */
    export interface Contract extends Control {
        /**
         * The dirty state of the control.  This will only change when the user performs an action to change the value, or the dirty state is set explicitly by the extension.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * The validation state of the control.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        readonly subLabel: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria-label on the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Validations on the control.
         */
        readonly validations: KnockoutObservableArray<Validation>;
        /**
         * Latest validation results.
         */
        readonly validationResults: KnockoutReadOnlyObservableArray<ValidationResult>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Triggers validation on this control when called.  Returns a promise that resolves once validation on this control has completed.
         * Promise return a value of true (valid) or false (invalid)
         */
        readonly triggerValidation: (focusOnFirstInvalid?: boolean, validateHidden?: boolean) => Q.Promise<boolean>;
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        readonly clearValidation: () => Q.Promise<void>;
    }
    export const enum ValueUpdateTrigger {
        /**
         * (default) Trigger value update when the control widget value changes
         */
        Input = 4,
        /**
         * Trigger value update on blur.
         */
        Blur = 3
    }
    export class DateTimeRange {
        /**
         * Start date/time in local timezone.
         */
        startDateTime: KnockoutObservable<Date>;
        /**
         * End date/time in local timezone.
         */
        endDateTime: KnockoutObservable<Date>;
        /**
         * Creates a DateTimeRange object
         *
         * @param startDateTime The start date/time in local timezone
         * @param endDateTime The end date/time in local timezone
         */
        constructor(startDateTime?: Date, endDateTime?: Date);
    }
}

// FILE: Fx\Controls\FrameControl.d.ts
declare module "Fx/Controls/FrameControl" {
    /**
     * Options for configuring a FrameControl control.
     */
    export interface Options {
        /**
         * The URL of the page to embed in an iframe.
         */
        readonly src: string;
        /**
         * Callback to handle messages posted from iframe to the FrameControl.
         * FrameControl defines the shape of the message received from iframe.
         *
         * @param message Message received from iframe.
         */
        readonly onReceiveMessage?: (message: unknown) => void;
    }
    /**
     * FrameControl view model contract.
     */
    export interface Contract extends MsPortalFx.Control {
        /**
         * Method to post message from FrameControl to iframe.
         * FrameControl defines the shape for the message posted to iframe.
         *
         * @param message Data posted from FrameControl to iframe.
         */
        readonly postMessage: (message: unknown) => void;
    }
    /**
     * Creates a FrameControl viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a FrameControl viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Graph.d.ts
declare module "Fx/Controls/Graph" {
    import Internal = MsPortalFx.Base.Internal;
    import Loadable = MsPortalFx.ViewModels.Controls.Loadable;
    /**
     * Scroll-bars enabled for the control. Flags enum, literals can be combined.
     */
    export enum GraphScrollBars {
        /**
         * No scroll-bars.
         */
        None = 0,
        /**
         * Horizontal scroll-bar.
         */
        Horizontal = 1,
        /**
         * Vertical scroll-bar.
         */
        Vertical = 2
    }
    /**
     * Modes of scroll-bars appearance.
     */
    export enum GraphScrollBarsVisibilityMode {
        /**
         * Scroll-bars are visible all the time when mouse pointer is on the graph canvas.
         */
        AlwaysVisible = 0,
        /**
         * Scroll-bars are hidden all the time.
         */
        AlwaysHidden = 1,
        /**
         * Scroll-bars are only visible when some node(s) are not fully inside the view rectangle.
         */
        AppearWhenNodesOutsideOfTheView = 2
    }
    /**
     * Skin styles of the graph editor.
     */
    export enum GraphEditorSkinStyle {
        /**
         * Canvas and node background colors are consistent with typical blade and parts background colors.
         */
        Blade = 0,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is a tint of blue.
         */
        Document = 1,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is a more bright tint of blue, node shape has borders stroke.
         */
        Document2 = 2,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is grey-ish, node shape has borders stroke.
         */
        Document3 = 3
    }
    /**
     * Strategies defining how edges connect to nodes and how they follow the nodes' moves.
     */
    export enum EdgeConnectionStrategy {
        /**
         * Edge line is a ray originating at the center of the start node and going to the center of the end node.
         */
        NodeCenter = 0,
        /**
         * Edge path is a Bezier curve originating at the output port of the start node and going to the input port of the end node.
         */
        NodePort = 1
    }
    /**
     * Capabilities of the graph editor. Flags enum, literals can be combined.
     */
    export enum GraphEditorCapabilities {
        /**
         * No editor capabilities. Only viewing, panning and zooming-in/-out allowed on the graph.
         */
        None = 0,
        /**
         * Capability to move nodes (connected edges move accordingly).
         */
        MoveEntities = 1,
        /**
         * Capability to update lists of nodes and edges.
         */
        AddRemoveEntities = 2
    }
    /**
     * Defines how graph entities are rendered.
     */
    export enum EntityRenderMode {
        /**
         * When a graph entity is added or removed, all entities are rebuilt and re-rendered on the DOM.
         */
        Rebuild = 0,
        /**
         * When a graph entity is added or removed, existing entities are not re-rendered. Node bindings
         * will be updated for existing nodes, but only the changed (added or removed) entities are
         * modified in the DOM structure of the graph.
         */
        Incremental = 1
    }
    /**
     * @deprecated Graph.EdgeStrength - To be removed in one of the next releases.
     * Used to be a limited enumeration of edge line strength grades.
     * Now strength/thickness is set using a number from the range [1; 6] - where 1 represents the weakest (the thinnest) and 6 - the strongest (the thickest) connection.
     */
    export enum EdgeStrength {
        /**
         * Normal strength grade.
         */
        Normal = 1,
        /**
         * Strong connection grade.
         */
        Strong = 2
    }
    /**
     * Definition of edge line types.
     */
    export enum EdgeType {
        /**
         * Single line/curve.
         */
        Single = 1,
        /**
         * 2 parallel lines/curves.
         */
        Double = 2
    }
    /**
     * Definition of edge line styles.
     */
    export enum EdgeStyle {
        /**
         * Solid line/curve.
         */
        Solid = 1,
        /**
         * Dotted line/curve.
         */
        Dotted = 2,
        /**
         * Dashed line/curve.
         */
        Dashed = 3
    }
    /**
     * Definition of edge markers.
     */
    export enum EdgeMarker {
        /**
         * None.
         */
        None = 1,
        /**
         * Arrow.
         */
        Arrow = 2,
        /**
         * Circle.
         */
        Circle = 3
    }
    /**
     * The Edge end contract.
     */
    export interface IEdgeEnd {
        /**
         * The identifier of the edge end.
         */
        id: KnockoutObservable<string>;
    }
    /**
     * Enum for type of graph entity.
     */
    export enum GraphEntityType {
        GraphNode = 0,
        GraphEdge = 1
    }
    /**
     * Represents the selected entity in the selectableSet
     */
    export class SelectedGraphEntity implements MsPortalFx.ViewModels.DynamicBladeSelection {
        id: string;
        entityType: GraphEntityType;
        detailBlade: string;
        detailBladeInputs: Object;
        extension: string;
        constructor(id: string, entityType: GraphEntityType, detailBlade: string, detailBladeInputs: Object, extension?: string);
    }
    /**
     * An abstract class that holds common elements for things that go in the graph.
     * Don't instantiate this.
     */
    export class GraphEntity {
        /**
         * Whether this entity allows being selected by a user or not.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Whether this entity is selected or not.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * The id of this entity. Used for referring to other graph nodes. You may need to
         * overwrite the default one when loading existing graphs.
         */
        id: KnockoutObservable<string>;
        /**
         * A meaningful label for screen readers to use. This should be a concise name of the graph application. https://www.w3.org/TR/wai-aria-1.1/#aria-label
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Set whether the entity should be dimmed (i.e. reduce the opacity).
         */
        dimmed: KnockoutObservable<boolean>;
        /**
         * CommandGroup to display in the context menu of node.
         */
        commandGroup: KnockoutObservable<string>;
        /**
         * Creates a graph entity.
         *
         * @param id The object's id.
         */
        constructor(id?: string);
    }
    /**
     * A graph edge. Put these in Graph.ViewModel's edge array.
     */
    export class GraphEdge extends GraphEntity {
        /**
         * The id of the start node for the edge. Do not change this after adding the edge to the
         * graph. This is set automatically by the constructor, and you should never need to change it.
         */
        startNodeId: KnockoutObservable<string>;
        /**
         * The id of the end node for the edge. Do not change this after adding the edge to the graph.
         * This is set automatically by the constructor, and you should never need to change it.
         */
        endNodeId: KnockoutObservable<string>;
        /**
         * The edge line thickness (in pixels). Limited to values in the range [1; 6].
         */
        strength: KnockoutObservable<number>;
        /**
         * The compound type characteristics of the edge line.
         */
        type: KnockoutObservable<EdgeType>;
        /**
         * The style of the edge line.
         */
        style: KnockoutObservable<EdgeStyle>;
        /**
         * The start marker of the edge.
         */
        startMarker: KnockoutObservable<EdgeMarker>;
        /**
         * The end marker of the edge.
         */
        endMarker: KnockoutObservable<EdgeMarker>;
        /**
         * The padding (in pixels) value used to float the edge ray a bit off the start node bounding rectangle. Only applied when graph EdgeConnectionStrategy is NodeCenter. Default value is 7px.
         */
        startNodePadding: KnockoutObservable<number>;
        /**
         * The padding (in pixels) value used to float the edge ray a bit off the end node bounding rectangle. Only applied when graph EdgeConnectionStrategy is NodeCenter. Default value is 7px.
         */
        endNodePadding: KnockoutObservable<number>;
        /**
         * The label of the edge
         */
        label: KnockoutObservable<string>;
        /**
         * Create a graph edge.
         *
         * @param startNode The node the edge emanates from.
         * @param endNode the node the edge ends on.
         */
        constructor(startNode: IEdgeEnd, endNode: IEdgeEnd);
    }
    /**
     * An interface for optionally updating a rectangle.
     */
    export interface IUpdateRect {
        /**
         * The X coordinate of the node's top-left corner.
         */
        x?: number;
        /**
         * The Y coordinate of the node's top-left corner.
         */
        y?: number;
        /**
         * The height of the node.
         */
        height?: number;
        /**
         * The width of the node.
         */
        width?: number;
    }
    /**
     * A cartesian point interface definition.
     */
    export interface IPoint {
        /**
         * The x coordinate of the point.
         */
        x: number;
        /**
         * The y coordinate of the point.
         */
        y: number;
    }
    /**
     * A rectangle interface definition.
     */
    export interface IRect {
        /**
         * The x coordinate of the rectangle.
         */
        x: number;
        /**
         * The y coordinate of the rectangle.
         */
        y: number;
        /**
         * The height of the rectangle.
         */
        height: number;
        /**
         * The width of the rectangle.
         */
        width: number;
    }
    /**
     * A graph node. Put these in Graph.ViewModel's graphNodes array.
     */
    export class GraphNode extends GraphEntity implements MsPortalFx.ViewModels.DynamicBladeSelection {
        /**
         * The view model to use for displaying the graph node's content.
         */
        extensionViewModel: any;
        /**
         * A Knockout template describing what the graph node looks like.
         */
        extensionTemplate: string;
        /**
         * The name of the blade to launch when the user activates this node.
         */
        detailBlade: string;
        /**
         * Inputs to the blade to launch when the user activates this node.
         */
        detailBladeInputs: Object;
        /**
         * The extension to which the blade specified in detailBlade belongs.
         */
        extension: string;
        /**
         * Specifies if the node is detached link holder
         */
        detachedLinkHolder: boolean;
        /**
         * Only used for constructor purposes. Shouldn't be touched by the extension.
         * We would make this protected, but it need to be proxied over, so we can't.
         */
        private initialRect;
        constructor(initialRect?: IUpdateRect);
    }
    /**
     * The contract definition of Graph edge interface for the purposes of addition logic.
     */
    export interface IGraphEdgeForAddition {
        /**
         * The identifier of the node the edge starts from.
         */
        startNodeId: string;
        /**
         * The identifier of the node the edge ends at.
         */
        endNodeId: string;
    }
    /**
     * Configurable options for the setNodeRects function call.
     */
    export interface ISetNodeRectOptions {
        /**
         * When true, clears the existing undo/redo stack.
         * Default: false;
         */
        clearUndo?: boolean;
    }
    /**
     * The contract definition of Graph node interface for the purposes of deletion logic.
     */
    export interface IGraphNodeForDeletion {
        /**
         * The identifier of the node.
         */
        id: string;
    }
    /**
     * The contract definition of Graph edge interface for the purposes of deletion logic.
     */
    export interface IGraphEdgeForDeletion {
        /**
         * The identifier of the edge.
         */
        id: string;
    }
    /**
     * Utility class encapsulates deletion functionality.
     */
    export class GraphEntitiesDeletion {
        /**
         * Performs deletion of the specified nodes and edges from the specified graph model.
         * @param model ViewModel instance to run the deletion on.
         * @param nodesToDelete List of nodes to delete.
         * @param edgesToDelete List of edges to delete.
         */
        static run(model: ViewModel, nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]): void;
    }
    /**
     * The contract that defines a graph for the pcGraph binding.
     */
    export interface Contract extends Loadable.Contract {
        /**
         * A meaningful label for screenreaders to use. This should be a concise name of the graph application. https://www.w3.org/TR/wai-aria-1.1/#aria-label
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * The scroll-bars enabled for the graph instance. Make sure to set .scrollBarsVisibilityMode property as needed as well.
         */
        scrollBars: KnockoutObservable<GraphScrollBars>;
        /**
         * The mode of scroll-bars appearance/visibility. Make sure to set .scrollBars property as needed as well.
         */
        scrollBarsVisibilityMode: KnockoutObservable<GraphScrollBarsVisibilityMode>;
        /**
         * The strategy defining how edges connect to nodes and how they follow the nodes' moves.
         */
        edgeConnectionStrategy: KnockoutObservable<EdgeConnectionStrategy>;
        /**
         * The editing capabilities the graph editor exposes.
         */
        editorCapabilities: KnockoutObservable<GraphEditorCapabilities>;
        /**
         * A collection of all the graph nodes in the graph.
         */
        graphNodes: MsPortalFx.Base.Internal.IObservableMap<GraphNode>;
        /**
         * A collection of all the edges in the graph.
         */
        edges: MsPortalFx.Base.Internal.IObservableMap<GraphEdge>;
        /**
         * How many pixels tall and wide each grid cell is. Used in snap to grid.
         */
        gridResolution: KnockoutObservable<number>;
        /**
         * The currently selected nodes and edges.
         */
        selectableSet: MsPortalFx.ViewModels.SelectableSet<SelectedGraphEntity, SelectedGraphEntity>;
        /**
         * When true, the user can multi-select by clicking in the background and dragging. When false, clicking and dragging in the background pans.
         * Default is false.
         */
        rectSelectionMode: KnockoutObservable<boolean>;
        /**
         * The strategy that determines how graph entities are rendered when the list of nodes or edges is updated. Default is
         * EdgeRenderingStrategy.Rebuild, but performance gains may be seen when adding or removing entities by setting this
         * to EntityRenderMode.Incremental.
         */
        entityRenderMode: KnockoutObservable<EntityRenderMode>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom and center the graph in the viewport.
         */
        zoomToFit: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Padding (in pixels) around the graph bounds when zoomToFit is called. Takes effect for zoomToFit() calls made AFTER zoomToFitPadding observable value change. Default value is 100.
         */
        zoomToFitPadding: KnockoutObservable<number>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom in.
         */
        zoomIn: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom out.
         */
        zoomOut: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom to 100%.
         */
        zoomTo100Percent: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to select the node and bring it into the view with animation.
         */
        focusOnNode: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to select the edge and bring it into the view with animation.
         */
        focusOnEdge: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * Bring a rectangle into the view with animation.
         */
        bringRectIntoView: KnockoutObservable<(rect: IRect) => MsPortalFx.Base.Promise>;
        /**
         * Adds the specified GraphEdge instance to the list of the view model edges.
         * To be overridden in custom ViewModel implementation to customize the edge that is being created when user drags it from source to destination node.
         *
         * @param edgeToAdd The edge instance to add.
         * @return A promise object that is resolved when the operation completes or fails.
         */
        addEdge(edgeToAdd: IGraphEdgeForAddition): Q.Promise;
        /**
         * Creates copies of selected entities
         */
        duplicateSelectedEntities: KnockoutObservable<() => Q.Promise<void>>;
        /**
         * Flag specifying whether to show link context menu
         */
        edgeContextMenuVisible: KnockoutObservable<boolean>;
        /**
         * Deletes the specified graph entities (nodes and edges).
         *
         * @param nodesToDelete The array of nodes to delete.
         * @param edgesToDelete The array of edges to delete.
         * @return A promise object that is resolved when the operation completes or fails.
         */
        deleteEntities(nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]): Q.Promise;
        /**
         * Whether or not the widget has been attached yet.
         */
        widgetAttached: KnockoutObservable<boolean>;
        /**
         * Notifies subscribers when the a layout change has been committed to the graph. The number given has no useful meaning but is used to trigger
         * the notification to the extension.
         */
        layoutChanged: KnockoutObservable<number>;
        /**
         * Returns a new candidate layout without overlaps, given a proposed movement of some nodes.
         * The returned candidate layout is used to preview the change and, if the user commits the change,
         * to update the committed locations of nodes.
         * This should be specified by the extension. If it's set null, no automatic layout will occur.
         *
         * @param changedNodes The nodes with explicitly changed positions.
         * @param rootId The node under the user's cursor (which should not move).
         * @return The nodes with implicitly changed positions.
         */
        getLayoutNoOverlaps: KnockoutObservable<(changedNodes: StringMap<IPoint>, rootId: string) => MsPortalFx.Base.PromiseV<StringMap<IPoint>>>;
        /**
         * Sets the rects for specified graph nodes.
         *
         * All calls to this function will result in animation, so best practice is to initialize nodes with
         * their starting rects (per the optional constructor).
         * This API is used to allow the widget to track animated and committed state, as well as allow for batch updates.
         *
         * @param rects Map of rects.
         * @param options Configurable options (ex: undo/redo stack).
         * @return A promise that resolves once the changes have been applied.
         */
        setNodeRects: KnockoutObservable<(rects: StringMap<IUpdateRect>, options?: ISetNodeRectOptions) => MsPortalFx.Base.Promise>;
        /**
         * Returns all rects for every graph node, or a specified list of graph node ids.
         *
         * This can only be called after widgetAttached() is true, otherwise it will throw an exception.
         *
         * @param ids The list of ids from which to return corresponding graphNodes.
         * @return A promise that resolves with a string map of committed rects.
         */
        getNodeRects: KnockoutObservable<(ids?: string[]) => MsPortalFx.Base.PromiseV<StringMap<IRect>>>;
        /**
         * A flag to disable zoom in/out behavior on mouse wheel events. If not provided, default to false.
         *
         * @return A value indicating whether zoom in/out behavior on mouse wheel events is disabled.
         */
        disableMouseWheelZoom: KnockoutObservable<boolean>;
        /**
         * A flag to enable lineage display for graphs (i.e. dim [reduce opacity] all the nodes except the selected and nodes in
         * its upstream and downstream).
         *
         * @return A boolean indicating if lineage display should be enabled.
         */
        enableLineage: KnockoutObservable<boolean>;
    }
    /**
     * The view model for pcGraph. Contains the representation of a graph.
     */
    export class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * See contract.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * See contract.
         */
        scrollBars: KnockoutObservable<GraphScrollBars>;
        /**
         * See contract.
         */
        scrollBarsVisibilityMode: KnockoutObservable<GraphScrollBarsVisibilityMode>;
        /**
         * See contract.
         */
        edgeConnectionStrategy: KnockoutObservable<EdgeConnectionStrategy>;
        /**
         * See contract.
         */
        editorCapabilities: KnockoutObservable<GraphEditorCapabilities>;
        /**
         * See contract.
         */
        graphNodes: Internal.ObservableMap<GraphNode>;
        /**
         * See contract.
         */
        edges: Internal.ObservableMap<GraphEdge>;
        /**
         * See contract.
         */
        gridResolution: KnockoutObservable<number>;
        /**
         * See contract.
         */
        selectableSet: MsPortalFx.ViewModels.SelectableSet<SelectedGraphEntity, SelectedGraphEntity>;
        /**
         * See contract.
         */
        widgetAttached: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        layoutChanged: KnockoutObservable<number>;
        /**
         * See contract.
         */
        getLayoutNoOverlaps: KnockoutObservable<(changedNodes: StringMap<IPoint>, rootId: string) => MsPortalFx.Base.PromiseV<StringMap<IPoint>>>;
        /**
         * See contract.
         */
        setNodeRects: KnockoutObservable<(rects: StringMap<IUpdateRect>, options?: ISetNodeRectOptions) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        getNodeRects: KnockoutObservable<(ids?: string[]) => MsPortalFx.Base.PromiseV<StringMap<IRect>>>;
        /**
         * See contract.
         */
        rectSelectionMode: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        entityRenderMode: KnockoutObservable<EntityRenderMode>;
        /**
         * See contract.
         */
        zoomToFit: KnockoutObservable<() => Q.Promise<void>>;
        /**
         * See contract.
         */
        zoomToFitPadding: KnockoutObservable<number>;
        /**
         * See contract.
         */
        zoomIn: KnockoutObservable<() => Q.Promise<void>>;
        /**
         * See contract.
         */
        zoomOut: KnockoutObservable<() => Q.Promise<void>>;
        /**
         * See contract.
         */
        zoomTo100Percent: KnockoutObservable<() => Q.Promise<void>>;
        /**
         * See contract.
         */
        focusOnNode: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        focusOnEdge: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        bringRectIntoView: KnockoutObservable<(rect: IRect) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        addEdge: (edgeToAdd: IGraphEdgeForAddition) => Q.Promise;
        /**
         * See contract.
         */
        duplicateSelectedEntities: KnockoutObservable<() => Q.Promise<void>>;
        /**
         * See contract.
         */
        edgeContextMenuVisible: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        deleteEntities: (nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]) => Q.Promise;
        /**
         * See contract.
         */
        disableMouseWheelZoom: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        enableLineage: KnockoutObservable<boolean>;
        /**
         * Used by selectable set to determine if a graph node is part of the selected set. Extension authors
         * should never need to call this.
         *
         * @param selectedGraphEntity the SelectedGraphEntity to compare.
         * @param selectionItem the selected item to compare.
         * @return boolean whether the selected item is the graph entity or not.
         */
        static itemMatchesSelection(selectedGraphEntity: SelectedGraphEntity, selectionItem: SelectedGraphEntity): boolean;
        /**
         * Transforms a graph entity into a selection contract. Extension authors should never need to call this.
         *
         * @param graphEntity the graph node to transform.
         * @return the graph node that manages selection state.
         */
        static createSelection(selectedGraphEntity: SelectedGraphEntity): SelectedGraphEntity;
        /**
         * The style skin applied to the graph editor defining canvas and entities styling (mostly colors).
         * Only used for constructor purposes. Shouldn't be touched by the extension.
         * We would make this protected, but it need to be proxied over, so we can't.
         */
        private styleSkin;
        /**
         * Creates a graph view model
         * @param lifetimeManager Lifetime manager object dealing with proper resources disposal.
         * @param styleSkin Style skin for the graph editor. Default to GraphEditorSkinStyle.Blade.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, styleSkin?: GraphEditorSkinStyle);
    }
}

// FILE: Fx\Controls\GridBase.d.ts
declare module "Fx/Controls/GridBase" {
    /**
     * Grid selection mode.
     */
    export const enum SelectionMode {
        /**
         * Select a single row at a time.
         */
        Single = 0,
        /**
         * Select a multiple rows at a time.
         */
        Multiple = 1
    }
    /**
     * Grid sort direction.
     */
    export const enum SortDirection {
        /**
         * Data is sorted in ascending order.
         */
        Ascending = 1,
        /**
         * Data is sorted in descending order.
         */
        Descending = -1,
        /**
         * Data is not sorted.
         */
        Unsorted = 0
    }
}

// FILE: Fx\Controls\HotSpot.d.ts
declare module "Fx/Controls/HotSpot" {
    import * as Selectable from "Fx/Composition/Selectable";
    import BaseViewModel = MsPortalFx.ViewModels.Controls.HotSpot.BaseViewModel;
    /**
     * @deprecated Fx/Controls/HotSpot.ViewModelOptions is deprecated. Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Hotspot options.
     */
    export interface ViewModelOptions {
        /**
         * A function to be called when the hotspot is clicked.
         */
        onClick?: () => void;
        /**
         * Whether to activate the hotspot during customize or not.
         */
        clickableDuringCustomize?: boolean;
        /**
         * Disabled state of the hotspot.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    /**
     * @deprecated Fx/Controls/HotSpot.ViewModel is deprecated. Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * View model for hotspots.
     */
    export class ViewModel extends BaseViewModel {
        private _msPortalFxOnClick;
        /**
         * @deprecated Fx/Controls/HotSpot.ViewModel is deprecated. Use fxclick directly in your HTML template instead.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: ViewModelOptions);
    }
    /**
     * @deprecated Fx/Controls/HotSpot.ViewModel2 is deprecated. Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export class ViewModel2 extends BaseViewModel {
        /**
         * Selectable that tracks if hotspot selection state
         */
        selectable: Selectable.Selectable2<any>;
        /**
         * @deprecated Fx/Controls/HotSpot.ViewModel2 is deprecated. Use fxclick directly in your HTML template instead.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, selectableOptions?: Selectable.Selectable2Options<any>, clickableDuringCustomize?: boolean);
    }
}

// FILE: Fx\Controls\InfoBalloon.d.ts
declare module "Fx/Controls/InfoBalloon" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Options {
        /**
         * Html to be shown in the balloon.
         */
        content?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Desired aria-label value of the anchor. If 'content' member field is too long, please
         * make use of this field; make it a shorter summary of the full content.
         */
        ariaLabel?: KnockoutObservableBase<string> | string;
    }
    /**
     * InfoBalloon control view model
     */
    export interface Contract extends Control {
        /**
         * Html to be shown in the balloon.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Desired aria-label value of the anchor. If 'content' member field is too long, please
         * make use of this field; make it a shorter summary of the full content.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates an InfoBalloon control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns an InfoBalloon viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\InfoBox.d.ts
declare module "Fx/Controls/InfoBox" {
    import { BladeLink, ResourceLink, ClickableLink } from "Fx/Composition";
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The 'size' property is no longer supported in InfoBox. Use the different variants of 'create' method to choose the correct type.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export type Size = Obsolete;
    /**
     * The style options for info box.
     */
    export const enum Style {
        /**
         * Info style.
         */
        Info = 1,
        /**
         * Upsell style.
         */
        Upsell = 2,
        /**
         * Success style.
         */
        Success = 3,
        /**
         * Warning style.
         */
        Warning = 4,
        /**
         * Error style.
         */
        Error = 5
    }
    /**
     * InfoBox create options.
     */
    export interface Options extends BaseOptions {
        /**
         * The 'image' property is no longer supported in InfoBox. It only supports predefined styles now.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        image?: Obsolete;
        /**
         * The 'size' property is no longer supported in InfoBox. Use the different variants of 'create' method to choose the correct type.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        size?: Obsolete;
        /**
         * Clickable invoked when the InfoBox is clicked.
         *
         * If a function is specified, clicking the infobox will trigger a callback to the function.
         * If a clickable link is provided, then clicking the info box will open that external link.
         * If a blade-reference clickable is provided (BladeLink, or ResourceLink), then the respective
         * blade will get opened.
         */
        onClick?: Function | BladeLink | ResourceLink | ClickableLink;
        /**
         * Flag indicating if the info box can be closed.
         */
        canClose?: boolean;
        /**
         * Defines the action performed once the infobox is dismissed.
         */
        onCloseClickCallback?: Function;
    }
    /**
     * Inline InfoBox create options.
     */
    export interface InlineOptions extends BaseOptions {
    }
    /**
     * Base InfoBox create options.
     */
    export interface BaseOptions {
        /**
         * Style of the infobox, defaults to Info.
         */
        style?: Style | KnockoutObservableBase<Style>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The text or html to display in the control.
         */
        text?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the infobox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * InfoBox control view model.
     */
    export interface Contract extends BaseContract {
        /**
         * The 'image' property is no longer supported in InfoBox. It only supports predefined styles now.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        readonly image: Obsolete;
        /**
         * The 'size' property is no longer supported in InfoBox. Use the different variants of 'create' method to choose the correct type.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        readonly size: Obsolete;
    }
    /**
     * Inline InfoBox control view model.
     */
    export interface InlineContract extends BaseContract {
    }
    /**
     * InfoBox control base view model.
     */
    export interface BaseContract extends Control {
        /**
         * Style of the infobox, defaults to Info.
         */
        readonly style: KnockoutObservableBase<Style>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The text or html to display in the control.
         */
        readonly text: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Whether the form element is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The aria-label on the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates an InfoBox control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns an InfoBox viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
    /**
     * Creates an inline InfoBox control viewmodel (no border, no background fill, which does not support canClose or clickables).
     *
     * @param lifetime The lifetime of the control.
     * @param options inline InfoBox Options that modify the appearance and behavior of the control.
     *
     * @returns an inline InfoBox viewmodel.
     */
    export function createInline(lifetime: MsPortalFx.Base.LifetimeManager, options?: InlineOptions): InlineContract;
}

// FILE: Fx\Controls\Legend.d.ts
declare module "Fx/Controls/Legend" {
    import { HatchingPattern as Pattern } from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    import { Control } from "Fx/Controls/ControlsBase";
    export { Pattern };
    export { FxChartColorClass };
    /**
     * ItemSetting defines the properties required to build legend items.
     * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of legend items.
     */
    export interface ItemSetting {
        /**
         * Data key used to identify the row index. Leave unset to use the index within data.
         */
        readonly indexKey?: string;
        /**
         * Data key used to identify the color.
         */
        readonly colorKey?: string;
        /**
         * Data key of the hatching pattern.
         */
        readonly hatchingKey?: string;
        /**
         * Data key used to identify the boolean column indicating if the row is selected.
         */
        readonly selectedKey?: string;
        /**
         * Data key used to label the row for display purpose. Data has to be string, we use to show center caption for quick indication of the item.
         */
        readonly labelKey: string;
    }
    /**
     * Options for Legend ViewModel.
     */
    export interface Options<T> {
        /**
         * ItemSetting defines the properties required to build legend items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of legend items.
         */
        itemSetting?: ItemSetting;
        /**
         * Legend items to display.
         */
        items?: T[] | KnockoutObservableArray<T>;
        /**
         * Index of current hovered row in the legend. If hoveredIndex is not initialized, legend items cannot be navigated or selected.
         */
        hoveredIndex?: KnockoutObservableBase<string>;
        /**
         * Aria label for the legend.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Legend ViewModel contract.
     */
    export interface Contract<T> extends Control {
        /**
         * ItemSetting defines the properties required to build legend items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of legend items.
         */
        readonly itemSetting: ItemSetting;
        /**
         * Legend items to display.
         */
        readonly items: KnockoutObservableArray<T>;
        /**
         * Index of current hovered row in the legend. If hoveredIndex is not initialized, legend items cannot be navigated or selected.
         */
        readonly hoveredIndex: KnockoutObservableBase<string>;
        /**
         * Aria label for the legend.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates a Legend control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a Legend control viewmodel
     */
    export function create<T>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<T>): Contract<T>;
}

// FILE: Fx\Controls\LineChart.d.ts
declare module "Fx/Controls/LineChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export import ChartEvents = ChartBase.ChartEvents;
    export import ConditionOperator = ChartBase.ConditionOperator;
    export import Interpolation = ChartBase.Interpolation;
    export import RenderingCondition = ChartBase.RenderingCondition;
    export { FxChartColorClass };
    /**
     * Defines line styles of the line chart.
     */
    export const enum LineStyle {
        /**
         * The series line is solid.
         */
        Solid = 0,
        /**
         * The series line is dotted.
         */
        Dotted = 1,
        /**
         * The series line is dashed.
         */
        Dashed = 2,
        /**
         * The series line is a trendline.
         */
        Trendline = 3,
        /**
         * The series line is a usage threshold.
         */
        UsageThreshold = 4,
        /**
         * The series line is a warning threshold.
         */
        WarningThreshold = 5
    }
    /**
     * This base interface defines the how a series should be rendered on the chart.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        readonly renderingConditions?: RenderingCondition[];
        /**
         * Indicates if the series is selectable.
         * By default, the series line is selectable and selectable styling is shown. To disallow selecting the series line, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the series line is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Defines the interpolation type for the series.
         * By default the interpolation is Linear and the data points will be connected by straight lines.
         */
        readonly interpolation?: Interpolation;
        /**
         * Defines the line type for the series in the current view.
         * By default solid line will be rendered.
         */
        readonly lineStyle?: LineStyle;
        /**
         * Optionally show a circle for the data point.
         * Default value is true and data point circle will be shown.
         */
        readonly showDataPoints?: boolean;
        /**
         * Indicates if the series is hidden from the legend
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Options for configuring a LineChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the line chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * LineChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the line chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @return A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Q.Promise;
    }
    /**
     * Creates a LineChart control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a LineChart control viewmodel
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\ListView.d.ts
declare module "Fx/Controls/ListView" {
    import { ToolbarItem } from "Fx/Controls/Toolbar";
    import { ClickableLink, BladeLink, ResourceLink } from "Fx/Composition";
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Base ListView options.
     */
    export interface Options {
        /**
         * The accessibility label for the List.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Disabled state of the control.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates when the list is in a loading state.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Message to display when the list is in a loading state.
         */
        readonly loadingMessage?: string | KnockoutObservableBase<string>;
        /**
         * Indicates when the list has no data to display.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Message displayed when list is empty.
         */
        readonly noDataMessage?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Css class specific to this List.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Context menu options.
         */
        readonly contextMenu?: ContextMenuOptions<any, any>;
        /**
         * Selection options.
         */
        readonly selection?: SelectionOptions<any>;
    }
    /**
     * SimpleListView options.
     */
    export interface SimpleListViewOptions extends Options {
        /**
         * Items displayed in the list.
         */
        readonly items: ReadonlyArray<SimpleItemDefinition> | KnockoutObservableArray<SimpleItemDefinition>;
    }
    /**
     * TemplateListView options.
     */
    export interface TemplateListViewOptions<TViewModel> extends Options {
        /**
         * Template used on each item.
         */
        readonly itemTemplate?: string | KnockoutObservableBase<string>;
        /**
         * Items displayed in the list.
         */
        readonly items: ReadonlyArray<TemplateItemDefinition<TViewModel>> | KnockoutObservableArray<TemplateItemDefinition<TViewModel>>;
        /**
         * Gallery display options.
         */
        readonly galleryView?: GalleryViewOptions;
    }
    /**
     * CustomListView options.
     */
    export interface CustomListViewOptions extends Options {
        /**
         * Items displayed in the list.
         */
        readonly items: ReadonlyArray<CustomItemDefinition> | KnockoutObservableArray<CustomItemDefinition>;
        /**
         * Gallery display options.
         */
        readonly galleryView?: GalleryViewOptions;
    }
    /**
     * Base ListView contract.
     */
    export interface Contract<TItem extends Item> extends Control {
        /**
         * Items displayed in the list.
         */
        readonly items: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The accessibility label for the List.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates when the list is in a loading state.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Message to display when the list is in a loading state.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * Indicates when the list has no data to display.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Message to display when the list has no data.
         */
        readonly noDataMessage: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Css class specific to this List.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Context menu properties and methods.
         * Will be null when no contextMenu options is provided during ListView's initialization.
         */
        readonly contextMenu: ContextMenuContract;
        /**
         * ListView selection properties and methods.
         * Will be null when no selection options is provided during ListView initialization.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * ListView focus properties and methods.
         */
        readonly focus: FocusContract<TItem>;
    }
    /**
     * SimpleListView contract.
     */
    export interface SimpleListViewContract extends Contract<SimpleItem> {
    }
    /**
     * TemplateListView contract.
     */
    export interface TemplateListViewContract<TViewModel> extends Contract<TemplateItem<TViewModel>> {
        /**
         * galleryView display properties and methods.
         */
        readonly galleryView?: GalleryViewContract;
    }
    /**
     * CustomListView contract.
     */
    export interface CustomListViewContract extends Contract<CustomItem> {
        /**
         * galleryView display properties and methods.
         */
        readonly galleryView?: GalleryViewContract;
    }
    /**
     * Base ListView ItemDefinition.
     */
    export interface ItemDefinition {
        /**
         * The item accessibility label.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Css class specific to this item.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Disabled state of the item.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback executed or link opened when the user clicks the item.
         */
        readonly onItemClick?: (() => void) | ClickableLink | BladeLink | ResourceLink;
    }
    /**
     * ItemDefinition to define SimpleListView item
     */
    export interface SimpleItemDefinition extends ItemDefinition {
        /**
         * Content to be displayed for item
         */
        readonly content: string | KnockoutObservableBase<string>;
    }
    /**
     * ItemDefinition to define TemplateListView item
     */
    export interface TemplateItemDefinition<TViewModel> extends ItemDefinition {
        /**
         * viewModel that bind to the itemTemplate
         */
        readonly viewModel: TViewModel;
    }
    /**
     * ItemDefinition to define CustomListView item
     */
    export interface CustomItemDefinition extends ItemDefinition {
        /**
         * Content to be displayed
         */
        readonly content: HtmlContent | Control | KnockoutObservableBase<HtmlContent | Control>;
    }
    /**
     * Base ListView Item Contract.
     */
    export interface Item {
        /**
         * Css class specific to this item.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The item accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state of the item.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is selected.
         */
        readonly selected: KnockoutReadOnlyObservableBase<boolean>;
    }
    /**
     * SimpleListView Item Contract.
     */
    export interface SimpleItem extends Item {
        /**
         * Content to be displayed
         */
        readonly content: KnockoutObservableBase<string>;
    }
    /**
     * TemplateListView Item Contract.
     */
    export interface TemplateItem<TViewModel> extends Item {
        /**
         * viewModel that bind to the itemTemplate
         */
        readonly viewModel: TViewModel;
    }
    /**
     * CustomListView Item Contract.
     */
    export interface CustomItem extends Item {
        /**
         * Content to be displayed
         */
        readonly content: KnockoutReadOnlyObservableBase<HtmlContent | Control>;
    }
    /**
     * ListView selection mode.
     */
    export const enum SelectionMode {
        /**
         * Select a single row at a time.
         */
        Single = 0,
        /**
         * Select a multiple rows at a time.
         */
        Multiple = 1
    }
    /**
     * ListView selection options.
     */
    export interface SelectionOptions<TItem extends Item> {
        /**
         * Selection mode (defaults to Single).
         */
        readonly selectionMode: SelectionMode;
        /**
         * Determines if a item can be selected.
         *
         * @param item The item to select.
         * @returns Indicates if the item can be selected.
         */
        readonly canSelectItem?: (item: TItem) => boolean;
        /**
         * Determines if a item can be unselected.
         *
         * @param item The item to unselect.
         * @returns Indicates if the item can be unselected.
         */
        readonly canUnselectItem?: (item: TItem) => boolean;
        /**
         * Determines if selection UI is visible.
         * Defaults to true.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ListView selection contract.
     */
    export interface SelectionContract<TItem extends Item> {
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * The currently selected items.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * Selects an item.
         *
         * @item The item to select.
         * @return Indicates if the item was selected. Would return false if the item is unselectable.
         */
        readonly selectItem: (item: TItem) => boolean;
        /**
         * Unselects an item.
         *
         * @item The item to unselect.
         * @return Indicates if the item was unselected.
         */
        readonly unselectItem: (item: TItem) => boolean;
        /**
         * Selects all items.
         *
         * @return Indicates if all items were selected. Would return false if any item is unselectable.
         */
        readonly selectAllItems: () => boolean;
        /**
         * Unselects all items.
         *
         * @return Indicates if all items were unselected. Would return false if any item is still selected.
         */
        readonly unselectAllItems: () => boolean;
        /**
         * Determines if selection UI is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * ListView context menu options.
     */
    export interface ContextMenuOptions<TItem extends Item, TContract extends Contract<TItem>> {
        /**
         * Determines if the list item supports context menu.
         * This is true by default and only needs to be implemented to opt specific list items out.
         * This controls if the context menu shortcut is displayed in the list item.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param item The item to show menus for.
         * @returns Indicates if the item can show a context menu.
         */
        readonly canShowMenu?: (item: TItem) => boolean;
        /**
         * Supplies commands to be displayed in the Items context menu.
         * This is not called when multiple items are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param item The item to supply commands for.
         * @returns The commands for the context menu or a promise for the commands.
         */
        readonly supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, item: TItem, list: TContract) => ToolbarItem[] | Q.Promise<ToolbarItem[]>;
        /**
         * Supplies commands to be displayed in the Items context menu.
         * This is called only when multiple rows are selected. And SelectionOptions with SelectionMode.Multi must be supplied.
         *
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply the commands for.
         * @param list The list.
         * @returns The commands for the context menu or a promise for the commands.
         */
        readonly supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionContract<TItem>, list: TContract) => ToolbarItem[] | Q.Promise<ToolbarItem[]>;
        /**
         * Indicates if the context menu buttons are displayed in the list margin.
         * Defaults to true.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ListView context menu contract.
     */
    export interface ContextMenuContract {
        /**
         * Indicates if the context menu buttons are displayed in the list margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * ListView context menu contract.
     */
    export interface FocusContract<TItem extends Item> {
        /**
         * Indicates if the context menu buttons are displayed in the list margin.
         */
        readonly currentItem: KnockoutReadOnlyObservableBase<TItem>;
    }
    /**
     * Gallery Options for horizonal display
     */
    export interface GalleryViewOptions {
        /**
         * If wrapping overflow items.
         * Set to true by default.
         */
        wrap: boolean | KnockoutObservableBase<boolean>;
        /**
         * If each item can grow/shrink its size based on its container.
         * Set to false by default.
         */
        autofit: boolean | KnockoutObservableBase<boolean>;
        /**
         * Displays standard border styling for the item.
         * This is false by default for backwards compatability.
         * However, it is highly recommended this be set to true for consistent styling across the portal.
         */
        showBorder?: boolean;
    }
    /**
     * Gallery properties for horizonal display
     */
    export interface GalleryViewContract {
        /**
         * If wrapping overflow items.
         * Set to true by default.
         */
        readonly wrap: KnockoutObservableBase<boolean>;
        /**
         * If each item can grow/shrink its size based on its container.
         * Set to false by default.
         */
        readonly autofit: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a SimpleListView viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the SimpleListView.
     *
     * @returns a SimpleListView viewmodel
     */
    export function createSimpleListView(lifetime: MsPortalFx.Base.LifetimeManager, options: SimpleListViewOptions): SimpleListViewContract;
    /**
     * Creates a TemplateListView viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the TemplateListView.
     *
     * @returns a TemplateListView viewmodel
     */
    export function createTemplateListView<TViewModel>(lifetime: MsPortalFx.Base.LifetimeManager, options: TemplateListViewOptions<TViewModel>): TemplateListViewContract<TViewModel>;
    /**
     * Creates a CustomListView viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the TemplateListView.
     *
     * @returns a CustomListView viewmodel
     */
    export function createCustomListView(lifetime: MsPortalFx.Base.LifetimeManager, options: CustomListViewOptions): CustomListViewContract;
}

// FILE: Fx\Controls\LocationDropDown.d.ts
declare module "Fx/Controls/LocationDropDown" {
    import { Location as BaseLocation, Validation as BaseValidation } from "Fx/Controls/BaseResourceDropDown";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { Location as ArmLocation } from "Fx/ResourceManagement";
    /**
     * The contract for the values returned by the location dropdown
     */
    export type Location = ArmLocation;
    /**
     * The validation type accepted by the dropdown
     */
    export type Validation = BaseValidation<Location>;
    /**
     * The contract for options to create the location drop down
     */
    export type Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseLocation.Options<THtmlKeyMap>;
    /**
     * The contract for options to create the location drop down
     */
    export type CustomOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseLocation.CustomOptions<THtmlKeyMap>;
    /**
     * The contract for the location dropdown
     */
    export interface Contract extends BaseLocation.Contract {
    }
    /**
     * This creates a location dropdown control.
     * @param container The container associated with the part or blade.
     * @param options The location dropdown options. See interface
     */
    export function create<THtmlKeyMap extends StringMap<HtmlContent>>(container: AnyBladeContainer, options: Options<THtmlKeyMap>): Contract;
    /**
     * This creates a location dropdown control with the ability to add additional locations.
     * @param container The container associated with the part or blade.
     * @param options The location dropdown options. See interface
     */
    export function createCustom<THtmlKeyMap extends StringMap<HtmlContent>>(container: AnyBladeContainer, options: CustomOptions<THtmlKeyMap>): Contract;
}

// FILE: Fx\Controls\LogStream.d.ts
declare module "Fx/Controls/LogStream" {
    import { Control } from "Fx/Controls/ControlsBase";
    export const enum LogItemType {
        /**
         * Indicates general information.
         */
        Text = 0,
        /**
         * Indicates important information.
         */
        Information = 1,
        /**
         * Indicates success information
         */
        Success = 2,
        /**
         * Indicates warning information.
         */
        Warning = 3,
        /**
         * Indicates error information.
         */
        Error = 4
    }
    export interface LogItem {
        /**
         * The text to log.
         */
        text: string;
        /**
         * The type of text to log.
         */
        type?: LogItemType;
    }
    export interface Options {
        /**
         * Alternate text for screen reader, label for this log-stream
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Controls display updating.
         */
        paused?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Controls filtering of messages in the log stream.
         */
        filters?: LogItemType[] | KnockoutObservableArray<LogItemType>;
    }
    export interface Contract extends Control {
        /**
         * Alternate text for screen reader, label for this log-stream
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Controls display updating.  When set to true, the log stream will buffer messages and will show them when unpaused.
         */
        readonly paused: KnockoutObservableBase<boolean>;
        /**
         * Controls filtering of messages in the log stream.
         */
        readonly filters: KnockoutObservableArray<LogItemType>;
        /**
         * Clears the log stream control.
         */
        reset(): void;
        /**
         * Writes an entry to the log
         * @param entry The text to show in the control.  Passing in a LogItem or array of LogItems allows you to control the level of entry (error, warning, etc.)
         */
        log(entry: string | string[] | LogItem | LogItem[]): void;
    }
    /**
     * Creates an LogStream control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns an LogStream viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Map.d.ts
declare module "Fx/Controls/Map" {
    import { Control } from "Fx/Controls/ControlsBase";
    export import Image = MsPortalFx.Base.Image;
    /**
     * By default, map will take the size(width) of the container and will grow or shrink based on the container width.
     * The height will be adjusted automatically based on the supported aspect ratio.
     */
    export const mapAspectRatio = 2;
    /**
     * Map item coordinate.
     */
    export interface Location {
        /**
         * Latitude coordinate for the map item.
         */
        readonly latitude: number;
        /**
         * Longitude coordinate for the map item.
         */
        readonly longitude: number;
    }
    /**
     * Map Item contract for basic layout.
     */
    export interface Item {
        /**
         * Specify unique id for the item.
         */
        readonly id: string;
        /**
         * Location for the item.
         */
        readonly location: Location;
        /**
         * The icon displayed for the item.
         */
        readonly icon?: KnockoutObservableBase<Image>;
        /**
         * The width of the icon
         */
        readonly iconWidth?: KnockoutObservableBase<number>;
        /**
         * The height of the icon
         */
        readonly iconHeight?: KnockoutObservableBase<number>;
    }
    /**
     * Event callback for Map interactions.
     */
    export interface Events {
        /**
         * Click on an item.
         */
        readonly itemClick?: (item: Item) => void;
        /**
         * Mouse enter on an item.
         */
        readonly itemMouseEnter?: (item: Item) => void;
        /**
         * Mouse leave on an item.
         */
        readonly itemMouseLeave?: (item: Item) => void;
    }
    /**
     * Initialization options for basic layout map.
     */
    export interface Options {
        /**
         * Map items to be displayed.
         */
        readonly items?: Item[] | KnockoutObservableArray<Item>;
        /**
         * Events supported by the map control.
         */
        readonly events?: Events;
        /**
         * The width of the control.
         * If map size needs to be fixed, provide the width for the map. The height will be automatically calculated based on the supported aspect ratio.
         * By default/width is set to 0, map will take the width of the container and will grow or shrink based on the container width.
         * The height will be adjusted automatically based on the supported aspect ratio.
         */
        readonly width?: number | KnockoutObservableBase<number>;
        /**
         * Aria label for the control.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Aria description for the control.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * View model contract for the map widget with basic layout.
     */
    export interface Contract extends Control {
        /**
         * Map items to be displayed.
         */
        readonly items: KnockoutObservableArray<Item>;
        /**
         * The width of the control.
         * If map size needs to be fixed, provide the width for the map. The height will be automatically calculated based on the supported aspect ratio.
         * By default/width is set to 0, map will take the width of the container and will grow or shrink based on the container width.
         * The height will be adjusted automatically based on the supported aspect ratio.
         */
        readonly width: KnockoutObservableBase<number>;
        /**
         * The height of the control.
         * The new map layout will preserve the aspect ratio and automatically compute the height.
         */
        readonly height: KnockoutReadOnlyObservableBase<number>;
        /**
         * Aria label for the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria description for the control.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * Creates a basic layout Map control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a basic layout Map control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Markdown.d.ts
declare module "Fx/Controls/Markdown" {
    import { Control } from "Fx/Controls/ControlsBase";
    export interface Options {
        /**
         * markdown Input string containing markdown to be converted to html and displayed.
         */
        markdown?: string | KnockoutObservableBase<string>;
        /**
         * Alternate text for screen reader to describe this article shortly
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface Contract extends Control {
        /**
         * markdown Input string containing markdown to be converted to html and displayed.
         */
        readonly markdown: KnockoutObservableBase<string>;
        /**
         * Alternate text for screen reader to describe this article shortly
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates an Markdown control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a Markdown viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Menu.d.ts
declare module "Fx/Controls/Menu" {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    /**
     * Attributes common to all items and groups in the menu.
     */
    export interface MenuItemBase extends FxImpl.Controls.Menu.MenuItemBase {
    }
    /**
     * Defines an item in a group of the menu.
     */
    export interface MenuItem extends FxImpl.Controls.Menu.MenuItem {
    }
    /**
     * Defines a group in the menu.
     */
    export interface MenuGroup extends FxImpl.Controls.Menu.MenuGroup {
    }
    /**
     * The options for the menu.
     */
    export interface Options extends FxImpl.Controls.Menu.Options {
    }
    /**
     * The sort order used for groups in the menu.
     */
    export import SortOrder = MsPortalFx.ViewModels.Controls.Lists.Grid.SortOrder;
    /**
     * The sort functions used to sort groups in the menu.
     */
    export enum SortFunction {
        /**
         * Uses the built-in Array.sort() function.
         */
        Default = 0,
        /**
         * Uses the getTime() value of Date object to sort.
         */
        DateTime = 1,
        /**
         * Uses custom sorting, that ensures that the support group is prioritized over others.
         */
        SupportFirst = 9999
    }
    /**
     * Defines the view model for the menu control.
     */
    export class ViewModel extends FxControls.Base.ViewModel {
        /**
         * The groups of menu items.
         */
        groups: KnockoutObservableArray<MenuGroup>;
        /**
         * Specifies the sort order used for groups in the menu.
         */
        groupSortOrder: SortOrder;
        /**
         * Specifies the sort function used to order groups in the menu.
         */
        groupSortFunction: SortFunction;
        /**
         * A value indicating whether or not to show the search box.
         */
        showSearch: boolean;
        /**
         * Asynchronously initializes the view model.
         *
         * @param groups The menu groups.
         * @param options The menu options.
         * @return A Promise that resolves once the view model is initialized.  This Promise can be included in that Promise returned
         * from the containing Blade's 'onInitialize'/'onInputsSet' method.
         */
        initialize: (groups: MenuGroup[], options: Options) => Q.Promise<void>;
        private _msPortalFxData;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, groupSortFunction?: SortFunction);
        /**
         * Sets the options for the menu.
         *
         * @param options The options to configure the menu.
         */
        setOptions: (options: Options) => void;
    }
}

// FILE: Fx\Controls\Metrics.d.ts
declare module "Fx/Controls/Metrics" {
    import { Contract as SingleMetricContract } from "Fx/Controls/SingleMetric";
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Size of the metrics.
     */
    export const enum Size {
        /**
         * Shows small metrics - Font: 20px, Height: 32px, Margin: 14px.
         */
        Small = 0,
        /**
         * Shows medium metrics - Font: 40px, Height: 35px, Margin: 30px.
         */
        Medium = 1,
        /**
         * Shows large metrics - Font: 40px, Height: 45px, Margin: 22px.
         */
        Large = 2,
        /**
         * Shows Xlarge metrics - Font: 40px, Height: 45px, Margin: 25px.
         */
        XLarge = 3,
        /**
         * Shows extra small metrics - Font: 20px, Height: 30px, Margin: 12px.
         */
        ExtraSmall = 4
    }
    /**
     * Orientation of the metrics.
     */
    export const enum Orientation {
        /**
         * Metrics will be displayed horizontally.
         */
        Horizontal = 0,
        /**
         * Metrics will be displayed vertically.
         */
        Vertical = 1
    }
    export interface Options {
        /**
         * Metrics items to display
         */
        items?: SingleMetricContract[] | KnockoutObservableArray<SingleMetricContract>;
        /**
         * The orientation of the items in the metrics.
         */
        orientation?: Orientation | KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         */
        size?: Size | KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface Contract extends Control {
        /**
         * Metrics items to display
         */
        readonly items: KnockoutObservableArray<SingleMetricContract>;
        /**
         * The orientation of the items in the metrics.
         */
        readonly orientation: KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         */
        readonly size: KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates a Metrics control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a Metrics control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\MonitorChart.d.ts
declare module "Fx/Controls/MonitorChart" {
    /**
     * Defines how data points are aggregated for a metric.
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. Please switch to the equivalent definition in MonitorChartV2.
     */
    export const enum AggregationType {
        /**
         * No aggregation is done.
         */
        None = 0,
        /**
         * Data points are aggregated by taking the average of their values.
         */
        Average = 1,
        /**
         * Data points are aggregated by taking the min of their values.
         */
        Minimum = 2,
        /**
         * Data points are aggregated by taking the max of their values.
         */
        Maximum = 3,
        /**
         * Data points are aggregated by taking the total of their values.
         */
        Total = 4
    }
    /**
     * Defines what visualization to use when rendering the chart.
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. Please switch to the equivalent definition in MonitorChartV2.
     */
    export const enum ChartType {
        /**
         * Line chart.
         */
        Line = 0,
        /**
         * Bar chart.
         */
        Bar = 1
    }
    /**
     * Defines the unit of a metric.
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. Please switch to the equivalent definition in MonitorChartV2.
     */
    export const enum Unit {
        /**
         * Count unit.
         */
        Count = 0,
        /**
         * Bytes unit.
         */
        Bytes = 1,
        /**
         * Seconds unit.
         */
        Seconds = 2,
        /**
         * CountPerSecond unit.
         */
        CountPerSecond = 3,
        /**
         * BytesPerSecond unit.
         */
        BytesPerSecond = 4,
        /**
         * Percent unit.
         */
        Percent = 5,
        /**
         * MilliSeconds unit.
         */
        MilliSeconds = 6,
        /**
         * ByteSeconds unit.
         */
        ByteSeconds = 7
    }
    /**
     * Defines the timespan over which data points are fetched and plotted.
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. Please switch to the equivalent definition in MonitorChartV2.
     */
    export interface Timespan {
        /**
         * A relative timespan indicates that data points are plotted for a moving timespan, whose
         * end time is always now().
         */
        relative?: {
            /**
             * Length of time over which metrics are plotted.
             */
            durationMs: number;
        };
        /**
         * An absolute timespan indicates that data points are plotted for a fixed timespan.
         */
        absolute?: {
            /**
             * The start time of the timespan.
             */
            start: Date;
            /**
             * The end time of the timespan.
             */
            end: Date;
        };
        /**
         * How frequently the data points shown on the chart should be updated.
         */
        refreshIntervalMs?: number;
    }
    /**
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. Please switch to the equivalent definition in MonitorChartV2.
     */
    export interface ResourceMetadata {
        /**
         * The resource id of the resource.
         */
        resourceId: string;
        /**
         * The kind of the resource.
         */
        kind?: string;
        /**
         * The sku of the resource.
         */
        sku?: {
            /**
             * The sku name.
             */
            name?: string;
            /**
             * The sku tier.
             */
            tier?: string;
            /**
             * The sku size.
             */
            size?: string;
            /**
             * The sku family.
             */
            family?: string;
            /**
             * The sku model.
             */
            model?: string;
            /**
             * The sku capacity.
             */
            capacity?: string;
        };
        /**
         * Additional properties for the resource.
         */
        properties?: any;
    }
    /**
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. Please switch to the equivalent definition in MonitorChartV2.
     */
    export interface Metric {
        /**
         * Resource information about the resource to which this metric belongs.
         */
        resourceMetadata: ResourceMetadata;
        /**
         * The non-localized metric name.
         */
        name: string;
        /**
         * The aggregation type to use for this metric.
         */
        aggregationType?: AggregationType;
        /**
         * The time grain to use for this metric.
         */
        timeGrainMs?: number;
        /**
         * The unit of this metric.
         */
        unit?: Unit;
        /**
         * The type of this metric.
         *
         * This propery should be used when dealing with resource types that have subcontainers (e.g. Storage Accounts or Virtual Machines).
         */
        type?: string;
        /**
         * Css class to apply to this metric series.
         *
         * This css class should be one of the built in msportalfx-bgcolor-* colors.
         *
         * @see https://github.com/Azure/portaldocs/blob/334634c8a7601f729c4ee6fa673eb00d25045c60/portal-sdk/generated/portalfx-style-guide-color-palette.md#coloring-to-differentiate-data
         * @see https://df.onecloud.azure-test.net/?SamplesExtension=true#blade/SamplesExtension/SDKMenuBlade/styleguidecolorpalettetitle
         */
        cssClass?: string;
    }
    /**
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. Please switch to the equivalent definition in MonitorChartV2.
     */
    export interface ChartDefinition {
        /**
         * The metrics to plot on this chart.
         */
        metrics: Metric[];
        /**
         * The visualization to use for this chart.
         *
         * Defaults to line chart.
         */
        chartType?: ChartType;
        /**
         * The timespan to use for this chart.
         *
         * Note: This overrides the top-level timespan provided in the Options object.
         */
        timespan?: Timespan;
        /**
         * The title of this chart.
         *
         * Defaults to a string generated from the metrics plotted on this chart.
         */
        title?: string;
        /**
         * The subtitle of this chart.
         *
         * Defaults to a string generated from the resources plotted on this chart.
         */
        subtitle?: string;
        /**
         * Message to display if no data can be loaded for this chart.
         */
        noDataMessage?: string;
        /**
         * Disables pinning for this chart.
         */
        disablePinning?: boolean;
        /**
         * Callback that's executed when the user clicks this chart while
         * the chart is functioning normally.
         *
         * Defaults to opening the Metrics blade.
         */
        onClick?: () => void;
        /**
         * Css class to apply to this chart.
         *
         * Multiple css classes can be added by separating them with a space.
         */
        cssClass?: string;
        /**
         * Aria label for the chart.
         *
         * Defaults to "Resource metrics" if not set.
         */
        ariaLabel?: string;
    }
    /**
     * MonitorChart options.
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. References to this control will be redirected to MonitorChartV2. This control will be removed in the future, please switch to MonitorChartV2.
     */
    export interface Options {
        /**
         * The charts to render.
         */
        charts?: ChartDefinition[] | KnockoutObservableArray<ChartDefinition>;
        /**
         * The timespan used for all charts, unless overriden in an individual chart.
         *
         * Defaults to relative duration of 24 hours.
         */
        timespan?: Timespan | KnockoutObservableBase<Timespan>;
    }
    /**
     * MonitorChart control.
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. References to this control will be redirected to MonitorChartV2. This control will be removed in the future, please switch to MonitorChartV2.
     */
    export interface Contract {
        /**
         * The charts rendered.
         */
        readonly charts: KnockoutObservableArray<ChartDefinition>;
        /**
         * The timespan used for all charts, unless overriden in an individual chart.
         */
        readonly timespan: KnockoutObservableBase<Timespan>;
    }
    /**
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. References to this control will be redirected to MonitorChartV2. This control will be removed in the future, please switch to MonitorChartV2.
     */
    export const create: Obsolete;
    /**
     * @deprecated MonitorChart control has been replaced by MonitorChartV2. References to this control will be redirected to MonitorChartV2. This control will be removed in the future, please switch to MonitorChartV2.
     */
    export module Internal {
        interface BladeManagementApiContainer extends MsPortalFx.ViewModels.BladeManagement, MsPortalFx.Base.LifetimeManager {
        }
        interface TelemetryData {
            constructorStartTimestamp: number;
            constructorEndTimestamp: number;
            /**
             * Indicating the initiall load performance is already logged.
             * Note: The extension author can put the whole control within a ko, and setting the ko to false will result in the whole control widget get removed.
             * And later when ko set to true again, the widget will get initialize again without calling the constuctor in the viewmodel.
             */
            firstWidgetLoad: KnockoutObservable<boolean>;
        }
        /**
         * Internal viewmodel used for monitor charts.
         * @deprecated MonitorChart control has been replaced by MonitorChartV2. References to this control will be redirected to MonitorChartV2. This control will be removed in the future, please switch to MonitorChartV2.
         */
        class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
            /**
             * Charts property that stores the charts array provided by the consumer of this control and
             * is **not** proxied across to the widget.
             *
             * This is to prevent the Javascript array provided by the consumer from being frozen
             * by the PO layer.
             */
            charts: KnockoutObservableArray<ChartDefinition>;
            /**
             * Charts property that mirrors the charts property and **is proxied** to the widget.
             */
            _msPortalFxCharts: KnockoutObservableBase<ChartDefinition[]>;
            /**
             * Timespan property that stores the timespan provided by the consumer of this control and
             * is **not** proxied across to the widget.
             *
             * This is to prevent the Javascript array provided by the consumer from being frozen
             * by the PO layer.
             */
            timespan: KnockoutObservableBase<Timespan>;
            /**
             * Timespan property that mirrors the timespan property and **is proxied** to the widget.
             */
            _msPortalFxTimespan: KnockoutObservableBase<Timespan>;
            /**
             * Data to pass to the widget for perf telemetry logging.
             */
            telemetryData: TelemetryData;
            /**
             * Returns true when this part is hosted in a dashboard.
             */
            readonly isPartOnDashboard: boolean;
            private _container;
            constructor(container: BladeManagementApiContainer, options?: Options);
            /**
             * Allows the MonitorChart widget to open a blade when it's clicked.
             *
             * This openBlade api exists in the ViewModel because the widget does not have the container context on
             * which this control resides (which is important so the shell knows whether to open a blade in a journey
             * or to start a new journey).
             */
            openBlade(bladeReference: FxImpl.Composition.Selectable.BladeReference<any>, options?: MsPortalFx.ViewModels.OpenBladeOptions): Q.Promise<boolean>;
        }
    }
}

// FILE: Fx\Controls\MonitorChartV2.d.ts
declare module "Fx/Controls/MonitorChartV2" {
    import { BladeReference } from "Fx/Composition";
    import { AnyContainer } from "Fx/Composition/ViewModelBase";
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     *  Describes the ARM resource whose metric is being plotted on the chart.
     */
    export interface ResourceMetadata {
        /**
         * The ARM resource id of the resource.
         */
        id: string;
        /**
         * The resource kind of the resource.
         * This is optional and makes fetching the resource faster.
         * When this is not specified it is fetched from ARM and populated.
         */
        kind?: string;
        /**
         * The sku of the resource.
         * These optional features makes fetching the resource faster.
         * When this is not specified it is fetched from ARM and populated.
         */
        sku?: {
            /**
             * The sku name.
             */
            name?: string;
            /**
             * The sku tier.
             */
            tier?: string;
            /**
             * The sku size.
             */
            size?: string;
            /**
             * The sku family.
             */
            family?: string;
            /**
             * The sku model.
             */
            model?: string;
            /**
             * The sku capacity.
             */
            capacity?: string;
        };
    }
    /**
     *  Describes the scope of the metric is being plotted on the chart.
     *  Use Scope when creating a chart with cross-resource queries.
     */
    export interface CrossResourceMetadata {
        /**
         * The subscription to query metrics for.
         */
        subscription: Pick<MsPortalFx.Azure.Subscription, "subscriptionId" | "uniqueDisplayName">;
        /**
         * The resource type to query metric for.
         * For example, "microsoft.compute/virtualmachines" or "microsoft.keyvault/vault"
         */
        resourceType: string;
        /**
         * The region in which to query the resource type.
         * For example, "westus2"
         */
        region: string;
    }
    /**
     * This namespace contains types related to a threshold line to be plotted on the metric on chart.
     */
    export namespace Threshold {
        /**
         * Describes the properties of a threshold line on the metric plotted on chart.
         */
        interface Options {
            /**
             * The identifier for the threshold.
             * Each threshold on a metric has a unique identifier.
             * The id can also be used to identify and access a threshold from `Metric.Threshold` array.
             * If not provided a default one is created.
             */
            id?: string;
            /**
             * The upper bound of the threshold line. Defaults to 0.
             */
            upperThreshold?: number | KnockoutObservableBase<number>;
            /**
             * The lower bound of the threshold. Defaults to 0.
             */
            lowerThreshold?: number | KnockoutObservableBase<number>;
            /**
             * Boolean to indicate if the threshold appears as a locked line on chart
             * or a moveable line to change values. The threshold line is always locked on dashboards.
             */
            isLocked?: boolean;
        }
        /**
         * Returned from `MonitorChartV2.Threshold.create`. Represents a threshold line for a metric plotted on the chart.
         */
        interface Contract {
            /**
             * The identifier for the threshold.
             * Each threshold on a metric has a unique identifier.
             * The id can also be used to identify and access a threshold from `Metric.Threshold` array.
             * If not provided a default one is created.
             */
            readonly id: string;
            /**
             * The upper bound of the threshold line.
             */
            readonly upperThreshold: KnockoutObservableBase<number>;
            /**
             * The lower bound of the threshold line.
             */
            readonly lowerThreshold: KnockoutObservableBase<number>;
        }
        /**
         * Creates a new `Threshold.Contract` from the provided `Threshold.Options`.
         * @param lifetime The lifetime object.
         * @param options The `Threshold.Options` object.
         * @returns A `Threshold.Contract` object.
         */
        function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    }
    /**
     * This namespace contains types related to a metric being plotted on the chart
     */
    export namespace Metric {
        /**
         * Aggregation to use for the metric values
         */
        const enum AggregationType {
            /**
             * No aggregation. Invalid value.
             */
            None = 0,
            /**
             * Sum of metric values per bucket.
             */
            Sum = 1,
            /**
             * Minimum of metric values per bucket.
             */
            Min = 2,
            /**
             * Maximum of metric values per bucket.
             */
            Max = 3,
            /**
             * Average of metric values per bucket.
             */
            Avg = 4,
            /**
             * Unique count of metric values per bucket.
             */
            Unique = 5,
            /**
             * 90th Percentile of metric values per bucket.
             */
            Percentile = 6,
            /**
             * Count of metric values per bucket.
             */
            Count = 7
        }
        /**
         * Visualization options related to a metric on the chart
         */
        interface Visualization {
            /**
             * The localized metric display name to be displayed on the chart.
             * When not specified the metric id is used to display on the chart.
             */
            displayName?: string;
            /**
             * The localized resource display name to be displayed on the chart
             * When not specified the ARM resource name is displayed on the chart.
             */
            resourceDisplayName?: string;
            /**
             * Color of the metric when plotted on the chart, in hexadecimal format (e.g. #c7f1c7).
             * NOTE: Make sure the colors work in dark and light themes.
             * When unspecified, chart chooses a random color.
             */
            color?: string;
        }
        /**
         * Options for creating a metric.
         */
        interface Options {
            /**
             * Information that identifies the resource to which the metric belongs.
             */
            resourceMetadata: ResourceMetadata | CrossResourceMetadata;
            /**
             * The name of the metric.
             */
            name: string;
            /**
             * The aggregation type to use for this metric.
             */
            aggregationType: AggregationType | KnockoutObservableBase<AggregationType>;
            /**
             * Additional information to use when determining the correct metrics provider.
             * This is required when making a cross-resource query and using a Scope as the resourceMetadata.
             * For example, VM providers need to use this, because they can have multiple providers for
             * one VM resource (i.e. Host and Guest metrics).
             * This is only needed for certain providers and not all.
             * When not specified, chart uses a fixed default for each metric type.
             */
            namespace?: string;
            /**
             * Visualization options for the metric.
             * Defaults to a fixed visualization options on all metrics.
             */
            metricVisualization?: Visualization | KnockoutObservableBase<Visualization>;
            /**
             * Threshold options for the metric.
             * This is used to place threshold lines on the chart for the metric.
             * When not specified, there are no threshold lines placed on the chart.
             */
            thresholds?: Threshold.Options[];
        }
        /**
         * Returned from `MonitorChartV2.Metric.create` call. Contract object for the metric.
         */
        interface Contract {
            /**
             * Information that identifies the resource to which the metric belongs.
             */
            readonly resourceMetadata: ResourceMetadata | CrossResourceMetadata;
            /**
             * Name of the metric. This can be used to uniquely identify the metric, inside a chart's Metric array.
             */
            readonly name: string;
            /**
             * The aggregation type to use for this metric.
             */
            readonly aggregationType: KnockoutObservableBase<AggregationType>;
            /**
             * Additional information to use when determining the correct metrics provider.
             * For example, VM providers need to use this, because they can have multiple providers for
             * one VM resource (i.e. Host and Guest metrics).
             * This is only needed for certain providers and not all
             * When not specified, chart uses a fixed default for each metric type.
             */
            readonly namespace?: string;
            /**
             * Visualization options for the metric.
             */
            readonly metricVisualization: KnockoutObservableBase<Visualization>;
            /**
             * Threshold options for the metric. This is used to place threshold lines on the chart
             * for the metric
             */
            readonly thresholds: KnockoutObservableArray<Threshold.Contract>;
        }
        /**
         * Creates a `Metric.Contract` for the `Metric.Options` provided by callers.
         * Use this `Metric.Contract` object to later manipulate the `MonitorChartV2.charts().metrics` array.
         *
         * @param lifetime The lifetime object. Use the lifetime associated with MonitorChart control here.
         * @param options The `Metric.Options` object for the metric.
         * @returns A `Metric.Contract` object.
         */
        function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    }
    /**
     *  Sort order when fetching the groups/segments
     */
    export const enum SortOrder {
        /**
         * No specific sort-order requested.
         */
        Unsorted = 0,
        /**
         * The groups returned are sorted in increasing order by value of individual group
         */
        Ascending = 1,
        /**
         * The groups returned are sorted in decreasing order by value of individual group
         */
        Descending = 2
    }
    /**
     * Describes the grouping/segmentation of the metric on the chart.
     */
    export interface Grouping {
        /**
         * The dimension to group against.
         */
        dimension: string;
        /**
         * the number of dimensions to fetch when grouped, default is 10.
         */
        top?: number;
        /**
         * Order of the groups fetched, default is descending
         */
        sort?: SortOrder;
    }
    /**
     * A collection of all the filters on the chart.
     */
    export interface FilterCollection {
        /**
         * Array containing all the Filters applied to the chart.
         */
        filters: Filter[];
    }
    /**
     * Operators for filter comparisons.
     */
    export const enum FilterComparisonOperator {
        Equal = 0,
        NotEqual = 1,
        Contains = 2,
        StartsWith = 3
    }
    /**
     * Describes an individual filter which can be added to the FilterCollection of the chart.
     */
    export interface Filter {
        /**
         * The dimension key for the filter.
         */
        key: string;
        /**
         * Filter operator to be applied to the values (= or )
         * Defaults to equal.
         */
        operator?: FilterComparisonOperator;
        /**
         * The set of values for the key we want to filter against.
         */
        values: string[];
    }
    /**
     * Time range over which data points are fetched and plotted.
     */
    export interface TimeRange {
        /**
         * The start of the time range.
         */
        startTime: Date;
        /**
         * The end of the time range.
         */
        endTime: Date;
    }
    /**
     * Supported grains that can be applied on a timespan for the chart.
     */
    export const enum Grain {
        /**
         * Chart chooses an automatic grain to display.
         */
        Automatic = 1,
        /**
         * Grain to set to per minute over the given time range.
         */
        Minutely = 2,
        /**
         * Grain to set to per hour over the given time range.
         */
        Hourly = 3,
        /**
         * Grain to set to per day over the given time range.
         */
        Daily = 4,
        /**
         * Grain to set to per week over the given time range.
         */
        Weekly = 5,
        /**
         * Grain to set to per month over the given time range.
         */
        Monthly = 6,
        /**
         * Grain to set to every 5 minutes over the given time range.
         */
        Every_5_Minutes = 7,
        /**
         * Grain to set to every 15 minutes over the given time range.
         */
        Every_15_Minutes = 8,
        /**
         * Grain to set to every 30 minutes over the given time range.
         */
        Every_30_Minutes = 9,
        /**
         * Grain to set to every 6 hours over the given time range.
         */
        Every_6_Hours = 10,
        /**
         * Grain to set to every 12 hours over the given time range.
         */
        Every_12_Hours = 11
    }
    /**
     * Timespan signifies the absolute or relative time range for which the chart displays the data.
     */
    export interface Timespan {
        /**
         * The absolute time range of the chart's timespan.
         * If this is not present relative duration is used.
         * If neither of absolute or relative is specified, chart defaults to past 24 hours time range.
         */
        absolute?: TimeRange;
        /**
         * The related duration for the chart's timespan.
         * If this is not present absolute duration is used.
         * If neither of absolute or relative is specified, chart defaults to past 24 hours time range.
         */
        relative?: {
            duration: number;
        };
        /**
         * The grain of the time context.
         * Defaults to a fixed grain with respect to the timespan.
         */
        grain?: Grain;
        /**
         * Set to true to display time as UTC on the chart
         * Defaults to using local time.
         */
        showUTCTime?: boolean;
    }
    /**
     * Represents the visual elements of a chart.
     */
    export interface VisualizationContract {
        /**
         * The type of chart to be used. Defaults to a line chart.
         */
        readonly chartType: KnockoutObservableBase<ChartType>;
        /**
         * Options related to how the legend should be displayed.
         * Defaults to a fixed legend visualization with legends on bottom.
         */
        readonly legendVisualization: KnockoutObservableBase<LegendVisualization>;
        /**
         * Options related to how the axis should be displayed.
         * Defaults to a fixed axis visualization.
         */
        readonly axisVisualization: KnockoutObservableBase<AxisVisualization>;
        /**
         * Indicates whether users can pin this chart to their dashboard.
         * Defaults to false and pin button is always shown.
         */
        readonly disablePinning: KnockoutObservableBase<boolean>;
        /**
         * Indicates whether users have a toolbar item to directly go to alerts blade to configure alert for the metrics on this chart.
         * Defaults to false and alert toolbar button is hidden.
         */
        readonly enableAlertToolbar: KnockoutObservableBase<boolean>;
    }
    /**
     * Represents the visual elements of a chart.
     */
    export interface Visualization {
        /**
         * The type of chart to be used. Defaults to a line chart.
         */
        chartType?: ChartType | KnockoutObservableBase<ChartType>;
        /**
         * Options related to how the legend should be displayed.
         * Defaults to a fixed legend visualization with legends on bottom.
         */
        legendVisualization?: LegendVisualization | KnockoutObservableBase<LegendVisualization>;
        /**
         * Options related to how the axis should be displayed.
         * Defaults to a fixed axis visualization.
         */
        axisVisualization?: AxisVisualization | KnockoutObservableBase<AxisVisualization>;
        /**
         * Indicates whether users can pin this chart to their dashboard.
         * Defaults to false and pin button is always shown.
         */
        disablePinning?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates whether users have a toolbar item to directly go to alerts blade to configure alert for the metrics on this chart.
         * Defaults to false and alert toolbar button is hidden.
         */
        enableAlertToolbar?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * List of supported chart types.
     */
    export const enum ChartType {
        /**
         * Bar Chart.
         */
        Bar = 1,
        /**
         * Line Chart.
         */
        Line = 2,
        /**
         * Area Chart.
         */
        Area = 3,
        /**
         * Scatter plot chart.
         */
        Scatter = 4
    }
    /**
     * Represents how to display a chart's axis.
     */
    export interface AxisVisualization {
        /**
         * x-axis visualization options.
         */
        x?: IndividualAxisVisualization;
        /**
         * y-axis visualization options.
         */
        y: IndividualAxisVisualization;
    }
    /**
     * Visualization options for a particular axis.
     */
    export interface IndividualAxisVisualization {
        /**
         * Determines if the axis is visible on the chart or hidden.
         */
        isVisible: boolean;
        /**
         * Defines the smallest value shown for the axis.
         * Defaults to '0' for numeric axis and start timespan for date axis.
         */
        min?: number;
        /**
         * Defines the largest value shown for the axis.
         * Defaults to maximum data value of the plotted data for numeric axis and end timespan for date axis.
         */
        max?: number;
    }
    /**
     * List of relative positions to place legend.
     */
    export const enum LegendPosition {
        /**
         * Legends placed on bottom of chart.
         */
        Bottom = 2,
        /**
         * Legends placed on right of chart.
         */
        Right = 4
    }
    /**
     * Represents how to style a chart's legend.
     */
    export interface LegendVisualization {
        /**
         * Controls if the legend is visible or hidden on the chart.
         */
        isVisible: boolean;
        /**
         * Controls the position of legend with respect to the chart.
         * Default is to position on bottom of chart.
         */
        position?: LegendPosition;
    }
    /**
     * Indicating create Blade reference event type.
     */
    export enum CreateBladeReferenceEvent {
        OnPin = 0,
        OnClick = 1
    }
    /**
     * Options for how the MonitorChart reacts to a click.
     */
    export interface OpenBladeOptions {
        /**
         * Set to false to disable chart click behavior. Default to 'true'
         */
        openBlade?: boolean;
        /**
         * A function invoked both when the Chart is clicked and when the Chart is pinned to a Dashboard.
         * Must return a BladeReference that doesn't include any functions (like any 'onClosed' callback function).
         *
         * @param event An indication of why the BladeReference is being created.
         * @return A blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        createBladeReference?: (event: CreateBladeReferenceEvent) => BladeReference<any>;
    }
    /**
     * MonitorChartV2 title kind.
     */
    export const enum TitleKind {
        /** no title */
        None = 0,
        /** title is automatically generated */
        Auto = 1,
        /** title is customized */
        Custom = 2
    }
    /**
     * MonitorChartV2 options.
     */
    export interface Options {
        /**
         * The list of metrics to plot on this chart.
         */
        metrics: Metric.Options[];
        /**
         * The filters to apply on the chart for all metrics.
         * If not specified, data isn't filtered.
         */
        filterCollection?: FilterCollection | KnockoutObservableBase<FilterCollection>;
        /**
         * Specify the grouping to segment the chart against.
         * If not specified chart is not segmented.
         */
        grouping?: Grouping | KnockoutObservableBase<Grouping>;
        /**
         * Controls the display properties of chart.
         */
        visualization?: Visualization;
        /**
         * Title for the chart. Defaults to no title.
         */
        title?: string | KnockoutObservableBase<string>;
        /**
         * Specifies the kind of title to be displayed.
         * Defaults to 'Custom' if 'title' is supplied. Otherwise, defaults to 'None'.
         */
        titleKind?: TitleKind | KnockoutObservableBase<TitleKind>;
        /**
         * The timespan used for the MonitorChartV2
         * Defaults to past 24 hours.
         */
        timespan?: Timespan | KnockoutObservableBase<Timespan>;
        /**
         * Aria label for the MonitorChartV2. Defaults to "MonitorChartV2"
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Control blade to open when chart is clicked.
         * When omitted, click chart will navigate to metric blade for editing the chart.
         */
        openBladeOnClick?: OpenBladeOptions | KnockoutObservableBase<OpenBladeOptions>;
    }
    /**
     * MonitorChartV2 control.
     */
    export interface Contract extends Control {
        /**
         * The list of metrics to plot on this chart.
         */
        readonly metrics: KnockoutObservableArray<Metric.Contract>;
        /**
         * The filters applied on all metrics on this chart.
         */
        readonly filterCollection: KnockoutObservableBase<FilterCollection>;
        /**
         * Specifies the grouping the chart is segmented against.
         */
        readonly grouping: KnockoutObservableBase<Grouping>;
        /**
         * Controls the display properties of chart.
         */
        readonly visualization: VisualizationContract;
        /**
         * Title for the chart.
         */
        readonly title: KnockoutObservableBase<string>;
        /**
         * Specifies the kind of title to be displayed.
         * Defaults to 'Custom' if 'title' is supplied. Otherwise, defaults to 'None'.
         */
        readonly titleKind: KnockoutObservableBase<TitleKind>;
        /**
         * The timespan used for the chart.
         */
        readonly timespan: KnockoutObservableBase<Timespan>;
        /**
         * Aria label for the MonitorChartV2.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Control blade to navigate to when chart is clicked.
         * When omitted, click chart will navigate to metric blade for editing the chart.
         */
        readonly openBladeOnClick: KnockoutObservableBase<OpenBladeOptions>;
        /**
         * Metrics data provider.
         * Used to fetch filter dimensions and their values.
         */
        readonly metricsDataProvider: Q.Promise<MetricsDataProvider>;
    }
    /**
     * Creates a MonitorChartV2 viewModel.
     *
     *  @param container The container of the control. This must be a container object.
     *  @param options Options that modify the appearance and behavior of the control.
     *
     *  @returns a MonitorChartV2 viewModel.
     */
    export function create(container: AnyContainer, options?: Options): Contract;
    /**
     * Metrics filter dimension name.
     */
    export interface FilterName {
        /**
         * Unique identifier for filter dimension.
         */
        id: string;
        /**
         * The localized display name for filter dimension.
         */
        displayName?: string;
    }
    /**
     * Metrics filter dimension
     */
    export interface DimensionDefinition {
        /**
         * The name for the dimension.
         */
        dimensionName: FilterName;
        /**
         * Description for the dimension.
         */
        description?: string;
        /**
         * List of operators supported by this dimension".
         * Note: default is Equals and Not Equals.
         */
        supportedOperators?: FilterComparisonOperator[];
        /**
         * List of operators not supporting multiselect
         */
        multiSelectNonSupportedOpList?: FilterComparisonOperator[];
    }
    /**
     * Metrics Chart data providers.
     */
    export interface MetricsDataProvider {
        /**
         * Get all filter attributes for a set of metrics.
         * @param metrics Metrics to fetch filters for
         */
        getFilterAttributes(metrics: Metric.Options[]): Q.Promise<DimensionDefinition[]>;
        /**
         * Get values for a filter.
         * @param metrics Metrics to fetch filter values for
         * @param filterId Filter attribute to fetch values for
         * @param timespan Timespan for values query
         */
        getFilterValues(metrics: Metric.Options[], filterId: string, timespan: Timespan): Q.Promise<string[]>;
    }
}

// FILE: Fx\Controls\MultiLineTextBox.d.ts
declare module "Fx/Controls/MultiLineTextBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Events on which vlue of the control can be updated
     */
    export import ValueUpdateTrigger = FormBase.ValueUpdateTrigger;
    /**
     * Options for configuring a multiline textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * the number of lines in the control.
         */
        rows?: number | KnockoutObservableBase<number>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Controls when the control will update it's value in response to the user typing into it.
         */
        valueUpdateTrigger?: ValueUpdateTrigger;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Enable the control to be spellcheck. Default as false
         * (Warning. Perf hit. Do not enable this for a huge text).
         */
        spellcheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the Enter + Shift key.
         */
        onEnterPressed?: (value: string) => void;
    }
    /**
     * Multiline textbox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * the number of lines in the control.
         */
        readonly rows: KnockoutObservableBase<number>;
        /**
         * Enable the MultiLintTextBox to be spellcheck.
         * (Warning. Perf hit. Do not enable this for a huge text).
         */
        readonly spellcheck: KnockoutObservableBase<boolean>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a mulitline textbox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a multiline textbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\NumericTextBox.d.ts
declare module "Fx/Controls/NumericTextBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Events on which vlue of the control can be updated
     */
    export import ValueUpdateTrigger = FormBase.ValueUpdateTrigger;
    /**
     * Options for configuring a numeric textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * Minimum number allowed.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum number allowed.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        decimalPoint?: number | KnockoutObservableBase<number>;
        /**
         * Text to display when entered text is not numeric.
         */
        notANumberErrorMessage?: string;
        /**
         * Specifies whether an empty value should be allowed or if it should be replaced with a 0 value.  Defaults to false.
         */
        allowEmpty?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Controls when the control will update it's value in response to the user typing into it.
         */
        valueUpdateTrigger?: ValueUpdateTrigger;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number | KnockoutObservableBase<number>;
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: number) => void;
    }
    /**
     * Numeric TextBox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number>;
        /**
         * Minimum number allowed.
         */
        readonly min: KnockoutObservableBase<number>;
        /**
         * Maximum number allowed.
         */
        readonly max: KnockoutObservableBase<number>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        readonly decimalPoint: KnockoutObservableBase<number>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a Numeric TextBox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a numeric textbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\OAuthButton.d.ts
declare module "Fx/Controls/OAuthButton" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Options {
        /**
         * Aria label for the OAuthButton.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText?: string | KnockoutObservableBase<string>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight?: number;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth?: number;
        /**
         * Request url used to pop up the OAuth window.  Note: When registering app with provider (e.g., github) you need to specify Authorization callback URL: https://portal.azure.com/TokenAuthorize
         * e.g. for github it is https://github.com/login/oauth/authorize?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&state=<RANDOM_STRING>
         */
        requestUrl?: string | KnockoutObservableBase<string>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Called when authentication is successful.
         * value is a string in the form of "https://portal.azure.com/TokenAuthorize?code=abcd12345678abcdef12"
         */
        onAuthenticationSucceeded: (value: string) => void;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Contract extends FormBase.Contract {
        /**
         * Request url used to pop up the OAuth window.  Note: When registering app with provider (e.g., github) you need to specify Authorization callback URL: https://portal.azure.com/TokenAuthorize
         * e.g. for github it is https://github.com/login/oauth/authorize?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&state=<RANDOM_STRING>
         */
        requestUrl: KnockoutObservableBase<string>;
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText: KnockoutObservableBase<string>;
    }
    /**
     * Creates an OAuth button control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns an OAuth button control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\OptionsGroup.d.ts
declare module "Fx/Controls/OptionsGroup" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Item<TValue> {
        text: string;
        value: TValue;
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Optional alternate text for screen readers if the text is not explicit enough.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    /**
     * Options for configuring a options group control
     */
    export interface Options<TValue> {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If true, sets each item to equal width and the total size of the control to the size of the element.
         * Otherwise, sets the width of each item in the options group to the size of the content. Defaults to false.
         */
        uniformItemWidth?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The list of items of the options group
         */
        items?: Array<Item<TValue>> | KnockoutObservableArray<Item<TValue>>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: TValue | KnockoutObservableBase<TValue>;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * ItemPicker control view model
     */
    export interface Contract<TValue> extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * The list of items of the options group
         */
        readonly items: KnockoutObservableArray<Item<TValue>>;
    }
    /**
     * Creates a options group control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns an options group control viewmodel
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\PairedTimeline.d.ts
declare module "Fx/Controls/PairedTimeline" {
    import * as PairedTimelineBadges from "Fx/Controls/PairedTimelineBadges";
    import * as RangeSelection from "Fx/Controls/RangeSelection";
    import Controls = MsPortalFx.ViewModels.Controls;
    import Visualization = Controls.Visualization;
    import Chart = Visualization.Chart;
    import Metrics = Visualization.Metrics;
    import Loadable = Controls.Loadable;
    export const enum SelectionMode {
        /**
         * Indicates that the user can select one item at at time by clicking.
         */
        Single = 0,
        /**
         * Indicates that the user can select and unselect multiple items at at time by clicking and control-clicking.
         */
        Multiple = 1
    }
    export interface SelectableOptions {
        /**
         * Indicates selection mode or single or multiple selection (default Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Gets or sets the selected item for single selection backward compatibility.
         */
        selectedItem?: KnockoutObservable<any>;
        /**
         * Gets or sets the selected items.
         */
        selection?: MsPortalFx.ViewModels.SelectableSet<any, any>;
        /**
         * Indicates that the item should activate when selected (default true).
         */
        activateOnSelected?: boolean;
    }
    /**
     * Extension options
     */
    export interface ExtensionOptions {
        /**
         * Selection options.
         */
        selectable?: SelectableOptions;
    }
    /**
     * Contract container for the Chart and Metrics controls
     */
    export interface PairedTimelineChartContract<TX, TY> extends Loadable.Contract {
        /**
         * Identifier of chart
         */
        id: string;
        /**
         * Chart control contract
         */
        chart: Chart.Contract<TX, TY>;
        /**
         * Chart height in number of units(integer). Each unit is 45 px.
         */
        chartHeight: KnockoutObservableBase<number>;
        /**
         * The message to display when chart is un-configured or there is no chart data.
         */
        noDataMessage: KnockoutObservableBase<string>;
        /**
         * CSS class to be applied to the List View item
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * Selectable for the buttons in the PT
         */
        buttonSelectables: MsPortalFx.ViewModels.Selectable<string>[];
        /**
         * The title for the chart.
         */
        title: KnockoutObservableBase<string>;
        /**
         * Whether or not the title is shown.
         */
        showTitle: KnockoutObservableBase<boolean>;
    }
    /**
     * Container for the Chart and Metrics controls
     */
    export class PairedTimelineChart<TX, TY> extends Loadable.ViewModel implements PairedTimelineChartContract<TX, TY> {
        /**
         * Identifier of chart
         */
        id: string;
        /**
         * Chart control
         */
        chart: Chart.ViewModel<TX, TY>;
        /**
         * Chart height in number of units(integer). Each unit is 45 px.
         */
        chartHeight: KnockoutObservableBase<number>;
        /**
         * The message to display when the chart is un-configured or there is no chart data.
         */
        noDataMessage: KnockoutObservableBase<string>;
        /**
         * CSS class to be applied to the List View item
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * Selectable for the buttons in the PT
         */
        buttonSelectables: MsPortalFx.ViewModels.Selectable<string>[];
        /**
         * The title for the chart.
         */
        title: KnockoutObservableBase<string>;
        /**
         * Whether or not the title is shown.
         * Title will only be shown for >1 chart height charts.
         */
        showTitle: KnockoutObservableBase<boolean>;
        /**
         * Creates a paired timeline.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param id Id of this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, id: string);
        dispose(): void;
    }
    export const enum PairedTimelineButtonVisibilityOptions {
        ShowOnHover = 1,
        AlwaysShow = 2
    }
    export interface PairedTimelineButtonOptions {
        /**
         * Whether the Edit buttons should be shown.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Text to use for the edit button, default is "Edit"
         */
        text: KnockoutObservableBase<string>;
        /**
         * Controls the visibility of the buttons. (always vs onhover)
         */
        visibility: KnockoutObservableBase<PairedTimelineButtonVisibilityOptions>;
    }
    export interface Contract<TX, TY> extends Loadable.Contract {
        /**
         * The collection of Paired Timeline charts.
         */
        ptCharts: KnockoutObservableArray<PairedTimelineChart<TX, TY>>;
        /**
         * Options used to configure the loaded plugins for selection.
         * Updating this property after the widget is initialized will have no effect.
         * A null or undefined value disables selection.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Enable metrics rules.
         */
        enableMetricsRules: KnockoutObservableBase<boolean>;
        /**
         * Metrics options
         */
        metricsOptions: Metrics.VisualContract;
        /**
         * Enables sliders to select a range on the x axis.
         */
        enableRangeSelection: KnockoutObservableBase<boolean>;
        /**
         * Range selection view model.
         */
        rangeSelectionViewModel: RangeSelection.ViewModel<TX>;
        /**
         * Options for the buttons defined in the PT.
         */
        buttonOptions: PairedTimelineButtonOptions[];
        /**
         * Badges View model
         */
        badgesViewModel: PairedTimelineBadges.ViewModel<TX>;
    }
    export class ViewModel<TX, TY> extends Loadable.ViewModel implements Contract<TX, TY> {
        /**
         * The collection of Paired Timeline charts.
         */
        ptCharts: KnockoutObservableArray<PairedTimelineChart<TX, TY>>;
        /**
         * Options used to configure the loaded plugins for selection.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Enable Metrics Rules
         */
        enableMetricsRules: KnockoutObservableBase<boolean>;
        /**
         * MetricsOptions
         */
        metricsOptions: Metrics.VisualContract;
        /**
         * Enables sliders to select a range on the x axis.
         */
        enableRangeSelection: KnockoutObservableBase<boolean>;
        /**
         * Range selection view model.
         */
        rangeSelectionViewModel: RangeSelection.ViewModel<TX>;
        /**
         * Badges View model
         */
        badgesViewModel: PairedTimelineBadges.ViewModel<TX>;
        /**
         * Options for the buttons defined in the PT.
         */
        buttonOptions: PairedTimelineButtonOptions[];
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, ptCharts: KnockoutObservableArray<PairedTimelineChart<TX, TY>>, extensionOptions: ExtensionOptions, rangeSelectionOptions?: RangeSelection.Options<TX>, pairedTimelineBadgesOptions?: PairedTimelineBadges.Options<TX>);
    }
}

// FILE: Fx\Controls\PairedTimelineBadges.d.ts
declare module "Fx/Controls/PairedTimelineBadges" {
    import DockedBalloon = MsPortalFx.ViewModels.Controls.DockedBalloon;
    import FxViewModelsControlsBase = MsPortalFx.ViewModels.Controls.Base;
    /**
     * Contract for an individual displayable badge.
     */
    export interface BadgeContract<TX> {
        /**
         * Badge Identifier
         */
        id: string;
        /**
         * Unique class name for this badge.
         */
        className: KnockoutObservableBase<string>;
        /**
         * The badge text
         */
        text: string;
        /**
         * The x value corresponding to the event this badge is reporting.
         */
        xValue: TX;
        /**
         * The coordinate where the badge is rendered.
         */
        coordinate?: KnockoutObservableBase<number>;
        /**
         * The icon to display for the badge.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * Whether the badge is displayed.
         */
        visible?: KnockoutObservableBase<boolean>;
    }
    /**
     * Class for an individual Badge.
     */
    export class Badge<TX> extends FxViewModelsControlsBase.ViewModel implements BadgeContract<TX> {
        /**
         * Badge Identifier
         */
        id: string;
        /**
         * Unique class name for this badge.
         */
        className: KnockoutObservableBase<string>;
        /**
         * The badge text
         */
        text: string;
        /**
         * The x value corresponding to the event this badge is reporting.
         */
        xValue: TX;
        /**
         * The icon to display for the badge.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * Whether the badge is displayed.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * The coordinate where the badge is rendered.
         */
        coordinate: KnockoutObservableBase<number>;
        /**
         * Creates a paired timeline.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param id Id of this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: BadgeContract<TX>);
    }
    export interface Options<TX> {
        /**
         * The collection of badges
         */
        badges: KnockoutObservableArray<BadgeContract<TX>>;
        /**
         * Height of the badges when displayed on the paired timeline
         */
        height: KnockoutObservableBase<number>;
        /**
         * Balloon for displaying badge information.
         */
        balloon: KnockoutObservableBase<DockedBalloon.ViewModel>;
        /**
         * Enables badges that will be displayed at top of paired timeline
         */
        visible: KnockoutObservableBase<boolean>;
    }
    export class ViewModel<TX> extends FxViewModelsControlsBase.ViewModel {
        /**
         * The collection of badges
         */
        badges: KnockoutObservableArray<BadgeContract<TX>>;
        /**
         * Height of the badges when displayed on the paired timeline
         */
        height: KnockoutObservableBase<number>;
        /**
         * Balloon for displaying badge information.
         */
        balloon: KnockoutObservableBase<DockedBalloon.ViewModel>;
        /**
         * Enables badges that will be displayed at top of paired timeline
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * An optional selectableSet to make the badges selectable
         */
        selectableSet: KnockoutObservableBase<MsPortalFx.ViewModels.SelectableSet<any, any>>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<TX>);
        /**
         * Set the viewmodel's array of badges to the incoming badges. Optionally set up a selectableSet on these badges with the given callbacks.
         */
        pushAllBadges(newBadges: BadgeContract<TX>[], useSelectableSet?: boolean, itemMatchesSelection?: (item: BadgeContract<TX>, selection: any) => boolean, createSelection?: (item: BadgeContract<TX>) => any): void;
    }
}

// FILE: Fx\Controls\PasswordBox.d.ts
declare module "Fx/Controls/PasswordBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a password textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Shows validation as a popup.
         */
        showValidationsAsPopup?: boolean;
        /**
         * Aria label for the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: string) => void;
    }
    /**
     * Password box control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a password box control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a password box control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Pill.d.ts
declare module "Fx/Controls/Pill" {
    import { BladeLink, ResourceLink } from "Fx/Composition";
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import * as Dialog from "Fx/Composition/Dialog";
    import { Image } from "Fx/Images";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Common edit contract properties.
     */
    export interface Editor {
        /**
         * The editor will render this content in edit mode.
         */
        content: Control | HtmlContent;
    }
    /**
     * Inline editor.
     *
     * @deprecated InlineEditor<T> has been deprecated. Please migrate to dialog editor or custom editor for this scenario.
     */
    export interface InlineEditor<T> extends Editor {
        /**
         * Callback function called when the editMode is ended.
         *
         * @returns new value for the pill.
         */
        onEditModeExited: () => T | Q.Promise<T>;
    }
    /**
     * Dialog editor.
     */
    export interface DialogEditor<T> extends Editor {
        /**
         * Dialog title.
         */
        title: string | KnockoutObservableBase<string>;
        /**
         * Callback function called when the editMode is ended.
         * @param result Obtained dialog result by clicking a dialog button or dismiss the dialog. When the user clicks outside of the dialog, the dialog will be dismissed and will return DialogButton.Cancel.
         *
         * @returns new value for the pill.
         */
        onEditModeExited: (result: Dialog.DialogButton) => T | Q.Promise<T>;
        /**
         * Buttons used for the dialog.
         */
        buttons: Dialog.CustomDialogButton[] | Dialog.DialogButtons;
        /**
         * Optional telemetry name that is used when the show dialog telemetry is logged
         */
        telemetryName?: string;
    }
    /**
     * Custom editor.
     */
    export interface CustomEditor {
        /**
         * Clickable invoked when the pill is clicked.
         * It supports a traditional callback, or a blade-reference based clickable.
         * The author has responsibility to manage the pill value to make changes.
         */
        onClick: Function | BladeLink | ResourceLink;
    }
    /**
     * Options for configuring a pill control.
     */
    export interface Options<T> {
        /**
         * A function that generates the displaying text for key.
         */
        getKeyText: (value: T) => string;
        /**
         * A function that generates the displaying text for operator.
         */
        getOperatorText?: (value: T) => string;
        /**
         * A function that generates the displaying text for value.
         */
        getValueText: (value: T) => string;
        /**
         * The initial value of the pill.
         */
        value: T | KnockoutObservableBase<T>;
        /**
         * When the user clicks the pill the enter edit mode, this callback will be called to create editing controls.
         * The 'editorLifetime' reflects the time in edit mode and should be used when instantiating the control view models.
         */
        createEditor: (editorLifetime: MsPortalFx.Base.DisposableLifetimeManager) => InlineEditor<T> | DialogEditor<T> | CustomEditor | Q.Promise<InlineEditor<T>> | Q.Promise<DialogEditor<T>> | Q.Promise<CustomEditor>;
        /**
         * Callback that fires when the pill is removed.
         */
        onRemoved?: (value: T) => void;
        /**
         * Show a remove button to allow users to remove the pill.
         */
        showRemoveButton?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show an icon on the left side of the pill.
         */
        icon?: Image | KnockoutObservableBase<Image>;
        /**
         * Enable "readOnly" mode that removes editable behavior from the pill.
         */
        readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates that whether the pill is in edit mode or not.
         */
        editMode?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sanitized html string shown in the info balloon popup in readonly mode.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Tooltip to show on hover in readOnly mode.
         *
         * tooltip property is obsoleted. Please use infoBalloonContent property for specifying the tooltip.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        tooltip?: Obsolete;
        /**
         * If true then this pill will not trigger the unsaved changes dialog, even after the user makes changes.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Aria label for pill.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Pill's disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Pill control contract.
     */
    export interface Contract<T> extends Control {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<T>;
        /**
         * Show a remove button to allow users to remove the pill.
         */
        readonly showRemoveButton: KnockoutObservableBase<boolean>;
        /**
         * Show an icon on the left side of the pill.
         */
        readonly icon: KnockoutObservableBase<Image>;
        /**
         * Enable "readOnly" mode that removes editable behavior from the pill.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Indicates that whether the pill is in edit mode or not.
         */
        readonly editMode: KnockoutObservableBase<boolean>;
        /**
         * Sanitized html string shown in the info balloon popup in readonly mode.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * Tooltip to show on hover in readOnly mode.
         *
         * tooltip property is obsoleted. Please use infoBalloonContent property for specifying the tooltip.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        readonly tooltip: KnockoutObservableBase<Obsolete>;
        /**
         * Aria label for pill.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Pill's disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a pill control with inline edit mode contract.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a Pill contract
     */
    export function create<T>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<T>): Contract<T>;
}

// FILE: Fx\Controls\PillCollection.d.ts
declare module "Fx/Controls/PillCollection" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import * as Pill from "Fx/Controls/Pill";
    import { FxElement } from "Fx/Events";
    import { Image } from "Fx/Images";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export const enum Theme {
        /**
         * Theme for filters (default).
         */
        Filter = 1,
        /**
         * Theme for tags.
         */
        Tag = 2
    }
    /**
     * Options for configuring a pill collection control.
     */
    export interface Options {
        /**
         * The initial set of pills in the collection.
         */
        items: Pill.Contract<any>[] | KnockoutObservableArray<Pill.Contract<any>>;
        /**
         * Options for "add pill" button.
         */
        addition?: AdditionOptions;
        /**
         * Aria label for pill collection.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Pill collection's disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Pill collection's theme.
         */
        theme?: Theme;
        /**
         * Max number of items of pill to show.
         */
        maxVisibleItems?: number;
        /**
         * Show pills in multiple rows or truncate them when they exceeds a single row.
         */
        multipleRows?: boolean;
    }
    /**
     * Options for "add pill" button.
     */
    export interface AdditionOptions {
        /**
         * Enable the "add pill" button.
         */
        canAddPill?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Set this true to always show label or label will be hidden, if there is any items.
         */
        alwaysShowLabel?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon for "add pill" button. If not given, default icon will be used.
         */
        icon?: Image | KnockoutObservableBase<Image>;
        /**
         * Label for "add pill" button.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for "add pill" button.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * A function called when the user clicks "add pill" button.
         * Returns a pill viewModel that will be added to "items".
         * If nothing is returned, this callback becomes like simple onClick handler and the author has responsibility to manage the pill collection items to make changes.
         *
         * @param target The target FxElement of the "add pill" button.
         */
        addPill?: (target: FxElement) => Pill.Contract<any> | void;
    }
    export interface Addition {
        /**
         * Enable the "add pill" button.
         */
        readonly canAddPill: KnockoutObservableBase<boolean>;
        /**
         * Set this true to always show label or label will be hidden, if there is any items.
         */
        readonly alwaysShowLabel: KnockoutObservableBase<boolean>;
        /**
         * Icon for "add pill" button. If not given, default icon will be used.
         */
        readonly icon: KnockoutObservableBase<Image>;
        /**
         * Label for "add pill" button.
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for "add pill" button.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    export interface Contract extends Control {
        /**
         * The set of pills in the collection.
         */
        readonly items: KnockoutObservableArray<Pill.Contract<any>>;
        /**
         * Options for "add pill" button.
         */
        readonly addition: Addition;
        /**
         * Aria label for pill collection.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Pill collection's disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates an Pill collection control contract.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a Pill collection contract
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\PricingControl.d.ts
declare module "Fx/Controls/PricingControl" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Options<TValue> {
        /**
         * Text of the Pricing control.
         */
        text?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * SubText of the Pricing control.
         */
        subText?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Barcolor in HEX.
         * If your color is not accessible in dark theme. You can use `.ext-pricing-control-border` in your css to add themeable colors instead of this.
         *
         * Example:
         *   .ext-pricing-control-border { border-color: blue }
         *   .ext-dark-mode .ext-pricing-control-border { border-color: red }
         */
        barColor?: string | KnockoutObservableBase<string>;
        /**
         * Link text.
         */
        linkText?: string | KnockoutObservableBase<string>;
        /**
         * Callback for when link is clicked.
         */
        onLinkClick?: Function;
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * The value of the control.
         */
        value?: TValue | KnockoutObservableBase<TValue>;
        /**
         * Indicates that the control is in a loading state.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * PricingControl view model
     */
    export interface Contract<TValue> extends FormBase.Contract {
        /**
         * Text of the Pricing control.
         */
        readonly text: KnockoutObservableBase<string | HtmlContent>;
        /**
         * SubText of the Pricing control.
         */
        readonly subText: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Color of the Pricing control. Must be valid Hexadecimal.
         * Default is Green.
         */
        readonly barColor: KnockoutObservableBase<string>;
        /**
         * Link text.
         */
        readonly linkText: KnockoutObservableBase<string>;
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * Indicates that the control is in a loading state.
         */
        readonly loading: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates an  Pricing Control view model.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the Pricing Control.
     *
     * @returns an Pricing Control viewmodel.
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\ProgressBar.d.ts
declare module "Fx/Controls/ProgressBar" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Status type of progress indicators
     */
    export const enum StatusType {
        /**
         * In progress style.
         */
        InProgress = 0,
        /**
         * Error style.
         */
        Error = 1,
        /**
         * Warning style.
         */
        Warning = 2,
        /**
         * Success style.
         */
        Success = 3,
        /**
         * Indeterminate style.
         */
        Indeterminate = 4
    }
    export interface Options {
        /**
         * Value percentage of the current progress.
         */
        valuePercentage?: number | KnockoutObservableBase<number>;
        /**
         * Status of the progress indicator.
         */
        status?: StatusType | KnockoutObservableBase<StatusType>;
        /**
         * Text for screen reader to describe this progressbar
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Contract extends Control {
        /**
         * Value percentage of the current progress.
         */
        readonly valuePercentage: KnockoutObservableBase<number>;
        /**
         * Status of the progress indicator.
         */
        readonly status: KnockoutObservableBase<StatusType>;
        /**
         * Text for screen reader to describe this progressbar
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a ProgressBar control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a ProgressBar viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\QuotaGauge.d.ts
declare module "Fx/Controls/QuotaGauge" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Warning shape.
     */
    export const enum ErrorWarningShape {
        /**
         * Default triangle warning/error.
         */
        Triangle = 0,
        /**
         * Circle warning/error.
         */
        Circle = 1
    }
    /**
     * Built-in sizes for QuotaGauge control.
     */
    export const enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determined by Min(width, height).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyLarge = 3,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 4,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 5,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 6,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 7
    }
    /**
     * Options for configuring a QuotaGauge control.
     */
    export interface Options {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle the css style for warning/error. True for triangle or false for circle.
         */
        errorWarningShape?: ErrorWarningShape | KnockoutObservableBase<ErrorWarningShape>;
        /**
         * Gauge Size for display.
         */
        gaugeSize?: GaugeSize | KnockoutObservableBase<GaugeSize>;
        /**
         * The current tracking instance value. For example, CPU/Memory/Website instance.
         */
        instance?: number | KnockoutObservableBase<number>;
        /**
         * The quota for current instance.
         */
        instanceQuota?: number | KnockoutObservableBase<number>;
        /**
         * The total value of all instances. For example, all CPU/Memory/Websites usage.
         */
        total?: number | KnockoutObservableBase<number>;
        /**
         * The quota for total value of all instances.
         */
        totalQuota?: number | KnockoutObservableBase<number>;
        /**
         * Show center content.
         */
        showCenter?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Omit Total bar.
         */
        omitTotal?: boolean | KnockoutObservableBase<boolean>;
        /**
         * No quota verification.
         */
        noQuota?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum?: number | KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset?: number | KnockoutObservableBase<number>;
        /**
         *  Center text unit.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * Total caption value display formatter. The following formatter arguments will be substituted with respective values when displaying the total caption,
         *  {0} is instance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         */
        totalCaptionFormat?: string | KnockoutObservableBase<string>;
        /**
         * Center Text value display format. The following formatter arguments will be substituted with respective values when displaying the center text,
         *  {0} is instance value
         *  {1} is instance Quota,
         *  {2} is total
         *  {3} is total Quota
         *  {4} is maximum
         */
        valueDisplayFormat?: string | KnockoutObservableBase<string>;
        /**
         * Hide the current tick mark.
         */
        hideTick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * QuotaGauge control view model contract.
     */
    export interface Contract extends Control {
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle the css style for warning/error. True for triangle or false for circle.
         */
        readonly errorWarningShape: KnockoutObservableBase<ErrorWarningShape>;
        /**
         * Gauge Size for display.
         */
        readonly gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * The current tracking instance value. For example, CPU/Memory/Website instance.
         */
        readonly instance: KnockoutObservableBase<number>;
        /**
         * The quota for current instance.
         */
        readonly instanceQuota: KnockoutObservableBase<number>;
        /**
         * The total value of all instances. For example, all CPU/Memory/Websites usage.
         */
        readonly total: KnockoutObservableBase<number>;
        /**
         * The quota for total value of all instances.
         */
        readonly totalQuota: KnockoutObservableBase<number>;
        /**
         * Total caption value display formatter. The following formatter arguments will be substituted with respective values when displaying the total caption,
         *  {0} is instance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         */
        readonly totalCaption: KnockoutObservableBase<string>;
        /**
         * Show center content.
         */
        readonly showCenter: KnockoutObservableBase<boolean>;
        /**
         * Omit Total bar.
         */
        readonly omitTotal: KnockoutObservableBase<boolean>;
        /**
         * No quota verification.
         */
        readonly noQuota: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        readonly maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        readonly startOffset: KnockoutObservableBase<number>;
        /**
         *  Center text unit.
         */
        readonly unit: KnockoutObservableBase<string>;
        /**
         * Center Text value display format. The following formatter arguments will be substituted with respective values when displaying the center text,
         *  {0} is instance value
         *  {1} is instance Quota,
         *  {2} is total
         *  {3} is total Quota
         *  {4} is maximum
         */
        readonly valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Hide the current tick mark.
         */
        readonly hideTick: KnockoutObservableBase<boolean>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * Creates a QuotaGauge control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a QuotaGauge control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\RadioButtons.d.ts
declare module "Fx/Controls/RadioButtons" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Item<TValue> {
        text: string | HtmlContent;
        value: TValue;
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Optional alternate text for screen readers if the text is not explicit enough.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    /**
     * Options for configuring a radio button control
     */
    export interface Options<TValue> {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, each button will each appear on their own line.  Defaults to false.
         */
        singleItemPerLine?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The list of items of the radio buttons
         */
        items?: Array<Item<TValue>> | KnockoutObservableArray<Item<TValue>>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: TValue | KnockoutObservableBase<TValue>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * RadioButtons control view model
     */
    export interface Contract<TValue> extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * The list of items of the radio button
         */
        readonly items: KnockoutObservableArray<Item<TValue>>;
    }
    /**
     * Creates a radio buttons control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a radio buttons control viewmodel
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\RangeSelection.d.ts
declare module "Fx/Controls/RangeSelection" {
    import FxControls = MsPortalFx.ViewModels.Controls;
    export const enum LabelPosition {
        /**
         * Range selection labels will be oriented on the inside of the selection range
         */
        Inside = 0,
        /**
         * Range selection labels will be oriented on the outside of the selection range
         */
        Outside = 1
    }
    export interface Range<T> {
        /**
         * The beginning of the range selection.  May be null to indicate open beginning of range.
         */
        start: T;
        /**
         * The end of the range selection.  May be null to indicate open ended range.
         */
        end: T;
    }
    export interface Options<T> {
        /**
         * Specifies position of range selection labels.
         */
        labelPosition?: KnockoutObservableBase<LabelPosition>;
        /**
         * The range selected if enableRangeSelection was enabled.
         */
        rangeSelection?: KnockoutObservableBase<Range<T>>;
    }
    export class ViewModel<T> extends FxControls.Base.ViewModel {
        /**
         * Specifies position of range selection labels.
         */
        labelPosition: KnockoutObservableBase<LabelPosition>;
        /**
         * The range selected if enableRangeSelection was enabled.
         */
        rangeSelection: KnockoutObservableBase<Range<T>>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<T>);
    }
}

// FILE: Fx\Controls\RangeSlider.d.ts
declare module "Fx/Controls/RangeSlider" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import { SliderLegends } from "Fx/Controls/Slider";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a range slider control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria label of the control, for screen reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Legends for the slider.
         */
        legends?: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        hideTextbox?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Options for configuring a simple range slider control
     */
    export interface SimpleRangeSliderOptions extends Options {
        /**
         * Minimum value of the range slider.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum value of the range slider.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the range slider takes between min and max.
         */
        step?: number | KnockoutObservableBase<number>;
    }
    /**
     * Options for configuring a custom range slider control
     */
    export interface CustomRangeSliderOptions extends Options {
        /**
         * Custom range slider clickstop values.
         */
        customValues: Array<number> | KnockoutObservableBase<Array<number>>;
    }
    /**
     * RangeSlider control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * Start value of the range.
         */
        readonly start: KnockoutObservableBase<number>;
        /**
         * End value of the range.
         */
        readonly end: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        readonly showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Legends for the slider.
         */
        readonly legends: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        readonly hideTextbox: KnockoutObservableBase<boolean>;
    }
    /**
     * RangeSlider control view model for simple values
     */
    export interface SimpleRangeSliderContract extends Contract {
        /**
         * Minimum value of the range slider.
         */
        readonly min: KnockoutObservableBase<number>;
        /**
         * Maximum value of the range slider.
         */
        readonly max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the range slider takes between min and max.
         */
        readonly step: KnockoutObservableBase<number>;
    }
    /**
     * RangeSlider control view model for custom values
     */
    export interface CustomRangeSliderContract extends Contract {
        /**
         * Custom slider clickstop values.
         */
        readonly customValues: KnockoutObservableBase<number[]>;
    }
    /**
     * Creates a range slider control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a range slider control viewmodel
     */
    export function createSimpleRangeSlider(lifetime: MsPortalFx.Base.LifetimeManager, options?: SimpleRangeSliderOptions): SimpleRangeSliderContract;
    /**
     * Creates a range slider control viewmodel with custom values.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a range slider control viewmodel
     */
    export function createCustomRangeSlider(lifetime: MsPortalFx.Base.LifetimeManager, options: CustomRangeSliderOptions): CustomRangeSliderContract;
}

// FILE: Fx\Controls\Recommendations.d.ts
declare module "Fx/Controls/Recommendations" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options supplied to the Recommendations control.
     */
    export interface Options {
        /**
         * The ARM resource id.
         */
        readonly resourceId: string;
    }
    /**
     *  View model contract for the Recommendations control.
     */
    export interface Contract extends Control {
        /**
         * The total number of recommendations.
         */
        readonly totalRecommendationCount: KnockoutReadOnlyObservableBase<number>;
    }
    /**
     * Creates a Recommendations view model.
     *
     *  @param lifetime The lifetime of the control.
     *  @param options Options that modify the appearance and behavior of the control.
     *
     *  @returns a Recommendations view model.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\ResourceGroupDropDown.d.ts
declare module "Fx/Controls/ResourceGroupDropDown" {
    import { ResourceGroup as BaseResourceGroup, Validation as BaseValidation } from "Fx/Controls/BaseResourceDropDown";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    /**
     * The modes possible for the dropdown
     */
    export import Mode = BaseResourceGroup.Mode;
    /**
     * The mode of the value returned by the control
     */
    export import SelectedMode = BaseResourceGroup.SelectedMode;
    /**
     * The contract for the values returned by the resource group dropdown
     * It contains the ARM Value and a flag for if you are in create mode
     */
    export import Value = BaseResourceGroup.Value;
    /**
     * The validation type accepted by the dropdown
     */
    export type Validation = BaseValidation<Value>;
    /**
     * The contract for options to create the resource group drop down
     */
    export type Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseResourceGroup.Options<THtmlKeyMap>;
    /**
     * The contract for the resource group dropdown
     */
    export interface Contract extends BaseResourceGroup.Contract {
    }
    /**
     * This creates a resource group dropdown control.
     * @param container The container associated with the part or blade.
     * @param options The resource group dropdown options. See interface
     */
    export function create<THtmlKeyMap extends StringMap<HtmlContent>>(container: AnyBladeContainer, options: Options<THtmlKeyMap>): Contract;
}

// FILE: Fx\Controls\ScatterChart.d.ts
declare module "Fx/Controls/ScatterChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export { FxChartColorClass };
    /**
     * This base interface defines the how a series should be rendered on the chart.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Defines the radius of circles.
         * By default 2px radius will be used to show the data point circle.
         */
        readonly radius?: number;
        /**
         * Indicates if the series is selectable.
         * By default, the data point circle is selectable and selectable styling is shown. To disallow selecting the data point circle, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the data point is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Indicates if the series is hidden from the legend
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Users can optionally provide event handler callbacks for all or subset of events.
     */
    export interface ChartEvents<TX, TY> {
        /**
         * Event handler for mouse click on the plot area.
         *
         * Event callback.
         * @param x The pixel value of x coordinate
         * @param y The pixel value of y coordinate.
         * @param xValue The x axis value at the x coordinate.
         * @param yValue The y axis value at the y coordinate.
         */
        readonly plotAreaClick?: (x: number, y: number, xValue: TX, yValue: TY) => void;
        /**
         * Event handler for click on a point.
         *
         * Event callback.
         * @param data EventData with clicked seriesName and the x, y value to the clicked point.
         */
        readonly pointClick?: (data: EventData<TX, TY>) => void;
    }
    /**
     * Options for configuring a ScatterChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the scatter chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * ScatterChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the scatter chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @return A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Q.Promise;
    }
    /**
     * Creates a ScatterChart control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a ScatterChart control viewmodel
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\SearchBox.d.ts
declare module "Fx/Controls/SearchBox" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options for configuring a SearchBox control
     */
    export interface Options {
        /**
         * The default placeholder text.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * The delay after you finish typing to trigger the update callback in milliseconds.  Defaults to 400 ms
         */
        valueUpdateTimeout?: number;
        /**
         * The update callback.  Called when the user types in entries (after they stop typing for the duration of valueUpdateTimeout)
         * value is the value typed in by the user
         * returns the values shown in the dropdown
         */
        update?: (value: string) => Q.Promise<string[]>;
        /**
         * The submit callback.  Called when the user selects an item, or hits enter.
         * value is the value of the selected item
         * typedValue is the value that the user typed in (this will match value when the user hits enter)
         * returns a promise that when resolved will take the control out of the busy state
         */
        submit?: (value: string, typedValue: string) => Q.Promise<boolean>;
        /**
         * Disabled state of the search box.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Hide suggestion box.
         */
        hideSuggestions?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria label for search box.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Maximum number of results shown.  Defaults to 5.
         */
        resultLimit?: number | KnockoutObservableBase<number>;
    }
    /**
     * SearchBox control view model
     */
    export interface Contract extends Control {
        /**
         * The placeholder text that is shown when the user has not entered a value.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * Disabled state of the search box.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Hide suggestion box.
         */
        readonly hideSuggestions: KnockoutObservableBase<boolean>;
        /**
         * Aria label for search box.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Maximum number of results shown.
         */
        readonly resultLimit: KnockoutObservableBase<number>;
        /**
         * Programmatically updates the internal SearchBox value as if the end-user typed it in.
         * This triggers updates and/or submits callbacks.
         */
        updateValue(newValue: string): void;
        /**
         * A helper function for that removes all items, closes dropdown & clears textbox.
         * @return A promise that is resolved when the reset has been completed.
         */
        reset(): Q.Promise<void>;
    }
    /**
     * Creates a SearchBox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a SearchBox viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Section.d.ts
declare module "Fx/Controls/Section" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a form section
     */
    export interface Options {
        /**
         * The name of the section.
         * Can be an HTML template and optional view model. See HtmlContent interface in Fx/Controls/ControlsBase
         * This will be displayed as a tab header if the section is inside a tab control.
         *
         * To track telemetry across locales, please use telemetryName for a consistent identifier.
         */
        name?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sections, controls & HtmlContent to nest within the section.
         */
        children?: any[] | KnockoutObservableArray<any>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The minimum height of the section in pixels.  Use this to reduce jumpiness in forms.
         */
        minHeight?: number;
        /**
         * Labels will appear to the left of child controls when this is set to true.
         * Labels are set to the size of the largest label in a consecutive set (unless leftLabelWidth is set).
         *
         * If smartAlignLabels is set to true, this has no effect.
         */
        leftLabelPosition?: boolean;
        /**
         * The width of the left label in px.
         * Setting this property implies leftLabelPosition = true.
         *
         * If smartAlignLabels is set to true, this has no effect.
         */
        leftLabelWidth?: number;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Align labels by available size of the blade. (left or above the control).
         */
        smartAlignLabel?: boolean;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        telemetryName?: string;
    }
    /**
     * Section view model
     */
    export interface Contract extends Control {
        /**
         * The sections, controls & HtmlContent to nest within the section.
         */
        readonly children: KnockoutObservableArray<any>;
        /**
         * Changes the section state to disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The dirty state of the control.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The name of the section.
         * Can be an HTML template and optional view model. See HtmlContent interface in Fx/Controls/ControlsBase
         * This will be displayed as a tab header if the section is inside a tab control.
         *
         * To track telemetry across locales, please use telemetryName for a consistent identifier.
         */
        readonly name: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The validation state of the control.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * A custom css class to apply to the section.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        readonly telemetryName: KnockoutObservableBase<string>;
        /**
         * Triggers validation on all child elements.
         */
        readonly triggerValidation: () => Q.Promise<boolean>;
    }
    /**
     * Creates a section view model
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\SingleMetric.d.ts
declare module "Fx/Controls/SingleMetric" {
    import { HatchingPattern as Pattern } from "Fx/Controls/ChartBase";
    import { Contract as InfoBalloonContract } from "Fx/Controls/InfoBalloon";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export { Pattern };
    export { FxChartColorClass };
    export const enum Alignment {
        /**
         * Top edge for vertical alignment.
         */
        Top = 1,
        /**
         * Left edge for horizontal alignment.
         */
        Left = 2,
        /**
         * Right edge for horizontal alignment.
         */
        Right = 4,
        /**
         * Bottom edge for vertical alignment.
         */
        Bottom = 8
    }
    export interface Options {
        /**
         * The value of the metric.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The unit for the metric.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * The caption for the metric.
         */
        caption?: string | KnockoutObservableBase<string>;
        /**
         * The info balloon for the metric.
         */
        infoBalloon?: InfoBalloonContract | KnockoutObservableBase<InfoBalloonContract>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass?: string | FxChartColorClass | KnockoutObservableBase<string | FxChartColorClass>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern?: Pattern | KnockoutObservableBase<Pattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        captionAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * The visibility of the single metric.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface Contract {
        /**
         * The value of the metric.
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The unit for the metric.
         */
        readonly unit: KnockoutObservableBase<string>;
        /**
         * The caption for the metric.
         */
        readonly caption: KnockoutObservableBase<string>;
        /**
         * The info balloon for the metric.
         */
        readonly infoBalloon: KnockoutObservableBase<InfoBalloonContract>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        readonly hideInfoBalloon: KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        readonly barCssClass: KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        readonly showBarColor: KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        readonly hatchingPattern: KnockoutObservableBase<Pattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        readonly unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        readonly captionAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The visibility of the single metric.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        readonly prioritized: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates a SingleMetric viewmodel which will be used in Metrics viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a SingleMetric viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\SingleValueGauge.d.ts
declare module "Fx/Controls/SingleValueGauge" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Built-in sizes for SingleValueGauge control.
     */
    export const enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determined by Min(width, hight).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only
         */
        CenterOnlyLarge = 3,
        /**
         * Icon 21px square size of donut shape gauge with center.
         */
        Icon = 4,
        /**
         * Tiny 30px square size of donut shape gauge with center.
         */
        Tiny = 5,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 6,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 7,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 8,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 9
    }
    /**
     * Options for configuring a SingleValueGauge control.
     */
    export interface Options {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        gaugeSize?: GaugeSize | KnockoutObservableBase<GaugeSize>;
        /**
         * Hide the current tick mark.
         */
        hideTick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum?: number | KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset?: number | KnockoutObservableBase<number>;
        /**
         * Center text unit.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * Current value.
         */
        current?: number | KnockoutObservableBase<number>;
        /**
         * Formatter for displaying caption value. The following formatter arguments will be substituted with respective values when displaying the caption value,
         *  {0} is current
         */
        captionDisplayFormat?: string | KnockoutObservableBase<string>;
        /**
         * Formatter for displaying center value. The following formatter arguments will be substituted with respective values when displaying the center value,
         *  {0} is current
         */
        valueDisplayFormat?: string | KnockoutObservableBase<string>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * SingleValueGauge control view model contract.
     */
    export interface Contract extends Control {
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        readonly gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * Hide the current tick mark.
         */
        readonly hideTick: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        readonly maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        readonly startOffset: KnockoutObservableBase<number>;
        /**
         * Center text unit.
         */
        readonly unit: KnockoutObservableBase<string>;
        /**
         * Current value.
         */
        readonly current: KnockoutObservableBase<number>;
        /**
         * Formatter for displaying caption value. The following formatter arguments will be substituted with respective values when displaying the caption value,
         *  {0} is current
         */
        readonly captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Formatter for displaying center value. The following formatter arguments will be substituted with respective values when displaying the center value,
         *  {0} is current
         */
        readonly valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * Creates a SingleValueGauge control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a SingleValueGauge control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Slider.d.ts
declare module "Fx/Controls/Slider" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a slider control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria label of the control, for screen reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number | KnockoutObservableBase<number>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Legends for the slider.
         */
        legends?: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        hideTextbox?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Options for configuring the slider control with simple values
     */
    export interface SimpleSliderOptions extends Options {
        /**
         * Minimum value of the slider.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step?: number | KnockoutObservableBase<number>;
    }
    /**
     * Options for configuring the slider control with custom values
     */
    export interface CustomSliderOptions extends Options {
        /**
         * Custom slider clickstop values.
         */
        customValues: number[] | KnockoutObservableBase<number[]>;
    }
    /**
     * Legend for Slider
     */
    export interface SliderLegends {
        /**
         * The labels for the slider.
         */
        labels: SliderLabel[];
        /**
         * Label to show when the value is active.
         */
        activeValueLabel: (value: number) => string;
        /**
         * Sublabel to show when the value is active.
         */
        activeValueSublabel?: (value: number) => string;
    }
    /**
     * Label for Slider
     */
    export interface SliderLabel {
        /**
         * The value of the slider to map.
         */
        value: number;
        /**
         * The label for the corresponding slider value.
         */
        label: string;
    }
    /**
     * Slider control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        readonly showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Legends for the slider.
         */
        readonly legends: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        readonly hideTextbox: KnockoutObservableBase<boolean>;
    }
    /**
     * Slider control view model for simple values
     */
    export interface SimpleSliderContract extends Contract {
        /**
         * Minimum value of the range slider.
         */
        readonly min: KnockoutObservableBase<number>;
        /**
         * Maximum value of the range slider.
         */
        readonly max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the range slider takes between min and max.
         */
        readonly step: KnockoutObservableBase<number>;
    }
    /**
     * Slider control view model for custom values
     */
    export interface CustomSliderContract extends Contract {
        /**
         * Custom slider clickstop values.
         */
        readonly customValues: KnockoutObservableBase<number[]>;
    }
    /**
     * Creates a slider control viewmodel with simple values.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a slider control viewmodel
     */
    export function createSimpleSlider(lifetime: MsPortalFx.Base.LifetimeManager, options?: SimpleSliderOptions): SimpleSliderContract;
    /**
     * Creates a slider control viewmodel with custom values.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a slider control viewmodel
     */
    export function createCustomSlider(lifetime: MsPortalFx.Base.LifetimeManager, options: CustomSliderOptions): CustomSliderContract;
}

// FILE: Fx\Controls\Splitter.d.ts
declare module "Fx/Controls/Splitter" {
    import { Control } from "Fx/Controls/ControlsBase";
    export const enum Panes {
        Primary = 0,
        Secondary = 1,
        Both = 2
    }
    export interface Options {
        /**
         * The initial size of the primary pane.
         */
        primaryPaneSize?: number;
        /**
         * Controls which panes are visible.  Defaults to Both
         */
        showPanes?: Panes | KnockoutObservableBase<Panes>;
        /**
         * Set to true to change splitter orientation to vertical.  Defaults to false.
         */
        vertical?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Reverses the splitter's flow.  This is mostly used to put the primary pane on the right in order to set a fixed initial width via primaryPaneSize.
         */
        reversed?: boolean;
        /**
         * Minimum pane sizes
         */
        minPaneSizes?: {
            primaryPaneSize: number;
            secondaryPaneSize: number;
        };
        /**
         * Accessibility names for the splitter panes.
         */
        ariaLabels?: {
            /**
             * Accessibility name for the primary pane.
             */
            primaryPane?: string | KnockoutObservableBase<string>;
            /**
             * Accessibility name for the secondary pane.
             */
            secondaryPane?: string | KnockoutObservableBase<string>;
        };
    }
    export interface Contract extends Control {
        /**
         * Controls which panes are visible.  Defaults to Both
         */
        readonly showPanes: KnockoutObservableBase<Panes>;
        /**
         * Set to true to change splitter orientation to vertical.  Defaults to false.
         */
        readonly vertical: KnockoutObservableBase<boolean>;
    }
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Storage\BlobContainerDropDown.d.ts
declare module "Fx/Controls/Storage/BlobContainerDropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Actions user can take using a SAS signature.
     */
    export type AccessPolicyPermissons = "Read" | "Write" | "List" | "Delete" | "Add" | "Create";
    /**
     * The lease state for the given blob container.
     */
    export type LeaseState = "available" | "leased" | "expired" | "breaking" | "broken";
    /**
     * The contract for the values returned by the storage container dropdown.
     */
    export interface Container {
        /**
         * The name of the selected container.
         */
        readonly name: string;
        /**
         * The full URI path to the selected container, including SAS token.
         */
        readonly uri: string;
        /**
         * The lease state of this container.
         */
        readonly leaseState: LeaseState;
    }
    export interface Options {
        /**
         * Required. The ID of the Storage Account for which to pull containers.
         */
        readonly storageAccountId: string | KnockoutObservableBase<string>;
        /**
         * The aria-label for the control.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        readonly label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        readonly subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control
         */
        readonly validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        readonly infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Change the default filter string.
         */
        readonly filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Toggle multiselect on.
         */
        readonly multiSelect?: boolean;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * Enables select all for multiselect.
         */
        readonly selectAll?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        readonly suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Control or view the visible state of this control.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * File share drop down Viewmodel
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the dropdown
         */
        readonly value: KnockoutObservableBase<Container> & KnockoutObservableBase<Container[]>;
        /**
         * The Storage Account ID for which to pull containers.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly storageAccountId: KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Puts the control into a loading state.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText: KnockoutObservableBase<string>;
    }
    export interface GenerateSasUriOptions {
        /**
         * The URI to the specific container
         */
        readonly containerUri: string;
        /**
         * ARM id of the storage account in which this container exists.
         */
        readonly storageAccountId: string;
        /**
         * Set of actions user can take with the generated SASUri.
         */
        readonly accessPolicyPermissions: AccessPolicyPermissons[];
        /**
         * The SAS token will not be valid after this time.
         */
        readonly accessPolicyEndTime: Date;
        /**
         * The SAS token will not be valid until this time.
         */
        readonly accessPolicyStartTime?: Date;
        /**
         * The name of the specified blob in the container to generate a SAS Uri for.
         */
        readonly blobName?: string;
    }
    /**
     * Given a container, generate a URI signed with a SAS (Shared Access Signature) token.
     * Use the options to control permissions and duration of availability for this url.
     *
     * @param options Options that modify the duration and permissions for the SasUri.
     *
     * @return A URI that can be used to access the container with authentication.
     */
    export function generateSasUri(options: GenerateSasUriOptions): Q.Promise<string>;
    /**
     * Creates a container drop down viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a container drop down viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Storage\FileShareDropDown.d.ts
declare module "Fx/Controls/Storage/FileShareDropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The contract for the values returned by the file share dropdown
     */
    export interface FileShare {
        /**
         * The name of the select File Share.
         */
        readonly name: string;
        /**
         * The full URL path to the selected File Share.
         */
        readonly url: string;
    }
    /**
     * Options for configuring the file share drop down.
     */
    export interface Options {
        /**
         * Required. The ID of the Storage Account for which to pull file shares
         */
        storageAccountId: string | KnockoutObservableBase<string>;
        /**
         * The aria-label for the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Change the default filter string.
         */
        filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Toggle multiselect on.
         */
        multiSelect?: boolean;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        multiItemDisplayText?: string | KnockoutObservableBase<string>;
        selectAll?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Control or view the visible state of this control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * File share drop down Viewmodel
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the dropdown
         */
        readonly value: KnockoutObservableBase<FileShare> & KnockoutObservableBase<FileShare[]>;
        /**
         * The Storage Account ID for which to pull file shares.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly storageAccountId: KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Puts the control into a loading state.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText: KnockoutObservableBase<string>;
    }
    /**
     * Creates a file share drop down viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a file share drop down viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Storage\StorageAccountDropDown.d.ts
declare module "Fx/Controls/Storage/StorageAccountDropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The specific type of Storage Account.
     * Used for filtering storage accounts. These values from the Storage Resource Provider.
     */
    export type StorageAccountType = "Premium_LRS" | "Standard_LRS" | "Standard_ZRS" | "Standard_GRS" | "Standard_RAGRS";
    /**
     * The specific kind of Storage Account.
     * Used for filtering storage accounts. These values from the Storage RP.
     */
    export type StorageAccountKind = "Storage" | "StorageV2" | "BlobStorage";
    /**
     * Type for the 'value' property of the StorageAccount DropDown.
     */
    export interface StorageAccount {
        /**
         * ID of the selected storage account.
         */
        readonly id: string;
        /**
         * Name of the storage account. Matches the name in the 'id' property.
         */
        readonly name: string;
        /**
         * Storage account type as in 'StorageAccountType'.
         */
        readonly type: StorageAccountType;
        /**
         * Storage account kind as in 'StorageAccountKind'.
         */
        readonly kind: StorageAccountKind;
        /**
         * Indicates whether the selected storage account exists, or needs to be created by
         * the consumer of the picker.
         */
        readonly isExisting: boolean;
        /**
         * Indicates whether the storage account is a classic storage account.
         */
        readonly isClassic: boolean;
        /**
         * The selected location object.
         */
        readonly location: string;
    }
    export interface CreateOptions {
        /**
         * Indicates whether the location dropdown should be shown.
         * Default is false.
         */
        readonly showLocationDropdown?: boolean;
        /**
         * The default storage account type to select in the create account blade
         * Default is all account types shown.
         */
        readonly defaultStorageAccountType?: string;
    }
    /**
     * Options for configuring the storage account picker.
     */
    export interface Options {
        /**
         * The subscription ID where accounts should be pulled from.
         *
         * If this is not supplied a warning is logged indicating an invalid subscriptionId.
         */
        readonly subscriptionId?: string | KnockoutObservableBase<string>;
        /**
         * Region of the resource in DNS form (e.g. westus).
         *
         * If specified, only storage accounts in this location will be displayed.
         * If not specified, all locations are shown.
         */
        readonly location?: string | KnockoutObservableBase<string>;
        /**
         * Name of the resource group.
         *
         * If specified, only storage accounts in this resource group will be displayed.
         * If not specified, storage accounts from all resource groups will be displayed.
         */
        readonly resourceGroup?: string | KnockoutObservableBase<string>;
        /**
         * If specified, only account types in the list will be shown.
         * Cannot be used at the same time as invalidAccountTypes, filtering will be
         * performed only if one of the two parameters is added.
         *
         * If not specified, (and invalid account types not specified) all accounts types will be shown.
         *
         * See StorageAccountType.
         */
        readonly validAccountTypes?: ReadonlyArray<StorageAccountType> | KnockoutObservableArray<StorageAccountType>;
        /**
         * If specified, all account types except those in the list will be shown.
         * Cannot be used at the same time as validAccountTypes, filtering will be
         * performed only if one of the two parameters is added.
         *
         * If not specified, (and valid account types not specified) all accounts types will be shown.
         *
         * See StorageAccountType.
         */
        readonly invalidAccountTypes?: ReadonlyArray<StorageAccountType> | KnockoutObservableArray<StorageAccountType>;
        /**
         * If specified, only account of the specified kinds will be shown.
         * If not specified, all accounts kinds will be shown.
         *
         * See StorageAccountKind.
         */
        readonly kinds?: ReadonlyArray<StorageAccountKind>;
        /**
         * Indicates whether classic resources should be listed.
         *
         * Defaults to: false
         */
        readonly showClassicResources?: boolean;
        /**
         * Indicates whether ARM resources should be listed.
         *
         * Defaults to: false
         */
        readonly showArmResources?: boolean;
        /**
         * Indicates whether the create new option should be displayed.
         *
         * Defaults to: false
         */
        readonly showCreate?: boolean;
        /**
         * Indicates whether a "none" option should be selectable.
         *
         * Defaults to: false
         */
        readonly hideNoneItem?: boolean;
        /**
         * Create options to pass to the picker.
         *
         * If not specified the create storage account experience will display with no defaults selected.
         */
        readonly createOptions?: CreateOptions;
        /**
         * The aria-label for the control.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        readonly label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        readonly subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        readonly validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        readonly infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Change the default filter string.
         */
        readonly filterPlaceholder?: string;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        readonly suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Control or view the visible state of this control.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Storage Account drop down ViewModel.
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the dropdown.
         */
        readonly value: KnockoutObservableBase<StorageAccount>;
        /**
         * The Subscription Id from which to pull Storage Accounts.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly subscriptionId: KnockoutObservableBase<string>;
        /**
         * The location from which to pull Storage Accounts.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly location: KnockoutObservableBase<string>;
        /**
         * The name of the resourceGroup from which to pull Storage Accounts.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly resourceGroup: KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Puts the control into a loading state.  When in the loading state, the control will be disabled and have the text "Loading..." shown.
         */
        readonly loading: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a storage account drop down viewmodel.
     *
     * @param container The container for the control.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a storage account drop down viewmodel
     */
    export function create(container: AnyBladeContainer, options: Options): Contract;
}

// FILE: Fx\Controls\SubscriptionDropDown.d.ts
declare module "Fx/Controls/SubscriptionDropDown" {
    import { Subscription as BaseSubscription, Validation as BaseValidation } from "Fx/Controls/BaseResourceDropDown";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    /**
     * The contract for the values returned by the subscription dropdown
     */
    export import Subscription = MsPortalFx.Azure.Subscription;
    /**
     * The contract for options to create the subscription drop down
     */
    export type Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseSubscription.Options<THtmlKeyMap>;
    /**
     * The validation type accepted by the dropdown
     */
    export type Validation = BaseValidation<Subscription>;
    /**
     * The contract for the subscription dropdown
     */
    export interface Contract extends BaseSubscription.Contract {
    }
    /**
     * This creates a subscription dropdown control.
     * @param container The container associated with the part or blade.
     * @param options The subscription dropdown options. See interface
     */
    export function create<THtmlKeyMap extends StringMap<HtmlContent>>(container: AnyBladeContainer, options: Options<THtmlKeyMap>): Contract;
}

// FILE: Fx\Controls\Summary.d.ts
declare module "Fx/Controls/Summary" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { ValidationResult } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring an Summary control.
     */
    export interface Options {
        /**
         * The title for the control.
         */
        name?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The children to display within the control.
         */
        children?: Array<Group> | KnockoutObservableArray<Group>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Summary view model
     */
    export interface Contract extends Control {
        /**
         * The title for the control.
         */
        readonly name: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The children to display within the control.
         */
        readonly children: KnockoutObservableArray<Group>;
    }
    /**
     * Creates an Summary control view model.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the summary.
     *
     * @returns an Summary viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
    /**
     * Summary Group.
     *
     * Collection of Items.
     */
    export interface Group {
        /**
         * Label for the item.
         */
        name?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The items to layout inside the Group
         */
        children: Array<Item | HtmlContent> | KnockoutObservableArray<Item | HtmlContent>;
        /**
         * Enables multi column layout. Default is false.
         * Displays a predefined layout with a bolded label, value, and icon.
         */
        isMultiColumn?: boolean;
    }
    /**
     * Summary Item.
     *
     * Label/Value pairs to display in a 2 column layout.
     */
    export interface Item {
        /**
         * Label for the item.
         */
        label: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Item value.
         */
        value: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Show a control's invalid validations.
         *
         * Takes a validationResults array from a control.
         * This array is available on any control which supports validations.
         *
         * If you create a TextBox.
         *      const myTextBoxVm = TextBox.create(container, {options});
         *
         * You can then set this property to myTextBoxVm.validationResults.
         */
        validationResults?: KnockoutReadOnlyObservableArray<ValidationResult>;
        /**
         * Icon that is left of the label/value.
         */
        icon?: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
    }
}

// FILE: Fx\Controls\TabControl.d.ts
declare module "Fx/Controls/TabControl" {
    import { Control } from "Fx/Controls/ControlsBase";
    import { Contract as SectionContract } from "Fx/Controls/Section";
    /**
     * Options for configuring a tab control
     */
    export interface Options {
        /**
         * The section view models containing the contents of each tab.
         */
        tabs?: SectionContract[];
        /**
         * A custom css class to apply to the tab control.
         */
        cssClass?: string;
        /**
         * The minimum height of the tab control in pixels.  Use this to reduce jumpiness in forms.
         */
        minHeight?: number;
        /**
         * Show required asterisks on tab.
         * If there is any required control or section within the tab we show a red '*' on the left of the tab header.
         */
        showRequiredStatusOnTabs?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show validation failure on tab.
         * If there is any invalid control or section within the tab we show a red 'o' on the right of the tab header.
         */
        showValidationStatusOnTabs?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Align labels by available size of the blade. (left or above the control).
         */
        smartAlignLabel?: boolean;
        /**
         * Indicates if tabs are closeable. Adds a 'x' to the tab header.
         */
        allowClosableTabs?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Popup an alert when a tab is closed when dirty.
         */
        alertOnClose?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface TabIndexObservable extends KnockoutReadOnlyObservableBase<number> {
        /**
         * Sets active tab by index.
         * setFocus focuses on the tab header, if focus is within the blade.
         */
        (index: number, setFocus?: boolean): number;
    }
    export interface TabObservable extends KnockoutReadOnlyObservableBase<SectionContract> {
        /**
         * Sets active tab by section.
         * setFocus focuses on the tab header, if focus is within the blade.
         */
        (section: SectionContract, setFocus?: boolean): SectionContract;
    }
    /**
     * Tab control view model
     */
    export interface Contract extends Control {
        /**
         * The section view models containing the contents of each tab.
         */
        readonly tabs: KnockoutObservableArray<SectionContract>;
        /**
         * Gets and sets the currently active tab.
         */
        readonly activeTab: TabObservable;
        /**
         * Gets and sets the currently active tab.
         */
        readonly activeTabIndex: TabIndexObservable;
        /**
         * The dirty state of the control.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Show required asterisks on tab.
         * If there is any required control or section within the tab we show a red '*' on the left of the tab header.
         */
        readonly showRequiredStatusOnTabs: KnockoutObservableBase<boolean>;
        /**
         * Show validation failure on tab.
         * If there is any invalid control or section within the tab we show a red 'o' on the right of the tab header.
         */
        readonly showValidationStatusOnTabs: KnockoutObservableBase<boolean>;
        /**
         * Indicates if tabs are closeable. Adds a 'x' to the tab header.
         */
        readonly allowClosableTabs: KnockoutObservableBase<boolean>;
        /**
         * The validation state of the control.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Popup an alert when a tab is closed when dirty.
         */
        readonly alertOnClose: KnockoutObservableBase<boolean>;
        /**
         * Triggers validation on all child elements.
         */
        readonly triggerValidation: () => Q.Promise<boolean>;
    }
    /**
     * Creates a tab control view model
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\TagsByResource.d.ts
declare module "Fx/Controls/TagsByResource" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options for configuring a TagsByResource control.
     */
    export interface Options {
        /**
         * Initial list of resources with the number of instances.
         */
        readonly resources: ReadonlyArray<TargetItem> | KnockoutObservableArray<TargetItem>;
        /**
         * Optional list of subscriptions for tag suggestion lookups by GUID.
         */
        readonly customSubscriptionIds?: ReadonlyArray<string> | KnockoutObservableArray<string>;
        /**
         * The initial value of the control.
         * If an observable is provided, there will be a 2-way binding set up between the observable and the value of the control.
         */
        readonly value?: ReadonlyArray<TaggedResource> | KnockoutObservableArray<TaggedResource>;
        /**
         * Button commands for tag row in the grid.
         */
        readonly buttonCommands?: ReadonlyArray<Command>;
        /**
         * Menu commands for tag row in the grid.
         */
        readonly menuCommands?: ReadonlyArray<Command>;
        /**
         * Flag to hide the resource column in the tags grid.
         * Default is to show the resource column.
         */
        readonly hideResourceColumn?: boolean | KnockoutObservable<boolean>;
    }
    /**
     * TagsByResource control view model.
     */
    export interface Contract extends Control {
        /**
         * List of resources with the number of instances.
         * This property is read-only. To mutate, change the value of the resources property provided in the TagsByResource options.
         */
        readonly resources: KnockoutReadOnlyObservableArray<TargetItem>;
        /**
         * The set of resources with their associated tags.
         */
        readonly value: KnockoutReadOnlyObservableArray<TaggedResource>;
        /**
         * The EditableGrid dirty state.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * The EditableGrid disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * List of subscriptions used for tag suggestion lookups.
         * This property is read-only. To mutate, change the value of the customSubscriptionIds property provided in the
         * TagsByResource options.
         */
        readonly customSubscriptionIds: KnockoutReadOnlyObservableArray<string>;
        /**
         * The maximum number of tags reached externally state.
         * This property can be set by the caller if the maximum number of tags is reached when merging tags in the
         * control with existing tags on resources external to the editor.
         */
        readonly maxTagsReached: KnockoutObservableBase<boolean>;
        /**
         * Triggers validation on all child elements.
         */
        readonly triggerValidation: () => Q.Promise<boolean>;
        /**
         * Indicates the validation state of the grid.
         * This is the result of the latest validation.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Retrieves the tags for a given resource as a StringMap for the provisioner parameters.
         */
        readonly resourceTagsAsMap: (resource: TargetItem) => ReadonlyStringMap<string>;
    }
    /**
     * The types of items that can be passed to the TagsByResource control through the options object.
     */
    export type TargetItem = TargetResource | TargetResourceType;
    /**
     * Target resource details applied to dropdown.
     * Use the id property for updating deployment template.
     */
    export interface TargetResource {
        /**
         * Resource unique identifier.
         */
        readonly id: string;
        /**
         * Custom display name for target resource.
         */
        readonly displayName: string;
        /**
         * The number of resource instances.
         */
        readonly count: number | KnockoutObservableBase<number>;
    }
    /**
     * Target resource type details applied to dropdown.
     */
    export interface TargetResourceType {
        /**
         * The fully qualified resource type name (e.g., "Microsoft.Web/Sites").
         * Used for retrieving the localized display name.
         * If there is no asset defined in PDL matching this name, the string will be displayed as-is.
         */
        readonly resourceType: string;
        /**
         * The number of resource instances.
         */
        readonly count: number | KnockoutObservableBase<number>;
    }
    /**
     * A single tag item.
     */
    export interface TagItem {
        /**
         * The tag name or key.
         */
        readonly name: string;
        /**
         * The tag value.
         */
        readonly value: string;
    }
    /**
     * Output of user-defined key/value pairs by ID.
     */
    export interface TaggedResource {
        /**
         * The unique identifier for the resource.
         */
        readonly id: string;
        /**
         * Set of key/value pairs used to tag the resource type.
         */
        readonly tags: ReadonlyArray<TagItem>;
    }
    /**
     * Command information for button and menu commands.
     */
    export interface Command {
        /**
         * The label for the command.
         */
        readonly label: string;
        /**
         * The icon for the command.
         */
        readonly icon: MsPortalFx.Base.Image;
        /**
         * The flag which indicates whether the command can execute or not.
         */
        readonly canExecute: KnockoutObservableBase<boolean>;
        /**
         * The callback to execute the command.
         */
        readonly execute: (target: CommandTarget) => Q.Promise<void>;
    }
    /**
     * Target information for the button and menu commands.
     */
    export interface CommandTarget {
        /**
         * The name of the tag.
         */
        readonly name: string;
        /**
         * The value of the tag.
         */
        readonly value: string;
        /**
         * The resources associated with the tag.
         */
        readonly resources: ReadonlyArray<string>;
    }
    /**
     * Creates a TagsByResource control.
     *
     * @param lifetime The lifetime manager for the TagsByResource control.
     * @param options The options for creating the TagsByResource control.
     * @returns The created TagsByResource control.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\TextBlock.d.ts
declare module "Fx/Controls/TextBlock" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options for configuring a TextBlock control
     */
    export interface Options {
        /**
         * Text shown in the TextBlock
         */
        text?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * TextBlock control view model
     */
    export interface Contract extends Control {
        /**
         * Text shown in the TextBlock
         */
        readonly text: KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
    }
    /**
     * Creates a TextBlock control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a TextBlock viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\TextBox.d.ts
declare module "Fx/Controls/TextBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Events on which value of the control can be updated
     */
    export import ValueUpdateTrigger = FormBase.ValueUpdateTrigger;
    /**
     * Options for configuring a TextBox control.
     */
    export interface Options {
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * When set, the TextBox will be read only.
         */
        readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Determines when the control will update it's value in response to the user typing into it.
         */
        valueUpdateTrigger?: ValueUpdateTrigger;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the TextBox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Show validation as a popup to the right of the control.
         */
        showValidationsAsPopup?: boolean;
        /**
         * Enable the TextBox to be spellchecked. Default is false.
         * (Warning. Perf hit. Do not enable this for a large text).
         */
        spellcheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: string) => void;
    }
    /**
     * TextBox control viewmodel.
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * When set, the TextBox will be read only.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the enter key.
         */
        readonly onEnterPressed: (value: string) => void;
        /**
         * Enable the TextBox to be spellchecked. Default is false.
         * (Warning. Perf hit. Do not enable this for a large text).
         */
        readonly spellcheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a TextBox control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a TextBox viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\TimePicker.d.ts
declare module "Fx/Controls/TimePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a time picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DatePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange> | DateTimeRange[] | KnockoutObservableArray<DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Date | KnockoutObservableBase<Date>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * TimePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Date>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        readonly enabledDateTimeRange: KnockoutObservableBase<DateTimeRange> | KnockoutObservableArray<DateTimeRange>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
    }
    /**
     * Creates a time picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a time picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Toggle.d.ts
declare module "Fx/Controls/Toggle" {
    import { Contract as FormBaseContract } from "Fx/Controls/FormBase";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Text value shown besides the toggle control.
     */
    export interface ValueText {
        /**
         * Text value shown besides the toggle control during on state.
         */
        onText: string | HtmlContent;
        /**
         * Text value shown besides the toggle control during off state.
         */
        offText: string | HtmlContent;
    }
    /**
     * Options for the Toggle control.
     */
    export interface Options {
        /**
         *  The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Options text value for when the Toggle is in either active or inactive state.
         */
        valueText?: ValueText | KnockoutObservableBase<ValueText>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state. This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed. Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Indicates if the control is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         *  Indicates whether the control is visble or not.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Initial value of the control.
         */
        value?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Toggle control view model
     */
    export interface Contract extends FormBaseContract {
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<boolean>;
        /**
         * Options text value for when the Toggle is in either active or inactive state.
         */
        readonly valueText: KnockoutObservableBase<ValueText>;
    }
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Toolbar.d.ts
declare module "Fx/Controls/Toolbar" {
    import { Image } from "Fx/Images";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    import { BladeLink, ResourceLink, ClickableLink } from "Fx/Composition";
    import * as FileDownload from "Fx/Controls/FileDownload";
    import { Control } from "Fx/Controls/ControlsBase";
    import * as FileUpload from "Fx/Controls/FileUpload";
    export import DownloadContextCallback = FileDownload.DownloadContextCallback;
    export import DownloadDialogOptions = FileDownload.DownloadDialogOptions;
    export import DownloadStatus = FileDownload.DownloadStatus;
    export import DataUriContext = FileDownload.DataUriContext;
    export import SasLikeContext = FileDownload.SasLikeContext;
    export import OAuthContext = FileDownload.OAuthContext;
    export import BlobUriContext = FileDownload.BlobUriContext;
    /**
     * Union type of all items supported by the Toolbar.
     */
    export type ToolbarItem = ToolbarItems.BasicButtonContract | ToolbarItems.ToggleButtonContract | ToolbarItems.MoveResourceButtonContract | ToolbarItems.OAuthButtonContract | ToolbarItems.SeparatorContract | ToolbarItems.BlobUriFileDownloadButtonContract | ToolbarItems.DataUriFileDownloadButtonContract | ToolbarItems.SasLikeFileDownloadButtonContract | ToolbarItems.OAuthFileDownloadButtonContract | ToolbarItems.StreamFileUploadButtonContract | ToolbarItems.BlobFileUploadButtonContract<any> | ToolbarItems.MenuButtonContract | ToolbarItems.FeedbackButtonContract;
    /**
     * Union type of all items supported by the Menu Button
     */
    export type MenuItem = Exclude<ToolbarItem, ToolbarItems.MenuButtonContract>;
    /**
     * Options used to configure the toolbar control.
     */
    export interface Options {
        /**
         * Controls label visibility.  Defaults to false.
         */
        readonly showLabels?: boolean | KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently disabled. Defaults to false.
         */
        readonly disabled?: boolean | KnockoutObservable<boolean>;
        /**
         * Items shown in the toolbar.
         */
        readonly items: ToolbarItems.ToolbarItemContract[] | KnockoutObservable<ToolbarItems.ToolbarItemContract[]>;
    }
    /**
     * Toolbar control viewmodel.
     */
    export interface Contract extends Control {
        /**
         * Controls label visibility.
         */
        readonly showLabels: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservable<boolean>;
        /**
         * Sets the list of items that will be shown in the toolbar.
         */
        readonly setItems: (items: ToolbarItems.ToolbarItemContract[]) => void;
    }
    /**
     * Creates a toolbar viewmodel.
     * @param lifetime lifetime of the viewmodel
     * @param options Options used to configure the toolbar
     * @returns A toolbar viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    /**
     * namespace for all toolbar item create methods and their respective interfaces.
     */
    export namespace ToolbarItems {
        /**
         * Base toolbar item interface.
         */
        interface ToolbarItemContract {
            /**
             * Set by the button create methods and used internally.
             * Exposed on the public API surface in order to provide some measure of type safety when passing in items into toolbar apis.
             */
            readonly type: number;
        }
        /**
         * Base toolbar button viewmodel.
         */
        interface BaseButtonContract extends ToolbarItemContract {
            /**
             * disables this toolbar item.
             * message is the tooltip shown for the disabled item.
             */
            readonly disabled: KnockoutObservableBase<boolean>;
            /**
             * enables the toolbar item.
             */
            readonly disabledMessage: KnockoutObservableBase<string>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel: KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip: KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label: KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon: KnockoutObservableBase<Image>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass: KnockoutObservableBase<string>;
        }
        /**
         * Options used to configure a toolbar button.
         */
        interface BasicButtonOptions {
            /**
             * callback invoked when the button is clicked.
             */
            readonly onClick: (() => void) | BladeLink | ResourceLink | ClickableLink;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Toolbar button viewmodel.
         */
        interface BasicButtonContract extends BaseButtonContract {
        }
        /**
         * Creates a toolbar button viewmodel.
         * @param lifetime
         * @param options
         * @returns A toolbar button viewmodel
         */
        function createBasicButton(lifetime: MsPortalFx.Base.LifetimeManager, options: BasicButtonOptions): BasicButtonContract;
        /**
         * Options used to create a toggle button.
         */
        interface ToggleButtonOptions {
            /**
             * State of the toggle button.
             */
            readonly checked?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The option group that contains the toggle button.
             */
            readonly optionGroupName?: string;
            /**
             * callback invoked when the button is clicked.
             * data is the state of the button.
             */
            readonly onToggled: (checked: boolean) => void;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the button.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Toggle button viewmodel
         */
        interface ToggleButtonContract extends BaseButtonContract {
            /**
             * The Current state of the toggle button.
             */
            readonly checked: KnockoutObservableBase<boolean>;
        }
        /**
         * Creates a toggle button viewmodel.
         * @param lifetime the lifetime of the viewmodel
         * @param options Options used to create the viewmodel
         * @returns A create button viewmodel
         */
        function createToggleButton(lifetime: MsPortalFx.Base.LifetimeManager, options: ToggleButtonOptions): ToggleButtonContract;
        /**
         * Options used to configure an OAuth button.
         */
        interface OAuthButtonOptions {
            /**
             * Request url used to pop up the OAuth window.
             */
            readonly requestUrl?: string | KnockoutObservable<string>;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * OAuth button viewmodel
         */
        interface OAuthButtonContract extends BaseButtonContract {
            /**
             * Request url used to pop up the OAuth window.
             */
            readonly requestUrl: KnockoutObservable<string>;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth: KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight: KnockoutObservable<number>;
            /**
             * This will be updated with the value of the full url containing the token once the user has signed in.
             */
            readonly value: KnockoutReadOnlyObservable<string>;
        }
        /**
         * Creates an OAuth button.
         * @param lifetime lifetime of the viewmodel
         * @param options Options used to create the OAuth button viewmodel
         * @returns An OAuth button viewmodel
         */
        function createOAuthButton(lifetime: MsPortalFx.Base.LifetimeManager, options?: OAuthButtonOptions): OAuthButtonContract;
        /**
         * Options used to configure the move resource button
         */
        interface MoveResourceButtonOptions {
            /**
             * The id of the resource to be moved.
             */
            readonly resourceId: string;
            /**
             * Opens the move blade as a sub journey.
             */
            readonly asSubJourney?: boolean;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Move resource button viewmodel.
         */
        interface MoveResourceButtonContract extends ToolbarItemContract {
            /**
             * disables this toolbar item.
             * message is the tooltip shown for the disabled item.
             */
            readonly disabled: KnockoutObservableBase<boolean>;
            /**
             * enables the toolbar item.
             */
            readonly disabledMessage: KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass: KnockoutObservableBase<string>;
        }
        /**
         * Creates a move resource button.
         * @param container the container hosting this control
         * @param options Options used to configure the move resource button
         * @returns A move resource button viewmodel
         */
        function createMoveResourceButton(container: AnyBladeContainer, options: MoveResourceButtonOptions): MoveResourceButtonContract;
        /**
         * Options used to configure a data uri download button.
         */
        interface DataUriFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: DataUriContext | DownloadContextCallback<DataUriContext>;
            /**
             * Callback executed when download is complete.
             */
            readonly onComplete?: (downloadStatus: DownloadStatus) => void;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Data uri download button viewmodel.
         */
        interface DataUriFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Indicates if the file is downloaded successfully or not.
             * When command is executing and downloading the file, the downloadStatus will be set to null.
             */
            readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
        }
        /**
         * Creates a data uri download button viewmodel
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a data uri download button
         * @returns a data uri download button viewmodel
         */
        function createDataUriFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: DataUriFileDownloadButtonOptions): DataUriFileDownloadButtonContract;
        /**
         * Options used to configure a sas like download button.
         */
        interface SasLikeFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: SasLikeContext | DownloadContextCallback<SasLikeContext>;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Sas-like download button viewmodel.
         */
        interface SasLikeFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
        }
        /**
         * Creates a sas-like download button viewmodel
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a sas-like download button
         * @returns a sas-like download button viewmodel
         */
        function createSasLikeFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: SasLikeFileDownloadButtonOptions): SasLikeFileDownloadButtonContract;
        /**
         * Options used to configure an OAuth download button.
         */
        interface OAuthFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: OAuthContext | DownloadContextCallback<OAuthContext>;
            /**
             * Callback executed when download is complete.
             */
            readonly onComplete?: (downloadStatus: DownloadStatus) => void;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * OAuth download button viewmodel.
         */
        interface OAuthFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Indicates if the file is downloaded successfully or not.
             * When command is executing and downloading the file, the downloadStatus will be set to null.
             */
            readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
        }
        /**
         * Creates an OAuth download button viewmodel
         * @param container the lifetime of the viewmodel
         * @param options Options used to create an OAuth download button
         * @returns an OAuth download button viewmodel
         */
        function createOAuthFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: OAuthFileDownloadButtonOptions): OAuthFileDownloadButtonContract;
        /**
         * Options used to configure a blob uri download button.
         */
        interface BlobUriFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: BlobUriContext | DownloadContextCallback<BlobUriContext>;
            /**
             * Callback executed when download is complete.
             */
            readonly onComplete?: (downloadStatus: DownloadStatus) => void;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Blob uri download button viewmodel.
         */
        interface BlobUriFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Indicates if the file is downloaded successfully or not.
             * When command is executing and downloading the file, the downloadStatus will be set to null.
             */
            readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
        }
        /**
         * Creates a blob uri download button viewmodel
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a blob uri download button
         * @returns a blob uri download button viewmodel
         */
        function createBlobUriFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: BlobUriFileDownloadButtonOptions): BlobUriFileDownloadButtonContract;
        /**
         * Base options for configuring a file upload button.
         */
        interface FileUploadButtonOptions {
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The button label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the button.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
            /**
             * A comma-separated list of allowed file mime-types, excluding extensions.
             * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
             * The file filtering  behavior depends on native browser support.
             */
            readonly accept?: string | KnockoutObservableBase<string>;
            /**
             * A comma-separated list of allowed file extensions.
             * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
             * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
             * Eg: "pfx,cer"
             */
            readonly allowedFileExtensions?: string | KnockoutObservableBase<string>;
            /**
             * The maximum number of files allowed to be uploaded at once.
             * This limit is applied post-selection.
             */
            readonly maxFiles?: number;
        }
        /**
         * Options for configuring a file upload button for streaming file uploads.
         */
        interface StreamFileUploadButtonOptions extends FileUploadButtonOptions {
            /**
             * The stream upload context.
             */
            uploadContext: FileUpload.StreamFileUploadContext | KnockoutObservableBase<FileUpload.StreamFileUploadContext>;
        }
        /**
         * Options for configuring a file upload button for blob store file uploads.
         */
        interface BlobFileUploadButtonOptions<T> extends FileUploadButtonOptions {
            /**
             * The blob store upload context around how/where to upload and size limits.
             */
            uploadContext: FileUpload.BlobStoreFileUploadContext<T> | KnockoutObservableBase<FileUpload.BlobStoreFileUploadContext<T>>;
        }
        /**
         * FileUpload button view model contract.
         */
        interface FileUploadButtonContract extends BaseButtonContract {
            /**
             * A comma-separated list of allowed file mime-types, excluding extensions.
             * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
             * The file filtering  behavior depends on native browser support.
             */
            readonly accept: KnockoutObservableBase<string>;
            /**
             * A comma-separated list of allowed file extensions.
             * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
             * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
             * Eg: "pfx,cer"
             */
            readonly allowedFileExtensions: KnockoutObservableBase<string>;
            /**
             * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress etc.
             * UploadTask is used to initiate the file upload, pause/resume uploads, cancel and dispose the file upload.
             */
            readonly uploadTasks: KnockoutReadOnlyObservableArray<FileUpload.AsyncUploadTaskContract>;
            /**
             * Method to reset the uploadTasks array. This method will use the widget callback to initialize the uploadTasks array with empty array.
             * Calling this method will not dispose(abort) the uploads.
             * Uploads which have already started will continue upload in the background.
             * Uploads which have not been started will be cleaned up.
             */
            readonly resetUploadTasks: () => Q.Promise<void>;
        }
        /**
         * FileUpload button view model contract for streaming file upload.
         */
        interface StreamFileUploadButtonContract extends FileUploadButtonContract {
            /**
             * The stream upload context.
             */
            readonly uploadContext: KnockoutObservableBase<FileUpload.StreamFileUploadContext>;
        }
        /**
         * FileUpload button view model for blob store file uploads.
         */
        interface BlobFileUploadButtonContract<T> extends FileUploadButtonContract {
            /**
             * The blob store upload context around how/where to upload and size limits.
             */
            readonly uploadContext: KnockoutObservableBase<FileUpload.BlobStoreFileUploadContext<T>>;
        }
        /**
         * Creates a FileUpload button view model for Stream File uploads.
         *
         * @param lifetime The lifetime of the file upload button
         * @param options Options that modify the appearance and behavior of the file upload button.
         *
         * @returns a file upload button view model
         */
        function createStreamUploadButton(lifetime: MsPortalFx.Base.LifetimeManager, options: StreamFileUploadButtonOptions): StreamFileUploadButtonContract;
        /**
         * Creates a FileUpload button view model for Blob store and Azure File Service uploads.
         *
         * @param lifetime The lifetime of the file upload button
         * @param options BlobFileUploadButtonOptions that modify the appearance and behavior of the file upload button.
         *
         * @returns a file upload button viewmodel
         */
        function createBlobStoreUploadButton<T>(lifetime: MsPortalFx.Base.LifetimeManager, options: BlobFileUploadButtonOptions<T>): BlobFileUploadButtonContract<T>;
        /**
         * Options used to configure a menu button
         */
        interface MenuButtonOptions {
            /**
             * Buttons shown in the menu
             */
            readonly buttons?: MenuItem[] | KnockoutObservableBase<MenuItem[]>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Group button viewmodel.
         */
        interface MenuButtonContract extends BaseButtonContract {
            /**
             * Buttons shown in the menu
             */
            readonly buttons: KnockoutObservableBase<MenuItem[]>;
        }
        /**
         * Creates a menu button viewmodel
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a menu button
         * @returns a menu button viewmodel
         */
        function createMenuButton(container: MsPortalFx.Base.LifetimeManager, options: MenuButtonOptions): MenuButtonContract;
        /**
         * Toolbar separator.
         */
        interface SeparatorContract extends ToolbarItemContract {
        }
        /**
         * Creates a toolbar separator.
         * @returns a toolbar separator viewmodel
         */
        function createSeparator(): SeparatorContract;
        /**
         * Toolbar feedback button.
         */
        interface FeedbackButtonContract extends ToolbarItemContract {
            /**
             * disables this toolbar item.
             * message is the tooltip shown for the disabled item.
             */
            readonly disabled: KnockoutObservableBase<boolean>;
            /**
             * enables the toolbar item.
             */
            readonly disabledMessage: KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip: KnockoutObservableBase<string>;
        }
        /**
         * Options for the feedback button.
         */
        interface FeedbackButtonOptions {
            /**
             * Callback triggered after the button is clicked, and subsequently after the feedback pane opens.
             * Note that this callback cannot be used for navigation.
             * Note that this callback is often supplied by extensions to perform custom logging/telemetry.
             *
             * @param keypress Indicates if the button is opened by keypress.
             */
            readonly onButtonClicked?: (keypress: boolean) => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName: string;
        }
        /**
         * Creates a feedback button.
         *
         * @param container The lifetime of the viewmodel.
         * @param options The feedback button options.
         * @returns a feedback button viewmodel
         */
        function createFeedbackButton(container: MsPortalFx.Base.LifetimeManager, options: FeedbackButtonOptions): FeedbackButtonContract;
    }
}

// FILE: Fx\Controls\TriStateCheckBox.d.ts
declare module "Fx/Controls/TriStateCheckBox" {
    import { HtmlContent, OverflowMode } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Overflow Mode for text overflow
     */
    export { OverflowMode };
    /**
     * CheckBoxValue value states.
     */
    export const enum Value {
        /**
         * TriStateCheckBox state representing unchecked state.
         */
        Unchecked = 0,
        /**
         * TriStateCheckBox state representing checked state.
         */
        Checked = 1,
        /**
         * TriStateCheckBox state representing indeterminate state.
         */
        Indeterminate = 2
    }
    /**
     * Options for configuring a tri-state textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria-label on the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set to true, the label will be placed to the right of the control
         */
        labelOnRight?: boolean;
        /**
         * If set to true, the user can set the indeterminate state of the control
         */
        userCanSetIndeterminate?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Value | KnockoutObservableBase<Value>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        overflowMode?: OverflowMode | KnockoutObservableBase<OverflowMode>;
    }
    /**
     * TriStateCheckBox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Value>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        readonly overflowMode: KnockoutObservableBase<OverflowMode>;
    }
    /**
     * Creates a tristate checkbox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     *
     * @returns a tristate checkbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Validations.d.ts
declare module "Fx/Controls/Validations" {
    export import CaseInsensitiveComparison = MsPortalFx.ViewModels.CaseInsensitiveComparisonValidation;
    export import Contains = MsPortalFx.ViewModels.ContainsValidation;
    export import ContainsCharacters = MsPortalFx.ViewModels.ContainsCharactersValidation;
    export import Custom = MsPortalFx.ViewModels.CustomValidation;
    export import CustomV = MsPortalFx.ViewModels.CustomValidationV;
    export import Equals = MsPortalFx.ViewModels.EqualsValidation;
    export import HasDigit = MsPortalFx.ViewModels.HasDigitValidation;
    export import HasLetter = MsPortalFx.ViewModels.HasLetterValidation;
    export import HasLowerCaseLetter = MsPortalFx.ViewModels.HasLowerCaseLetterValidation;
    export import HasPunctuation = MsPortalFx.ViewModels.HasPunctuationValidation;
    export import HasUpperCaseLetter = MsPortalFx.ViewModels.HasUpperCaseLetterValidation;
    export import Invalid = MsPortalFx.ViewModels.InvalidValidation;
    export import LengthRange = MsPortalFx.ViewModels.LengthRangeValidation;
    export import LocaleAwareCaseInsensitiveComparison = MsPortalFx.ViewModels.LocaleAwareCaseInsensitiveComparisonValidation;
    export import MaxLength = MsPortalFx.ViewModels.MaxLengthValidation;
    export import MaxValue = MsPortalFx.ViewModels.MaxValueValidation;
    export import MinLength = MsPortalFx.ViewModels.MinLengthValidation;
    export import MinValue = MsPortalFx.ViewModels.MinValueValidation;
    export import NotContains = MsPortalFx.ViewModels.NotContainsValidation;
    export import NotContainsCharacters = MsPortalFx.ViewModels.NotContainsCharactersValidation;
    export import NotRegExMatch = MsPortalFx.ViewModels.NotRegExMatchValidation;
    export import Numeric = MsPortalFx.ViewModels.NumericValidation;
    export import Range = MsPortalFx.ViewModels.RangeValidation;
    export import RegExMatch = MsPortalFx.ViewModels.RegExMatchValidation;
    export import Required = MsPortalFx.ViewModels.RequiredValidation;
    export import StaticMessage = MsPortalFx.ViewModels.StaticMessageValidation;
    export import Uri = MsPortalFx.ViewModels.UriValidation;
    export import Validation = MsPortalFx.ViewModels.FormValidation;
    export import ValidationResult = MsPortalFx.ViewModels.ValidationResult;
    export import ValidationState = MsPortalFx.ViewModels.Controls.Validators.ValidationState;
    export import ValidationType = MsPortalFx.ViewModels.FormValidationType;
}

// FILE: Fx\Controls\Video.d.ts
declare module "Fx/Controls/Video" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options that can be set on the Video control.
     */
    export interface Options {
        /**
         * Source of the video.
         */
        src?: KnockoutObservableBase<string> | string;
        /**
         * Play video immediately after load.
         */
        autoplay?: KnockoutObservableBase<boolean> | boolean;
        /**
         * On first play callback function.
         */
        onFirstPlay?: KnockoutObservableBase<Callback> | Callback;
    }
    /**
     * Video control view model
     */
    export interface Contract extends Control {
        /**
         * URL of the desired video (Supports HTML5 video, YouTube, Channel9).
         */
        src: KnockoutObservableBase<string>;
        /**
         * Play video immediately after load (only works for HTML5 and YouTube).
         */
        autoplay: KnockoutObservableBase<boolean>;
        /**
         * True if current video type supports autoplay.
         */
        canAutoplay: KnockoutReadOnlyObservable<boolean>;
        /**
         * Called when the video is played in first time (only works for HTML5, YouTube and Channel9).
         */
        onFirstPlay: KnockoutObservableBase<Callback>;
    }
    /**
     * Callback function type for events.
     */
    export type Callback = () => void;
    /**
     * Creates a Video control viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the Video view model.
     *
     * @returns a Video view model
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Cryptography.d.ts
declare module "Fx/Cryptography" {
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxImpl.Rpc;
    import FxPromiseV = FxBase.PromiseV;
    export module Internal {
        const getHmacSha256EndPoint: FxRpc.FuncEndPointDefinition<GetHmacSha256Options, string>;
        /**
         * Returns an hmac sha256 token generated by hashing the provided string with the specified key.
         *
         * @param options Parameters required by the function.
         * @param client The rpc client from which this call originates. Defaults to the current iFrame.
         *  Note: the default behavior should only be overridden for testing.
         * @return A promise that resolves to a hmac sha256 hashed string.
         */
        function getHmacSha256(options: GetHmacSha256Options, client?: FxRpc.Client): FxPromiseV<string>;
    }
    /**
     * Options that must be passed when calling the getHmacSha256 function.
     */
    export interface GetHmacSha256Options {
        /**
         * The string to hash, can be any length.
         */
        stringToHash: string;
        /**
         * The key, encoded in base 64.
         */
        key: string;
        /**
         * Optional parameter to skip retry on failed API calls
         */
        skipRetry?: boolean;
    }
    /**
     * HmacSha256 RPC endpoint response interface
     */
    export interface HmacSha256ResponseModel {
        data: string;
    }
    /**
     * Returns an hmac sha256 token generated by hashing the provided string with the specified key.
     *
     * @param options Parameters required by the function.
     * @return A promise that resolves to a hmac sha256 hashed string.
     */
    export function getHmacSha256(options: GetHmacSha256Options): FxBase.PromiseV<string>;
}

// FILE: Fx\DependencyInjection.d.ts
declare module "Fx/DependencyInjection" {
    global {
        interface DependencyInjectionScope {
            "": undefined;
        }
    }
    /**
     * The generic construct signature.
     */
    export type Constructor<T> = new (...args: any[]) => T;
    /**
     * The signature of an interceptor function.
     */
    export type Interceptor<T> = (previous: T) => T | void;
    /**
     * A decorator that registers the attributed class as a dependency injected class.
     *
     * @param scope The scope of the registered class.
     */
    export function Class(scope?: keyof DependencyInjectionScope): <T>(target: Constructor<T>) => void;
    /**
     * A decorator that registers the attributed method as a dependency injected factory method.
     *
     * @param scope The scope of the registered class.
     */
    export function Factory(scope?: keyof DependencyInjectionScope): <T>(target: Constructor<T>, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => T | PromiseLike<T>>) => void;
    export abstract class Container {
        /**
         * Gets the instance associated with the registered type. Within a container, the same instance is always returned for the same type.
         *
         * @param type The type.
         * @returns The instance.
         */
        abstract get<T>(type: Constructor<T>): T;
        /**
         * The async version of get. Used to compose types that are registered with an async factory method.
         *
         * @param type The type.
         * @returns A promise that resolves to the instance.
         */
        abstract getAsync<T>(type: Constructor<T> | PromiseLike<Constructor<T>>): Q.Promise<T>;
        /**
         * Registers the instance for the given type. Compositions for the given type will use the
         * instance instead. The container will not acquire lifetime ownership and therefore will not call
         * dispose on the instance when the container is disposed.
         *
         * @param type The type.
         * @param value The instance.
         * @returns The current 'this' context.
         */
        abstract set<T>(type: Constructor<T>, value: T): this;
        /**
         * Registers an interceptor for the given type. Interceptors are invoked on newly composed instances and can be used to customize them.
         *
         * @param type The type.
         * @param interceptor The interceptor.
         * @returns The current 'this' context.
         */
        abstract setInterceptor<T>(type: Constructor<T>, interceptor: Interceptor<T>): this;
        /**
         * Creates a child container with the specified scope. The newly created container will be disposed when current container is being disposed.
         *
         * @param scope The scope.
         * @returns The child container.
         */
        abstract createChildContainer(scope?: keyof DependencyInjectionScope): RootContainer;
    }
    /**
     * The dependency injection container.
     */
    export interface RootContainer extends Container {
        /**
         * Disposes the container. All composed instances will also be disposed. This method will wait for the completion
         * of any async factory methods that are still executing. Instances explicitly specified with the set method will
         * not be disposed.
         *
         * @returns A promise that resolves when all composed instances have been disposed.
         */
        disposeAsync(): Q.Promise<void>;
    }
    /**
     * Create a new instance of the dependency injection container.
     */
    export function createContainer(scope?: keyof DependencyInjectionScope): RootContainer;
    /**
     * The global singleton dependency injection container.
     */
    export const container: RootContainer;
}

// FILE: Fx\Diagnostics.d.ts
declare module "Fx/Diagnostics" {
    import FxDiagnostics = MsPortalFx.Base.Diagnostics;
    export import LogMessage = FxDiagnostics.LogMessage;
    export import LogEntryLevel = FxDiagnostics.LogEntryLevel;
    export interface Log {
        /**
         * Log debug information. This is only logged to the console.
         * It is not persisted in server telemetry.
         *
         * @param entry The message/error to log.
         * @param restArgs[] Extra information to log with the message.
         */
        debug(entry: LogMessage, ...restArgs: any[]): void;
        /**
         * Log error information.
         *
         * @param entry The message/error to log.
         * @param code The message code. Can be used for quick filtering of telemetry logs.
         * @param restArgs[] Extra information to log with the message.
         */
        error(entry: LogMessage, code?: number, ...restArgs: any[]): void;
        /**
         * Log warning information.
         *
         * @param entry The message/error to log.
         * @param code The message code. Can be used for quick filtering of telemetry logs.
         * @param restArgs[] Extra information to log with the message.
         */
        warning(entry: LogMessage, code?: number, ...restArgs: any[]): void;
        /**
         * Log information.
         *
         * @param level Information level type.
         * @param entry The message/error to log.
         * @param code The message code. Can be used for quick filtering of telemetry logs.
         * @param args[] Extra information to log with the message.
         */
        writeEntry(level: LogEntryLevel, entry: LogMessage, code: number, args: any[]): void;
    }
    export const createLog: (require: LocalRequire) => Log;
}

// FILE: Fx\DirectoryManagement.d.ts
declare module "Fx/DirectoryManagement" {
    /**
     * Directory information saved in user settings.
     */
    export interface UserSettingsDirectoryInfo {
        /**
         * Tenant id.
         */
        readonly id: string;
        /**
         * The tenant domain name.
         */
        readonly domainName: string;
        /**
         * The tenant display name.
         */
        readonly displayName: string;
    }
    /**
     * Interface for user's directory settings.
     */
    export interface UserDirectorySettings {
        /**
         * List of favorite tenants.
         */
        readonly favoriteDirectoriesList: ReadonlyArray<string>;
        /**
         * The default directory for the user.
         */
        readonly userDefaultDirectory: UserSettingsDirectoryInfo;
    }
    /**
     * Gets the current directory settings for the user.
     * Note: this is a highly privileged operation, only available to a small set of extensions.
     */
    export function getUserDirectorySettings(): Q.Promise<UserDirectorySettings>;
    /**
     * Saves the given directory settings for the user.
     * Note: this is a highly privileged operation, only available to a small set of extensions.
     *
     * @param settings The directory settings to persist.
     * @returns A boolean indicating whether the settings were saved successfully.
     */
    export function saveUserDirectorySettings(settings: Partial<UserDirectorySettings>): Q.Promise<boolean>;
}

// FILE: Fx\Events.d.ts
declare module "Fx/Events" {
    /**
     * A reference to a DOM element in the portal
     */
    export import FxElement = MsPortalFx.ViewModels.FxElement;
    /**
     * Information describing a event generated by a mouse action
     */
    export import FxMouseEvent = MsPortalFx.ViewModels.FxMouseEvent;
}

// FILE: Fx\Experimentation.d.ts
declare module "Fx/Experimentation" {
    /**
     * Represents the flights enabled for an extension
     */
    export interface ExtensionFlights {
        /**
         * Returns whether the flight is present for the logged in user.
         * @param flightName The name of the flight (this value is case insensitive).
         */
        has(flightName: string): boolean;
        /**
         * Gets a list of all the flights present for the extension.
         */
        getAll(): ReadonlyArray<string>;
    }
    /**
     * Accesses the experimentation features
     */
    export interface Experimentation {
        /**
         * Gets all the flights assigned to this extension.
         * The promise always succeeds even if the underlying call might fail. In this case there will be no flights assigned.
         * For more information on how to set up flights using the ExP platform see https://aka.ms/portalfx/experimentation
         * NOTE: there is no perf penalty to call this API multiple times, as the result is cached.
         * @returns An object that can be used for querying the existance of a particular flight.
         */
        getExtensionFlights(): Q.Promise<ExtensionFlights>;
    }
    export class Experimentation {
    }
}

// FILE: Fx\Feedback.d.ts
declare module "Fx/Feedback" {
    import Rpc = FxImpl.Rpc;
    export interface NpsDetails {
        /**
         * The display name of the product to be shown in the NPS survey.
         * The question will be of the form:
         *     How likely are you to recommend {your product name} to a friend or colleague?
         */
        readonly productDisplayName: string;
        /**
         * The product id that will be logged in the portal telemetry table.
         */
        readonly productId: string;
    }
    export module Internal {
        /**
         * RPC endpoint to show survey.
         */
        const showNpsEndpoint: Rpc.FuncEndPointDefinition<NpsDetails, void>;
        /**
         * RPC endpoint to check if survey can be shown.
         */
        const canShowNpsEndpoint: Rpc.FuncEndPointDefinition<void, boolean>;
    }
    /**
     * Requests an NPS toast to be displayed. The response to the feedback will be recorded in the portal telemetry tables.
     *
     * Note that the NPS survey will only be shown once per session. Calling this API does not guarantee that the survey will be shown.
     *
     * @param params NPS parameters.
     */
    export function showNps(params: NpsDetails): void;
    /**
     * Checks if an NPS survey can be shown. If this returns true, extensions can call the showNPSSurvey to show NPS.
     * If this returns false, an NPS survey has already been shown and calling the showNPSSurvey will result in a no-op.
     *
     */
    export function canShowNps(): Q.Promise<boolean>;
}

// FILE: Fx\Images.d.ts
declare module "Fx/Images" {
    /**
     * Available SVG elements provided by the framework.
     */
    export import SvgType = MsPortalFx.Services.Image.SvgType;
    /**
     * Built in SVGs provided by the framework.
     */
    export import Images = MsPortalFx.Base.Images;
    /**
     * Interface of image objects used by the framework.
     */
    export import Image = MsPortalFx.Base.Image;
}

// FILE: Fx\NotifyResourcesCreated.d.ts
declare module "Fx/NotifyResourcesCreated" {
    /**
     * The resource type whose set of resources for the user has created.
     */
    export const enum CreatedResourcesType {
        /**
         * Subscriptions.
         */
        Subscriptions = 1
    }
    /**
     * Notify FX that the set of resources of some type have created.
     *
     * @param createdResourcesType  The resource type whose set of resources for the user has created.
     */
    export function notifyResourcesCreated(createdResourcesType: CreatedResourcesType): void;
}

// FILE: Fx\Pinner.d.ts
declare module "Fx/Pinner" {
    import FxRpc = FxImpl.Rpc;
    import FxComposition = MsPortalFx.Composition;
    /**
     * Options that can be passed when calling the pin function.
     */
    export interface Options {
        /**
         * The value to indicate whether to show a notification or not.
         */
        readonly notify: boolean;
    }
    export module Internal {
        /**
         * RPC endpoint to pin provided parts.
         */
        const pinEndPoint: FxRpc.FuncEndPointDefinition<PinParams, void>;
        /**
         * Options that must be passed when calling the pin function.
         */
        interface PinParams {
            /**
             * Parts to pin to the dashboard.
             */
            parts: (FxComposition.PartReference<any> | FxComposition.ResourcePartReference)[];
            /**
             * The value to indicate whether to show a notification or not.
             */
            options?: Options;
        }
    }
    /**
     * Pins the specified parts to the currently opened dashboard.
     *
     * @param parts Parts to pin to the dashboard.
     * @param options Optional arguments used by the function.
     * @return A promise that resolves to completion of pinning.
     */
    export function pin(parts: (FxComposition.PartReference<any> | FxComposition.ResourcePartReference)[], options?: Options): Q.Promise<void>;
}

// FILE: Fx\Redirect.d.ts
declare module "Fx/Redirect" {
    import { BladeReference } from "Fx/Composition";
    /**
     * The parameters callers may provide that will be passed to the authentication provider.
     */
    export type AllowedSignInParameters = "amr_values" | "acr_values" | "claims";
    /**
     * The options for forcing the user to sign in again.
     */
    export interface ForceSignInOptions {
        /**
         * The blade to launch upon successful sign in.
         */
        readonly bladeReference?: BladeReference<unknown>;
        /**
         * The reason for forcing the user to sign in.
         */
        readonly reason: string;
        /**
         * Optional map of query parameters and values to pass to the authentication provider.
         */
        readonly signInParameters?: ReadonlyTypedStringMap<AllowedSignInParameters, string>;
        /**
         * The tenant ID or directory name to sign into.
         */
        readonly tenantId?: string;
    }
    /**
     * Forces the user to sign in.
     *
     * This is a highly privileged operation with a very limited set of permitted callers.
     *
     * @param options The options used to configure the forced reauthentication.
     * @returns A promise that will only ever be actionable in the failure case. If this function executes successfully, the browser will navigate and the caller will not receive the result. Otherwise, this promise will reject.
     */
    export function forceSignIn(options: ForceSignInOptions): Q.Promise<void>;
}

// FILE: Fx\ResourceManagement.d.ts
declare module "Fx/ResourceManagement" {
    import FxAzure = MsPortalFx.Azure;
    /**
     * Data contract for a single Azure subscription.
     */
    export type Subscription = FxAzure.Subscription;
    /**
     * Data contract for a single location.
     */
    export import Location = MsPortalFx.Azure.Location;
    /**
     * Data contract for a resource group
     */
    export import ResourceGroup = MsPortalFx.Azure.ResourceGroup;
    /**
     * The enum for which recommended group a location should appear in
     */
    export import RegionSegment = MsPortalFx.Azure.RegionSegment;
    /**
     * The ARM ID interface.
     */
    export interface ArmId {
        /**
         * The kind of ARM ID.
         */
        readonly kind: ArmId.Kind;
        /**
         * The subscription for the ARM ID.
         * Valid/required for these kinds:
         *      Subscription,
         *      SubscriptionProvider,
         *      SubscriptionResource,
         *      ResourceGroup,
         *      Provider,
         *      Resource,
         *      SubscriptionTag,
         *      SubscriptionTagValue
         */
        readonly subscription: string;
        /**
         * The resource group for the ARM ID.
         * Valid/required for these kinds:
         *      ResourceGroup,
         *      Provider,
         *      Resource
         */
        readonly resourceGroup: string;
        /**
         * The tag name for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionTag,
         *      SubscriptionTagValue
         */
        readonly tagName: string;
        /**
         * The tag value for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionTagValue
         */
        readonly tagValue: string;
        /**
         * The provider (namespace) for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionProvider,
         *      SubscriptionResource,
         *      Provider,
         *      Resource,
         *      TenantProvider,
         *      TenantResource
         */
        readonly provider: string;
        /**
         * The collection of resource types for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         */
        readonly resourceTypes: ReadonlyArray<string>;
        /**
         * The collection of resource IDs for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         */
        readonly resourceIds: ReadonlyArray<string>;
        /**
         * The full resource name for the ARM ID.
         * Valid for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         */
        readonly resourceName: string;
        /**
         * The fully qualified resource type for the ARM ID.
         * Valid for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         */
        readonly resourceType: string;
    }
    /**
     * Namespace with the functions and ancillary bits like the Kind.
     */
    export namespace ArmId {
        /**
         * The ARM ID kind enumeration.
         */
        const enum Kind {
            /**
             * Invalid ARM ID.
             */
            Invalid = 0,
            /**
             * Subscription ID.
             * eg: /subscriptions/{subscription}
             */
            Subscription = 1,
            /**
             * Subscription provider ID.
             * This is a provider at the subscription level.
             * eg: /subscriptions/{subscription}/providers/{provider}
             */
            SubscriptionProvider = 2,
            /**
             * Subscription resource ID. Can have nested type/ID pairs.
             * This is a resource at the subscription level.
             * eg: /subscriptions/{subscription}/providers/{provider}/{resourceTypes[n]}/{resourceIds[n]}
             */
            SubscriptionResource = 3,
            /**
             * Resource group ID.
             * eg: /subscriptions/{subscription}/resourceGroups/{resourceGroup}
             */
            ResourceGroup = 4,
            /**
             * Provider ID.
             * This is a provider at the resource group level.
             * eg: /subscriptions/{subscription}/resourceGroups/{resourceGroup}/providers/{provider}
             */
            Provider = 5,
            /**
             * Resource ID. Can have nested type/ID pairs.
             * This is a resource at the resource group level.
             * eg: /subscriptions/{subscription}/resourceGroups/{resourceGroup}/providers/{provider}/{resourceTypes[n]}/{resourceIds[n]}
             */
            Resource = 6,
            /**
             * Tenant provider ID.
             * This is a provider at the tenant level.
             * eg: /providers/{provider}
             */
            TenantProvider = 7,
            /**
             * Tenant resource ID. Can have nested type/ID pairs.
             * This is a resource at the tenant level.
             * eg: /providers/{provider}/{resourceTypes[n]}/{resourceIds[n]}
             */
            TenantResource = 8,
            /**
             * Subscription tag ID.
             * eg: /subscriptions/{subscription}/tagNames/{tagName}
             */
            SubscriptionTag = 9,
            /**
             * Subscription tag value ID.
             * eg: /subscriptions/{subscription}/tagNames/{tagName}/tagValues/{tagValue}
             */
            SubscriptionTagValue = 10
        }
        /**
         * Parses the ID from ARM to the ARM ID.
         *
         * @param id The ID from ARM to parse.
         * @returns The ARM ID.
         */
        const parse: (id: string) => ArmId;
        /**
         * Builds the ARM ID string from the ARM ID using the given desired kind.
         * Specify 'kind' here to generate an ARM ID string related to given 'armId' if there is a valid relationship.
         * As an example, given a resource group ARM ID 'armId' and a desired subscription ID 'kind', there is a valid
         * relationship (subscription is a parent of a resource group).
         * However, given a resource group ARM ID 'armId' and a desired resource ID 'kind', there is not a valid
         * relationship with the given information (can't convert from a resource group ID to a child resource ID).
         *
         * @param armId The ARM ID.
         * @param kind The desired ARM ID kind for the generated string.
         * @returns The ARM ID string representing the desired kind, empty string if not valid.
         */
        function stringify(armId: Partial<ArmId>, kind?: Kind): string;
        /**
         * Sanitizes an ID to prevent PI leakage.
         *
         * @param armId The ID to sanitize.
         * @return The sanitized ID.
         */
        function sanitizeId(armId: ArmId): string;
    }
    /**
     * Namespace for the resource name utility function.
     */
    export namespace ResourceName {
        /**
         * The partial bits of a resource needed for the resource name.
         * This can be a resource, resource group or subscription.
         */
        interface PartialResource {
            /**
             * The ID for the resource.
             */
            id: string | KnockoutObservable<string>;
            /**
             * The name of the resource.
             */
            name?: string | KnockoutObservable<string>;
            /**
             * The tags for the resource.
             */
            tags?: StringMap<string> | KnockoutObservable<StringMap<string>>;
            /**
             * The ARM ID for the resource if already parsed.
             */
            armId?: ArmId;
        }
        /**
         * Gets the resource name formatted for the given resource.
         *
         * @param resource The resource for the name.
         * @param skipSplitName Optional boolean flag to skip splitting the resource.name property.
         * @returns The resource name formatted for the UX.
         */
        function getDisplayName(resource: PartialResource, skipSplitName?: boolean): string;
    }
    /**
     * Executes the supplied callback method initially with the current set of selected subscriptions and each time thereafter
     * when the selected subscriptions change.
     *
     * @param lifetime The lifetime object that will notify when the data is no longer required.
     * @param callback The callback function to be executed when the selected subscriptions change.
     */
    export function onSelectedSubscriptionsChange(lifetime: MsPortalFx.Base.LifetimeManager, callback: (subscriptions: ReadonlyArray<Subscription>) => void): Q.Promise<void>;
    export const DEV: {
        resetInSessionSelectedSubscriptions: () => void;
    };
}

// FILE: Fx\ResourceManagement\Deployments.d.ts
declare module "Fx/ResourceManagement/Deployments" {
    import { ArmError } from "Fx/Controls/ArmErrorList";
    import { BladeReference } from "Fx/Composition";
    import FxBase = MsPortalFx.Base;
    /**
     * Options for opening a blade identified by a resource ID.
     */
    export interface PartialResourceLink {
        /**
         * The resource ID.
         */
        readonly resourceId: string;
    }
    /**
     * Structure for options for opening a blade by clicking on a link.
     */
    export interface PartialBladeLink {
        /**
         * Blade reference of blade to be opened.
         */
        readonly bladeReference: BladeReference<any>;
        /**
         * Optionally specify if the blade should open in a context pane.
         */
        readonly openInContextPane?: boolean;
    }
    /**
     * Structure for navigating to a website by clicking on a link.
     */
    export interface UriLink {
        /**
         * The URI to navigate to.
         */
        readonly uri: string;
        /**
         * The window to load the page in.
         */
        readonly target: "_blank" | "_self";
    }
    /**
     * The allowed link types.
     */
    export type AllowedLinkType = PartialResourceLink | PartialBladeLink | UriLink | Function;
    /**
     * The allowed button types.
     */
    export type AllowedButtonType = PartialResourceLink | PartialBladeLink | Function;
    /**
     * Structure for binding link data to a template.
     */
    export interface Link {
        /**
         * The text to display.
         */
        readonly text: string;
        /**
         * The behavior to bind to the link's click event.
         */
        readonly onClick: AllowedLinkType;
    }
    /**
     * Enum of next step types.
     */
    export const enum NextStepTypes {
        /**
         * Next step type for actions which must be completed for the created resource to fully function.
         */
        Required = 0,
        /**
         * Next step type for suplemental creates.
         */
        Recommended = 1
    }
    /**
     * Interface for next step links in the blade shown after submitting a provisioning request.
     */
    export interface NextStepLink {
        /**
         * Type of suggestion in the suggested next steps section
         */
        readonly type: NextStepTypes;
        /**
         * The link to show in the "Next steps" list.
         */
        readonly link: Link;
    }
    /**
     * Options for the spotlight section on the post-create blade.
     */
    export interface SpotlightContent {
        /**
         * The icon to show.
         */
        readonly icon: FxBase.Image | KnockoutObservableBase<FxBase.Image>;
        /**
         * The title of the spotlight.
         */
        readonly title: string | KnockoutObservableBase<string>;
        /**
         * The description to show.
         */
        readonly description: string | KnockoutObservableBase<string>;
        /**
         * The link to show.
         */
        readonly link: Link;
    }
    /**
     * Options for buttons on the post-create blade.
     */
    export interface ButtonOptions {
        /**
         * The label for the button.
         */
        readonly text: string;
        /**
         * The action that is executed when the button is clicked.
         */
        readonly onClick: AllowedButtonType;
    }
    /**
     * The options passed to the extension blade when retrieving custom content shown on the blade launched after submitting a provisioning request.
     */
    export interface PostProvisioningOptions {
        /**
         * The root level deployment object.
         */
        readonly deployment: ArmDeployment;
        /**
         * A key or hash that encodes or corresponds to information about a provisioning request.
         * This must be a valid resource tag value to persist across sessions. View the tag value rules at https://go.microsoft.com/fwlink/?LinkID=2097613.
         * This is provided as a parameter in provisioning.deployTemplate called from TemplateBlade.DoesProvisioning blades.
         */
        readonly provisioningHash: string;
        /**
         * The marketplace ID for the deployment.
         */
        readonly marketplaceItemId: string;
        /**
         * The ID of the primary resource created by the deployment.
         * This is provided in TemplateBlade.DoesProvisioning.DeployTemplateOptions passed to the provisioner.
         */
        readonly primaryResourceId: string;
    }
    /**
     * Interface for customization of content shown on the blade launched after submitting a provisioning request.
     */
    export interface PostProvisioningContent {
        /**
         * The blade or specific resource blade that should open when the user clicks the "Go to resource" button.
         * The text option will be ignored.
         */
        readonly goToResourceButton?: ButtonOptions;
        /**
         * Options for a custom button to show when the deployment completes.
         */
        readonly customButton?: ButtonOptions;
        /**
         * Links to free tutorials related to the resource being created.
         */
        readonly tutorials?: ReadonlyArray<Link>;
        /**
         * Links to provide users with information on what to do next.
         * These links are only displayed after the deployment completes successfully.
         * Blade supports up to 4 links.
         */
        readonly nextSteps?: ReadonlyArray<NextStepLink>;
        /**
         * Options for the spotlight.
         */
        readonly spotlight?: SpotlightContent;
    }
    /**
     * The deployments array.
     */
    export interface ArmDeployments {
        /**
         * Deployment object.
         */
        readonly value: ReadonlyArray<ArmDeployment>;
        /**
         * The next link if the deployments array is too large.
         */
        readonly nextLink?: string;
    }
    /**
     * An ARM deployment.
     */
    export interface ArmDeployment {
        /**
         * Deployment id.
         */
        readonly id: string;
        /**
         * Deployment name.
         */
        readonly name: string;
        /**
         * Deployment properties;
         */
        readonly properties: ArmDeploymentProperties;
        /**
         * The tags associated with the deployment.
         */
        readonly tags?: ReadonlyStringMap<string>;
    }
    /**
     * Properties of an ARM deployment.
     */
    export interface ArmDeploymentProperties {
        /**
         * Correlation id.
         */
        readonly correlationId: string;
        /**
         * Deployment mode.
         */
        readonly mode: string;
        /**
         * Provisioning state.
         */
        readonly provisioningState: string;
        /**
         * Template link.
         */
        readonly templateLink: ArmLink;
        /**
         * Deployment timestamp.
         */
        readonly timestamp: Date;
        /**
         * Deployment duration.
         */
        readonly duration: string;
        /**
         * Deployment parameters.
         */
        readonly parameters?: ReadonlyStringMap<ArmParameter>;
        /**
         * Deployment outputs.
         */
        readonly outputs?: ReadonlyStringMap<ArmParameter>;
        /**
         * Deployment parameters link.
         */
        readonly parametersLink?: ArmLink;
        /**
         * Errors that occurred during deployment.
         */
        readonly error?: ArmError;
        /**
         * The list of resources affected by this deployment.
         */
        readonly outputResources?: ReadonlyArray<{
            id: string;
        }>;
    }
    export interface ArmParameter {
        /**
         * The type of parameter.
         */
        readonly type: string;
        /**
         * The value of the parameter.
         */
        readonly value: any;
    }
    export interface ArmLink {
        /**
         * Template content version.
         */
        readonly contentVersion?: string;
        /**
         * Template Uri.
         */
        readonly uri: string;
    }
}

// FILE: Fx\ResourceManagement\Marketplace.d.ts
declare module "Fx/ResourceManagement/Marketplace" {
    /**
     * Marketplace offer plan.
     */
    export import OfferPlan = Common.Marketplace.OfferPlan;
    /**
     * Marketplace offer pricing details model.
     * Used to retrieve the pricing information for a Marketplace offer.
     */
    export import OfferPricingDetails = Common.Marketplace.OfferPricingDetails;
    /**
     * Marketplace product (offer).
     */
    export import Product = Common.Marketplace.Product;
    /**
     * Marketplace artifact.
     */
    export import Artifact = Common.Marketplace.Artifact;
    /**
     * The context from which a marketplace create is kicked off.
     */
    export import LaunchingContext = Common.Marketplace.LaunchingContext;
    /**
     * Marketplace item.
     */
    export import Item = Common.Marketplace.Item;
    /**
     * The interface of context supplied by marketplace
     */
    export import Context = Common.Marketplace.Context;
}

// FILE: Fx\ResourceManagement\Provisioning.d.ts
declare module "Fx/ResourceManagement/Provisioning" {
    import PartReference = MsPortalFx.Composition.PartReference;
    import FxResourceManager = MsPortalFx.Azure.ResourceManager;
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    export import TemplateDeploymentMode = FxResourceManager.TemplateDeploymentMode;
    /**
     * The response from ARM when a template validate call succeeds.
     */
    export import TemplateValidationResponse = FxResourceManager.TemplateValidationResponse;
    /**
     * The ARM template validation error.
     */
    export import TemplateValidationError = FxResourceManager.TemplateValidationError;
    export import AllDeployTemplateOptions = Common.Provisioning.AllDeployTemplateOptions;
    /**
     * Initial values for form initialization. Use those values to initialize the subscription,
     * resource group, and location drop down controls.
     */
    export import InitialValues = Common.Provisioning.InitialValues;
    /**
     * Options for the DeployTemplate method on provisioning context
     */
    export import DeployTenantLevelTemplateOptions = Common.Provisioning.DeployTenantLevelTemplateOptions;
    /**
     * Options for the DeployTemplate method at resource group level on provisioning context
     */
    export import DeployTemplateOptions = Common.Provisioning.DeployTemplateOptions;
    /**
     * Options for the DeployTemplate method at subscription level on provisioning context
     */
    export import DeploySubscriptionLevelTemplateOptions = Common.Provisioning.DeploySubscriptionLevelTemplateOptions;
    /**
     * Options for the DeployTemplate method at subscription level on provisioning context
     */
    export import DeployManagementGroupLevelTemplateOptions = Common.Provisioning.DeployManagementGroupLevelTemplateOptions;
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperationProperties = Common.Provisioning.TemplateDeploymentOperationProperties;
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperation = Common.Provisioning.TemplateDeploymentOperation;
    export import BaseDeployTemplateResults = Common.Provisioning.BaseDeployTemplateResults;
    export import DeployTemplateResults = Common.Provisioning.DeployTemplateResults;
    /**
     * The deployment status codes.
     */
    export enum DeploymentStatusCode {
        /**
         * Template preflight, validation or deployment failure (based on the operation performed).
         */
        Failure = -1,
        /**
         * Deployment was accepted or successful (based on the operation performed).
         */
        Success = 0,
        /**
         * ARM rejected the deployment request.
         */
        DeploymentRequestFailed = 1,
        /**
         * Deployment failed.
         */
        DeploymentFailed = 2,
        /**
         * Deployment status unknown.
         */
        DeploymentStatusUnknown = 3,
        /**
         * An unexpected error occurred while provisioning the resource group.
         */
        ErrorProvisioningResourceGroup = 4,
        /**
         * An unexpected error occurred while submitting the deployment request.
         */
        ErrorSubmittingDeploymentRequest = 5,
        /**
         * An unexpected error occurred while getting the deployment status.
         */
        ErrorGettingDeploymentStatus = 6,
        /**
         * Invalid arguments.
         */
        InvalidArgs = 7,
        /**
         * An unexpected error occurred while registering the resource providers.
         */
        ErrorRegisteringResourceProviders = 8,
        /**
         * Deployment canceled.
         */
        DeploymentCanceled = 9,
        /**
         * Unknown error.
         */
        UnknownError = 10
    }
    /**
     * Options for the DeployCustom method on provisioning context
     */
    export interface DeployCustomOptions<TResult> {
        /**
         * A promise for when provisioning has finished
         */
        provisioningPromise: Q.Promise<TResult>;
        /**
         * Function to provide a part reference based on the resourceId of a deployment.
         * Defaults to the part reference provided by the marketplace UI.Definition file
         * or null if no marketplace item was provieded to this provisioning blade.
         * @param resource The result of the provisioning promise
         * @returns a part reference to pin to dashboard
         */
        supplyPartReference?(result: TResult): PartReference<any>;
    }
    /**
     * Options for validating the form prior to sending the preflight validation request to ARM.
     */
    export import FormValidationOptions = Common.Provisioning.FormValidationOptions;
}

// FILE: ResourceManagement.d.ts
declare module "Fx/Resources/ResourceManagement" {
    export = ResourceManagement;
    const ResourceManagement: {
        readonly resourceTitleWithParts: string;
        readonly resourceWithNoName: string;
    };
}

// FILE: Fx\Specs\DropDown.d.ts
declare module "Fx/Specs/DropDown" {
    import { BladeReference } from "Fx/Composition";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    import { ParameterProviderBladeReference, ParameterProviderOptions } from "Fx/Composition/Selectable";
    export = Main;
    module Main {
        import FxViewModels = MsPortalFx.ViewModels;
        import Specs = MsPortalFx.Azure.ResourceManager.Pickers.Specs;
        import FxForms = FxViewModels.Forms;
        import SpecPicker = HubsExtension.Azure.SpecPicker;
        /**
         * A spec picker drop down which will show promotoed features of the specs available.
         */
        module DropDown {
            /**
             * Inteface to select the pricing blade on a spec drop down
             */
            interface PricingBladeSelection extends FxViewModels.DynamicBladeSelection {
                /**
                 * An identifying string for the hotspot. Must be unique from all other hotspots
                 * on the part so that the parameter provider can hook into the collector correctly
                 * advise name spacing as well e.g. "Spec.DropDown.Foo1"
                 */
                hotspot: string;
            }
            /**
             * Interface to a pricing blade reference class
             */
            interface PricingBladeReferenceClass {
                new (options: ParameterProviderOptions<any, any, any>): ParameterProviderBladeReference<any, any, any>;
            }
            /**
             * Interface to a pricing blade reference factory
             */
            interface PricingBladeReferenceFactory {
                /**
                 * Creates a reference to the BillingSpecPickerV3 blade in the SamplesExtension extension.
                 * @param options Configures the blade reference.
                 */
                createReference(options: {
                    /**
                     * A callback that supplies initial data for the parameter provider in the child blade each time it opens.
                     * Note that the object received by the parameter provider will be a deep clone of the value you give, rather than the original instance, because it is passed (and sometimes stored) in a serialized form.
                     * @return Initial data for the child blade.
                     */
                    supplyInitialData?: () => any;
                    /** A callback to be invoked when the child blade supplies a result and closes. */
                    receiveResult?: (result: any) => void;
                }): BladeReference<any>;
            }
            /**
             * Base Options for the spec picker dropdown
             */
            interface BaseOptions extends FxForms.Base.Input.Options<string> {
                /**
                 * The spec picker extender viewmodel which will be used to display specs to be picked
                 */
                specPickerExtender: SpecPicker.SpecPickerExtender;
                /**
                 * A callback that supplies initial data for the parameter provider
                 * in the child blade each time it opens.
                 *
                 * Note that the object received by the parameter provider will be a
                 * deep clone of the value you give, rather than the original instance,
                 * because it is passed (and sometimes stored) in a serialized form.
                 *
                 * @return Initial data for the child blade.
                 */
                initialData: KnockoutObservableBase<Specs.InitialData>;
                /**
                 * The Form ViewModel for the selector control.
                 */
                form?: FxForms.Form.ViewModel<any>;
                /**
                 * The path to the property on the Form data model being set
                 * Used instead of accessor
                 */
                accessor?: FxForms.EditScopeAccessors<Specs.Result>;
                /**
                 * This will map the spec to the name in option for the dropdown
                 * defaults to spec code
                 */
                specNameMap?: (spec: SpecPicker.Spec) => string;
                /**
                 * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
                 */
                suppressDirtyBehavior?: boolean;
                /**
                 * Open the spec picker blade in a context pane when the link is clicked
                 * defaults to false
                 */
                contextPane?: boolean;
            }
            /**
             * Options for the spec picker dropdown
             */
            interface Options extends BaseOptions {
                /**
                 * When authoring your Blade using no-PDL (that is, TypeScript decorators),
                 * supply a code-genetrated BladeReference class.
                 * When authoring your Blade using PDL, supply 'PricingBladeSelection'.
                 */
                pricingBlade?: PricingBladeSelection;
            }
            /**
             * Options for the spec picker dropdown
             */
            interface OptionsWithBladeReference extends BaseOptions {
                /**
                 * When authoring your Blade using no-PDL (that is, TypeScript decorators),
                 * supply a code-generated blade reference factory using BladeReferences.forBlade("MyPricingBladeReference"),
                 * or the BladeReference class if using the legacy Blade references API and code-generators.
                 * When authoring your Blade using PDL, supply 'PricingBladeSelection'.
                 */
                pricingBladeReference?: PricingBladeReferenceFactory | PricingBladeReferenceClass;
            }
            /**
             * This is a section which has on it a selectable on it.
             * This is to keep a consistent api with the spec selector
             * and infobox with the control having a selectable
             */
            interface SelectableSection extends FxForms.Section.ViewModel {
                /**
                 * The selectable on the section control to be bound to
                 * in the pdl
                 */
                selectable?: FxViewModels.Selectable<any>;
            }
        }
        /**
         * DropDown which creates a collector and selector that launches a spec picker blade
         */
        class DropDown {
            /**
             * ParameterCollector created to interface with the spec picker blade ParameterProvider
             */
            collector: FxViewModels.ParameterCollector<SpecPicker.ParameterCollectionV3.SpecPickerProviderCollectorParameter>;
            /**
             * The info box control.
             */
            control: DropDown.SelectableSection;
            /**
             * The selected spec(s).
             */
            value: KnockoutObservableBase<Specs.Result>;
            /**
             * Constructs a drop down for specs that can launch a specpicker blade
             *
             * @param container The container associated with the part or other composition item hosting this parameter collector.
             * @param DropDown options that extends both the colector and the BaseDropDownOptions
             */
            constructor(container: FxViewModels.ContainerContract | AnyBladeContainer, options: DropDown.Options | DropDown.OptionsWithBladeReference);
        }
    }
}

// FILE: Fx\Telemetry.d.ts
declare module "Fx/Telemetry" {
    export type ActionModifier = "complete" | "cancel";
    export interface StartTelemetryEvent {
        /**
         * The source of the telemetry data e.g. navigation, blade.
         */
        readonly source: string;
        /**
         * The action being recorded.
         */
        readonly action: string;
        /**
         * The asset type for the telemetry data (optional).
         */
        readonly assetType?: string;
        /**
         * A name associated with the event or item that was the target of the event (optional).
         */
        readonly name?: string;
        /**
         * Whether or not this event should be considered optional. Defaults to false.
         */
        readonly optional?: boolean;
    }
    export interface TelemetryEvent extends StartTelemetryEvent {
        readonly data?: any;
    }
    /**
     * Records a telemetry event.
     *
     * @param evt The telemetry event.
     */
    export const trace: (evt: TelemetryEvent) => void;
}

// FILE: Fx\TimeZones.d.ts
declare module "Fx/TimeZones" {
    export const enum TimeZoneId {
        /**
         * The fake timezone ID for the current (pseudo) timezone.
         */
        Current = "Current",
        /**
         * The timezone ID for 'Line Islands Standard Time'.
         */
        LineIslandsStandardTime = "Line Islands Standard Time",
        /**
         * The timezone ID for 'Samoa Standard Time'.
         */
        SamoaStandardTime = "Samoa Standard Time",
        /**
         * The timezone ID for 'Tonga Standard Time'.
         */
        TongaStandardTime = "Tonga Standard Time",
        /**
         * The timezone ID for 'UTC+13'.
         */
        UTCPlus13 = "UTC+13",
        /**
         * The timezone ID for 'Chatham Islands Standard Time'.
         */
        ChathamIslandsStandardTime = "Chatham Islands Standard Time",
        /**
         * The timezone ID for 'Fiji Standard Time'.
         */
        FijiStandardTime = "Fiji Standard Time",
        /**
         * The timezone ID for 'Kamchatka Standard Time'.
         */
        KamchatkaStandardTime = "Kamchatka Standard Time",
        /**
         * The timezone ID for 'New Zealand Standard Time'.
         */
        NewZealandStandardTime = "New Zealand Standard Time",
        /**
         * The timezone ID for 'Russia Time Zone 11'.
         */
        RussiaTimeZone11 = "Russia Time Zone 11",
        /**
         * The timezone ID for 'UTC+12'.
         */
        UTCPlus12 = "UTC+12",
        /**
         * The timezone ID for 'Bougainville Standard Time'.
         */
        BougainvilleStandardTime = "Bougainville Standard Time",
        /**
         * The timezone ID for 'Central Pacific Standard Time'.
         */
        CentralPacificStandardTime = "Central Pacific Standard Time",
        /**
         * The timezone ID for 'Magadan Standard Time'.
         */
        MagadanStandardTime = "Magadan Standard Time",
        /**
         * The timezone ID for 'Norfolk Standard Time'.
         */
        NorfolkStandardTime = "Norfolk Standard Time",
        /**
         * The timezone ID for 'Russia Time Zone 10'.
         */
        RussiaTimeZone10 = "Russia Time Zone 10",
        /**
         * The timezone ID for 'Sakhalin Standard Time'.
         */
        SakhalinStandardTime = "Sakhalin Standard Time",
        /**
         * The timezone ID for 'Lord Howe Standard Time'.
         */
        LordHoweStandardTime = "Lord Howe Standard Time",
        /**
         * The timezone ID for 'AUS Eastern Standard Time'.
         */
        AUSEasternStandardTime = "AUS Eastern Standard Time",
        /**
         * The timezone ID for 'E. Australia Standard Time'.
         */
        EAustraliaStandardTime = "E. Australia Standard Time",
        /**
         * The timezone ID for 'Vladivostok Standard Time'.
         */
        VladivostokStandardTime = "Vladivostok Standard Time",
        /**
         * The timezone ID for 'Tasmania Standard Time'.
         */
        TasmaniaStandardTime = "Tasmania Standard Time",
        /**
         * The timezone ID for 'West Pacific Standard Time'.
         */
        WestPacificStandardTime = "West Pacific Standard Time",
        /**
         * The timezone ID for 'AUS Central Standard Time'.
         */
        AUSCentralStandardTime = "AUS Central Standard Time",
        /**
         * The timezone ID for 'Cen. Australia Standard Time'.
         */
        CenAustraliaStandardTime = "Cen. Australia Standard Time",
        /**
         * The timezone ID for 'Korea Standard Time'.
         */
        KoreaStandardTime = "Korea Standard Time",
        /**
         * The timezone ID for 'North Korea Standard Time'.
         */
        NorthKoreaStandardTime = "North Korea Standard Time",
        /**
         * The timezone ID for 'Yakutsk Standard Time'.
         */
        YakutskStandardTime = "Yakutsk Standard Time",
        /**
         * The timezone ID for 'Tokyo Standard Time'.
         */
        TokyoStandardTime = "Tokyo Standard Time",
        /**
         * The timezone ID for 'Transbaikal Standard Time'.
         */
        TransbaikalStandardTime = "Transbaikal Standard Time",
        /**
         * The timezone ID for 'Aus Central W. Standard Time'.
         */
        AusCentralWStandardTime = "Aus Central W. Standard Time",
        /**
         * The timezone ID for 'China Standard Time'.
         */
        ChinaStandardTime = "China Standard Time",
        /**
         * The timezone ID for 'Singapore Standard Time'.
         */
        SingaporeStandardTime = "Singapore Standard Time",
        /**
         * The timezone ID for 'North Asia East Standard Time'.
         */
        NorthAsiaEastStandardTime = "North Asia East Standard Time",
        /**
         * The timezone ID for 'Taipei Standard Time'.
         */
        TaipeiStandardTime = "Taipei Standard Time",
        /**
         * The timezone ID for 'Ulaanbaatar Standard Time'.
         */
        UlaanbaatarStandardTime = "Ulaanbaatar Standard Time",
        /**
         * The timezone ID for 'W. Australia Standard Time'.
         */
        WAustraliaStandardTime = "W. Australia Standard Time",
        /**
         * The timezone ID for 'Altai Standard Time'.
         */
        AltaiStandardTime = "Altai Standard Time",
        /**
         * The timezone ID for 'N. Central Asia Standard Time'.
         */
        NCentralAsiaStandardTime = "N. Central Asia Standard Time",
        /**
         * The timezone ID for 'North Asia Standard Time'.
         */
        NorthAsiaStandardTime = "North Asia Standard Time",
        /**
         * The timezone ID for 'SE Asia Standard Time'.
         */
        SEAsiaStandardTime = "SE Asia Standard Time",
        /**
         * The timezone ID for 'Tomsk Standard Time'.
         */
        TomskStandardTime = "Tomsk Standard Time",
        /**
         * The timezone ID for 'W. Mongolia Standard Time'.
         */
        WMongoliaStandardTime = "W. Mongolia Standard Time",
        /**
         * The timezone ID for 'Myanmar Standard Time'.
         */
        MyanmarStandardTime = "Myanmar Standard Time",
        /**
         * The timezone ID for 'Bangladesh Standard Time'.
         */
        BangladeshStandardTime = "Bangladesh Standard Time",
        /**
         * The timezone ID for 'Central Asia Standard Time'.
         */
        CentralAsiaStandardTime = "Central Asia Standard Time",
        /**
         * The timezone ID for 'Omsk Standard Time'.
         */
        OmskStandardTime = "Omsk Standard Time",
        /**
         * The timezone ID for 'Nepal Standard Time'.
         */
        NepalStandardTime = "Nepal Standard Time",
        /**
         * The timezone ID for 'India Standard Time'.
         */
        IndiaStandardTime = "India Standard Time",
        /**
         * The timezone ID for 'Sri Lanka Standard Time'.
         */
        SriLankaStandardTime = "Sri Lanka Standard Time",
        /**
         * The timezone ID for 'Pakistan Standard Time'.
         */
        PakistanStandardTime = "Pakistan Standard Time",
        /**
         * The timezone ID for 'Qyzylorda Standard Time'.
         */
        QyzylordaStandardTime = "Qyzylorda Standard Time",
        /**
         * The timezone ID for 'Ekaterinburg Standard Time'.
         */
        EkaterinburgStandardTime = "Ekaterinburg Standard Time",
        /**
         * The timezone ID for 'West Asia Standard Time'.
         */
        WestAsiaStandardTime = "West Asia Standard Time",
        /**
         * The timezone ID for 'Afghanistan Standard Time'.
         */
        AfghanistanStandardTime = "Afghanistan Standard Time",
        /**
         * The timezone ID for 'Arabian Standard Time'.
         */
        ArabianStandardTime = "Arabian Standard Time",
        /**
         * The timezone ID for 'Astrakhan Standard Time'.
         */
        AstrakhanStandardTime = "Astrakhan Standard Time",
        /**
         * The timezone ID for 'Azerbaijan Standard Time'.
         */
        AzerbaijanStandardTime = "Azerbaijan Standard Time",
        /**
         * The timezone ID for 'Caucasus Standard Time'.
         */
        CaucasusStandardTime = "Caucasus Standard Time",
        /**
         * The timezone ID for 'Georgian Standard Time'.
         */
        GeorgianStandardTime = "Georgian Standard Time",
        /**
         * The timezone ID for 'Mauritius Standard Time'.
         */
        MauritiusStandardTime = "Mauritius Standard Time",
        /**
         * The timezone ID for 'Russia Time Zone 3'.
         */
        RussiaTimeZone3 = "Russia Time Zone 3",
        /**
         * The timezone ID for 'Saratov Standard Time'.
         */
        SaratovStandardTime = "Saratov Standard Time",
        /**
         * The timezone ID for 'Volgograd Standard Time'.
         */
        VolgogradStandardTime = "Volgograd Standard Time",
        /**
         * The timezone ID for 'Iran Standard Time'.
         */
        IranStandardTime = "Iran Standard Time",
        /**
         * The timezone ID for 'Arab Standard Time'.
         */
        ArabStandardTime = "Arab Standard Time",
        /**
         * The timezone ID for 'Arabic Standard Time'.
         */
        ArabicStandardTime = "Arabic Standard Time",
        /**
         * The timezone ID for 'Belarus Standard Time'.
         */
        BelarusStandardTime = "Belarus Standard Time",
        /**
         * The timezone ID for 'E. Africa Standard Time'.
         */
        EAfricaStandardTime = "E. Africa Standard Time",
        /**
         * The timezone ID for 'Russian Standard Time'.
         */
        RussianStandardTime = "Russian Standard Time",
        /**
         * The timezone ID for 'Turkey Standard Time'.
         */
        TurkeyStandardTime = "Turkey Standard Time",
        /**
         * The timezone ID for 'E. Europe Standard Time'.
         */
        EEuropeStandardTime = "E. Europe Standard Time",
        /**
         * The timezone ID for 'Egypt Standard Time'.
         */
        EgyptStandardTime = "Egypt Standard Time",
        /**
         * The timezone ID for 'FLE Standard Time'.
         */
        FLEStandardTime = "FLE Standard Time",
        /**
         * The timezone ID for 'GTB Standard Time'.
         */
        GTBStandardTime = "GTB Standard Time",
        /**
         * The timezone ID for 'Israel Standard Time'.
         */
        IsraelStandardTime = "Israel Standard Time",
        /**
         * The timezone ID for 'Jordan Standard Time'.
         */
        JordanStandardTime = "Jordan Standard Time",
        /**
         * The timezone ID for 'Libya Standard Time'.
         */
        LibyaStandardTime = "Libya Standard Time",
        /**
         * The timezone ID for 'Middle East Standard Time'.
         */
        MiddleEastStandardTime = "Middle East Standard Time",
        /**
         * The timezone ID for 'Namibia Standard Time'.
         */
        NamibiaStandardTime = "Namibia Standard Time",
        /**
         * The timezone ID for 'Kaliningrad Standard Time'.
         */
        KaliningradStandardTime = "Kaliningrad Standard Time",
        /**
         * The timezone ID for 'South Africa Standard Time'.
         */
        SouthAfricaStandardTime = "South Africa Standard Time",
        /**
         * The timezone ID for 'Sudan Standard Time'.
         */
        SudanStandardTime = "Sudan Standard Time",
        /**
         * The timezone ID for 'Syria Standard Time'.
         */
        SyriaStandardTime = "Syria Standard Time",
        /**
         * The timezone ID for 'West Bank Standard Time'.
         */
        WestBankStandardTime = "West Bank Standard Time",
        /**
         * The timezone ID for 'Central Europe Standard Time'.
         */
        CentralEuropeStandardTime = "Central Europe Standard Time",
        /**
         * The timezone ID for 'Central European Standard Time'.
         */
        CentralEuropeanStandardTime = "Central European Standard Time",
        /**
         * The timezone ID for 'Romance Standard Time'.
         */
        RomanceStandardTime = "Romance Standard Time",
        /**
         * The timezone ID for 'W. Central Africa Standard Time'.
         */
        WCentralAfricaStandardTime = "W. Central Africa Standard Time",
        /**
         * The timezone ID for 'W. Europe Standard Time'.
         */
        WEuropeStandardTime = "W. Europe Standard Time",
        /**
         * The timezone ID for 'UTC'.
         */
        UTC = "UTC",
        /**
         * The timezone ID for 'GMT Standard Time'.
         */
        GMTStandardTime = "GMT Standard Time",
        /**
         * The timezone ID for 'Greenwich Standard Time'.
         */
        GreenwichStandardTime = "Greenwich Standard Time",
        /**
         * The timezone ID for 'Morocco Standard Time'.
         */
        MoroccoStandardTime = "Morocco Standard Time",
        /**
         * The timezone ID for 'Sao Tome Standard Time'.
         */
        SaoTomeStandardTime = "Sao Tome Standard Time",
        /**
         * The timezone ID for 'Azores Standard Time'.
         */
        AzoresStandardTime = "Azores Standard Time",
        /**
         * The timezone ID for 'Cape Verde Standard Time'.
         */
        CapeVerdeStandardTime = "Cape Verde Standard Time",
        /**
         * The timezone ID for 'Mid-Atlantic Standard Time'.
         */
        MidMinusAtlanticStandardTime = "Mid-Atlantic Standard Time",
        /**
         * The timezone ID for 'UTC-02'.
         */
        UTCMinus02 = "UTC-02",
        /**
         * The timezone ID for 'Argentina Standard Time'.
         */
        ArgentinaStandardTime = "Argentina Standard Time",
        /**
         * The timezone ID for 'Bahia Standard Time'.
         */
        BahiaStandardTime = "Bahia Standard Time",
        /**
         * The timezone ID for 'E. South America Standard Time'.
         */
        ESouthAmericaStandardTime = "E. South America Standard Time",
        /**
         * The timezone ID for 'Greenland Standard Time'.
         */
        GreenlandStandardTime = "Greenland Standard Time",
        /**
         * The timezone ID for 'Magallanes Standard Time'.
         */
        MagallanesStandardTime = "Magallanes Standard Time",
        /**
         * The timezone ID for 'Montevideo Standard Time'.
         */
        MontevideoStandardTime = "Montevideo Standard Time",
        /**
         * The timezone ID for 'SA Eastern Standard Time'.
         */
        SAEasternStandardTime = "SA Eastern Standard Time",
        /**
         * The timezone ID for 'Saint Pierre Standard Time'.
         */
        SaintPierreStandardTime = "Saint Pierre Standard Time",
        /**
         * The timezone ID for 'Tocantins Standard Time'.
         */
        TocantinsStandardTime = "Tocantins Standard Time",
        /**
         * The timezone ID for 'Newfoundland Standard Time'.
         */
        NewfoundlandStandardTime = "Newfoundland Standard Time",
        /**
         * The timezone ID for 'Atlantic Standard Time'.
         */
        AtlanticStandardTime = "Atlantic Standard Time",
        /**
         * The timezone ID for 'Central Brazilian Standard Time'.
         */
        CentralBrazilianStandardTime = "Central Brazilian Standard Time",
        /**
         * The timezone ID for 'Pacific SA Standard Time'.
         */
        PacificSAStandardTime = "Pacific SA Standard Time",
        /**
         * The timezone ID for 'Paraguay Standard Time'.
         */
        ParaguayStandardTime = "Paraguay Standard Time",
        /**
         * The timezone ID for 'SA Western Standard Time'.
         */
        SAWesternStandardTime = "SA Western Standard Time",
        /**
         * The timezone ID for 'Venezuela Standard Time'.
         */
        VenezuelaStandardTime = "Venezuela Standard Time",
        /**
         * The timezone ID for 'Cuba Standard Time'.
         */
        CubaStandardTime = "Cuba Standard Time",
        /**
         * The timezone ID for 'Eastern Standard Time'.
         */
        EasternStandardTime = "Eastern Standard Time",
        /**
         * The timezone ID for 'Eastern Standard Time (Mexico)'.
         */
        EasternStandardTimeMexico = "Eastern Standard Time (Mexico)",
        /**
         * The timezone ID for 'Haiti Standard Time'.
         */
        HaitiStandardTime = "Haiti Standard Time",
        /**
         * The timezone ID for 'SA Pacific Standard Time'.
         */
        SAPacificStandardTime = "SA Pacific Standard Time",
        /**
         * The timezone ID for 'Turks And Caicos Standard Time'.
         */
        TurksAndCaicosStandardTime = "Turks And Caicos Standard Time",
        /**
         * The timezone ID for 'US Eastern Standard Time'.
         */
        USEasternStandardTime = "US Eastern Standard Time",
        /**
         * The timezone ID for 'Canada Central Standard Time'.
         */
        CanadaCentralStandardTime = "Canada Central Standard Time",
        /**
         * The timezone ID for 'Central America Standard Time'.
         */
        CentralAmericaStandardTime = "Central America Standard Time",
        /**
         * The timezone ID for 'Central Standard Time'.
         */
        CentralStandardTime = "Central Standard Time",
        /**
         * The timezone ID for 'Central Standard Time (Mexico)'.
         */
        CentralStandardTimeMexico = "Central Standard Time (Mexico)",
        /**
         * The timezone ID for 'Easter Island Standard Time'.
         */
        EasterIslandStandardTime = "Easter Island Standard Time",
        /**
         * The timezone ID for 'Mountain Standard Time'.
         */
        MountainStandardTime = "Mountain Standard Time",
        /**
         * The timezone ID for 'Mountain Standard Time (Mexico)'.
         */
        MountainStandardTimeMexico = "Mountain Standard Time (Mexico)",
        /**
         * The timezone ID for 'US Mountain Standard Time'.
         */
        USMountainStandardTime = "US Mountain Standard Time",
        /**
         * The timezone ID for 'Pacific Standard Time'.
         */
        PacificStandardTime = "Pacific Standard Time",
        /**
         * The timezone ID for 'Pacific Standard Time (Mexico)'.
         */
        PacificStandardTimeMexico = "Pacific Standard Time (Mexico)",
        /**
         * The timezone ID for 'UTC-08'.
         */
        UTCMinus08 = "UTC-08",
        /**
         * The timezone ID for 'Alaskan Standard Time'.
         */
        AlaskanStandardTime = "Alaskan Standard Time",
        /**
         * The timezone ID for 'UTC-09'.
         */
        UTCMinus09 = "UTC-09",
        /**
         * The timezone ID for 'Marquesas Standard Time'.
         */
        MarquesasStandardTime = "Marquesas Standard Time",
        /**
         * The timezone ID for 'Aleutian Standard Time'.
         */
        AleutianStandardTime = "Aleutian Standard Time",
        /**
         * The timezone ID for 'Hawaiian Standard Time'.
         */
        HawaiianStandardTime = "Hawaiian Standard Time",
        /**
         * The timezone ID for 'UTC-11'.
         */
        UTCMinus11 = "UTC-11",
        /**
         * The timezone ID for 'Dateline Standard Time'.
         */
        DatelineStandardTime = "Dateline Standard Time"
    }
    /**
     * Interface for a specific TimeZone object.
     */
    export interface TimeZone {
        /**
         * ID of the TimeZone
         */
        readonly id: TimeZoneId;
        /**
         * Default offset in minutes of the timezone from UTC.
         */
        readonly defaultUtcOffset: number;
        /**
         * Standard name of the timezone, e.g. "Pacific Standard Time"
         */
        readonly standardName: string;
        /**
         * Daylight name of the timezone, e.g. "Pacific Daylight Time"
         */
        readonly daylightName: string;
        /**
         * Display string of the timezone, e.g. "(UTC-08:00) Pacific Time (US & Canada)"
         */
        readonly displayString: string;
    }
    /**
     * Gets the current timezone object. This has special properties and the name should typically not be used as that is a fake name.
     * @returns The current timezone object
     */
    export function getCurrentTimeZone(): TimeZone;
    /**
     * List of all available timezones sorted based on UTC offset
     * @returns The list of all available timezone objects
     */
    export function getTimeZones(): ReadonlyArray<TimeZone>;
    /**
     * Get the timezone object corresponding to a particular ID
     * @param timezoneId The ID of the timezone
     * @returns The timezone object corresponding to the ID
     */
    export function getTimeZoneById(timezoneId: TimeZoneId): TimeZone;
    /**
     * Get the timezone object corresponding to a particular standard name
     * @param timezoneName The name of the timezone
     * @returns The timezone object corresponding to the name
     */
    export function getTimeZoneByStandardName(timezoneName: string): TimeZone;
    /**
     * Get the timezone object corresponding to a particular standard name or daylight name
     * @param timezoneName The name of the timezone
     * @returns The timezone object corresponding to the name
     */
    export function getTimeZoneByName(timezoneName: string): TimeZone;
    /**
     * Get the timezone objects corresponding to a UTC offset for a given date
     * @param offset The UTC offset of the timezone
     * @param relativeDate The date for which the UTC offset is provided. If this is not provided, the offset is compared to the default UTC offset.
     * @returns The list of timezone objects with matching offsets
     */
    export function getTimeZonesByOffset(offset: number, relativeDate?: Date): ReadonlyArray<TimeZone>;
    /**
     * Converts a date/time in the local timezone to a date/time in the provided timezone, taking DST into account.
     * @param toTimeZoneId The ID of the timezone to convert the date/time to
     * @param date The date in local timezone to convert
     * @returns The date in the provided timezone
     */
    export function convertFromLocalTimeZone(toTimeZoneId: TimeZoneId, date: Date): Date;
    /**
     * Converts a date/time in the provided timezone to a date/time in the local timezone, taking DST into account.
     * @param fromTimeZoneId The ID of the timezone to convert the date/time from
     * @param date The date in the provided timezone to convert
     * @returns The date in the local timezone
     */
    export function convertToLocalTimeZone(fromTimeZoneId: TimeZoneId, date: Date): Date;
    /**
     * Gets the UTC offset of a given date/time in a given timezone. If no date is provided, this returns the default UTC offset for the timezone.
     * @param timezoneId The ID of the timezone to use for the calculation
     * @param date The relative date to use for offset calculation
     * @returns The UTC offset in minutes
     */
    export function getUtcOffsetForTimeZone(timezoneId: TimeZoneId, date?: Date): number;
}

// FILE: Fx\UriBuilder.d.ts
declare module "Fx/UriBuilder" {
    const _default: typeof MsPortalFx.Base.UriBuilder;
    export = _default;
}
